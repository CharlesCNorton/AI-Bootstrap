import numpy as np
import math
from itertools import product
from collections import Counter
from scipy.spatial import ConvexHull, Delaunay
from scipy.fft import fft, fftfreq
import matplotlib.pyplot as plt
import multiprocessing as mp

# 1. Defining Zonotope Generators
def define_generators(dimension):
    """
    Define rational and irrational generating vectors for the zonotope in specified dimension.
    Args:
        dimension: int, the dimension of the space (4 for this example)
    Returns:
        generators_rational: np.array of rational generators
        generators_irrational_list: list of np.arrays of irrational generators with different irrationals
    """
    print(f"Defining rational and irrational generating vectors in {dimension}D space...")

    # Rational generators in specified dimension
    generators_rational = np.eye(dimension)

    # Irrational numbers to use
    irrational_numbers = [
        [math.sqrt(2), math.sqrt(3), math.sqrt(5)],
        [math.pi, math.e, (1 + math.sqrt(5)) / 2],  # Using π, e, and φ
        [math.sqrt(7), math.sqrt(11), math.sqrt(13)]
    ]

    # Ensure we have the correct number of irrational numbers for the dimension
    irrational_numbers = [nums[:dimension] for nums in irrational_numbers]

    # Create list of irrational generators
    generators_irrational_list = []
    for nums in irrational_numbers:
        generators = []
        generators.append(np.eye(dimension)[0])  # First generator is rational
        for i, num in enumerate(nums):
            vec = np.zeros(dimension)
            vec[(i + 1) % dimension] = num  # Assign irrational number to next axis
            generators.append(vec)
        generators_irrational_list.append(np.array(generators))

    return generators_rational, generators_irrational_list

# 2. Computing Zonotope Vertices and Bounding Box
def get_zonotope_vertices(generators):
    """
    Compute the vertices of the zonotope generated by the given generators.
    Args:
        generators: np.array of generators
    Returns:
        vertices: np.array of zonotope vertices
    """
    coefficients = [0, 1]
    vertices = []
    for coeffs in product(coefficients, repeat=len(generators)):
        vertex = np.dot(coeffs, generators)
        vertices.append(vertex)
    return np.array(vertices)

def get_bounding_box(vertices, t):
    """
    Compute the bounding box for the dilated zonotope.
    Args:
        vertices: np.array of zonotope vertices
        t: dilation factor
    Returns:
        min_coords: np.array of minimum coordinates
        max_coords: np.array of maximum coordinates
    """
    scaled_vertices = vertices * t
    min_coords = np.floor(np.min(scaled_vertices, axis=0)).astype(int)
    max_coords = np.ceil(np.max(scaled_vertices, axis=0)).astype(int)
    return min_coords, max_coords

# 3. Point-in-Zonotope Test (Parallel)
def process_chunk(args):
    """
    Process a chunk of points to check which are inside the zonotope.
    Args:
        chunk: a chunk of points to be checked
        hull: Delaunay triangulation of the zonotope
    Returns:
        number of points inside the zonotope
    """
    chunk, hull = args
    chunk = np.array(chunk, dtype=np.float64)
    inside = hull.find_simplex(chunk) >= 0
    return np.sum(inside)

def compute_L_parallel(t, generators, chunk_size=5000):
    """
    Compute the number of integer lattice points inside the dilated zonotope tZ, using parallel processing.
    Args:
        t: dilation factor
        generators: np.array of generators
        chunk_size: number of points to process in each chunk
    Returns:
        lattice_points: int, number of lattice points inside tZ
    """
    vertices = get_zonotope_vertices(generators)
    min_coords, max_coords = get_bounding_box(vertices, t)
    scaled_vertices = vertices * t
    hull = Delaunay(scaled_vertices)

    grid_ranges = [range(min_coords[i], max_coords[i] + 1) for i in range(len(min_coords))]
    grid_points = list(product(*grid_ranges))

    with mp.Pool(mp.cpu_count()) as pool:
        chunks = [grid_points[i:i + chunk_size] for i in range(0, len(grid_points), chunk_size)]
        results = pool.map(process_chunk, [(chunk, hull) for chunk in chunks])

    lattice_points = sum(results)
    print(f"t = {t}, Total lattice points inside zonotope: {lattice_points}")
    return lattice_points

# 4. Fourier Analysis of the Perturbation Function
def perform_fourier_analysis(epsilon_values, t_values):
    """
    Perform Fourier analysis on the perturbation function epsilon(t).
    Args:
        epsilon_values: list of epsilon(t) values
        t_values: list of t values
    Returns:
        frequencies: np.array of frequencies
        amplitudes: np.array of amplitudes
    """
    print("\nPerforming Fourier analysis on epsilon(t)...")
    N = len(epsilon_values)
    T = t_values[1] - t_values[0]  # Assuming uniform spacing
    yf = fft(epsilon_values)
    xf = fftfreq(N, T)[:N // 2]

    amplitudes = 2.0 / N * np.abs(yf[0:N // 2])

    # Print dominant frequencies
    threshold = np.max(amplitudes) * 0.1  # Consider frequencies with amplitude >10% of max
    dominant_indices = np.where(amplitudes > threshold)[0]
    dominant_frequencies = xf[dominant_indices]
    dominant_amplitudes = amplitudes[dominant_indices]

    print("Dominant Frequencies and Amplitudes in the Perturbation Function:")
    for freq, amp in zip(dominant_frequencies, dominant_amplitudes):
        print(f"Frequency: {freq:.4f}, Amplitude: {amp:.4f}")

    return dominant_frequencies, dominant_amplitudes

# 5. Statistical Analysis of epsilon(t)
def statistical_analysis(epsilon_values):
    """
    Perform statistical analysis on epsilon(t).
    Args:
        epsilon_values: list of epsilon(t) values
    """
    print("\nConducting statistical analysis of epsilon(t)...")
    mean_epsilon = np.mean(epsilon_values)
    variance_epsilon = np.var(epsilon_values)
    counts = Counter(epsilon_values)
    most_common = counts.most_common(5)
    print(f"Mean of epsilon(t): {mean_epsilon}")
    print(f"Variance of epsilon(t): {variance_epsilon}")
    print("Most common values of epsilon(t):")
    for value, count in most_common:
        print(f"Value: {value}, Count: {count}")

# 6. Main Execution
def run_simulation(dimension=4, t_start=1, t_end=120, chunk_size=10000):
    """
    Run the full simulation, calculating the perturbation function and analyzing results.
    Args:
        dimension: int, dimension of the zonotope (default 4)
        t_start: int, starting value of t
        t_end: int, ending value of t
        chunk_size: number of points to process in each chunk for lattice-point counting
    """
    # 1. Define Generators
    generators_rational, generators_irrational_list = define_generators(dimension)

    t_values = list(range(t_start, t_end + 1))

    for idx, generators_irrational in enumerate(generators_irrational_list):
        print(f"\nTesting with irrational generators set {idx + 1}:")
        print(generators_irrational)

        L_rational_values = []
        L_irrational_values = []
        epsilon_values = []

        print("\nStarting lattice-point counting...")
        for t in t_values:
            L_rational_t = compute_L_parallel(t, generators_rational, chunk_size)
            L_irrational_t = compute_L_parallel(t, generators_irrational, chunk_size)
            epsilon_t = L_irrational_t - L_rational_t

            L_rational_values.append(L_rational_t)
            L_irrational_values.append(L_irrational_t)
            epsilon_values.append(epsilon_t)

            print(f"Result: L_irrational(t) = {L_irrational_t}, L_rational(t) = {L_rational_t}, epsilon(t) = {epsilon_t}")

        # 4. Fourier Analysis
        dominant_frequencies, dominant_amplitudes = perform_fourier_analysis(epsilon_values, t_values)

        # 5. Statistical Analysis
        statistical_analysis(epsilon_values)

        # 6. Plotting results
        plot_results(t_values, epsilon_values, L_rational_values, L_irrational_values, idx + 1)

def plot_results(t_values, epsilon_values, L_rational_values, L_irrational_values, set_number):
    """
    Plot the results for visualization.
    Args:
        t_values: list of t values
        epsilon_values: list of epsilon(t) values
        L_rational_values: list of L_rational(t) values
        L_irrational_values: list of L_irrational(t) values
        set_number: int, identifier for the current set of irrational generators
    """
    plt.figure(figsize=(10, 6))
    plt.plot(t_values, epsilon_values, marker='o', linestyle='-', color='b')
    plt.title(f'Perturbation Function ε(t) - Irrational Set {set_number}')
    plt.xlabel('t')
    plt.ylabel('ε(t)')
    plt.grid(True)
    plt.show()

    plt.figure(figsize=(10, 6))
    plt.plot(t_values, L_rational_values, marker='o', linestyle='-', color='g', label='L_rational(t)')
    plt.plot(t_values, L_irrational_values, marker='s', linestyle='--', color='r', label='L_irrational(t)')
    plt.title(f'Lattice-Point Counts - Irrational Set {set_number}')
    plt.xlabel('t')
    plt.ylabel('L(t)')
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    # Run the simulation with optimized memory handling and parallel processing
    run_simulation(dimension=4, t_start=1, t_end=120, chunk_size=10000)
