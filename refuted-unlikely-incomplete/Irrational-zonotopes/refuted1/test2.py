import numpy as np
import math
from itertools import product
from collections import Counter
from scipy.spatial import ConvexHull, Delaunay
from scipy.fft import fft, fftfreq
import matplotlib.pyplot as plt  # Optional, for plotting

# 1. Defining Zonotope Generators
def define_generators(dimension):
    """
    Define rational and irrational generating vectors for the zonotope in specified dimension.
    Args:
        dimension: int, the dimension of the space (2 or 3)
    Returns:
        generators_rational: np.array of rational generators
        generators_irrational_list: list of np.arrays of irrational generators with different irrationals
    """
    print(f"Defining rational and irrational generating vectors in {dimension}D space...")

    # Rational generators in specified dimension
    generators_rational = np.eye(dimension)

    # Irrational numbers to use
    irrational_numbers = [
        [math.sqrt(2), math.sqrt(3), math.sqrt(5)],
        [math.pi, math.e, (1 + math.sqrt(5)) / 2],  # Using π, e, and φ
        [math.sqrt(7), math.sqrt(11), math.sqrt(13)]
    ]

    # Ensure we have the correct number of irrational numbers for the dimension
    irrational_numbers = [nums[:dimension] for nums in irrational_numbers]

    # Create list of irrational generators
    generators_irrational_list = []
    for nums in irrational_numbers:
        # Construct generators with one rational and the rest irrational
        generators = []
        generators.append(np.eye(dimension)[0])  # First generator is rational
        for i, num in enumerate(nums):
            vec = np.zeros(dimension)
            vec[(i + 1) % dimension] = num  # Assign irrational number to next axis
            generators.append(vec)
        generators_irrational_list.append(np.array(generators))

    return generators_rational, generators_irrational_list

# 2. Computing Zonotope Vertices and Bounding Box
def get_zonotope_vertices(generators):
    """
    Compute the vertices of the zonotope generated by the given generators.
    Args:
        generators: np.array of generators
    Returns:
        vertices: np.array of zonotope vertices
    """
    # Coefficients range from 0 to 1 for zonotope generation
    coefficients = [0, 1]
    vertices = []
    for coeffs in product(coefficients, repeat=len(generators)):
        vertex = np.dot(coeffs, generators)
        vertices.append(vertex)
    return np.array(vertices)

def get_bounding_box(vertices, t):
    """
    Compute the bounding box for the dilated zonotope.
    Args:
        vertices: np.array of zonotope vertices
        t: dilation factor
    Returns:
        min_coords: np.array of minimum coordinates
        max_coords: np.array of maximum coordinates
    """
    scaled_vertices = vertices * t
    min_coords = np.floor(np.min(scaled_vertices, axis=0)).astype(int)
    max_coords = np.ceil(np.max(scaled_vertices, axis=0)).astype(int)
    return min_coords, max_coords

# 3. Point-in-Zonotope Test
def is_point_in_hull(point, hull):
    """
    Check if a point is inside a convex hull.
    Args:
        point: np.array representing the point to test
        hull: scipy.spatial.ConvexHull object
    Returns:
        is_inside: bool indicating whether the point is inside the hull
    """
    return hull.find_simplex(point) >= 0

# 4. Lattice-Point Counting Functions
def compute_L(t, generators):
    """
    Compute the number of integer lattice points inside the dilated zonotope tZ.
    Args:
        t: dilation factor
        generators: np.array of generators
    Returns:
        lattice_points: int, number of lattice points inside tZ
    """
    # Get zonotope vertices and bounding box
    vertices = get_zonotope_vertices(generators)
    min_coords, max_coords = get_bounding_box(vertices, t)

    # Scale the vertices for the dilated zonotope
    scaled_vertices = vertices * t

    # Create Delaunay triangulation for efficient point-in-hull test
    hull = Delaunay(scaled_vertices)

    # Enumerate all integer points within the bounding box
    grid_ranges = [range(min_coords[i], max_coords[i] + 1) for i in range(len(min_coords))]
    total_points = 0
    lattice_points = 0

    # To handle large grids, we process points in batches
    grid_points = np.array(list(product(*grid_ranges)), dtype=np.float64)
    total_points = len(grid_points)

    # Check which points are inside the zonotope
    inside = hull.find_simplex(grid_points) >= 0
    lattice_points = np.sum(inside)

    print(f"t = {t}, Total integer points checked: {total_points}, Lattice points inside zonotope: {lattice_points}")
    return lattice_points

# 5. Fourier Analysis of the Perturbation Function
def perform_fourier_analysis(epsilon_values, t_values):
    """
    Perform Fourier analysis on the perturbation function epsilon(t).
    Args:
        epsilon_values: list of epsilon(t) values
        t_values: list of t values
    Returns:
        frequencies: np.array of frequencies
        amplitudes: np.array of amplitudes
    """
    print("\nPerforming Fourier analysis on epsilon(t)...")
    N = len(epsilon_values)
    T = t_values[1] - t_values[0]  # Assuming uniform spacing
    yf = fft(epsilon_values)
    xf = fftfreq(N, T)[:N // 2]

    amplitudes = 2.0 / N * np.abs(yf[0:N // 2])

    # Print dominant frequencies
    threshold = np.max(amplitudes) * 0.1  # Consider frequencies with amplitude >10% of max
    dominant_indices = np.where(amplitudes > threshold)[0]
    dominant_frequencies = xf[dominant_indices]
    dominant_amplitudes = amplitudes[dominant_indices]

    print("Dominant Frequencies and Amplitudes in the Perturbation Function:")
    for freq, amp in zip(dominant_frequencies, dominant_amplitudes):
        print(f"Frequency: {freq:.4f}, Amplitude: {amp:.4f}")

    return dominant_frequencies, dominant_amplitudes

# 6. Statistical Analysis of epsilon(t)
def statistical_analysis(epsilon_values):
    """
    Perform statistical analysis on epsilon(t).
    Args:
        epsilon_values: list of epsilon(t) values
    """
    print("\nConducting statistical analysis of epsilon(t)...")
    mean_epsilon = np.mean(epsilon_values)
    variance_epsilon = np.var(epsilon_values)
    counts = Counter(epsilon_values)
    most_common = counts.most_common(5)
    print(f"Mean of epsilon(t): {mean_epsilon}")
    print(f"Variance of epsilon(t): {variance_epsilon}")
    print("Most common values of epsilon(t):")
    for value, count in most_common:
        print(f"Value: {value}, Count: {count}")

# 7. Main Execution
def main():
    # Set dimension (2 or 3)
    dimension = 4

    # 1. Define Generators
    generators_rational, generators_irrational_list = define_generators(dimension)

    # 2. Initialize t_values
    t_start = 1
    t_end = 130  # Can increase to 50 if computationally feasible
    t_values = list(range(t_start, t_end + 1))

    # 3. Iterate over different irrational generators
    for idx, generators_irrational in enumerate(generators_irrational_list):
        print(f"\nTesting with irrational generators set {idx + 1}:")
        print(generators_irrational)

        # Data Collection
        L_rational_values = []
        L_irrational_values = []
        epsilon_values = []

        print("\nStarting lattice-point counting...")
        for t in t_values:
            print(f"\nComputing for t = {t}")
            # Compute lattice-point counts
            L_rational_t = compute_L(t, generators_rational)
            L_irrational_t = compute_L(t, generators_irrational)
            epsilon_t = L_irrational_t - L_rational_t

            # Store results
            L_rational_values.append(L_rational_t)
            L_irrational_values.append(L_irrational_t)
            epsilon_values.append(epsilon_t)

            print(f"Result: L_irrational(t) = {L_irrational_t}, L_rational(t) = {L_rational_t}, epsilon(t) = {epsilon_t}")

        # 4. Fourier Analysis
        dominant_frequencies, dominant_amplitudes = perform_fourier_analysis(epsilon_values, t_values)

        # 5. Statistical Analysis
        statistical_analysis(epsilon_values)

        # 6. (Optional) Plotting
        plot_results(t_values, epsilon_values, L_rational_values, L_irrational_values, idx + 1)

def plot_results(t_values, epsilon_values, L_rational_values, L_irrational_values, set_number):
    """
    Plot the results for visualization.
    Args:
        t_values: list of t values
        epsilon_values: list of epsilon(t) values
        L_rational_values: list of L_rational(t) values
        L_irrational_values: list of L_irrational(t) values
        set_number: int, identifier for the current set of irrational generators
    """
    # Plot epsilon(t)
    plt.figure(figsize=(10, 6))
    plt.plot(t_values, epsilon_values, marker='o', linestyle='-', color='b')
    plt.title(f'Perturbation Function ε(t) - Irrational Set {set_number}')
    plt.xlabel('t')
    plt.ylabel('ε(t)')
    plt.grid(True)
    plt.show()

    # Plot lattice-point counts
    plt.figure(figsize=(10, 6))
    plt.plot(t_values, L_rational_values, marker='o', linestyle='-', color='g', label='L_rational(t)')
    plt.plot(t_values, L_irrational_values, marker='s', linestyle='--', color='r', label='L_irrational(t)')
    plt.title(f'Lattice-Point Counts - Irrational Set {set_number}')
    plt.xlabel('t')
    plt.ylabel('L(t)')
    plt.legend()
    plt.grid(True)
    plt.show()

if __name__ == "__main__":
    main()
