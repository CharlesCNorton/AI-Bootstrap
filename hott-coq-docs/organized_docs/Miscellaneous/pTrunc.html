<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>pTrunc</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library pTrunc</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Basics</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">WildCat</span> <span class="id" title="var">Truncations</span><br/>
&nbsp;&nbsp;<span class="id" title="var">Pointed.Core</span> <span class="id" title="var">Pointed.pEquiv</span> <span class="id" title="var">Pointed.Loops</span> <span class="id" title="var">Pointed.pModality</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">pointed_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1309"></a><h1 class="section">Truncations of pointed types</h1>

<div class="paragraph"> </div>

 TODO: Many things here can be generalized to any modality or any reflective subuniverse, and could be moved to pModality.v 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pTr</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">pType</span>) : <span class="id" title="var">pType</span><br/>
&nbsp;&nbsp;:= [<span class="id" title="var">Tr</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>, <span class="id" title="var">_</span>].<br/>

<br/>
</div>

<div class="doc">
We specialize <span class="inlinecode"><span class="id" title="var">pto</span></span> and <span class="inlinecode"><span class="id" title="var">pequiv_pto</span></span> from pModalities.v to truncations. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr</span> {<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} {<span class="id" title="var">A</span> : <span class="id" title="var">pType</span>} : <span class="id" title="var">A</span> -&gt;* <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">pto</span> (<span class="id" title="var">Tr</span> <span class="id" title="var">n</span>) <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_ptr</span> {<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} {<span class="id" title="var">A</span> : <span class="id" title="var">pType</span>} `{<span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">A</span> &lt;~&gt;* <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span> := @<span class="id" title="var">pequiv_pto</span> (<span class="id" title="var">Tr</span> <span class="id" title="var">n</span>) <span class="id" title="var">A</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
We could specialize <span class="inlinecode"><span class="id" title="var">pO_rec</span></span> to give the following result, but since maps induced by truncation-recursion compute on elements of the form <span class="inlinecode"><span class="id" title="var">tr</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>, we can give a better proof of pointedness than the one coming from <span class="inlinecode"><span class="id" title="var">pO_rec</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pTr_rec</span> <span class="id" title="var">n</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} `{<span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">Build_pMap</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>) <span class="id" title="var">Y</span> (<span class="id" title="var">Trunc_rec</span> <span class="id" title="var">f</span>) (<span class="id" title="var">point_eq</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
Note that we get an equality of pointed functions here, without Funext, while <span class="inlinecode"><span class="id" title="var">pO_rec_beta</span></span> only gives a pointed homotopy. This is because <span class="inlinecode"><span class="id" title="var">pTr_rec</span></span> computes on elements of the form <span class="inlinecode"><span class="id" title="var">tr</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pTr_rec_beta_path</span> <span class="id" title="var">n</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} `{<span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr_rec</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span> <span class="id" title="var">o</span>* <span class="id" title="var">ptr</span> = <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">pTr_rec</span>, "o*"; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Since&nbsp;<span class="inlinecode"><span class="id" title="var">f</span></span>&nbsp;is&nbsp;definitionally&nbsp;equal&nbsp;to&nbsp;<span class="inlinecode"><span class="id" title="var">Build_pMap</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">point_eq</span></span> <span class="inlinecode"><span class="id" title="var">f</span>)</span>,&nbsp;this&nbsp;works:&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ap</span> (<span class="id" title="var">Build_pMap</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_1p</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The version with a pointed homotopy. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pTr_rec_beta</span> <span class="id" title="var">n</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} `{<span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr_rec</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span> <span class="id" title="var">o</span>* <span class="id" title="var">ptr</span> ==* <span class="id" title="var">f</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">phomotopy_path</span> (<span class="id" title="var">pTr_rec_beta_path</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
A pointed version of the induction principle. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pTr_ind</span> <span class="id" title="var">n</span> {<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>} {<span class="id" title="var">Y</span> : <span class="id" title="var">pFam</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>)} `{<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">Y</span> <span class="id" title="var">x</span>)}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">pForall</span> <span class="id" title="var">X</span> (<span class="id" title="var">Build_pFam</span> (<span class="id" title="var">Y</span> <span class="id" title="var">o</span> <span class="id" title="var">tr</span>) (<span class="id" title="var">dpoint</span> <span class="id" title="var">Y</span>)))<br/>
&nbsp;&nbsp;: <span class="id" title="var">pForall</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>) <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">Build_pForall</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>) <span class="id" title="var">Y</span> (<span class="id" title="var">Trunc_ind</span> <span class="id" title="var">Y</span> <span class="id" title="var">f</span>) (<span class="id" title="var">dpoint_eq</span> <span class="id" title="var">f</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_ptr_rec</span> `{<span class="id" title="var">Funext</span>} {<span class="id" title="var">n</span>} {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} `{<span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span>}<br/>
&nbsp;&nbsp;: (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> -&gt;** <span class="id" title="var">Y</span>) &lt;~&gt;* (<span class="id" title="var">X</span> -&gt;** <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">pequiv_o_pto_O</span> <span class="id" title="var">_</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1310"></a><h2 class="section">Functoriality of <span class="inlinecode"><span class="id" title="var">pTr</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is0functor_ptr</span> <span class="id" title="var">n</span> : <span class="id" title="var">Is0Functor</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Build_Is0Functor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">pTr_rec</span> <span class="id" title="var">_</span> (<span class="id" title="var">ptr</span> <span class="id" title="var">o</span>* <span class="id" title="var">f</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is1functor_ptr</span> <span class="id" title="var">n</span> : <span class="id" title="var">Is1Functor</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Build_Is1Functor</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">pTr_ind</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_pForall</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">cbn</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">ap</span> <span class="id" title="var">tr</span> (<span class="id" title="var">p</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">pointed_reduce</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">concat_p1</span> <span class="id" title="var">_</span> @ <span class="id" title="var">concat_p1</span> <span class="id" title="var">_</span> @ <span class="id" title="var">ap</span> <span class="id" title="var">_</span> (<span class="id" title="var">concat_p1</span> <span class="id" title="var">_</span>))^.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">Build_pHomotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="tactic">apply</span> <span class="id" title="var">Trunc_rec_tr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">Z</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">Build_pHomotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="tactic">by</span> <span class="id" title="var">rapply</span> <span class="id" title="var">Trunc_ind</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="var">pointed_reduce</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Naturality of <span class="inlinecode"><span class="id" title="var">ptr</span></span>.  Note that we get a equality of pointed functions, not just a pointed homotopy. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr_natural_path</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">fmap</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span> <span class="id" title="var">o</span>* <span class="id" title="var">ptr</span> = <span class="id" title="var">ptr</span> <span class="id" title="var">o</span>* <span class="id" title="var">f</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">pTr_rec_beta_path</span> <span class="id" title="var">n</span> (<span class="id" title="var">ptr</span> <span class="id" title="var">o</span>* <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
The version with a pointed homotopy. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr_natural</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">fmap</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span> <span class="id" title="var">o</span>* <span class="id" title="var">ptr</span> ==* <span class="id" title="var">ptr</span> <span class="id" title="var">o</span>* <span class="id" title="var">f</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">phomotopy_path</span> (<span class="id" title="var">ptr_natural_path</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr_functor_pconst</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">fmap</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>) (@<span class="id" title="var">pconst</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>) ==* <span class="id" title="var">pconst</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">Build_pHomotopy</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">by</span> <span class="id" title="var">rapply</span> <span class="id" title="var">Trunc_ind</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_ptr_functor</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">emap</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr_loops</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> (<span class="id" title="var">loops</span> <span class="id" title="var">A</span>) &lt;~&gt;* <span class="id" title="var">loops</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">Build_pEquiv'</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">apply</span> <span class="id" title="var">equiv_path_Tr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr_iterated_loops</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">k</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> (<span class="id" title="var">iterated_loops</span> <span class="id" title="var">k</span> <span class="id" title="var">A</span>) &lt;~&gt;* <span class="id" title="var">iterated_loops</span> <span class="id" title="var">k</span> (<span class="id" title="var">pTr</span> (<span class="id" title="var">trunc_index_inc'</span> <span class="id" title="var">n</span> <span class="id" title="var">k</span>) <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">k</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="var">etransitivity</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">apply</span> <span class="id" title="var">ptr_loops</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">emap</span> <span class="id" title="var">loops</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHk</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr_loops_eq</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> (<span class="id" title="var">loops</span> <span class="id" title="var">A</span>) = <span class="id" title="var">loops</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>) :&gt; <span class="id" title="var">pType</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">path_ptype</span> (<span class="id" title="var">ptr_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>).<br/>

<br/>
<span class="comment">(*&nbsp;This&nbsp;lemma&nbsp;generalizes&nbsp;a&nbsp;goal&nbsp;that&nbsp;appears&nbsp;in&nbsp;<span class="inlinecode"><span class="id" title="var">ptr_loops_commutes</span></span>,&nbsp;allowing&nbsp;us&nbsp;to&nbsp;prove&nbsp;it&nbsp;by&nbsp;path&nbsp;induction.&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">path_Tr_commutes</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">a0</span> <span class="id" title="var">a1</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">a0</span> = <span class="id" title="var">a1</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">path_Tr</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">n</span>) (<span class="id" title="var">tr</span> <span class="id" title="var">p</span>) = <span class="id" title="var">ap</span> <span class="id" title="var">tr</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="var">ptr_loops</span></span>&nbsp;commutes&nbsp;with&nbsp;the&nbsp;two&nbsp;<span class="inlinecode"><span class="id" title="var">ptr</span></span>&nbsp;maps.&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ptr_loops_commutes</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: (<span class="id" title="var">ptr_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>) <span class="id" title="var">o</span>* <span class="id" title="var">ptr</span> ==* <span class="id" title="var">fmap</span> <span class="id" title="var">loops</span> <span class="id" title="var">ptr</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">Build_pHomotopy</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intro</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">path_Tr_commutes</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">apply</span> <span class="id" title="var">concat_1p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">apply</span> <span class="id" title="var">concat_p1</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Pointed truncation preserves binary products. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_ptr_prod</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>) &lt;~&gt;* <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span> * <span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_pEquiv'</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="var">nrapply</span> <span class="id" title="var">equiv_Trunc_prod_cmp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1311"></a><h2 class="section">Truncatedness of <span class="inlinecode"><span class="id" title="var">pForall</span></span> and <span class="inlinecode"><span class="id" title="var">pMap</span></span></h2>

<div class="paragraph"> </div>

 Buchholtz-van Doorn-Rijke, Theorem 4.2:  Let <span class="inlinecode"><span class="id" title="var">j</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode">-1</span> and <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode">-2</span>.  When <span class="inlinecode"><span class="id" title="var">X</span></span> is <span class="inlinecode"><span class="id" title="var">j</span></span>-connected and <span class="inlinecode"><span class="id" title="var">Y</span></span> is a pointed family of <span class="inlinecode"><span class="id" title="var">j</span>+<span class="id" title="var">k</span>+1</span>-truncated types, the type of pointed sections is <span class="inlinecode"><span class="id" title="var">n</span></span>-truncated.  We formalize it with <span class="inlinecode"><span class="id" title="var">j</span></span> replaced with a trunc index <span class="inlinecode"><span class="id" title="var">m</span></span>, and so there is a shift compared to the informal statement. This version also allows <span class="inlinecode"><span class="id" title="var">n</span></span> to be one smaller than BvDR allow. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">istrunc_pforall</span> `{<span class="id" title="var">Univalence</span>} {<span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">X</span> : <span class="id" title="var">pType@</span>{<span class="id" title="var">u</span>}) {<span class="id" title="var">iscX</span> : <span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span>.+1 <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">Y</span> : <span class="id" title="var">pFam@</span>{<span class="id" title="var">u</span> <span class="id" title="var">v</span>} <span class="id" title="var">X</span>) {<span class="id" title="var">istY</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">IsTrunc</span> (<span class="id" title="var">n</span> +2+ <span class="id" title="var">m</span>) (<span class="id" title="var">Y</span> <span class="id" title="var">x</span>)}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsTrunc@</span>{<span class="id" title="var">w</span>} <span class="id" title="var">n</span> (<span class="id" title="var">pForall</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> (<span class="id" title="var">istrunc_equiv_istrunc</span> <span class="id" title="var">_</span> (<span class="id" title="var">equiv_extension_along_pforall@</span>{<span class="id" title="var">v</span> <span class="id" title="var">w</span> <span class="id" title="var">u</span>} <span class="id" title="var">Y</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">istrunc_extension_along_conn</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">m</span>) <span class="id" title="var">_</span> <span class="id" title="var">Y</span> (<span class="id" title="var">HP</span>:=<span class="id" title="var">istY</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
From this we deduce the non-dependent version, which is Corollary 4.3 of BvDR.  We include <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-2</span> here as well, but in this case it is not interesting.  Since <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">-&gt;*</span> <span class="inlinecode"><span class="id" title="var">Y</span></span> is inhabited, the <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-1</span> case also gives contractibility, with weaker hypotheses. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">istrunc_pmap</span> `{<span class="id" title="var">Univalence</span>} {<span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} (<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;`{!<span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span>.+1 <span class="id" title="var">X</span>} `{!<span class="id" title="var">IsTrunc</span> (<span class="id" title="var">n</span> +2+ <span class="id" title="var">m</span>) <span class="id" title="var">Y</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">istrunc_pforall</span> <span class="id" title="var">X</span> (<span class="id" title="var">pfam_const</span> <span class="id" title="var">Y</span>).<br/>

<br/>
</div>

<div class="doc">
We can give a different proof of the <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-1</span> case (with the conclusion upgraded to contractibility).  This proof works for any reflective subuniverse and avoids univalence.  Is it possible to generalize this to dependent functions while still avoiding univalence and/or keeping <span class="inlinecode"><span class="id" title="var">O</span></span> a general RSU or modality?  Can <span class="inlinecode"><span class="id" title="var">istrunc_pmap</span></span> be proven without univalence?  What about <span class="inlinecode"><span class="id" title="var">istrunc_pforall</span></span>?  If the <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-2</span> or <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-1</span> cases can be proven without univalence, the rest can be done inductively without univalence. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">contr_pmap_isconnected_inO</span> `{<span class="id" title="var">Funext</span>} (<span class="id" title="var">O</span> : <span class="id" title="var">ReflectiveSubuniverse</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">O</span> <span class="id" title="var">X</span>} (<span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>) `{<span class="id" title="var">In</span> <span class="id" title="var">O</span> <span class="id" title="var">Y</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">Contr</span> (<span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> (<span class="id" title="var">contr_equiv'</span> ([<span class="id" title="var">O</span> <span class="id" title="var">X</span>, <span class="id" title="var">_</span>] -&gt;* <span class="id" title="var">Y</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">pequiv_o_pto_O</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Every pointed type is (-1)-connected. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is_minus_one_connected_pointed</span> (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> (<span class="id" title="var">Tr</span> (-1)) <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">contr_inhabited_hprop</span> <span class="id" title="var">_</span> (<span class="id" title="var">tr</span> <span class="id" title="var">pt</span>).<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>