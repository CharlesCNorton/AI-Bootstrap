<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Connectedness</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Connectedness</h1>

<div class="code">
</div>

<div class="doc">
<a id="lab1623"></a><h1 class="section">Connectedness</h1>

</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Basics</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="keyword">Types</span>.<br/>

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Extensions</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Factorization</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">Modalities.Modality</span>. <span class="comment">(*&nbsp;<span class="inlinecode"><span class="id" title="keyword">Export</span></span>&nbsp;since&nbsp;the&nbsp;actual&nbsp;definitions&nbsp;of&nbsp;connectedness&nbsp;appear&nbsp;there,&nbsp;in&nbsp;the&nbsp;generality&nbsp;of&nbsp;a&nbsp;modality.&nbsp;*)</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Modalities.Descent</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Truncations.Core</span> <span class="id" title="var">Truncations.SeparatedTrunc</span>.<br/>

<br/>
</div>

<div class="doc">
This reduces universe variables in <span class="inlinecode"><span class="id" title="var">conn_pointed_type</span></span> and <span class="inlinecode"><span class="id" title="var">conn_point_elim</span></span>, which refer to <span class="inlinecode"><span class="id" title="var">Unit</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Set</span> <span class="id" title="var">Universe</span> <span class="id" title="var">Minimization</span> <span class="id" title="var">ToSet</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">trunc_scope</span>.<br/>

<br/>
</div>

<div class="doc">
There is a slight controversy of indexing for connectedness — in particular, how the indexing for maps shoud relate to the indexing for types.  One may reasonably take the connectedness of a map to correspond either to that of its *fibers*, or of its *cofiber*; these differ by 1.  The traditional topological indexing uses the cofiber.  We use the fiber, as does Lurie in <span class="inlinecode"><span class="id" title="var">HTT</span></span>; but we choose to agree with the traditional indexing on types, while Lurie agrees with it on maps.

<div class="paragraph"> </div>

Currently, the translation is therefore as follows:

<div class="paragraph"> </div>

       HoTT              Traditional       Lurie

<div class="paragraph"> </div>

Map    (n-1)-connected   n-connected       n-connective
Type   n-connected       n-connected       (n+1)-connective

<div class="paragraph"> </div>

A handy benchmark: under our indexing, the map <span class="inlinecode"><span class="id" title="var">S1</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode">1</span> is 0-connected but not 1-connected, while the map <span class="inlinecode">1</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">S1</span></span> is (–1)–connected but not 0-connected.

<div class="paragraph"> </div>

One reason for our choice is that this way, the n-truncated and n-connected maps are the modal and modally-connected maps for the n-truncation modality.  Many of the basic lemmas about connected maps are in fact true for any modality, and can be found in <span class="inlinecode"><span class="id" title="var">Modality.v</span></span>.  Thus, here we consider mainly properties that involve the interaction of connectedness at different truncation levels. 
<div class="paragraph"> </div>

<a id="lab1624"></a><h2 class="section">Truncatedness of the type of extensions</h2>

<div class="paragraph"> </div>

 A key lemma on the interaction between connectedness and truncatedness: suppose one is trying to extend along an n-connected map, into a k-truncated family of types (k ≥ n).  Then the space of possible extensions is (k–n–2)-truncated.

<div class="paragraph"> </div>

(Mnemonic for the indexing: think of the base case, where k=n; then we know we can eliminate, so the space of extensions is contractible.)

<div class="paragraph"> </div>

This lemma is most useful via corollaries like the wedge-inclusion, the wiggly wedge, and their n-ary generalizations. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">istrunc_extension_along_conn</span> `{<span class="id" title="var">Funext</span>} {<span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) `{<span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>) {<span class="id" title="var">HP</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>:<span class="id" title="var">B</span>, <span class="id" title="var">IsTrunc</span> (<span class="id" title="var">m</span> +2+ <span class="id" title="var">n</span>) (<span class="id" title="var">P</span> <span class="id" title="var">b</span>)}<br/>
&nbsp;&nbsp;(<span class="id" title="var">d</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>:<span class="id" title="var">A</span>, <span class="id" title="var">P</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsTrunc</span> <span class="id" title="var">m</span> (<span class="id" title="var">ExtensionAlong</span> <span class="id" title="var">f</span> <span class="id" title="var">P</span> <span class="id" title="var">d</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">P</span> <span class="id" title="var">HP</span> <span class="id" title="var">d</span>. <span class="id" title="var">simple_induction</span> <span class="id" title="var">m</span> <span class="id" title="var">m'</span> <span class="id" title="var">IH</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">P</span> <span class="id" title="var">HP</span> <span class="id" title="var">d</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;m&nbsp;=&nbsp;–2&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> (<span class="id" title="var">Build_Contr</span> <span class="id" title="var">_</span> (<span class="id" title="var">extension_conn_map_elim</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span> <span class="id" title="var">P</span> <span class="id" title="var">d</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>. <span class="id" title="tactic">apply</span> (<span class="id" title="var">allpath_extension_conn_map</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;m&nbsp;=&nbsp;S&nbsp;m'&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">istrunc_S</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">e</span> <span class="id" title="var">e'</span>. <span class="id" title="tactic">refine</span> (<span class="id" title="var">istrunc_isequiv_istrunc</span> <span class="id" title="var">_</span> (<span class="id" title="var">path_extension</span> <span class="id" title="var">e</span> <span class="id" title="var">e'</span>)).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;magically&nbsp;infers:&nbsp;paths&nbsp;in&nbsp;extensions&nbsp;=&nbsp;extensions&nbsp;into&nbsp;paths,&nbsp;which&nbsp;by&nbsp;induction&nbsp;is&nbsp;m'-truncated.&nbsp;*)</span><br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1625"></a><h2 class="section">Connectedness of path spaces</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">isconnected_paths</span> `{<span class="id" title="var">Univalence</span>} {<span class="id" title="var">n</span> <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span> (<span class="id" title="var">x</span> = <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">contr_equiv'</span> <span class="id" title="var">_</span> (<span class="id" title="var">equiv_path_Tr</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)^-1).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1626"></a><h2 class="section">Connectivity of pointed types</h2>

<div class="paragraph"> </div>

 The connectivity of a pointed type and (the inclusion of) its point are intimately connected. 
<div class="paragraph"> </div>

 We can't make both of these <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>s, as that would result in infinite loops. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">conn_pointed_type@</span>{<span class="id" title="var">u</span>} {<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} {<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">u</span>}} (<span class="id" title="var">a0</span>:<span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">unit_name</span> <span class="id" title="var">a0</span>)}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span> | 1000.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isconnected_conn_map_to_unit</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">OO_cancelR_conn_map</span> (<span class="id" title="var">Tr</span> <span class="id" title="var">n</span>.+1) (<span class="id" title="var">Tr</span> <span class="id" title="var">n</span>) (<span class="id" title="var">unit_name</span> <span class="id" title="var">a0</span>) (<span class="id" title="var">const_tt</span> <span class="id" title="var">A</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">conn_point_incl</span> `{<span class="id" title="var">Univalence</span>} {<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a0</span>:<span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> (<span class="id" title="var">unit_name</span> <span class="id" title="var">a0</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">OO_cancelL_conn_map</span> (<span class="id" title="var">Tr</span> <span class="id" title="var">n</span>.+1) (<span class="id" title="var">Tr</span> <span class="id" title="var">n</span>) (<span class="id" title="var">unit_name</span> <span class="id" title="var">a0</span>) (<span class="id" title="var">const_tt</span> <span class="id" title="var">A</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">O_lex_leq_Tr</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Immediate</span> <span class="id" title="var">conn_point_incl</span> : <span class="id" title="var">typeclass_instances</span>.<br/>

<br/>
</div>

<div class="doc">
Note that <span class="inlinecode"><span class="id" title="var">OO_cancelR_conn_map</span></span> and <span class="inlinecode"><span class="id" title="var">OO_cancelL_conn_map</span></span> (Proposition 2.31 of CORS) generalize the above statements to 2/3 of a 2-out-of-3 property for connected maps, for any reflective subuniverse and its subuniverse of separated types.  If useful, we could specialize that more general form explicitly to truncations. 
<div class="paragraph"> </div>

 To prove an <span class="inlinecode"><span class="id" title="var">n</span></span>-truncated predicate on an (n+1)-connected, pointed type, it's enough to prove it for the basepoint. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">conn_point_elim</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) {<span class="id" title="var">A</span> : <span class="id" title="var">pType@</span>{<span class="id" title="var">u</span>}} `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Type@</span>{<span class="id" title="var">u</span>}) `{<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">P</span> <span class="id" title="var">a</span>)} (<span class="id" title="var">p0</span> : <span class="id" title="var">P</span> (<span class="id" title="var">point</span> <span class="id" title="var">A</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">P</span> <span class="id" title="var">a</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
This follows from <span class="inlinecode"><span class="id" title="var">conn_point_incl</span></span> and <span class="inlinecode"><span class="id" title="var">conn_map_elim</span></span>, but we give a direct proof. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.<br/>
</div>

<div class="doc">
Since <span class="inlinecode"><span class="id" title="var">A</span></span> is <span class="inlinecode"><span class="id" title="var">n</span>+1</span>-connected, <span class="inlinecode"><span class="id" title="var">a0</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> is <span class="inlinecode"><span class="id" title="var">n</span></span>-connected, which means that <span class="inlinecode"><span class="id" title="var">Tr</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">a0</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span>)</span> has an element. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> <span class="id" title="var">proof</span> (<span class="id" title="var">p</span> := <span class="id" title="var">center</span> (<span class="id" title="var">Tr</span> <span class="id" title="var">n</span> ((<span class="id" title="var">point</span> <span class="id" title="var">A</span>) = <span class="id" title="var">a</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">p</span> # <span class="id" title="var">p0</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1627"></a><h2 class="section">Decreasing connectedness</h2>

<div class="paragraph"> </div>

 An <span class="inlinecode"><span class="id" title="var">n</span>.+1</span>-connected type is also <span class="inlinecode"><span class="id" title="var">n</span></span>-connected.  This obviously can't be an <span class="inlinecode"><span class="id" title="keyword">Instance</span></span>! 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isconnected_pred</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span> `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isconnected_from_elim</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">C</span> ? <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">isconnected_elim</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">C</span> <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
A <span class="inlinecode"><span class="id" title="var">k</span></span>-connected type is <span class="inlinecode"><span class="id" title="var">n</span></span>-connected, when <span class="inlinecode"><span class="id" title="var">k</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode"><span class="id" title="var">n</span></span>.  We constrain <span class="inlinecode"><span class="id" title="var">k</span></span> by making it of the form <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+2+</span> <span class="inlinecode"><span class="id" title="var">m</span></span>, which makes the induction go through smoothly. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isconnected_pred_add</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">A</span> `{<span class="id" title="var">H</span> : <span class="id" title="var">IsConnected</span> (<span class="id" title="var">n</span> +2+ <span class="id" title="var">m</span>) <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">IHn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isconnected_pred</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
A version with the order of summands swapped, which is sometimes handy, e.g. in the next two results. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isconnected_pred_add'</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">A</span> `{<span class="id" title="var">H</span> : <span class="id" title="var">IsConnected</span> (<span class="id" title="var">m</span> +2+ <span class="id" title="var">n</span>) <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">isconnected_pred_add</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">trunc_index_add_comm</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>); <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
It follows that an <span class="inlinecode"><span class="id" title="var">n</span>.+1</span>-connected type is also <span class="inlinecode">-1</span>-connected. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">merely_isconnected</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span> `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">merely</span> <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;:= @<span class="id" title="var">center</span> <span class="id" title="var">_</span> (<span class="id" title="var">isconnected_pred_add'</span> <span class="id" title="var">n</span> (-1) <span class="id" title="var">A</span>).<br/>

<br/>
</div>

<div class="doc">
And that an <span class="inlinecode"><span class="id" title="var">n</span>.+2</span>-connected type is <span class="inlinecode">0</span>-connected. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">is0connected_isconnected</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) <span class="id" title="var">A</span> `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+2 <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> 0 <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">isconnected_pred_add'</span> <span class="id" title="var">n</span> 0 <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isconnmap_pred_add</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) `{<span class="id" title="var">IsConnMap</span> (<span class="id" title="var">n</span> +2+ <span class="id" title="var">m</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnMap</span> <span class="id" title="var">m</span> <span class="id" title="var">f</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">isconnected_pred_add</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1628"></a><h2 class="section">0-connectedness</h2>

<div class="paragraph"> </div>

 To be 0-connected is the same as to be (-1)-connected and that any two points are merely equal.  TODO: This should also be generalized to separated subuniverses (CORS Remark 2.35).  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">merely_path_is0connected</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) `{<span class="id" title="var">IsConnected</span> 0 <span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">merely</span> (<span class="id" title="var">x</span> = <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
This follows immediately from <span class="inlinecode"><span class="id" title="var">isconnected_paths</span></span> above. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">center</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">is0connected_merely_allpath</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) `{<span class="id" title="var">merely</span> <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">p</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>:<span class="id" title="var">A</span>), <span class="id" title="var">merely</span> (<span class="id" title="var">x</span> = <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> 0 <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">contr_inhabited_hprop</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">hprop_allpath</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span> <span class="id" title="var">w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">equiv_path_Tr</span> <span class="id" title="var">z</span> <span class="id" title="var">w</span> (<span class="id" title="var">p</span> <span class="id" title="var">z</span> <span class="id" title="var">w</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">tr</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The path component of a point <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X</span></span> is connected. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is0connected_component</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> 0 { <span class="id" title="var">z</span> : <span class="id" title="var">X</span> &amp; <span class="id" title="var">merely</span> (<span class="id" title="var">z</span> = <span class="id" title="var">x</span>) }.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Build_Contr</span> <span class="id" title="var">_</span> (<span class="id" title="var">tr</span> (<span class="id" title="var">x</span>; <span class="id" title="var">tr</span> <span class="id" title="var">idpath</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">Trunc_ind</span>; <span class="id" title="tactic">intros</span> [<span class="id" title="var">Z</span> <span class="id" title="var">p</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">tr</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">path_sigma_hprop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">p</span>^.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Any two points in a path component are merely equal.  This follows from <span class="inlinecode"><span class="id" title="var">merely_path_is0connected</span></span>, but this proof doesn't need univalence. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">merely_path_component</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">x</span> : <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">z1</span> <span class="id" title="var">z2</span> : { <span class="id" title="var">z</span> : <span class="id" title="var">X</span> &amp; <span class="id" title="var">merely</span> (<span class="id" title="var">z</span> = <span class="id" title="var">x</span>) })<br/>
&nbsp;&nbsp;: <span class="id" title="var">merely</span> (<span class="id" title="var">z1</span> = <span class="id" title="var">z2</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">z1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">z1</span> <span class="id" title="var">p1</span>], <span class="id" title="var">z2</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">z2</span> <span class="id" title="var">p2</span>].<br/>
&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">tr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">path_sigma_hprop</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">p1</span> @ <span class="id" title="var">p2</span>^).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The path component of a point <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X</span></span> is equivalent to the image of the constant map <span class="inlinecode"><span class="id" title="var">Unit</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span> at <span class="inlinecode"><span class="id" title="var">x</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_component_image_unit</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;: { <span class="id" title="var">z</span> : <span class="id" title="var">X</span> &amp; <span class="id" title="var">merely</span> (<span class="id" title="var">z</span> = <span class="id" title="var">x</span>) } &lt;~&gt; <span class="id" title="var">image</span> (<span class="id" title="var">Tr</span> (-1)) (<span class="id" title="var">unit_name</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">image</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">equiv_functor_sigma_id</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Trunc_functor_equiv</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">hfiber</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="var">equiv_contr_sigma</span> <span class="id" title="var">_</span>)^-1 <span class="id" title="var">oE</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">equiv_path_inverse</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
0-connected types are indecomposable 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">indecomposable_0connected</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>) `{<span class="id" title="var">IsConnected</span> 0 <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">Indecomposable</span> <span class="id" title="var">X</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">IsConnected</span> (-1) <span class="id" title="var">X</span>) <span class="id" title="tactic">by</span> <span class="id" title="tactic">refine</span> (<span class="id" title="var">isconnected_pred</span> (-1) <span class="id" title="var">X</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">constructor</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">z</span> := <span class="id" title="var">center</span> (<span class="id" title="var">merely</span> <span class="id" title="var">X</span>) : <span class="id" title="var">merely</span> <span class="id" title="var">X</span>); <span class="id" title="tactic">generalize</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">Trunc_rec</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">ishprop_sum</span>; <span class="id" title="tactic">try</span> <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">l</span> <span class="id" title="var">r</span>. <span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">not_is_inl_and_inr'</span> (<span class="id" title="var">f</span> <span class="id" title="var">z</span>) (<span class="id" title="var">l</span> <span class="id" title="var">z</span>) (<span class="id" title="var">r</span> <span class="id" title="var">z</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">remember</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) <span class="id" title="keyword">as</span> <span class="id" title="var">y</span> <span class="id" title="var">eqn</span>:<span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">y</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">a</span>|<span class="id" title="var">b</span>]; [ <span class="id" title="tactic">left</span> | <span class="id" title="tactic">right</span> ]; <span class="id" title="tactic">intros</span> <span class="id" title="var">x'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span>:<span class="id" title="tactic">assert</span> (<span class="id" title="var">q</span> := <span class="id" title="var">merely_path_is0connected</span> <span class="id" title="var">X</span> <span class="id" title="var">x</span> <span class="id" title="var">x'</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span>:<span class="id" title="tactic">refine</span> (<span class="id" title="var">transport</span> <span class="id" title="var">_</span> (<span class="id" title="var">ap</span> <span class="id" title="var">f</span> <span class="id" title="var">q</span>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span>:<span class="id" title="tactic">exact</span> (<span class="id" title="var">transport</span> <span class="id" title="var">_</span> <span class="id" title="var">p</span>^ <span class="id" title="var">tt</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">nx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Trunc_rec</span> (<span class="id" title="var">n</span> := -1) <span class="id" title="var">nx</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">center</span> (<span class="id" title="var">merely</span> <span class="id" title="var">X</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Truncation&nbsp;preserves&nbsp;connectedness.&nbsp;Note&nbsp;that&nbsp;this&nbsp;is&nbsp;for&nbsp;different&nbsp;levels.&nbsp;*)</span><br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">isconnected_trunc</span> {<span class="id" title="var">X</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">trunc_index</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span> (<span class="id" title="var">Tr</span> <span class="id" title="var">m</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IsConnected</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> (<span class="id" title="var">contr_equiv'</span> <span class="id" title="var">_</span> (<span class="id" title="var">Trunc_swap</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span> <span class="id" title="var">X</span>)^-1).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Wedge_Incl_Conn</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1629"></a><h2 class="section">Connectivity of the wedge into the product.</h2>


<div class="paragraph"> </div>

A very useful form of the key lemma <span class="inlinecode"><span class="id" title="var">istrunc_extension_along_conn</span></span> is the connectivity of the wedge into the product, for a pair of pointed spaces.  In fact this can be formulated without mentioning the wedge per se (so, without requiring HIT’s), since the statement only needs to talk about maps out of the wedge.

<div class="paragraph"> </div>

Once again, we believe that the type of the conclusion is an hprop (though we do not prove it) — essentially because it is wrapping up an elimination principle and its corresponding computation rule — and so we make the proof of this result opaque. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Context</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a0</span> : <span class="id" title="var">A</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span>.+1 <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">b0</span> : <span class="id" title="var">B</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">B</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>) {<span class="id" title="var">HP</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">IsTrunc</span> (<span class="id" title="var">m</span> +2+ <span class="id" title="var">n</span>) (<span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f_a0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>:<span class="id" title="var">B</span>, <span class="id" title="var">P</span> <span class="id" title="var">a0</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f_b0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>:<span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b0</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">f_a0b0</span> : <span class="id" title="var">f_a0</span> <span class="id" title="var">b0</span> = <span class="id" title="var">f_b0</span> <span class="id" title="var">a0</span>).<br/>

<br/>
<span class="id" title="keyword">Corollary</span> <span class="id" title="var">isconn_wedge_incl</span><br/>
&nbsp;&nbsp;: { <span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&amp; { <span class="id" title="var">e_a0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, <span class="id" title="var">f</span> <span class="id" title="var">a0</span> <span class="id" title="var">b</span> = <span class="id" title="var">f_a0</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&amp; { <span class="id" title="var">e_b0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b0</span> = <span class="id" title="var">f_b0</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;&amp; <span class="id" title="var">e_b0</span> <span class="id" title="var">a0</span> = (<span class="id" title="var">e_a0</span> <span class="id" title="var">b0</span>) @ <span class="id" title="var">f_a0b0</span> }}}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">goal_as_extension</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ExtensionAlong</span> (<span class="id" title="var">unit_name</span> <span class="id" title="var">a0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">ExtensionAlong</span> (<span class="id" title="var">unit_name</span> <span class="id" title="var">b0</span>) (<span class="id" title="var">P</span> <span class="id" title="var">a</span>) (<span class="id" title="var">unit_name</span> (<span class="id" title="var">f_b0</span> <span class="id" title="var">a</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">unit_name</span> (<span class="id" title="var">f_a0</span> ; (<span class="id" title="var">unit_name</span> <span class="id" title="var">f_a0b0</span>)))).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> (<span class="id" title="var">extension_conn_map_elim</span> <span class="id" title="var">m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> (<span class="id" title="var">conn_point_incl</span> <span class="id" title="var">a0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">istrunc_extension_along_conn</span> (<span class="id" title="var">n</span> := <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">apply</span> (<span class="id" title="var">conn_point_incl</span> <span class="id" title="var">b0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">apply</span> <span class="id" title="var">HP</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">goal_as_extension</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f_eb</span> <span class="id" title="var">name_ea_eab</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">ea_eab</span> := <span class="id" title="var">name_ea_eab</span> <span class="id" title="var">tt</span>); <span class="id" title="tactic">clear</span> <span class="id" title="var">name_ea_eab</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">pr1</span> (<span class="id" title="var">f_eb</span> <span class="id" title="var">a</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">apD10</span> (<span class="id" title="var">ea_eab</span> ..1) <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">pr2</span> (<span class="id" title="var">f_eb</span> <span class="id" title="var">a</span>) <span class="id" title="var">tt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;last&nbsp;component&nbsp;is&nbsp;essentially&nbsp;(g'&nbsp;..2),&nbsp;wrapped&nbsp;in&nbsp;a&nbsp;bit&nbsp;of&nbsp;path-algebra.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">moveL_Mp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">concatR</span> (<span class="id" title="var">apD10</span> (<span class="id" title="var">ea_eab</span> ..2) <span class="id" title="var">tt</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">ea</span> := <span class="id" title="var">ea_eab</span> ..1). <span class="id" title="tactic">generalize</span> <span class="id" title="var">ea</span>; <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">clear</span> <span class="id" title="var">ea_eab</span> <span class="id" title="var">ea</span>. <span class="id" title="tactic">intros</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">transport_arrow</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">transport_const</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">transport_paths_Fl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> 1%<span class="id" title="var">path</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It is easier to apply the above result with its components separated. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wedge_incl_elim</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">isconn_wedge_incl</span>.1.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wedge_incl_comp1</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, <span class="id" title="var">wedge_incl_elim</span> <span class="id" title="var">a0</span> <span class="id" title="var">b</span> = <span class="id" title="var">f_a0</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">isconn_wedge_incl</span>.2.1.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wedge_incl_comp2</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">wedge_incl_elim</span> <span class="id" title="var">a</span> <span class="id" title="var">b0</span> = <span class="id" title="var">f_b0</span> <span class="id" title="var">a</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">isconn_wedge_incl</span>.2.2.1.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wedge_incl_comp3</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">wedge_incl_comp2</span> <span class="id" title="var">a0</span> = (<span class="id" title="var">wedge_incl_comp1</span> <span class="id" title="var">b0</span>) @ <span class="id" title="var">f_a0b0</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">isconn_wedge_incl</span>.2.2.2.<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Wedge_Incl_Conn</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">wedge_incl_elim_uncurried</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a0</span> : <span class="id" title="var">A</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span>.+1 <span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">b0</span> : <span class="id" title="var">B</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">B</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>) {<span class="id" title="var">HP</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">IsTrunc</span> (<span class="id" title="var">m</span> +2+ <span class="id" title="var">n</span>) (<span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)}<br/>
&nbsp;&nbsp;(<span class="id" title="var">fs</span> : {<span class="id" title="var">f_a0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>:<span class="id" title="var">B</span>, <span class="id" title="var">P</span> <span class="id" title="var">a0</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; { <span class="id" title="var">f_b0</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>:<span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; <span class="id" title="var">f_a0</span> <span class="id" title="var">b0</span> = <span class="id" title="var">f_b0</span> <span class="id" title="var">a0</span> }})<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">fs</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">f_a0</span> [<span class="id" title="var">f_b0</span> <span class="id" title="var">f_a0b0</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">wedge_incl_elim</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f_a0b0</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>