<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>FunextVarieties</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library FunextVarieties</h1>

<div class="code">
</div>

<div class="doc">
<a id="lab1196"></a><h1 class="section">Varieties of function extensionality</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">HoTT.Basics</span> <span class="id" title="var">HoTT.Types</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Metatheory.Core</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
In the Overture, we defined function extensionality to be the assertion that the map <span class="inlinecode"><span class="id" title="var">apD10</span></span> is an equivalence.   We now prove that this follows from a couple of weaker-looking forms of function extensionality.  We do require eta conversion, which Coq 8.4+ has judgmentally.

<div class="paragraph"> </div>

   This proof is originally due to Voevodsky; it has since been simplified by Peter Lumsdaine and Michael Shulman. 
<div class="paragraph"> </div>

 Naive funext is the simple assertion that pointwise equal functions are equal.  The domain and codomain could live in different universes; the third universe argument is essentially the max of <span class="inlinecode"><span class="id" title="var">i</span></span> and <span class="inlinecode"><span class="id" title="var">j</span></span> (and similarly for all subsequent axioms). 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">NaiveFunext</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>}) (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>) -&gt; (<span class="id" title="var">f</span> = <span class="id" title="var">g</span>).<br/>

<br/>
</div>

<div class="doc">
Naive non-dependent funext is the same, but only for non-dependent functions.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">NaiveNondepFunext</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>) -&gt; (<span class="id" title="var">f</span> = <span class="id" title="var">g</span>).<br/>

<br/>
</div>

<div class="doc">
Weak funext says that a product of contractible types is contractible. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">WeakFunext</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">forall</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">Contr</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>)) -&gt; <span class="id" title="var">Contr</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
The obvious implications are
   Funext -&gt; NaiveFunext -&gt; WeakFunext and NaiveFunext -&gt; NaiveNondepFunext.
   None of these do anything fiddly with the universes either. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Funext_implies_NaiveFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">Funext_type@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>} -&gt; <span class="id" title="var">NaiveFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">fe</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">Funext_type</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> ((@<span class="id" title="var">apD10</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>)^-1 <span class="id" title="var">h</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">NaiveFunext_implies_WeakFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">NaiveFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>} -&gt; <span class="id" title="var">WeakFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">nf</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">Pc</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Build_Contr</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">center</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">nf</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">contr</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">NaiveFunext_implies_NaiveNondepFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">NaiveFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>} -&gt; <span class="id" title="var">NaiveNondepFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">fun</span> <span class="id" title="var">nf</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">nf</span> <span class="id" title="var">A</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">B</span>) <span class="id" title="var">f</span> <span class="id" title="var">g</span>.<br/>

<br/>
</div>

<div class="doc">
The non-obvious directions are that WeakFunext implies Funext and that NaiveNondepFunext implies WeakFunext (and hence all four are logically equivalent). 
<div class="paragraph"> </div>

<a id="lab1197"></a><h2 class="section">Weak funext implies Funext</h2>

<div class="paragraph"> </div>

 To show that WeakFunext implies Funext, the point is that under weak funext, the space of "pointwise homotopies" has the same universal property as the space of paths. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Homotopies</span>.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> (<span class="id" title="keyword">wf</span> : <span class="id" title="var">WeakFunext</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> {<span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>} {<span class="id" title="var">B</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>}.<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> (<span class="id" title="var">f</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">B</span> <span class="id" title="var">x</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Recall&nbsp;that&nbsp;<span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">==</span> <span class="inlinecode"><span class="id" title="var">g</span></span>&nbsp;is&nbsp;the&nbsp;type&nbsp;of&nbsp;pointwise&nbsp;paths&nbsp;(or&nbsp;"homotopies")&nbsp;from&nbsp;<span class="inlinecode"><span class="id" title="var">f</span></span>&nbsp;to&nbsp;<span class="inlinecode"><span class="id" title="var">g</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">Let</span> <span class="id" title="var">idhtpy</span> : <span class="id" title="var">f</span> == <span class="id" title="var">f</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">idpath</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
Weak funext implies that the "based homotopy space" of the Pi-type is contractible, just like the based path space.  Use priority 1, so we don't override <span class="inlinecode"><span class="id" title="var">Contr</span></span> <span class="inlinecode"><span class="id" title="var">Unit</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">contr_basedhtpy</span> : <span class="id" title="var">Contr</span> {<span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">B</span> <span class="id" title="var">x</span> &amp; <span class="id" title="var">f</span> == <span class="id" title="var">g</span> } | 1.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">WeakFunext</span> <span class="id" title="tactic">in</span> <span class="id" title="keyword">wf</span>. <span class="comment">(*&nbsp;Allow&nbsp;typeclass&nbsp;inference&nbsp;to&nbsp;find&nbsp;it&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Build_Contr</span> <span class="id" title="var">_</span> (<span class="id" title="var">f</span>;<span class="id" title="var">idhtpy</span>)). <span class="id" title="tactic">intros</span> [<span class="id" title="var">g</span> <span class="id" title="var">h</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;trick&nbsp;is&nbsp;to&nbsp;show&nbsp;that&nbsp;the&nbsp;type&nbsp;<span class="inlinecode">{<span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">==</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">}</span>&nbsp;is&nbsp;a&nbsp;retract&nbsp;of&nbsp;<span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode">{<span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span>}</span>,&nbsp;which&nbsp;is&nbsp;contractible&nbsp;due&nbsp;to&nbsp;J&nbsp;and&nbsp;weak&nbsp;funext.&nbsp;&nbsp;Here&nbsp;are&nbsp;the&nbsp;retraction&nbsp;and&nbsp;its&nbsp;section.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">r</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">k</span> =&gt; <span class="id" title="var">exist</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">f</span> == <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; (<span class="id" title="var">k</span> <span class="id" title="var">x</span>).1) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; (<span class="id" title="var">k</span> <span class="id" title="var">x</span>).2)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">s</span> := <span class="id" title="keyword">fun</span> (<span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">B</span> <span class="id" title="var">x</span>) (<span class="id" title="var">h</span> : <span class="id" title="var">f</span> == <span class="id" title="var">g</span>) <span class="id" title="var">x</span> =&gt; (<span class="id" title="var">g</span> <span class="id" title="var">x</span> ; <span class="id" title="var">h</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Because&nbsp;of&nbsp;judgemental&nbsp;eta-conversion,&nbsp;the&nbsp;retraction&nbsp;is&nbsp;actually&nbsp;definitional,&nbsp;so&nbsp;we&nbsp;can&nbsp;just&nbsp;replace&nbsp;the&nbsp;goal.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">r</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; (<span class="id" title="var">f</span> <span class="id" title="var">x</span> ; <span class="id" title="var">idpath</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>))) = <span class="id" title="var">r</span> (<span class="id" title="var">s</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ap</span>; <span class="id" title="var">srapply</span> <span class="id" title="var">path_contr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
This enables us to prove that pointwise homotopies have the same elimination rule as the identity type. 
</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> (<span class="id" title="var">Q</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">g</span> (<span class="id" title="var">h</span> : <span class="id" title="var">f</span> == <span class="id" title="var">g</span>), <span class="id" title="keyword">Type</span>).<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Context</span> (<span class="id" title="var">d</span> : <span class="id" title="var">Q</span> <span class="id" title="var">f</span> <span class="id" title="var">idhtpy</span>).<br/>

<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">htpy_ind</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> : <span class="id" title="var">Q</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= @<span class="id" title="var">transport</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">gh</span> =&gt; <span class="id" title="var">Q</span> <span class="id" title="var">gh</span>.1 <span class="id" title="var">gh</span>.2) (<span class="id" title="var">f</span>;<span class="id" title="var">idhtpy</span>) (<span class="id" title="var">g</span>;<span class="id" title="var">h</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id" title="var">path_contr</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) <span class="id" title="var">d</span>.<br/>

<br/>
</div>

<div class="doc">
The computation rule, of course, is only propositional. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="keyword">Definition</span> <span class="id" title="var">htpy_ind_beta</span> : <span class="id" title="var">htpy_ind</span> <span class="id" title="var">f</span> <span class="id" title="var">idhtpy</span> = <span class="id" title="var">d</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;:= <span class="id" title="var">transport</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> : (<span class="id" title="var">f</span>;<span class="id" title="var">idhtpy</span>) = (<span class="id" title="var">f</span>;<span class="id" title="var">idhtpy</span>) =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">transport</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">gh</span> =&gt; <span class="id" title="var">Q</span> <span class="id" title="var">gh</span>.1 <span class="id" title="var">gh</span>.2) <span class="id" title="var">p</span> <span class="id" title="var">d</span> = <span class="id" title="var">d</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id" title="var">path2_contr</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">path_contr</span> (<span class="id" title="var">f</span>;<span class="id" title="var">idhtpy</span>) (<span class="id" title="var">f</span>;<span class="id" title="var">idhtpy</span>)) (<span class="id" title="var">idpath</span> <span class="id" title="var">_</span>))^<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">idpath</span> <span class="id" title="var">_</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Homotopies</span>.<br/>

<br/>
</div>

<div class="doc">
Now the proof is fairly easy; we can just use the same induction principle on both sides.  This proof also preserves all the universes. 
</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">WeakFunext_implies_Funext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">WeakFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>} -&gt; <span class="id" title="var">Funext_type@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="keyword">wf</span>; <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">isequiv_adjointify</span> (@<span class="id" title="var">apD10</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">htpy_ind</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">g'</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">f</span> = <span class="id" title="var">g'</span>) <span class="id" title="var">idpath</span> <span class="id" title="var">g</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="var">revert</span> <span class="id" title="var">g</span>; <span class="id" title="tactic">refine</span> (<span class="id" title="var">htpy_ind</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ap</span> <span class="id" title="var">_</span> (<span class="id" title="var">htpy_ind_beta</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">h</span>; <span class="id" title="tactic">destruct</span> <span class="id" title="var">h</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">htpy_ind_beta</span> <span class="id" title="keyword">wf</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">NaiveFunext_implies_Funext</span> : <span class="id" title="var">NaiveFunext</span> -&gt; <span class="id" title="var">Funext_type</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">WeakFunext_implies_Funext</span> <span class="id" title="var">o</span> <span class="id" title="var">NaiveFunext_implies_WeakFunext</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1198"></a><h2 class="section">Naive non-dependent funext implies weak funext</h2>

<div class="paragraph"> </div>

 First we show that naive non-dependent funext suffices to show that postcomposition with an equivalence is an equivalence. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_postcompose_from_NaiveNondepFunext</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">nf</span> : <span class="id" title="var">NaiveNondepFunext</span>) {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">B</span> &lt;~&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;: (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) &lt;~&gt; (<span class="id" title="var">A</span> -&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">Build_Equiv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">g</span>:<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>) =&gt; <span class="id" title="var">f</span> <span class="id" title="var">o</span> <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">isequiv_adjointify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<span class="id" title="var">g</span>:<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>) =&gt; <span class="id" title="var">f</span> <span class="id" title="var">o</span> <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> =&gt; <span class="id" title="var">f</span>^-1 <span class="id" title="var">o</span> <span class="id" title="var">h</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> =&gt; <span class="id" title="var">nf</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">eisretr</span> <span class="id" title="var">f</span> (<span class="id" title="var">h</span> <span class="id" title="var">x</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> =&gt; <span class="id" title="var">nf</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">eissect</span> <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">y</span>)))).<br/>

<br/>
</div>

<div class="doc">
Now, if each <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> is contractible, the projection <span class="inlinecode"><span class="id" title="var">pr1</span></span> <span class="inlinecode">:</span> <span class="inlinecode">{<span class="id" title="var">x</span>:<span class="id" title="var">X</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span>}</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span> is an equivalence (this requires no funext).  Thus, postcomposition with it is also an equivalence, and hence the fiber of postcomposition over <span class="inlinecode"><span class="id" title="var">idmap</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> is contractible.  But this fiber is "the type of sections of <span class="inlinecode"><span class="id" title="var">pr1</span></span>" and hence equivalent to <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span>:<span class="id" title="var">X</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.  The latter equivalence requires full funext to prove, but without any funext we can show that <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">x</span>:<span class="id" title="var">X</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> is a *retract* of the type of sections, hence also contractible. 
</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">NaiveNondepFunext_implies_WeakFunext</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">NaiveNondepFunext</span> -&gt; <span class="id" title="var">WeakFunext</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">nf</span> <span class="id" title="var">X</span> <span class="id" title="var">P</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">T</span> := (<span class="id" title="var">hfiber</span> (<span class="id" title="var">equiv_postcompose_from_NaiveNondepFunext</span> <span class="id" title="var">nf</span> (<span class="id" title="var">equiv_pr1</span> <span class="id" title="var">P</span>)) <span class="id" title="var">idmap</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (@<span class="id" title="var">contr_retract</span> <span class="id" title="var">T</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">fp</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">transport</span> <span class="id" title="var">P</span> (<span class="id" title="var">ap10</span> <span class="id" title="var">fp</span>.2 <span class="id" title="var">x</span>) (<span class="id" title="var">fp</span>.1 <span class="id" title="var">x</span>).2)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; ((<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; (<span class="id" title="var">x</span> ; <span class="id" title="var">f</span> <span class="id" title="var">x</span>)) ; 1)) (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; 1)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Therefore, naive nondependent funext also implies full funext.  Interestingly, this requires the universe of the assumption codomain to be not just that of the conclusion codomain, but the max of that universe with the domain universe (which is unchanged). 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">NaiveNondepFunext_implies_Funext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">NaiveNondepFunext@</span>{<span class="id" title="var">i</span> <span class="id" title="var">max</span> <span class="id" title="var">max</span>} -&gt; <span class="id" title="var">Funext_type@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}<br/>
&nbsp;&nbsp;:= <span class="id" title="var">WeakFunext_implies_Funext</span> <span class="id" title="var">o</span> <span class="id" title="var">NaiveNondepFunext_implies_WeakFunext</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1199"></a><h2 class="section">Functional extensionality is downward closed</h2>

<div class="paragraph"> </div>

 If universe <span class="inlinecode"><span class="id" title="var">U_i</span></span> is functionally extensional, then so are universes <span class="inlinecode"><span class="id" title="var">U_i'</span></span> for <span class="inlinecode"><span class="id" title="var">i'</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">i</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">Funext_downward_closed@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span> <span class="id" title="var">i'</span> <span class="id" title="var">j'</span> <span class="id" title="var">max'</span> | <span class="id" title="var">i</span> &lt;= <span class="id" title="var">max</span>, <span class="id" title="var">j</span> &lt;= <span class="id" title="var">max</span>, <span class="id" title="var">i'</span> &lt;= <span class="id" title="var">max'</span>, <span class="id" title="var">j'</span> &lt;= <span class="id" title="var">max'</span>, <span class="id" title="var">i'</span> &lt;= <span class="id" title="var">i</span>, <span class="id" title="var">j'</span> &lt;= <span class="id" title="var">j</span>}<br/>
&nbsp;&nbsp;`{<span class="id" title="var">H</span> : <span class="id" title="var">Funext_type@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> <span class="id" title="var">max</span>}} : <span class="id" title="var">Funext_type@</span>{<span class="id" title="var">i'</span> <span class="id" title="var">j'</span> <span class="id" title="var">max'</span>}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">hnf</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Here&nbsp;we&nbsp;make&nbsp;use&nbsp;of&nbsp;cumulativity.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> =&gt; <span class="id" title="var">H</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>