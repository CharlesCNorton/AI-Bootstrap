<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>HomotopyGroup</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library HomotopyGroup</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Basics</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">Pointed</span> <span class="id" title="var">HSet</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Modalities.Modality</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Truncations.Core</span> <span class="id" title="var">Truncations.SeparatedTrunc</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Algebra.AbGroups</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">WildCat</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">pointed_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The type that the nth homotopy group will have. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">HomotopyGroup_type</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="var">pType</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">n</span>.+1 =&gt; <span class="id" title="var">Group</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Every&nbsp;homotopy&nbsp;group&nbsp;is,&nbsp;in&nbsp;particular,&nbsp;a&nbsp;pointed&nbsp;type.&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">HomotopyGroup_type_ptype</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">HomotopyGroup_type</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">pType</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">return</span> <span class="id" title="var">HomotopyGroup_type</span> <span class="id" title="var">n</span> -&gt; <span class="id" title="var">pType</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">X</span> =&gt; <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;works&nbsp;because&nbsp;<span class="inlinecode"><span class="id" title="var">ptype_group</span></span>&nbsp;is&nbsp;already&nbsp;a&nbsp;coercion.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">n</span>.+1 =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">G</span> =&gt; <span class="id" title="var">G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">HomotopyGroup_type_ptype</span> : <span class="id" title="var">HomotopyGroup_type</span> &gt;-&gt; <span class="id" title="var">pType</span>.<br/>

<br/>
</div>

<div class="doc">
We construct the wildcat structure on HomotopyGroup_type in the obvious way. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">isgraph_homotopygroup_type</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsGraph</span> (<span class="id" title="var">HomotopyGroup_type</span> <span class="id" title="var">n</span>) := <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is2graph_homotopygroup_type</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Is2Graph</span> (<span class="id" title="var">HomotopyGroup_type</span> <span class="id" title="var">n</span>) := <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is01cat_homotopygroup_type</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Is01Cat</span> (<span class="id" title="var">HomotopyGroup_type</span> <span class="id" title="var">n</span>) := <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is1cat_homotopygroup_type</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Is1Cat</span> (<span class="id" title="var">HomotopyGroup_type</span> <span class="id" title="var">n</span>) := <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is0functor_homotopygroup_type_ptype</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Is0Functor</span> (<span class="id" title="var">HomotopyGroup_type_ptype</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is1functor_homotopygroup_type_ptype</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Is1Functor</span> (<span class="id" title="var">HomotopyGroup_type_ptype</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
We first define <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode">1</span> <span class="inlinecode"><span class="id" title="var">X</span></span>, and use this to define <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span>.
  The reason is to make it easier for Coq to see that <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>.+1)</span> <span class="inlinecode"><span class="id" title="var">X</span></span> is
  definitionally equal to <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode">1</span> <span class="inlinecode">(<span class="id" title="var">iterated_loops</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span> 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Pi1</span> (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) : <span class="id" title="var">Group</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> (<span class="id" title="var">Build_Group</span> (<span class="id" title="var">Tr</span> 0 (<span class="id" title="var">loops</span> <span class="id" title="var">X</span>)));<br/>
&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">split</span>.<br/>
</div>

<div class="doc">
Operation 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">tr</span> (<span class="id" title="var">x</span> @ <span class="id" title="var">y</span>)).<br/>
</div>

<div class="doc">
Unit 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">tr</span> 1).<br/>
</div>

<div class="doc">
Inverse 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="var">srapply</span> <span class="id" title="var">Trunc_rec</span>; <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">tr</span> <span class="id" title="var">x</span>^).<br/>
</div>

<div class="doc">
IsHSet 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
</div>

<div class="doc">
Associativity 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_p_pp</span>.<br/>
</div>

<div class="doc">
Left identity 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_1p</span>.<br/>
</div>

<div class="doc">
Right identity 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_p1</span>.<br/>
</div>

<div class="doc">
Left inverse 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">tr</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_Vp</span>.<br/>
</div>

<div class="doc">
Right inverse 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">tr</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_pV</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Definition of the nth homotopy group 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Pi</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) : <span class="id" title="var">HomotopyGroup_type</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">exact</span> (<span class="id" title="var">pTr</span> 0 <span class="id" title="var">X</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">Pi1</span> (<span class="id" title="var">iterated_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
See <span class="inlinecode"><span class="id" title="var">pi_loops</span></span> below for an alternate unfolding. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pi_succ</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> : <span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span> $&lt;~&gt; <span class="id" title="var">Pi</span> 1 (<span class="id" title="var">iterated_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">grp_iso_id</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <span class="id" title="var">PiUtf8</span>.<br/>
&nbsp;&nbsp;<span class="id" title="keyword">Notation</span> &quot;'Ï€'" := <span class="id" title="var">Pi</span>.<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">PiUtf8</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">ishset_pi</span> {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} {<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsHSet</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
When n &gt;= 2 we have that the nth homotopy group is an abelian group. Note that we don't actually define it as an abelian group but merely show that it is one. This would cause lots of complications with the typechecker. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">isabgroup_pi</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsAbGroup</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+2 <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">Build_IsAbGroup</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">cbn</span>; <span class="id" title="tactic">apply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">tr</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">eckmann_hilton</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
For the same reason as above, we make <span class="inlinecode"><span class="id" title="var">Pi1</span></span> a functor before making <span class="inlinecode"><span class="id" title="var">Pi</span></span> a functor. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is0functor_pi1</span> : <span class="id" title="var">Is0Functor</span> <span class="id" title="var">Pi1</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Build_Is0Functor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_GroupHomomorphism</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">Tr</span> 0)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">fmap</span> <span class="id" title="var">loops</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>. }<br/>
&nbsp;&nbsp;</div>

<div class="doc">
Note: we don't have to be careful about which paths we choose here since we are trying to inhabit a proposition. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">tr</span>); <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">concat_pp_p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">whiskerL</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">concat_p_pp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">concat_pp_p</span> (<span class="id" title="var">ap</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">concat_pV</span>, <span class="id" title="var">concat_p1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">concat_p_pp</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">whiskerR</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ap_pp</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is0functor_pi</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">Is0Functor</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fmap_pi_succ</span> {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> $-&gt; <span class="id" title="var">Y</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">fmap</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1) <span class="id" title="var">f</span> $== <span class="id" title="var">fmap</span> (<span class="id" title="var">Pi</span> 1) (<span class="id" title="var">fmap</span> (<span class="id" title="var">iterated_loops</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is1functor_pi1</span> : <span class="id" title="var">Is1Functor</span> <span class="id" title="var">Pi1</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
The conditions for <span class="inlinecode"><span class="id" title="var">Pi1</span></span> to be a 1-functor only involve equalities of maps between groups, which reduce to equalities of maps between types.  Type inference shows that <span class="inlinecode"><span class="id" title="var">Tr</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">loops</span></span> is a 1-functor, and so it follows that <span class="inlinecode"><span class="id" title="var">Pi1</span></span> is a 1-functor. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">is1f</span> : <span class="id" title="var">Is1Functor</span> (<span class="id" title="var">Tr</span> 0 <span class="id" title="var">o</span> <span class="id" title="var">loops</span>)) <span class="id" title="tactic">by</span> <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Build_Is1Functor</span>; <span class="id" title="tactic">intros</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">by</span> <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap2</span> <span class="id" title="var">_</span> (<span class="id" title="var">is1functor_F</span> := <span class="id" title="var">is1f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">by</span> <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap_id</span> <span class="id" title="var">_</span> (<span class="id" title="var">is1functor_F</span> := <span class="id" title="var">is1f</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">by</span> <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap_comp</span> <span class="id" title="var">_</span> (<span class="id" title="var">is1functor_F</span> := <span class="id" title="var">is1f</span>)) ].<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is1functor_pi</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">Is1Functor</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
Sometimes it is convenient to regard <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> as landing in pointed types.  On objects, this is handled by the coercion <span class="inlinecode"><span class="id" title="var">HomotopyGroup_type_ptype</span></span>, but on morphisms it doesn't seem possible to define a coercion.  So we explicitly name the composite functor. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pPi</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">pType</span> -&gt; <span class="id" title="var">pType</span> := <span class="id" title="var">HomotopyGroup_type_ptype</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span> <span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is0functor_ppi</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">Is0Functor</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) := <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is1functor_ppi</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">Is1Functor</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) := <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">pPi</span></span> is equal to a more explicit map.  These are definitional for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> and <span class="inlinecode"><span class="id" title="var">n</span></span> a successor; it would be nice to make them definitional for generic <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ppi_ptr_iterated_loops</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pPi</span> <span class="id" title="var">n</span> = <span class="id" title="var">pTr</span> 0 <span class="id" title="var">o</span> <span class="id" title="var">iterated_loops</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">reflexivity</span>).<br/>

<br/>
</div>

<div class="doc">
Here is the associated object-wise equivalence, which is the identity map for <span class="inlinecode">0</span> and successors. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_ppi_ptr_iterated_loops</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pPi</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">pTr</span> 0 (<span class="id" title="var">iterated_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">pequiv_pmap_idmap</span>).<br/>

<br/>
</div>

<div class="doc">
These equivalences are natural. Put another way, we can compute <span class="inlinecode"><span class="id" title="var">fmap</span></span> <span class="inlinecode"><span class="id" title="var">Pi</span></span> in terms of the composite functor, up to the equivalences above. For <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span> or <span class="inlinecode"><span class="id" title="var">n</span></span> a successor, we can omit the equivalences; for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>, the induced maps are definitionally equal as pointed maps; for <span class="inlinecode"><span class="id" title="var">n</span></span> a successfor the underlying unpointed maps are definitionally equal, but the pointedness proofs are not, and this is handled by <span class="inlinecode"><span class="id" title="var">phomotopy_homotopy_hset</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fmap_ppi_ptr_iterated_loops</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pequiv_ppi_ptr_iterated_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span> <span class="id" title="var">o</span>* <span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;==* <span class="id" title="var">fmap</span> (<span class="id" title="var">pTr</span> 0) (<span class="id" title="var">fmap</span> (<span class="id" title="var">iterated_loops</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span>) <span class="id" title="var">o</span>* <span class="id" title="var">pequiv_ppi_ptr_iterated_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">pequiv_ppi_ptr_iterated_loops</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">refine</span> (<span class="id" title="var">pmap_postcompose_idmap</span> <span class="id" title="var">_</span> @* (<span class="id" title="var">pmap_precompose_idmap</span> <span class="id" title="var">_</span>)^*).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">pmap_postcompose_idmap</span> <span class="id" title="var">_</span> @* <span class="id" title="var">_</span> @* (<span class="id" title="var">pmap_precompose_idmap</span> <span class="id" title="var">_</span>)^*).<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">phomotopy_homotopy_hset</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">n</span>.+1</span> sends equivalences to group isomorphisms. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">groupiso_pi_functor</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">e</span> : <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span> $&lt;~&gt; <span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">emap</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1) <span class="id" title="var">e</span>.<br/>

<br/>
</div>

<div class="doc">
The homotopy groups of a loop space are those of the space shifted.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pi_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> : <span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">Pi</span> <span class="id" title="var">n</span> (<span class="id" title="var">loops</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">emap</span> (<span class="id" title="var">pTr</span> 0 <span class="id" title="var">o</span> <span class="id" title="var">loops</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">unfold_iterated_loops'</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Except in the lowest case, this can be expressed as an isomorphism of groups. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">groupiso_pi_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> : <span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+2 <span class="id" title="var">X</span> $&lt;~&gt; <span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 (<span class="id" title="var">loops</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> (<span class="id" title="var">groupiso_pi_functor</span> 0).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">unfold_iterated_loops'</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Naturality of <span class="inlinecode"><span class="id" title="var">pi_loops</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fmap_pi_loops</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;: (<span class="id" title="var">pi_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span>) <span class="id" title="var">o</span>* (<span class="id" title="var">fmap</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1) <span class="id" title="var">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;==* (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span> <span class="id" title="var">o</span> <span class="id" title="var">loops</span>) <span class="id" title="var">f</span>) <span class="id" title="var">o</span>* (<span class="id" title="var">pi_loops</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="var">srapply</span> <span class="id" title="var">phomotopy_homotopy_hset</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="var">O_functor_compose</span> 0 <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)^ @ <span class="id" title="var">_</span> @ (<span class="id" title="var">O_functor_compose</span> 0 <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">O_functor_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">pointed_htpy</span> (<span class="id" title="var">unfold_iterated_fmap_loops</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">f</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Homotopy groups preserve products.  This is a direct proof, but below we give a second proof whose underlying map is the natural one. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pi_prod'</span> {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pPi</span> <span class="id" title="var">n</span> (<span class="id" title="var">X</span> * <span class="id" title="var">Y</span>) &lt;~&gt;* (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>) * (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;First&nbsp;we&nbsp;re-express&nbsp;this&nbsp;in&nbsp;terms&nbsp;of&nbsp;the&nbsp;composite&nbsp;<span class="inlinecode"><span class="id" title="var">pTr</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">iterated_loops</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <span class="id" title="var">o</span>*<span class="id" title="var">E</span> <span class="id" title="var">pequiv_ppi_ptr_iterated_loops</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="var">equiv_functor_pprod</span> (<span class="id" title="var">pequiv_ppi_ptr_iterated_loops</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">pequiv_ppi_ptr_iterated_loops</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>))^-1* <span class="id" title="var">o</span>*<span class="id" title="var">E</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;For&nbsp;this&nbsp;composite,&nbsp;the&nbsp;proof&nbsp;is&nbsp;straightforward.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <span class="id" title="var">o</span>*<span class="id" title="var">E</span> <span class="id" title="var">pequiv_ptr_functor</span> 0 <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;1: <span class="id" title="var">nrapply</span> <span class="id" title="var">iterated_loops_prod</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_pEquiv'</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (<span class="id" title="var">equiv_O_prod_cmp</span> 0 <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The pointed map from left-to-right below, coming from functoriality, is an equivalence. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pi_prod</span> {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pPi</span> <span class="id" title="var">n</span> (<span class="id" title="var">X</span> * <span class="id" title="var">Y</span>) &lt;~&gt;* (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>) * (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_pEquiv</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;describes&nbsp;the&nbsp;natural&nbsp;map.&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="id" title="var">rapply</span> (<span class="id" title="var">equiv_pprod_coind</span> (<span class="id" title="var">pfam_const</span> <span class="id" title="var">_</span>) (<span class="id" title="var">pfam_const</span> <span class="id" title="var">_</span>)); <span class="id" title="tactic">split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) (@<span class="id" title="var">pfst</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) (@<span class="id" title="var">psnd</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;To&nbsp;see&nbsp;that&nbsp;it&nbsp;is&nbsp;an&nbsp;equivalence,&nbsp;we&nbsp;show&nbsp;that&nbsp;it&nbsp;is&nbsp;homotopic&nbsp;to&nbsp;<span class="inlinecode"><span class="id" title="var">pi_prod'</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> (<span class="id" title="var">isequiv_homotopic'</span> (<span class="id" title="var">pi_prod'</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">xy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">path_prod</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">path_prod</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,2: <span class="id" title="tactic">apply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">tr</span>). <span class="comment">(*&nbsp;Not&nbsp;obvious,&nbsp;but&nbsp;unfolding&nbsp;makes&nbsp;things&nbsp;cluttered.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">exact</span> (<span class="id" title="var">pfst_iterated_loops_prod</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">n</span>.+1) <span class="id" title="var">xy</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">exact</span> (<span class="id" title="var">psnd_iterated_loops_prod</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">n</span>.+1) <span class="id" title="var">xy</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
For positive <span class="inlinecode"><span class="id" title="var">n</span></span>, this equivalence is an isomorphism of groups. 
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">grp_iso_pi_prod</span> {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">GroupIsomorphism</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 (<span class="id" title="var">X</span> * <span class="id" title="var">Y</span>)) (<span class="id" title="var">grp_prod</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span>) (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">Y</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_GroupIsomorphism</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;underlying&nbsp;map&nbsp;is&nbsp;the&nbsp;natural&nbsp;one,&nbsp;so&nbsp;it&nbsp;is&nbsp;automatically&nbsp;a&nbsp;group&nbsp;homomorphism.&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">grp_prod_corec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1) (@<span class="id" title="var">pfst</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1) (@<span class="id" title="var">psnd</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span>)).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;is&nbsp;also&nbsp;the&nbsp;underlying&nbsp;map&nbsp;of&nbsp;<span class="inlinecode"><span class="id" title="var">pi_prod</span></span>,&nbsp;so&nbsp;we&nbsp;can&nbsp;reuse&nbsp;the&nbsp;proof&nbsp;that&nbsp;it&nbsp;is&nbsp;an&nbsp;equivalence.&nbsp;*)</span><br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">equiv_isequiv</span> (<span class="id" title="var">pi_prod</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">n</span>.+1))).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Homotopy groups of truncations 
<div class="paragraph"> </div>

 An <span class="inlinecode"><span class="id" title="var">n</span></span>-connected map induces an equivalence on the nth homotopy group.  We first state this for <span class="inlinecode"><span class="id" title="var">pTr</span></span> <span class="inlinecode">0</span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">iterated_loops</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>, since the proof works for general <span class="inlinecode"><span class="id" title="var">n</span></span>, and then we deduce the result for <span class="inlinecode"><span class="id" title="var">pPi</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> afterwards. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isequiv_pi_connmap'</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;`{!<span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pTr</span> 0) (<span class="id" title="var">fmap</span> (<span class="id" title="var">iterated_loops</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">O_inverts_conn_map</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">isconnected_iterated_fmap_loops</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">trunc_index_inc'_succ</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">trunc_index_inc_agree</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The same holds for <span class="inlinecode"><span class="id" title="var">pPi</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">isequiv_pi_connmap</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;`{!<span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;For&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>&nbsp;and&nbsp;<span class="inlinecode"><span class="id" title="var">n</span></span>&nbsp;a&nbsp;successor,&nbsp;<span class="inlinecode"><span class="id" title="var">fmap</span></span> <span class="inlinecode">(<span class="id" title="var">pPi</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">f</span></span>&nbsp;is&nbsp;definitionally&nbsp;equal&nbsp;to&nbsp;the&nbsp;map&nbsp;in&nbsp;the&nbsp;previous&nbsp;result&nbsp;as&nbsp;a&nbsp;map&nbsp;of&nbsp;types.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="var">rapply</span> <span class="id" title="var">isequiv_pi_connmap'</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_pi_connmap</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;`{!<span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">Pi</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">Pi</span> <span class="id" title="var">n</span> <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">Build_pEquiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">f</span>) <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
For positive <span class="inlinecode"><span class="id" title="var">n</span></span>, it is a group isomorphism. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">grp_iso_pi_connmap</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;`{!<span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">GroupIsomorphism</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span>) (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">Build_GroupIsomorphism</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1) <span class="id" title="var">f</span>) (<span class="id" title="var">isequiv_pi_connmap</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">f</span>).<br/>

<br/>
</div>

<div class="doc">
As a consequence, the truncation map <span class="inlinecode"><span class="id" title="var">ptr</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">pTr</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> induces an equivalence on <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.  We don't make this an instance, since it is found by typeclass search. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isequiv_pi_Tr</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">ptr</span> : <span class="id" title="var">Pi</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> -&gt; <span class="id" title="var">Pi</span> <span class="id" title="var">n</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>))<br/>
&nbsp;&nbsp;:= <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_pi_Tr</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Pi</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">Pi</span> <span class="id" title="var">n</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">Build_pEquiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">ptr</span>) <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
For positive <span class="inlinecode"><span class="id" title="var">n</span></span>, it is a group isomorphism. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">grp_iso_pi_Tr</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">GroupIsomorphism</span> (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span>) (<span class="id" title="var">Pi</span> <span class="id" title="var">n</span>.+1 (<span class="id" title="var">pTr</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span>))<br/>
&nbsp;&nbsp;:= <span class="id" title="var">grp_iso_pi_connmap</span> <span class="id" title="var">n</span> <span class="id" title="var">ptr</span>.<br/>

<br/>
</div>

<div class="doc">
An <span class="inlinecode"><span class="id" title="var">n</span></span>-connected map induces a surjection on <span class="inlinecode"><span class="id" title="var">n</span>+1</span>-fold loop spaces and <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode">(<span class="id" title="var">n</span>+1)</span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">issurj_iterated_loops_connmap</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;{<span class="id" title="var">C</span> : <span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsSurjection</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">iterated_loops</span> (<span class="id" title="var">n</span>.+1)) <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isconnected_iterated_fmap_loops</span>. <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">trunc_index_inc'_0n</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">issurj_pi_connmap</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>)<br/>
&nbsp;&nbsp;{<span class="id" title="var">C</span> : <span class="id" title="var">IsConnMap</span> <span class="id" title="var">n</span> <span class="id" title="var">f</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnMap</span> (<span class="id" title="var">Tr</span> (-1)) (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>.+1) <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">conn_map_O_functor_strong_leq</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">issurj_iterated_loops_connmap</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Pointed sections induce embeddings on homotopy groups. 
</div>
<div class="code">
<span class="id" title="keyword">Proposition</span> <span class="id" title="var">isembedding_pi_psect</span> {<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} {<span class="id" title="var">X</span> <span class="id" title="var">Y</span> : <span class="id" title="var">pType</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">s</span> : <span class="id" title="var">X</span> -&gt;* <span class="id" title="var">Y</span>) (<span class="id" title="var">r</span> : <span class="id" title="var">Y</span> -&gt;* <span class="id" title="var">X</span>) (<span class="id" title="var">k</span> : <span class="id" title="var">r</span> <span class="id" title="var">o</span>* <span class="id" title="var">s</span> ==* <span class="id" title="var">pmap_idmap</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsEmbedding</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">s</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isembedding_isinj_hset</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">isinj_section</span> (<span class="id" title="var">r</span>:=<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">r</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">lhs_V</span> <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap_comp</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">s</span> <span class="id" title="var">r</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap2</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">k</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">fmap_id</span> (<span class="id" title="var">pPi</span> <span class="id" title="var">n</span>) <span class="id" title="var">X</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>