<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Topological</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Topological</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">HoTT.Basics</span> <span class="id" title="var">HoTT.Types</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Extensions</span> <span class="id" title="var">HoTT.Truncations</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Accessible</span> <span class="id" title="var">Lex</span> <span class="id" title="var">Nullification</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1278"></a><h1 class="section">Topological localizations</h1>

<div class="paragraph"> </div>

 A topological localization -- or, as we will say, a topological nullification -- is a nullification at a family of hprops, or more generally an accessible modality whose generators of accessibility are all hprops.  This is not quite the same as Lurie's definition: in Higher Topos Theory, a topological localization is an accessible *left exact* localization at a pullback-stable class generated by a set of monomorphisms.  "Pullback-stable class generated by" is roughly incorporated into our internal notion of accessibility, so the main new difference here is that when the generation is internal in this way, the localization at a family of hprops is *automatically* left exact. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">Topological</span> <span class="id" title="var">O</span> := (<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span>, <span class="id" title="var">IsHProp</span> (<span class="id" title="var">acc_ngen</span> <span class="id" title="var">O</span> <span class="id" title="var">i</span>)).<br/>

<br/>
</div>

<div class="doc">
<a id="lab1279"></a><h2 class="section">Topological modalities are lex</h2>

<div class="paragraph"> </div>

 We prove left-exactness by proving that the universe of modal types is modal, using univalence.  It's unclear whether univalence is necessary or not in general; in one special case (open modalities) funext suffices.  But it's plausible that it would be necessary in general, because lex-ness of nullification is a statement about the path-spaces of a HIT, and characterizing those in any way usually requires some amount of univalence. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">lex_topological</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">O</span> : <span class="id" title="var">Modality</span>) `{<span class="id" title="var">IsAccModality</span> <span class="id" title="var">O</span>} `{<span class="id" title="var">Topological</span> <span class="id" title="var">O</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">Lex</span> <span class="id" title="var">O</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">lex_from_inO_typeO</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> ((<span class="id" title="var">equiv_ooextendable_isequiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)^-1%<span class="id" title="var">equiv</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">isequiv_adjointify</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">B</span> <span class="id" title="var">a</span>) ; <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">path_arrow</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">path_TypeO</span>, <span class="id" title="var">path_universe_uncurried</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">composeD</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<span class="id" title="var">equiv_adjointify</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">a'</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">transport</span> <span class="id" title="var">B</span> (<span class="id" title="var">path_ishprop</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>) <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">transport2</span> <span class="id" title="var">B</span> (<span class="id" title="var">path_contr</span> <span class="id" title="var">_</span> 1) <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>. <span class="id" title="tactic">apply</span> <span class="id" title="var">path_forall</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">a'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">apD</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">path_arrow</span>; <span class="id" title="tactic">intros</span> [].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">path_TypeO</span>, <span class="id" title="var">path_universe_uncurried</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">composeD</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">e</span> := <span class="id" title="var">isequiv_ooextendable</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">fst</span> (<span class="id" title="var">inO_iff_isnull</span> <span class="id" title="var">O</span> (<span class="id" title="var">B</span> <span class="id" title="var">tt</span>)) (<span class="id" title="var">inO_TypeO</span> (<span class="id" title="var">B</span> <span class="id" title="var">tt</span>)) <span class="id" title="var">i</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">composeD</span> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>; <span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">e</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <span class="id" title="var">oE</span> (<span class="id" title="var">Build_Equiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">e</span>)^-1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">equiv_contr_forall</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">lex_nullification</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">S</span> : <span class="id" title="var">NullGenerators</span>) `{<span class="id" title="keyword">forall</span> <span class="id" title="var">i</span>, <span class="id" title="var">IsHProp</span> (<span class="id" title="var">S</span> <span class="id" title="var">i</span>)}<br/>
: <span class="id" title="var">Lex</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">S</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">lex_topological</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1280"></a><h2 class="section">Lex modalities generated by n-types are topological</h2>

<div class="paragraph"> </div>

 For <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode">0</span>, nullification at a family of <span class="inlinecode"><span class="id" title="var">n</span></span>-types need not be lex.  For instance, the (-1)-truncation is nullification at <span class="inlinecode"><span class="id" title="var">Bool</span></span>.  However, if the nullification at a family of <span class="inlinecode"><span class="id" title="var">n</span></span>-types *is* lex, then it is topological. 
<div class="paragraph"> </div>

 This is kind of annoying to prove, not just because the proof is fiddly, but because we have to pass back and forth between different generating families for the "same" modality.  It's a bit easier to prove it about nullifications than about arbitrary accessible lex modalities. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">topological_lex_trunc_acc</span> `{<span class="id" title="var">Funext</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">B</span> : <span class="id" title="var">NullGenerators</span>) {<span class="id" title="var">Olex</span> : <span class="id" title="var">Lex</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">B</span>)}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">gtr</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">ngen_type</span> <span class="id" title="var">B</span> <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;: { <span class="id" title="var">D</span> : <span class="id" title="var">NullGenerators</span> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">c</span>, <span class="id" title="var">IsHProp</span> (<span class="id" title="var">ngen_type</span> <span class="id" title="var">D</span> <span class="id" title="var">c</span>)) *<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Nul</span> <span class="id" title="var">D</span> &lt;=&gt; <span class="id" title="var">Nul</span> <span class="id" title="var">B</span>) }.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">exists</span> (<span class="id" title="var">Build_NullGenerators</span> <span class="id" title="var">Empty</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Unit</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">split</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span> <span class="id" title="var">_</span>; [ | <span class="id" title="tactic">intros</span> [] ] ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ooextendable_equiv</span>, <span class="id" title="var">isequiv_contr_contr</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">O</span> := <span class="id" title="var">Nul</span> <span class="id" title="var">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">OeqB</span> := <span class="id" title="var">reflexive_O_eq</span> <span class="id" title="var">O</span> : <span class="id" title="var">O</span> &lt;=&gt; (<span class="id" title="var">Nul</span> <span class="id" title="var">B</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">B</span>) <span class="id" title="keyword">with</span> <span class="id" title="var">O</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Olex</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">clearbody</span> <span class="id" title="var">O</span> <span class="id" title="var">OeqB</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">B</span> <span class="id" title="var">OeqB</span> <span class="id" title="var">gtr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">B</span> <span class="id" title="var">OeqB</span> <span class="id" title="var">gtr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">exists</span> <span class="id" title="var">B</span>; <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">assumption</span> | <span class="id" title="tactic">reflexivity</span> ]. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">A</span> := <span class="id" title="var">ngen_indices</span> <span class="id" title="var">B</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">C</span> := <span class="id" title="var">A</span> + { <span class="id" title="var">a</span>:<span class="id" title="var">A</span> &amp; <span class="id" title="var">B</span>(<span class="id" title="var">a</span>) * <span class="id" title="var">B</span>(<span class="id" title="var">a</span>) }).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">D</span> := <span class="id" title="var">Build_NullGenerators</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">C</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">c</span>:<span class="id" title="var">C</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">c</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inl</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">merely</span> (<span class="id" title="var">B</span> <span class="id" title="var">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">inr</span> (<span class="id" title="var">a</span> ; (<span class="id" title="var">b1</span>, <span class="id" title="var">b2</span>)) =&gt; (<span class="id" title="var">b1</span> = <span class="id" title="var">b2</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> : <span class="id" title="keyword">Type</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">Dtrunc</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">c</span>:<span class="id" title="var">C</span>, <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span>.+1 (<span class="id" title="var">D</span> <span class="id" title="var">c</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> [<span class="id" title="var">a</span> | [<span class="id" title="var">a</span> [<span class="id" title="var">b1</span> <span class="id" title="var">b2</span>]]]; [ <span class="id" title="var">cbn</span> | <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Because&nbsp;<span class="inlinecode"><span class="id" title="var">trunc_hprop</span></span>&nbsp;can't&nbsp;be&nbsp;used&nbsp;as&nbsp;an&nbsp;idmap...&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">OeqD</span> : <span class="id" title="var">O</span> &lt;=&gt; (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">split</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">X_inO</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">Bc</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>:<span class="id" title="var">A</span>, <span class="id" title="var">IsConnected</span> <span class="id" title="var">O</span> (<span class="id" title="var">B</span> <span class="id" title="var">a</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> (@<span class="id" title="var">isconnected_O_leq</span> <span class="id" title="var">O</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">B</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">isconnected_acc_ngen</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">B</span>) <span class="id" title="var">a</span>). }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">ooextendable_const_isconnected_inO</span> <span class="id" title="var">O</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">destruct</span> <span class="id" title="var">c</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">a</span> | [<span class="id" title="var">a</span> [<span class="id" title="var">b1</span> <span class="id" title="var">b2</span>]]] | <span class="id" title="tactic">exact</span> <span class="id" title="var">X_inO</span> ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> <span class="id" title="var">isconnected_from_elim_to_O</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">isconnected_elim</span> <span class="id" title="var">O</span> (<span class="id" title="var">O</span> (<span class="id" title="var">merely</span> (<span class="id" title="var">B</span> <span class="id" title="var">a</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">to</span> <span class="id" title="var">O</span> <span class="id" title="var">_</span> (<span class="id" title="var">tr</span> <span class="id" title="var">b</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">as</span> [<span class="id" title="var">x</span> <span class="id" title="var">h</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">h</span> <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">cbn</span>. <span class="id" title="var">rapply</span> <span class="id" title="var">isconnected_paths</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">Dnull</span>; <span class="id" title="var">rapply</span> (@<span class="id" title="var">inO_leq</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">B</span>) <span class="id" title="var">O</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">a</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> ((<span class="id" title="var">equiv_ooextendable_isequiv</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">unit_name</span> <span class="id" title="var">X</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">tt</span>))^-1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">isequiv_contr_map</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">contr_equiv'</span> { <span class="id" title="var">x</span>:<span class="id" title="var">X</span> &amp; <span class="id" title="keyword">forall</span> <span class="id" title="var">u</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span>, <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">u</span> } <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">refine</span> (<span class="id" title="var">equiv_functor_sigma'</span> (<span class="id" title="var">equiv_unit_rec</span> <span class="id" title="var">X</span>) <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">composeD</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">equiv_path_arrow</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="var">isconnected_elim</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>) (<span class="id" title="var">A</span> := <span class="id" title="var">D</span> (<span class="id" title="var">inl</span> <span class="id" title="var">a</span>)) <span class="id" title="var">_</span> <span class="id" title="var">_</span>).1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">rapply</span> <span class="id" title="var">isconnected_acc_ngen</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">b</span>. <span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">bc</span> : <span class="id" title="var">IsConnMap</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>) (<span class="id" title="var">unit_name</span> <span class="id" title="var">b</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">hfiber</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">isconnected_equiv</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>) (<span class="id" title="var">b</span> = <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">equiv_contr_sigma</span> <span class="id" title="var">_</span>)^-1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">isconnected_acc_ngen</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>) (<span class="id" title="var">inr</span> (<span class="id" title="var">a</span>;(<span class="id" title="var">b</span>,<span class="id" title="var">x</span>)))). }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">p</span> := <span class="id" title="var">conn_map_elim</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>) (<span class="id" title="var">unit_name</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">b</span> = <span class="id" title="var">f</span> <span class="id" title="var">u</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; 1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Build_Contr</span> <span class="id" title="var">_</span> (<span class="id" title="var">f</span> <span class="id" title="var">b</span> ; <span class="id" title="var">p</span>)); <span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">q</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">path_sigma'</span> <span class="id" title="var">_</span> (<span class="id" title="var">q</span> <span class="id" title="var">b</span>)^ <span class="id" title="var">_</span>); <span class="id" title="tactic">apply</span> <span class="id" title="var">path_forall</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conn_map_elim</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>) (<span class="id" title="var">unit_name</span> <span class="id" title="var">b</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">intros</span> [].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">transport_forall_constant</span>, <span class="id" title="var">transport_paths_l</span>, <span class="id" title="var">inv_V</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> (<span class="id" title="var">conn_map_comp</span> (<span class="id" title="var">Nul</span> <span class="id" title="var">D</span>) (<span class="id" title="var">unit_name</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">u</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">b</span> = <span class="id" title="var">f</span> <span class="id" title="var">u</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; 1) <span class="id" title="var">tt</span> : <span class="id" title="var">p</span> <span class="id" title="var">b</span> = 1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_p1</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">IHn</span> <span class="id" title="var">D</span> <span class="id" title="var">OeqD</span> <span class="id" title="var">_</span>) <span class="id" title="keyword">as</span> [<span class="id" title="var">E</span> [<span class="id" title="var">HE</span> <span class="id" title="var">EeqD</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <span class="id" title="var">E</span>; <span class="id" title="tactic">split</span>; [ <span class="id" title="tactic">exact</span> <span class="id" title="var">HE</span> | ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="tactic">transitivity</span> <span class="id" title="var">EeqD</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="tactic">transitivity</span> <span class="id" title="var">_</span> <span class="id" title="var">OeqB</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>