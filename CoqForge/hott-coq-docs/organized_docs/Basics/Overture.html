<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Overture</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Overture</h1>

<div class="code">
</div>

<div class="doc">
<a id="lab338"></a><h1 class="section">Basic definitions of homotopy type theory</h1>

<div class="paragraph"> </div>

 This file defines some of the most basic types and type formers, such as sums, products, Sigma types and path types.  It defines the action of functions on paths <span class="inlinecode"><span class="id" title="var">ap</span></span>, transport, equivalences, and function extensionality.  It also defines truncatedness, and a number of other fundamental definitions used throughout the library. 
<div class="paragraph"> </div>

 Import the file of reserved notations so we maintain consistent level notations throughout the library. 
</div>
<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Export</span> <span class="id" title="var">Basics.Settings</span> <span class="id" title="var">Basics.Notations</span>.<br/>

<br/>
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Set</span> <span class="id" title="var">Polymorphic</span> <span class="id" title="keyword">Inductive</span> <span class="id" title="var">Cumulativity</span>.<br/>

<br/>
</div>

<div class="doc">
This command prevents Coq from automatically defining the eliminator functions for inductive types.  We will define them ourselves to match the naming scheme of the HoTT Book.  In principle we ought to make this <span class="inlinecode"><span class="id" title="keyword">Global</span></span>, but unfortunately the tactics <span class="inlinecode"><span class="id" title="tactic">induction</span></span> and <span class="inlinecode"><span class="id" title="tactic">elim</span></span> assume that the eliminators are named in Coq's way, e.g. <span class="inlinecode"><span class="id" title="var">thing_rect</span></span>, so making it global could cause unpleasant surprises for people defining new inductive types.  However, when you do define your own inductive types you are encouraged to also do <span class="inlinecode"><span class="id" title="keyword">Local</span></span> <span class="inlinecode"><span class="id" title="keyword">Unset</span></span> <span class="inlinecode"><span class="id" title="var">Elimination</span></span> <span class="inlinecode"><span class="id" title="var">Schemes</span></span> and then use <span class="inlinecode"><span class="id" title="keyword">Scheme</span></span> to define <span class="inlinecode"><span class="id" title="var">thing_ind</span></span>, <span class="inlinecode"><span class="id" title="var">thing_rec</span></span>, and (for compatibility with <span class="inlinecode"><span class="id" title="tactic">induction</span></span> and <span class="inlinecode"><span class="id" title="tactic">elim</span></span>) <span class="inlinecode"><span class="id" title="var">thing_rect</span></span>, as we have done below for <span class="inlinecode"><span class="id" title="var">paths</span></span>, <span class="inlinecode"><span class="id" title="var">Empty</span></span>, <span class="inlinecode"><span class="id" title="var">Unit</span></span>, etc.  We are hoping that this will be fixed eventually; see https://github.com/coq/coq/issues/3745.  
</div>
<div class="code">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Unset</span> <span class="id" title="var">Elimination</span> <span class="id" title="var">Schemes</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab339"></a><h2 class="section">Datatypes</h2>

<div class="paragraph"> </div>

<a id="lab340"></a><h3 class="section">Functions</h3>

<div class="paragraph"> </div>

 Notation for non-dependent function types 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;A -&gt; B" := (<span class="id" title="keyword">forall</span> (<span class="id" title="var">_</span> : <span class="id" title="var">A</span>), <span class="id" title="var">B</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab341"></a><h3 class="section">Option type</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">option</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> is the extension of <span class="inlinecode"><span class="id" title="var">A</span></span> with an extra element <span class="inlinecode"><span class="id" title="var">None</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">option</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">Some</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">option</span> <span class="id" title="var">A</span><br/>
| <span class="id" title="var">None</span> : <span class="id" title="var">option</span> <span class="id" title="var">A</span>.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">option_rect</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">option</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">Some</span> {<span class="id" title="var">A</span>} <span class="id" title="var">a</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">None</span> {<span class="id" title="var">A</span>}.<br/>

<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">option</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.option.type</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab342"></a><h3 class="section">Sum type</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">sum</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, written <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, is the disjoint sum of <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">sum</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) : <span class="id" title="keyword">Type</span> :=<br/>
| <span class="id" title="var">inl</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
| <span class="id" title="var">inr</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">sum</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">sum_rect</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">sum</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">sum_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">sum</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">sum_ind</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="tactic">rename</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x + y" := (<span class="id" title="var">sum</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">inl</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> , [<span class="id" title="var">A</span>] <span class="id" title="var">B</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">inr</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> , <span class="id" title="var">A</span> [<span class="id" title="var">B</span>] <span class="id" title="var">_</span>.<br/>

<br/>
<span class="comment">(*&nbsp;A&nbsp;notation&nbsp;for&nbsp;coproduct&nbsp;that's&nbsp;less&nbsp;overloaded&nbsp;than&nbsp;<span class="inlinecode">+</span>&nbsp;*)</span><br/>
<span class="id" title="keyword">Notation</span> &quot;x |_| y" := (<span class="id" title="var">sum</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab343"></a><h3 class="section">Product type</h3>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" title="var">prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, written <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, is the product of <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span>;
    the pair <span class="inlinecode"><span class="id" title="var">pair</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> of <span class="inlinecode"><span class="id" title="var">a</span></span> and <span class="inlinecode"><span class="id" title="var">b</span></span> is abbreviated <span class="inlinecode">(<span class="id" title="var">a</span>,<span class="id" title="var">b</span>)</span> 
</div>
<div class="code">
<span class="id" title="keyword">Record</span> <span class="id" title="var">prod</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>) := <span class="id" title="var">pair</span> { <span class="id" title="var">fst</span> : <span class="id" title="var">A</span> ; <span class="id" title="var">snd</span> : <span class="id" title="var">B</span> }.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">prod_rect</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">prod</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">prod_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">prod</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">prod_ind</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">P</span> <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">pair</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">fst</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> / .<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">snd</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> / .<br/>

<br/>
<span class="id" title="keyword">Add</span> <span class="id" title="keyword">Printing</span> <span class="id" title="keyword">Let</span> <span class="id" title="var">prod</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x * y" := (<span class="id" title="var">prod</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;( x , y , .. , z )" := (<span class="id" title="var">pair</span> .. (<span class="id" title="var">pair</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) .. <span class="id" title="var">z</span>) : <span class="id" title="var">core_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;A /\ B" := (<span class="id" title="var">prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">and</span> := <span class="id" title="var">prod</span> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">conj</span> := <span class="id" title="var">pair</span> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">pair</span> <span class="id" title="var">inl</span> <span class="id" title="var">inr</span> : <span class="id" title="var">core</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab344"></a><h2 class="section">Type classes</h2>

<div class="paragraph"> </div>

 This command prevents Coq from trying to guess the values of existential variables while doing typeclass resolution.  If you don't know what that means, ignore it. 
</div>
<div class="code">
<span class="id" title="keyword">Local</span> <span class="id" title="keyword">Set</span> <span class="id" title="keyword">Typeclasses</span> <span class="id" title="keyword">Strict</span> <span class="id" title="var">Resolution</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Relation</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) := <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Class</span> <span class="id" title="var">Reflexive</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Class</span> <span class="id" title="var">Symmetric</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Class</span> <span class="id" title="var">Transitive</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="tactic">transitivity</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> -&gt; <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">z</span>.<br/>

<br/>
</div>

<div class="doc">
A <span class="inlinecode"><span class="id" title="var">PreOrder</span></span> is both Reflexive and Transitive. 
</div>
<div class="code">
<span class="id" title="keyword">Class</span> <span class="id" title="var">PreOrder</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;{ <span class="id" title="var">PreOrder_Reflexive</span> : <span class="id" title="var">Reflexive</span> <span class="id" title="var">R</span> | 2 ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">PreOrder_Transitive</span> : <span class="id" title="var">Transitive</span> <span class="id" title="var">R</span> | 2 }.<br/>

<br/>
<span class="id" title="keyword">Global Existing Instance</span> <span class="id" title="var">PreOrder_Reflexive</span>.<br/>
<span class="id" title="keyword">Global Existing Instance</span> <span class="id" title="var">PreOrder_Transitive</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="tactic">reflexivity</span> {<span class="id" title="var">A</span> <span class="id" title="var">R</span> <span class="id" title="var">_</span>} / <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="tactic">symmetry</span> {<span class="id" title="var">A</span> <span class="id" title="var">R</span> <span class="id" title="var">_</span>} / <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="tactic">transitivity</span> {<span class="id" title="var">A</span> <span class="id" title="var">R</span> <span class="id" title="var">_</span>} / {<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Above, we have made <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, <span class="inlinecode"><span class="id" title="tactic">symmetry</span></span>, and <span class="inlinecode"><span class="id" title="tactic">transitivity</span></span> reduce under <span class="inlinecode"><span class="id" title="var">cbn</span></span>/<span class="inlinecode"><span class="id" title="tactic">simpl</span></span> to their underlying instances.  This allows the tactics to build proof terms referencing, e.g., <span class="inlinecode"><span class="id" title="var">concat</span></span>.  We use <span class="inlinecode"><span class="id" title="tactic">change</span></span> after the fact to make sure that we didn't <span class="inlinecode"><span class="id" title="var">cbn</span></span> away the original form of the relation.

<div class="paragraph"> </div>

    If we want to remove the use of <span class="inlinecode"><span class="id" title="var">cbn</span></span>, we can play tricks with <span class="inlinecode"><span class="id" title="keyword">Module</span></span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>s and <span class="inlinecode"><span class="id" title="keyword">Module</span></span>s to declare <span class="inlinecode"><span class="id" title="var">inverse</span></span> directly as an instance of <span class="inlinecode"><span class="id" title="var">Symmetric</span></span> without changing its type.  Then we can simply <span class="inlinecode"><span class="id" title="tactic">unfold</span></span> <span class="inlinecode"><span class="id" title="tactic">symmetry</span></span>.  See the comments around the definition of <span class="inlinecode"><span class="id" title="var">inverse</span></span>. 
<div class="paragraph"> </div>

 Overwrite <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> so that we use our version of <span class="inlinecode"><span class="id" title="var">Reflexive</span></span> rather than having the tactic look for it in the standard library.  We make use of the built-in reflexivity to handle, e.g., single-constructor inductives. 
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">old_reflexivity</span> := <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Tactic Notation</span> "reflexivity" :=<br/>
&nbsp;&nbsp;<span class="id" title="var">old_reflexivity</span><br/>
|| (<span class="id" title="tactic">intros</span>;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">R</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">R</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">R</span>) <span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">pre_proof_term_head</span> := <span class="id" title="keyword">constr</span>:(@<span class="id" title="tactic">reflexivity</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span> <span class="id" title="var">_</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">proof_term_head</span> := (<span class="id" title="tactic">eval</span> <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">pre_proof_term_head</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">proof_term_head</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">x</span>)).<br/>

<br/>
</div>

<div class="doc">
Even if we weren't using <span class="inlinecode"><span class="id" title="var">cbn</span></span>, we would have to redefine symmetry, since the built-in Coq version is sometimes too smart for its own good, and will occasionally fail when it should not. 
</div>
<div class="code">
<span class="id" title="keyword">Tactic Notation</span> "symmetry" :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">R</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">R</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">R</span>) <span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">R</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">x</span>) <span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">y</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">R</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">y</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">y</span>) <span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">pre_proof_term_head</span> := <span class="id" title="keyword">constr</span>:(@<span class="id" title="tactic">symmetry</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span> <span class="id" title="var">_</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">proof_term_head</span> := (<span class="id" title="tactic">eval</span> <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">pre_proof_term_head</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">proof_term_head</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span>); <span class="id" title="tactic">change</span> (<span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "etransitivity" <span class="id" title="var">open_constr</span>(<span class="id" title="var">y</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">R</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">R</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">z</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">R</span>) <span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">x</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">R</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">z</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">x</span>) <span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">z</span> := <span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span> |- ?<span class="id" title="var">R</span> ?<span class="id" title="var">x</span> ?<span class="id" title="var">z</span> =&gt; <span class="id" title="keyword">constr</span>:(<span class="id" title="var">z</span>) <span class="id" title="keyword">end</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">pre_proof_term_head</span> := <span class="id" title="keyword">constr</span>:(@<span class="id" title="tactic">transitivity</span> <span class="id" title="var">_</span> <span class="id" title="var">R</span> <span class="id" title="var">_</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">proof_term_head</span> := (<span class="id" title="tactic">eval</span> <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">pre_proof_term_head</span>) <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">proof_term_head</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>); [ <span class="id" title="tactic">change</span> (<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) | <span class="id" title="tactic">change</span> (<span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>) ].<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "etransitivity" := <span class="id" title="var">etransitivity</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
We redefine <span class="inlinecode"><span class="id" title="tactic">transitivity</span></span> to work without needing to include <span class="inlinecode"><span class="id" title="var">Setoid</span></span> or be using Leibniz equality, and to give proofs that unfold to <span class="inlinecode"><span class="id" title="var">concat</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Tactic Notation</span> "transitivity" <span class="id" title="keyword">constr</span>(<span class="id" title="var">x</span>) := <span class="id" title="var">etransitivity</span> <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab345"></a><h2 class="section">Basic definitions</h2>

<div class="paragraph"> </div>

 Define an alias for <span class="inlinecode"><span class="id" title="keyword">Set</span></span>, which is really <span class="inlinecode"><span class="id" title="var">Type₀</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <span class="id" title="var">Type0</span> := <span class="id" title="keyword">Set</span>.<br/>

<br/>
</div>

<div class="doc">
We make the identity map a notation so we do not have to unfold it,
    or complicate matters with its type. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <span class="id" title="var">idmap</span> := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab346"></a><h3 class="section">Constant functions</h3>

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">const</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>) := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab347"></a><h2 class="section">Sigma types</h2>

<div class="paragraph"> </div>

 <span class="inlinecode">(<span class="id" title="var">sig</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">P</span>)</span>, or more suggestively <span class="inlinecode">{<span class="id" title="var">x</span>:<span class="id" title="var">A</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)}</span> is a Sigma-type. 
</div>
<div class="code">
<span class="id" title="keyword">Record</span> <span class="id" title="var">sig</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) := <span class="id" title="var">exist</span> {<br/>
&nbsp;&nbsp;<span class="id" title="var">proj1</span> : <span class="id" title="var">A</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">proj2</span> : <span class="id" title="var">P</span> <span class="id" title="var">proj1</span> ;<br/>
}.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">sig_rect</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">sig</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">sig_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">sig</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">sig_rec</span> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <span class="id" title="var">sig</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">sig_ind</span> {<span class="id" title="var">_</span> <span class="id" title="var">_</span>}.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">sig_rec</span> {<span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>}.<br/>

<br/>
</div>

<div class="doc">
We make the parameters maximally inserted so that we can pass around <span class="inlinecode"><span class="id" title="var">pr1</span></span> as a function and have it actually mean "first projection" in, e.g., <span class="inlinecode"><span class="id" title="var">ap</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">exist</span> {<span class="id" title="var">A</span>}%<span class="id" title="var">_type</span> <span class="id" title="var">P</span>%<span class="id" title="var">_type</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">proj1</span> {<span class="id" title="var">A</span> <span class="id" title="var">P</span>} <span class="id" title="var">_</span> / .<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">proj2</span> {<span class="id" title="var">A</span> <span class="id" title="var">P</span>} <span class="id" title="var">_</span> / .<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">sig</span> (<span class="id" title="var">A</span> <span class="id" title="var">P</span>)%<span class="id" title="var">_type</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;{ x | P }" := (<span class="id" title="var">sig</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ x : A | P }" := (<span class="id" title="var">sig</span> (<span class="id" title="var">A</span> := <span class="id" title="var">A</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;'exists' x .. y , p" := (<span class="id" title="var">sig</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; .. (<span class="id" title="var">sig</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">p</span>)) ..)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;{ x : A  &amp; P }" := (<span class="id" title="var">sig</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span>:<span class="id" title="var">A</span> =&gt; <span class="id" title="var">P</span>)) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
This lets us pattern match sigma types in let expressions 
</div>
<div class="code">
<span class="id" title="keyword">Add</span> <span class="id" title="keyword">Printing</span> <span class="id" title="keyword">Let</span> <span class="id" title="var">sig</span>.<br/>

<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">sig</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.sigT.type</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">exist</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.sigT.intro</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">sig_rect</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.sigT.rect</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">proj1</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.sigT.proj1</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">proj2</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.sigT.proj2</span>.<br/>

<br/>
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">exist</span> : <span class="id" title="var">core</span>.<br/>

<br/>
</div>

<div class="doc">
We define notation for dependent pairs because it is too annoying to write and see <span class="inlinecode"><span class="id" title="var">exist</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> all the time.  However, we put it in its own scope, because sometimes it is necessary to give the particular dependent type, so we'd like to be able to turn off this notation selectively. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;( x ; y )" := (<span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) : <span class="id" title="var">fibration_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;( x ; .. ; y ; z )" := (<span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span> .. (<span class="id" title="var">exist</span> <span class="id" title="var">_</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>) ..) : <span class="id" title="var">fibration_scope</span>.<br/>
</div>

<div class="doc">
We bind <span class="inlinecode"><span class="id" title="var">fibration_scope</span></span> with <span class="inlinecode"><span class="id" title="var">sig</span></span> so that we are automatically in <span class="inlinecode"><span class="id" title="var">fibration_scope</span></span> when we are passing an argument of type <span class="inlinecode"><span class="id" title="var">sig</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Bind Scope</span> <span class="id" title="var">fibration_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">sig</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">pr1</span> := <span class="id" title="var">proj1</span>.<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">pr2</span> := <span class="id" title="var">proj2</span>.<br/>

<br/>
</div>

<div class="doc">
The following notation is very convenient, although it unfortunately clashes with Proof General's "electric period".  We have added <span class="inlinecode"><span class="id" title="var">format</span></span> specifiers in Notations.v so that it will display without an extra space, as <span class="inlinecode"><span class="id" title="var">x</span>.1</span> rather than as <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">.1</span>. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;x .1" := (<span class="id" title="var">pr1</span> <span class="id" title="var">x</span>) : <span class="id" title="var">fibration_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x .2" := (<span class="id" title="var">pr2</span> <span class="id" title="var">x</span>) : <span class="id" title="var">fibration_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">uncurry</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">A</span> * <span class="id" title="var">B</span>) : <span class="id" title="var">C</span> := <span class="id" title="var">f</span> (<span class="id" title="var">fst</span> <span class="id" title="var">p</span>) (<span class="id" title="var">snd</span> <span class="id" title="var">p</span>).<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">uncurry</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>} <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span> <span class="id" title="var">p</span> /.<br/>

<br/>
</div>

<div class="doc">
Composition of functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">compose</span> := (<span class="id" title="keyword">fun</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">g</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>)).<br/>

<br/>
</div>

<div class="doc">
We put the following notation in a scope because leaving it unscoped causes it to override identical notations in other scopes.  It's convenient to use the same notation for, e.g., function composition, morphism composition in a category, and functor composition, and let Coq automatically infer which one we mean by scopes.  We can't do this if this notation isn't scoped.  Unfortunately, Coq doesn't have a built-in <span class="inlinecode"><span class="id" title="var">function_scope</span></span> like <span class="inlinecode"><span class="id" title="var">type_scope</span></span>; <span class="inlinecode"><span class="id" title="var">type_scope</span></span> is automatically opened wherever Coq is expecting a <span class="inlinecode"><span class="id" title="keyword">Sort</span></span>, and it would be nice if <span class="inlinecode"><span class="id" title="var">function_scope</span></span> were automatically opened whenever Coq expects a thing of type <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">_</span>,</span> <span class="inlinecode"><span class="id" title="var">_</span></span> or <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">_</span></span>.  To work around this, we open <span class="inlinecode"><span class="id" title="var">function_scope</span></span> globally. 
<div class="paragraph"> </div>

 We allow writing <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">g</span>)%<span class="id" title="var">function</span></span> to force <span class="inlinecode"><span class="id" title="var">function_scope</span></span> over, e.g., <span class="inlinecode"><span class="id" title="var">morphism_scope</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;g 'o' f" := (<span class="id" title="var">compose</span> <span class="id" title="var">g</span>%<span class="id" title="var">function</span> <span class="id" title="var">f</span>%<span class="id" title="var">function</span>) : <span class="id" title="var">function_scope</span>.<br/>

<br/>
</div>

<div class="doc">
This definition helps guide typeclass inference. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Compose</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">g</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">C</span> := <span class="id" title="var">compose</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span>.<br/>

<br/>
</div>

<div class="doc">
Dependent composition of functions. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">composeD</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>} (<span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, <span class="id" title="var">C</span> <span class="id" title="var">b</span>) (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">g</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">composeD</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>}%<span class="id" title="var">_type_scope</span> (<span class="id" title="var">g</span> <span class="id" title="var">f</span>)%<span class="id" title="var">_function_scope</span> <span class="id" title="var">x</span>.<br/>

<br/>
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Unfold</span> <span class="id" title="var">composeD</span> : <span class="id" title="var">core</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;g 'oD' f" := (<span class="id" title="var">composeD</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span>) : <span class="id" title="var">function_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab348"></a><h2 class="section">The groupoid structure of identity types.</h2>

<div class="paragraph"> </div>

 The results in this file are used everywhere else, so we need to be extra careful about how we define and prove things.  We prefer hand-written terms, or at least tactics that allow us to retain clear control over the proof-term produced. 
<div class="paragraph"> </div>

 We define our own identity type, rather than using the one in the Coq standard library, so as to have more control over transitivity, symmetry and inverse.  It seems impossible to change these for the standard eq/identity type (or its Type-valued version) because it breaks various other standard things.  Merely changing notations also doesn't seem to quite work. 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">paths</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="var">idpath</span> : <span class="id" title="var">paths</span> <span class="id" title="var">a</span> <span class="id" title="var">a</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">idpath</span> {<span class="id" title="var">A</span> <span class="id" title="var">a</span>} , [<span class="id" title="var">A</span>] <span class="id" title="var">a</span>.<br/>

<br/>
#[<span class="id" title="var">export</span>] <span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">idpath</span> : <span class="id" title="var">core</span>.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">paths_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">paths</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">paths_ind</span> [<span class="id" title="var">A</span>] <span class="id" title="var">a</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">y</span> <span class="id" title="var">p</span> : <span class="id" title="tactic">rename</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">paths_rec</span> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <span class="id" title="var">paths</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">paths_rec</span> [<span class="id" title="var">A</span>] <span class="id" title="var">a</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">y</span> <span class="id" title="var">p</span> : <span class="id" title="tactic">rename</span>.<br/>

<br/>
<span class="comment">(*&nbsp;See&nbsp;comment&nbsp;above&nbsp;about&nbsp;the&nbsp;tactic&nbsp;<span class="inlinecode"><span class="id" title="tactic">induction</span></span>.&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">paths_rect</span> := <span class="id" title="var">paths_ind</span>.<br/>

<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">paths</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.identity.type</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">idpath</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.identity.refl</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">paths_rect</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.identity.ind</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;x = y :&gt; A" := (@<span class="id" title="var">paths</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x = y" := (<span class="id" title="var">x</span> = <span class="id" title="var">y</span> :&gt;<span class="id" title="var">_</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">reflexive_paths</span> {<span class="id" title="var">A</span>} : <span class="id" title="var">Reflexive</span> (@<span class="id" title="var">paths</span> <span class="id" title="var">A</span>) | 0 := @<span class="id" title="var">idpath</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">reflexive_paths</span> / .<br/>

<br/>
</div>

<div class="doc">
Our identity type is the Paulin-Mohring style.  We derive the Martin-Lof eliminator. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">paths_ind'</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">A</span>), (<span class="id" title="var">a</span> = <span class="id" title="var">b</span>) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;: (<span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>), <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">a</span> <span class="id" title="var">idpath</span>) -&gt; <span class="id" title="keyword">forall</span> (<span class="id" title="var">a</span> <span class="id" title="var">b</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">a</span> = <span class="id" title="var">b</span>), <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span> ? ? [].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
And here's the "right-sided" Paulin-Mohring eliminator. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">paths_ind_r</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span> : <span class="id" title="var">A</span>, <span class="id" title="var">b</span> = <span class="id" title="var">a</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">a</span> <span class="id" title="var">idpath</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> (<span class="id" title="var">y</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">p</span> : <span class="id" title="var">y</span> = <span class="id" title="var">a</span>), <span class="id" title="var">P</span> <span class="id" title="var">y</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">u</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We declare a scope in which we shall place path notations. This way they can be turned on and off by the user. 
<div class="paragraph"> </div>

 We bind <span class="inlinecode"><span class="id" title="var">path_scope</span></span> to <span class="inlinecode"><span class="id" title="var">paths</span></span> so that when we are constructing arguments to things like <span class="inlinecode"><span class="id" title="var">concat</span></span>, we automatically are in <span class="inlinecode"><span class="id" title="var">path_scope</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Bind Scope</span> <span class="id" title="var">path_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">paths</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The inverse of a path. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">inverse</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) : <span class="id" title="var">y</span> = <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span> <span class="id" title="var">idpath</span> =&gt; <span class="id" title="var">idpath</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">inverse</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.identity.sym</span>.<br/>

<br/>
</div>

<div class="doc">
Declaring this as <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> <span class="inlinecode"><span class="id" title="var">nomatch</span></span> prevents the tactic <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> from expanding it out into <span class="inlinecode"><span class="id" title="keyword">match</span></span> statements.  We only want <span class="inlinecode"><span class="id" title="var">inverse</span></span> to simplify when applied to an identity path. 
</div>
<div class="code">
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">inverse</span> {<span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>} <span class="id" title="var">p</span> : <span class="id" title="tactic">simpl</span> <span class="id" title="var">nomatch</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">symmetric_paths</span> {<span class="id" title="var">A</span>} : <span class="id" title="var">Symmetric</span> (@<span class="id" title="var">paths</span> <span class="id" title="var">A</span>) | 0 := @<span class="id" title="var">inverse</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">symmetric_paths</span> / .<br/>

<br/>
</div>

<div class="doc">
If we wanted to not have the constant <span class="inlinecode"><span class="id" title="var">symmetric_paths</span></span> floating around, and wanted to resolve <span class="inlinecode"><span class="id" title="var">inverse</span></span> directly, instead, we could play this trick, discovered by Georges Gonthier to fool Coq's restriction on <span class="inlinecode"><span class="id" title="var">Identity</span></span> <span class="inlinecode"><span class="id" title="keyword">Coercion</span></span>s:

<div class="paragraph"> </div>

<pre>
Module Export inverse.
  Definition inverse {A : Type} {x y : A} (p : x = y) : y = x
    := match p with idpath =&gt; idpath end.
End inverse.

Module Type inverseT.
  Parameter inverse : forall {A}, Symmetric (@paths A).
End inverseT.

Module inverseSymmetric (inverse : inverseT).
  Global Existing Instance inverse.inverse.
End inverseSymmetric.

Module Export symmetric_paths := inverseSymmetric inverse.
</pre>

<div class="paragraph"> </div>

 We define equality concatenation by destructing on both its arguments, so that it only computes when both arguments are <span class="inlinecode"><span class="id" title="var">idpath</span></span>.  This makes proofs more robust and symmetrical.  Compare with the definition of <span class="inlinecode"><span class="id" title="var">identity_trans</span></span>.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">concat</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">q</span> : <span class="id" title="var">y</span> = <span class="id" title="var">z</span>) : <span class="id" title="var">x</span> = <span class="id" title="var">z</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span>, <span class="id" title="var">q</span> <span class="id" title="keyword">with</span> <span class="id" title="var">idpath</span>, <span class="id" title="var">idpath</span> =&gt; <span class="id" title="var">idpath</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
See above for the meaning of <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> <span class="inlinecode"><span class="id" title="var">nomatch</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">concat</span> {<span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>} <span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="tactic">simpl</span> <span class="id" title="var">nomatch</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">transitive_paths</span> {<span class="id" title="var">A</span>} : <span class="id" title="var">Transitive</span> (@<span class="id" title="var">paths</span> <span class="id" title="var">A</span>) | 0 := @<span class="id" title="var">concat</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">transitive_paths</span> / .<br/>

<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">concat</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.identity.trans</span>.<br/>

<br/>
</div>

<div class="doc">
Note that you can use the Coq tactics <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>, <span class="inlinecode"><span class="id" title="tactic">transitivity</span></span>, <span class="inlinecode"><span class="id" title="var">etransitivity</span></span>, and <span class="inlinecode"><span class="id" title="tactic">symmetry</span></span> when working with paths; we've redefined them above to use typeclasses and to unfold the instances so you get proof terms with <span class="inlinecode"><span class="id" title="var">concat</span></span> and <span class="inlinecode"><span class="id" title="var">inverse</span></span>. 
<div class="paragraph"> </div>

 The identity path. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;1" := <span class="id" title="var">idpath</span> : <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The composition of two paths.  We put <span class="inlinecode"><span class="id" title="var">p</span></span> and <span class="inlinecode"><span class="id" title="var">q</span></span> in <span class="inlinecode"><span class="id" title="var">path_scope</span></span> explicitly.  This is a partial work-around for https://coq.inria.fr/bugs/show_bug.cgi?id=3990, which is that implicitly bound scopes don't nest well. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;p @ q" := (<span class="id" title="var">concat</span> <span class="id" title="var">p</span>%<span class="id" title="var">path</span> <span class="id" title="var">q</span>%<span class="id" title="var">path</span>) : <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The inverse of a path.  See above about explicitly placing <span class="inlinecode"><span class="id" title="var">p</span></span> in <span class="inlinecode"><span class="id" title="var">path_scope</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;p ^" := (<span class="id" title="var">inverse</span> <span class="id" title="var">p</span>%<span class="id" title="var">path</span>) : <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
An alternative notation which puts each path on its own line, via the <span class="inlinecode"><span class="id" title="var">format</span></span> specification in Notations.v.  Useful as a temporary device during proofs of equalities between very long composites; to turn it on inside a section, say <span class="inlinecode"><span class="id" title="keyword">Open</span></span> <span class="inlinecode"><span class="id" title="keyword">Scope</span></span> <span class="inlinecode"><span class="id" title="var">long_path_scope</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;p @' q" := (<span class="id" title="var">concat</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>) : <span class="id" title="var">long_path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
An important instance of <span class="inlinecode"><span class="id" title="var">paths_ind</span></span> is that given any dependent type, one can <i>transport</i> elements of instances of the type along equalities in the base:  <span class="inlinecode"><span class="id" title="var">transport</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode"><span class="id" title="var">u</span></span> transports <span class="inlinecode"><span class="id" title="var">u</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> to <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> along <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">transport</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">x</span>) : <span class="id" title="var">P</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span> <span class="id" title="var">idpath</span> =&gt; <span class="id" title="var">u</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
See above for the meaning of <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> <span class="inlinecode"><span class="id" title="var">nomatch</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">transport</span> {<span class="id" title="var">A</span>}%<span class="id" title="var">_type_scope</span> <span class="id" title="var">P</span>%<span class="id" title="var">_function_scope</span> {<span class="id" title="var">x</span> <span class="id" title="var">y</span>} <span class="id" title="var">p</span>%<span class="id" title="var">_path_scope</span> <span class="id" title="var">u</span> : <span class="id" title="tactic">simpl</span> <span class="id" title="var">nomatch</span>.<br/>

<br/>
</div>

<div class="doc">
Transport is very common so it is worth introducing a parsing notation for it.  However, we do not use the notation for output because it hides the fibration, and so makes it very hard to read involved transport expression. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> &quot;p # u" := (<span class="id" title="var">transport</span> <span class="id" title="var">_</span> <span class="id" title="var">p</span> <span class="id" title="var">u</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
The first time <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> is used in each direction, it creates transport lemmas called <span class="inlinecode"><span class="id" title="var">internal_paths_rew</span></span> and <span class="inlinecode"><span class="id" title="var">internal_paths_rew_r</span></span>.  See ../Tactics.v for how these compare to <span class="inlinecode"><span class="id" title="var">transport</span></span>.  We use <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> here to trigger the creation of these lemmas.  This ensures that they are defined outside of sections, so they are not unnecessarily polymorphic.  The lemmas below are not used in the library.  TODO: If Coq PR18299 is merged (possibly in Coq 8.20), then we can instead register wrappers for [transport] to be used for rewriting.  See the comment by Dan Christensen in that PR for how to do this.  Then the tactics [internal_paths_rew_to_transport] and [rewrite_to_transport] can be removed from ../Tactics.v. 
</div>
<div class="code">
<span class="id" title="keyword">Local Lemma</span> <span class="id" title="var">define_internal_paths_rew</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">P</span> (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">x</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span> :&gt; <span class="id" title="var">A</span>) : <span class="id" title="var">P</span> <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">H</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">u</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Local Lemma</span> <span class="id" title="var">define_internal_paths_rew_r</span> <span class="id" title="var">A</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">P</span> (<span class="id" title="var">u</span> : <span class="id" title="var">P</span> <span class="id" title="var">y</span>) (<span class="id" title="var">H</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span> :&gt; <span class="id" title="var">A</span>) : <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">rewrite</span> -&gt; <span class="id" title="var">H</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">u</span>. <span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">internal_paths_rew</span> {<span class="id" title="var">A</span>%<span class="id" title="var">_type_scope</span>} {<span class="id" title="var">a</span>} <span class="id" title="var">P</span>%<span class="id" title="var">_function_scope</span> <span class="id" title="var">f</span> {<span class="id" title="var">a0</span>} <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">internal_paths_rew_r</span> {<span class="id" title="var">A</span>%<span class="id" title="var">_type_scope</span>} {<span class="id" title="var">a</span> <span class="id" title="var">y</span>} <span class="id" title="var">P</span>%<span class="id" title="var">_function_scope</span> <span class="id" title="var">HC</span> <span class="id" title="var">X</span>.<br/>

<br/>
</div>

<div class="doc">
Having defined transport, we can use it to talk about what a homotopy theorist might see as "paths in a fibration over paths in the base"; and what a type theorist might see as "heterogeneous equality in a dependent type".  We will first see this appearing in the type of <span class="inlinecode"><span class="id" title="var">apD</span></span>. 
<div class="paragraph"> </div>

 Functions act on paths: if <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> and <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> is a path in <span class="inlinecode"><span class="id" title="var">A</span></span>, then <span class="inlinecode"><span class="id" title="var">ap</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.  We typically pronounce <span class="inlinecode"><span class="id" title="var">ap</span></span> as a single syllable, short for "application"; but it may also be considered as an acronym, "action on paths". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ap</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) : <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">f</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span> <span class="id" title="var">idpath</span> =&gt; <span class="id" title="var">idpath</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">ap</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span> {<span class="id" title="var">x</span> <span class="id" title="var">y</span>} <span class="id" title="var">p</span>%<span class="id" title="var">_path_scope</span> : <span class="id" title="tactic">simpl</span> <span class="id" title="var">nomatch</span>.<br/>

<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">ap</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.identity.congr</span>.<br/>

<br/>
</div>

<div class="doc">
We introduce the convention that <span class="inlinecode"><span class="id" title="var">apKN</span></span> denotes the application of a K-path between functions to an N-path between elements, where a 0-path is simply a function or an element. Thus, <span class="inlinecode"><span class="id" title="var">ap</span></span> is a shorthand for <span class="inlinecode"><span class="id" title="var">ap01</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <span class="id" title="var">ap01</span> := <span class="id" title="var">ap</span> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
</div>

<div class="doc">
Similarly, dependent functions act on paths; but the type is a bit more subtle. If <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span>:<span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> and <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> is a path in <span class="inlinecode"><span class="id" title="var">A</span></span>, then <span class="inlinecode"><span class="id" title="var">apD</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> should somehow be a path between <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> and <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>. Since these live in different types, we use transport along <span class="inlinecode"><span class="id" title="var">p</span></span> to make them comparable: <span class="inlinecode"><span class="id" title="var">apD</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">#</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span>.

<div class="paragraph"> </div>

  The type <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">#</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> can profitably be considered as a heterogeneous or dependent equality type, of "paths from <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> to <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> over <span class="inlinecode"><span class="id" title="var">p</span></span>". 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">apD</span> {<span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>} {<span class="id" title="var">B</span>:<span class="id" title="var">A</span>-&gt;<span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span>:<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>:<span class="id" title="var">A</span>, <span class="id" title="var">B</span> <span class="id" title="var">a</span>) {<span class="id" title="var">x</span> <span class="id" title="var">y</span>:<span class="id" title="var">A</span>} (<span class="id" title="var">p</span>:<span class="id" title="var">x</span>=<span class="id" title="var">y</span>):<br/>
&nbsp;&nbsp;<span class="id" title="var">p</span> # (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) = <span class="id" title="var">f</span> <span class="id" title="var">y</span><br/>
&nbsp;&nbsp;:=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">p</span> <span class="id" title="keyword">with</span> <span class="id" title="var">idpath</span> =&gt; <span class="id" title="var">idpath</span> <span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
See above for the meaning of <span class="inlinecode"><span class="id" title="tactic">simpl</span></span> <span class="inlinecode"><span class="id" title="var">nomatch</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">apD</span> {<span class="id" title="var">A</span>%<span class="id" title="var">_type_scope</span> <span class="id" title="var">B</span>} <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span> {<span class="id" title="var">x</span> <span class="id" title="var">y</span>} <span class="id" title="var">p</span>%<span class="id" title="var">_path_scope</span> : <span class="id" title="tactic">simpl</span> <span class="id" title="var">nomatch</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab349"></a><h3 class="section">Homotopies between functions</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pointwise_paths</span> <span class="id" title="var">A</span> (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pointwise_paths_concat</span> {<span class="id" title="var">A</span>} {<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> -&gt; <span class="id" title="var">pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-&gt; <span class="id" title="var">pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">h</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">p</span> <span class="id" title="var">x</span> @ <span class="id" title="var">q</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">reflexive_pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">Reflexive</span> (<span class="id" title="var">pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ?; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">transitive_pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">Transitive</span> (<span class="id" title="var">pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">pointwise_paths_concat</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">symmetric_pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">Symmetric</span> (<span class="id" title="var">pointwise_paths</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> ? ? <span class="id" title="var">p</span> ?; <span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">p</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">pointwise_paths</span> {<span class="id" title="var">A</span>}%<span class="id" title="var">_type_scope</span> {<span class="id" title="var">P</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span>)%<span class="id" title="var">_function_scope</span>.<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">reflexive_pointwise_paths</span> /.<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">transitive_pointwise_paths</span> /.<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">symmetric_pointwise_paths</span> /.<br/>

<br/>
#[<span class="id" title="var">export</span>]<br/>
<span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Unfold</span> <span class="id" title="var">pointwise_paths</span> : <span class="id" title="var">typeclass_instances</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;f == g" := (<span class="id" title="var">pointwise_paths</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">apD10</span> {<span class="id" title="var">A</span>} {<span class="id" title="var">B</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">B</span> <span class="id" title="var">x</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">f</span> = <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">f</span> == <span class="id" title="var">g</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="keyword">match</span> <span class="id" title="var">h</span> <span class="id" title="keyword">with</span> <span class="id" title="var">idpath</span> =&gt; 1 <span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">apD10</span> {<span class="id" title="var">A</span>%<span class="id" title="var">_type_scope</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> <span class="id" title="var">g</span>}%<span class="id" title="var">_function_scope</span> <span class="id" title="var">h</span>%<span class="id" title="var">_path_scope</span> <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ap10</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">f</span> = <span class="id" title="var">g</span>) : <span class="id" title="var">f</span> == <span class="id" title="var">g</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">apD10</span> <span class="id" title="var">h</span>.<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">ap10</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> {<span class="id" title="var">f</span> <span class="id" title="var">g</span>}%<span class="id" title="var">_function_scope</span> <span class="id" title="var">h</span>%<span class="id" title="var">_path_scope</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
For the benefit of readers of the HoTT Book: 
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <span class="id" title="var">happly</span> := <span class="id" title="var">ap10</span> (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ap11</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} {<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">f</span> = <span class="id" title="var">g</span>) {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">x</span> = <span class="id" title="var">y</span>) : <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">g</span> <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">h</span>, <span class="id" title="var">p</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">ap11</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> {<span class="id" title="var">f</span> <span class="id" title="var">g</span>}%<span class="id" title="var">_function_scope</span> <span class="id" title="var">h</span>%<span class="id" title="var">_path_scope</span> {<span class="id" title="var">x</span> <span class="id" title="var">y</span>} <span class="id" title="var">p</span>%<span class="id" title="var">_path_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab350"></a><h2 class="section">Equivalences</h2>

<div class="paragraph"> </div>

 Homotopy equivalences are a central concept in homotopy type theory. Before we define equivalences, let us consider when two types <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span> should be considered "the same".

<div class="paragraph"> </div>

   The first option is to require existence of <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> and <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> which are inverses of each other, up to homotopy.  Homotopically speaking, we should also require a certain condition on these homotopies, which is one of the triangle identities for adjunctions in category theory.  Thus, we call this notion an *adjoint equivalence*.

<div class="paragraph"> </div>

  The other triangle identity is provable from the first one, along with all the higher coherences, so it is reasonable to only assume one of them.  Moreover, as we will see, if we have maps which are inverses up to homotopy, it is always possible to make the triangle identity hold by modifying one of the homotopies.

<div class="paragraph"> </div>

   The second option is to use Vladimir Voevodsky's definition of an equivalence as a map whose homotopy fibers are contractible.  We call this notion a *homotopy bijection*.

<div class="paragraph"> </div>

   An interesting third option was suggested by André Joyal: a map <span class="inlinecode"><span class="id" title="var">f</span></span> which has separate left and right homotopy inverses.  We call this notion a *homotopy isomorphism*.

<div class="paragraph"> </div>

   While the second option was the one used originally, and it is the most concise one, it makes more sense to use the first one in a formalized development, since it exposes most directly equivalence as a structure.  In particular, it is easier to extract directly from it the data of a homotopy inverse to <span class="inlinecode"><span class="id" title="var">f</span></span>, which is what we care about having most in practice.  Thus, adjoint equivalences are what we will refer to merely as *equivalences*. 
<div class="paragraph"> </div>

 Naming convention: we use <span class="inlinecode"><span class="id" title="var">equiv</span></span> and <span class="inlinecode"><span class="id" title="var">Equiv</span></span> systematically to denote types of equivalences, and <span class="inlinecode"><span class="id" title="var">isequiv</span></span> and <span class="inlinecode"><span class="id" title="var">IsEquiv</span></span> systematically to denote the assertion that a given map is an equivalence. 
<div class="paragraph"> </div>

 A typeclass that includes the data making <span class="inlinecode"><span class="id" title="var">f</span></span> into an adjoint equivalence. 
</div>
<div class="code">
<span class="id" title="keyword">Class</span> <span class="id" title="var">IsEquiv</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) := {<br/>
&nbsp;&nbsp;<span class="id" title="var">equiv_inv</span> : <span class="id" title="var">B</span> -&gt; <span class="id" title="var">A</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">eisretr</span> : <span class="id" title="var">f</span> <span class="id" title="var">o</span> <span class="id" title="var">equiv_inv</span> == <span class="id" title="var">idmap</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">eissect</span> : <span class="id" title="var">equiv_inv</span> <span class="id" title="var">o</span> <span class="id" title="var">f</span> == <span class="id" title="var">idmap</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">eisadj</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">eisretr</span> (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) = <span class="id" title="var">ap</span> <span class="id" title="var">f</span> (<span class="id" title="var">eissect</span> <span class="id" title="var">x</span>) ;<br/>
}.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">eisretr</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span> {<span class="id" title="var">_</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">eissect</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span> {<span class="id" title="var">_</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">eisadj</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span> {<span class="id" title="var">_</span>} <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">IsEquiv</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We mark <span class="inlinecode"><span class="id" title="var">eisadj</span></span> as Opaque to deter Coq from unfolding it when simplifying. Since proofs of <span class="inlinecode"><span class="id" title="var">eisadj</span></span> typically have larger proofs than the rest of the equivalence data, we gain some speed up as a result. 
</div>
<div class="code">
<span class="id" title="keyword">Global Opaque</span> <span class="id" title="var">eisadj</span>.<br/>

<br/>
</div>

<div class="doc">
A record that includes all the data of an adjoint equivalence. 
</div>
<div class="code">
<span class="id" title="keyword">Record</span> <span class="id" title="var">Equiv</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> := {<br/>
&nbsp;&nbsp;<span class="id" title="var">equiv_fun</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> ;<br/>
&nbsp;&nbsp;<span class="id" title="var">equiv_isequiv</span> : <span class="id" title="var">IsEquiv</span> <span class="id" title="var">equiv_fun</span><br/>
}.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">equiv_fun</span> : <span class="id" title="var">Equiv</span> &gt;-&gt; <span class="id" title="var">Funclass</span>.<br/>

<br/>
<span class="id" title="keyword">Global Existing Instance</span> <span class="id" title="var">equiv_isequiv</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">equiv_fun</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">equiv_isequiv</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} <span class="id" title="var">_</span>.<br/>

<br/>
<span class="id" title="keyword">Bind Scope</span> <span class="id" title="var">equiv_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">Equiv</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;A &lt;~&gt; B" := (<span class="id" title="var">Equiv</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
A notation for the inverse of an equivalence.  We can apply this to a function as long as there is a typeclass instance asserting it to be an equivalence.  We can also apply it to an element of <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">&lt;~&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, since there is an implicit coercion to <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> and also an existing instance of <span class="inlinecode"><span class="id" title="var">IsEquiv</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> &quot;f ^-1" := (@<span class="id" title="var">equiv_inv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span>) : <span class="id" title="var">function_scope</span>.<br/>

<br/>
</div>

<div class="doc">
A shorthand for applying paths between equivalences like functions. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ap10_equiv</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">A</span> &lt;~&gt; <span class="id" title="var">B</span>} (<span class="id" title="var">h</span> : <span class="id" title="var">f</span> = <span class="id" title="var">g</span>) : <span class="id" title="var">f</span> == <span class="id" title="var">g</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">ap10</span> (<span class="id" title="var">ap</span> <span class="id" title="var">equiv_fun</span> <span class="id" title="var">h</span>).<br/>

<br/>
</div>

<div class="doc">
<a id="lab351"></a><h2 class="section">Function extensionality</h2>

<div class="paragraph"> </div>

 Function extensionality is stated as the axiom <span class="inlinecode"><span class="id" title="var">isequiv_apD10</span></span>.  In order to track where it is used, we create an empty type <span class="inlinecode"><span class="id" title="var">Funext</span></span> and require a term of that type in order to apply <span class="inlinecode"><span class="id" title="var">isequiv_apD10</span></span>.  Since there are no terms of that type, any definition that uses function extensionality (directly or indirectly) must have <span class="inlinecode"><span class="id" title="var">Funext</span></span> as a hypothesis.  This is done by adding <span class="inlinecode">`{<span class="id" title="var">Funext</span>}</span> to the argument list.  You can also assume it for an entire Section with <span class="inlinecode"><span class="id" title="keyword">Context</span></span> <span class="inlinecode">`{<span class="id" title="var">Funext</span>}</span>.  Since <span class="inlinecode"><span class="id" title="var">Funext</span></span> is a <span class="inlinecode"><span class="id" title="keyword">Class</span></span>, the provided argument will be found by typeclass search.

<div class="paragraph"> </div>

    This approach also has the advantage that it lets us use <span class="inlinecode"><span class="id" title="var">isequiv_apD10</span></span> at multiple universe levels, with a single assumption.

<div class="paragraph"> </div>

    To get rid of unneeded universe variables, we put <span class="inlinecode"><span class="id" title="var">Funext</span></span> in <span class="inlinecode"><span class="id" title="var">Type0</span></span> and make it <span class="inlinecode"><span class="id" title="var">Monomorphic</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Monomorphic Axiom</span> <span class="id" title="var">Funext</span> : <span class="id" title="var">Type0</span>.<br/>
<span class="id" title="keyword">Existing Class</span> <span class="id" title="var">Funext</span>.<br/>
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">isequiv_apD10</span> : <span class="id" title="keyword">forall</span> `{<span class="id" title="var">Funext</span>} (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) <span class="id" title="var">f</span> <span class="id" title="var">g</span>, <span class="id" title="var">IsEquiv</span> (@<span class="id" title="var">apD10</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).<br/>
<span class="id" title="keyword">Global Existing Instance</span> <span class="id" title="var">isequiv_apD10</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">path_forall</span> `{<span class="id" title="var">Funext</span>} {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">f</span> == <span class="id" title="var">g</span> -&gt; <span class="id" title="var">f</span> = <span class="id" title="var">g</span><br/>
&nbsp;&nbsp;:= (@<span class="id" title="var">apD10</span> <span class="id" title="var">A</span> <span class="id" title="var">P</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>)^-1.<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">path_forall</span> {<span class="id" title="var">_</span> <span class="id" title="var">A</span>%<span class="id" title="var">_type_scope</span> <span class="id" title="var">P</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span>)%<span class="id" title="var">_function_scope</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab352"></a><h2 class="section">Contractibility and truncation levels</h2>

<div class="paragraph"> </div>

 Truncation measures how complicated a type is in terms of higher path types. The (-2)-truncated types are the contractible ones, whose homotopy is completely trivial.  More precisely, a type <span class="inlinecode"><span class="id" title="var">A</span></span> is contractible if there is a point <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> and a (pointwise) homotopy connecting the identity on <span class="inlinecode"><span class="id" title="var">A</span></span> to the constant map at <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

   The (n+1)-truncated types are those whose path types are n-truncated.

<div class="paragraph"> </div>

   Thus, (-1)-truncated means "the type of paths between any two points is contractible". Such a type is necessarily a sub-singleton: any two points are connected by a path which is unique up to homotopy. In other words, (-1)-truncated types are truth values.  We call such types "propositions" or "h-propositions".

<div class="paragraph"> </div>

   Next, 0-truncated means "the type of paths between any two points is a sub-singleton". Thus, two points might not have any paths between them, or they have a unique path. Such a type may have many points but it is discrete in the sense that all paths are trivial. We call such types "sets" or "h-sets".

<div class="paragraph"> </div>

    In this library, a witness that a type is n-truncated is formalized by the <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> typeclass.  In many cases, the typeclass machinery of Coq can automatically infer a witness for a type being n-truncated.  Because <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> itself has no computational content (that is, all witnesses of n-truncation of a type are provably equal), it does not matter much which witness Coq infers.  Therefore, the primary concerns in making use of the typeclass machinery are coverage (how many goals can be automatically solved) and speed (how long does it take to solve a goal, and how long does it take to error on a goal we cannot automatically solve).  Careful use of typeclass instances and priorities, which determine the order of typeclass resolution, can be used to effectively increase both the coverage and the speed in cases where the goal is solvable.  Unfortunately, typeclass resolution tends to spin for a while before failing unless you're very, very, very careful.  We currently aim to achieve moderate coverage and fast speed in solvable cases.  How long it takes to fail typeclass resolution is not currently considered, though it would be nice someday to be even more careful about things.

<div class="paragraph"> </div>

In order to achieve moderate coverage and speedy resolution, we currently follow the following principles.  They set up a kind of directed flow of information, intended to prevent cycles and potentially infinite chains, which are often the ways that typeclass resolution gets stuck.

<div class="paragraph"> </div>

<ul class="doclist">
<li> We prefer to reason about <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">A</span></span> rather than <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(@<span class="id" title="var">paths</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>.  Whenever we see a statement (or goal) about truncation of paths, we try to turn it into a statement (or goal) about truncation of a (non-<span class="inlinecode"><span class="id" title="var">paths</span></span>) type.  We do not allow typeclass resolution to go in the reverse direction from <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> <span class="inlinecode"><span class="id" title="var">A</span></span> to <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">a</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>.

<div class="paragraph"> </div>


</li>
<li> We prefer to reason about syntactically smaller types.  That is, typeclass instances should turn goals of type <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span> into goals of type <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">P</span></span> <span class="inlinecode"><span class="id" title="var">a</span>)</span>; and goals of type <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> into the pair of goals of type <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>; rather than the other way around.  Ideally, we would add similar rules to transform hypotheses in the cases where we can do so.  This rule is not always the one we want, but it seems to heuristically capture the shape of most cases that we want the typeclass machinery to automatically infer.  That is, we often want to infer <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> from <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span>, but we (probably) don't often need to do other simple things with <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> which are broken by that reduction.

<div class="paragraph"> </div>

   We begin by defining the type that indexes the truncation levels.

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">trunc_index</span> : <span class="id" title="var">Type0</span> :=<br/>
| <span class="id" title="var">minus_two</span> : <span class="id" title="var">trunc_index</span><br/>
| <span class="id" title="var">trunc_S</span> : <span class="id" title="var">trunc_index</span> -&gt; <span class="id" title="var">trunc_index</span>.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">trunc_index_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">trunc_index</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">trunc_index_rec</span> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <span class="id" title="var">trunc_index</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="comment">(*&nbsp;See&nbsp;comment&nbsp;above&nbsp;about&nbsp;the&nbsp;tactic&nbsp;<span class="inlinecode"><span class="id" title="tactic">induction</span></span>.&nbsp;*)</span><br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">trunc_index_rect</span> := <span class="id" title="var">trunc_index_ind</span>.<br/>

<br/>
</div>

<div class="doc">
We will use <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> for <span class="inlinecode"><span class="id" title="var">trunc_index</span></span>es, so define a scope for them here. Numeral notation for <span class="inlinecode"><span class="id" title="var">trunc_index</span></span>es is set up in Basics/Trunc.v. 
</div>
<div class="code">
<span class="id" title="keyword">Bind Scope</span> <span class="id" title="var">trunc_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">trunc_index</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">trunc_S</span> <span class="id" title="var">_</span>%<span class="id" title="var">_trunc_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> &quot;n .+1" := (<span class="id" title="var">trunc_S</span> <span class="id" title="var">n</span>) : <span class="id" title="var">trunc_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;n .+2" := (<span class="id" title="var">n</span>.+1.+1)%<span class="id" title="var">trunc</span> : <span class="id" title="var">trunc_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;n .+3" := (<span class="id" title="var">n</span>.+1.+2)%<span class="id" title="var">trunc</span> : <span class="id" title="var">trunc_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;n .+4" := (<span class="id" title="var">n</span>.+1.+3)%<span class="id" title="var">trunc</span> : <span class="id" title="var">trunc_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;n .+5" := (<span class="id" title="var">n</span>.+1.+4)%<span class="id" title="var">trunc</span> : <span class="id" title="var">trunc_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">trunc_scope</span>.<br/>

<br/>
</div>

<div class="doc">
We define truncatedness using an inductive type <span class="inlinecode"><span class="id" title="var">IsTrunc_internal</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>.  We use a notation <span class="inlinecode"><span class="id" title="var">IsTrunc</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> simply to swap the orders of arguments, and notations <span class="inlinecode"><span class="id" title="var">Contr</span></span>, <span class="inlinecode"><span class="id" title="var">IsHProp</span></span> and <span class="inlinecode"><span class="id" title="var">IsHSet</span></span> which specialize to <span class="inlinecode"><span class="id" title="var">n</span></span> being <span class="inlinecode">-2</span>, <span class="inlinecode">-1</span> and <span class="inlinecode">0</span>, respectively.  An alternative is to use a <span class="inlinecode"><span class="id" title="keyword">Fixpoint</span></span>, and that was done in the past.  The advantages of the inductive approach are:  <span class="inlinecode"><span class="id" title="var">IsTrunc_internal</span></span> is cumulative; typeclass inherence works smoothly; the library builds faster.  Some disadvantages are that we need to manually apply the constructors when proving that something is truncated, and that the induction principle is awkward to work with. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">IsTrunc_internal</span> (<span class="id" title="var">A</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">u</span>}) : <span class="id" title="var">trunc_index</span> -&gt; <span class="id" title="var">Type@</span>{<span class="id" title="var">u</span>} :=<br/>
| <span class="id" title="var">Build_Contr</span> : <span class="id" title="keyword">forall</span> (<span class="id" title="var">center</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">contr</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">y</span>, <span class="id" title="var">center</span> = <span class="id" title="var">y</span>), <span class="id" title="var">IsTrunc_internal</span> <span class="id" title="var">A</span> <span class="id" title="var">minus_two</span><br/>
| <span class="id" title="var">istrunc_S</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">n</span>:<span class="id" title="var">trunc_index</span>}, (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>:<span class="id" title="var">A</span>, <span class="id" title="var">IsTrunc_internal</span> (<span class="id" title="var">x</span> = <span class="id" title="var">y</span>) <span class="id" title="var">n</span>) -&gt; <span class="id" title="var">IsTrunc_internal</span> <span class="id" title="var">A</span> (<span class="id" title="var">trunc_S</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Existing Class</span> <span class="id" title="var">IsTrunc_internal</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span> := (<span class="id" title="var">IsTrunc_internal</span> <span class="id" title="var">A</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">IsTrunc_internal_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">IsTrunc_internal</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">IsTrunc_internal_rec</span> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <span class="id" title="var">IsTrunc_internal</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">IsTrunc_internal_rect</span> := <span class="id" title="var">IsTrunc_internal_ind</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">IsTrunc_unfolded</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">minus_two</span> =&gt; { <span class="id" title="var">center</span> : <span class="id" title="var">A</span> &amp; <span class="id" title="keyword">forall</span> <span class="id" title="var">y</span>, <span class="id" title="var">center</span> = <span class="id" title="var">y</span> }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">n</span>.+1 =&gt; <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">x</span> = <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">istrunc_unfold</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span> -&gt; <span class="id" title="var">IsTrunc_unfolded</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">center</span> <span class="id" title="var">contr</span>|<span class="id" title="var">k</span> <span class="id" title="var">istrunc</span>].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">center</span>; <span class="id" title="var">contr</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">istrunc</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">isequiv_istrunc_unfold</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">istrunc_unfold</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simple</span> <span class="id" title="tactic">refine</span> (<span class="id" title="var">Build_IsEquiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">istrunc_unfold</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>) <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> [<span class="id" title="var">center</span> <span class="id" title="var">contr</span>]; <span class="id" title="tactic">exact</span> (<span class="id" title="var">Build_Contr</span> <span class="id" title="var">_</span> <span class="id" title="var">center</span> <span class="id" title="var">contr</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">exact</span> (<span class="id" title="var">istrunc_S</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">center</span> <span class="id" title="var">contr</span>|<span class="id" title="var">k</span> <span class="id" title="var">istrunc</span>]; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">center</span> <span class="id" title="var">contr</span>|<span class="id" title="var">k</span> <span class="id" title="var">istrunc</span>]; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_istrunc_unfold</span> (<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>) (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">Build_Equiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>  (<span class="id" title="var">isequiv_istrunc_unfold</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>).<br/>

<br/>
</div>

<div class="doc">
A version of <span class="inlinecode"><span class="id" title="var">istrunc_unfold</span></span> for successors. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">istrunc_paths</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) <span class="id" title="var">n</span> `{<span class="id" title="var">H</span> : <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span>} (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">x</span> = <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">istrunc_unfold</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">A</span> <span class="id" title="var">H</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">Contr</span> <span class="id" title="var">A</span> := (<span class="id" title="var">IsTrunc</span> <span class="id" title="var">minus_two</span> <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">IsHProp</span> <span class="id" title="var">A</span> := (<span class="id" title="var">IsTrunc</span> <span class="id" title="var">minus_two</span>.+1 <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">IsHSet</span> <span class="id" title="var">A</span> := (<span class="id" title="var">IsTrunc</span> <span class="id" title="var">minus_two</span>.+2 <span class="id" title="var">A</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">center</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) {<span class="id" title="var">H</span> : <span class="id" title="var">Contr</span> <span class="id" title="var">A</span>} : <span class="id" title="var">A</span> := <span class="id" title="var">pr1</span> (<span class="id" title="var">istrunc_unfold</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">contr</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">H</span> : <span class="id" title="var">Contr</span> <span class="id" title="var">A</span>} (<span class="id" title="var">y</span> : <span class="id" title="var">A</span>) : <span class="id" title="var">center</span> <span class="id" title="var">A</span> = <span class="id" title="var">y</span> := <span class="id" title="var">pr2</span> (<span class="id" title="var">istrunc_unfold</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>) <span class="id" title="var">y</span>.<br/>

<br/>
</div>

<div class="doc">
We define a slight variation of <span class="inlinecode"><span class="id" title="var">istrunc_unfold</span></span>, which differs only it what it does for <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-2</span>.  It will produce a section of the following type family. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">istrunc_codomain_fam</span> {<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">istrunc</span> : <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>) : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">center</span> <span class="id" title="var">A</span> = <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">y</span> = <span class="id" title="var">x</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The variant of <span class="inlinecode"><span class="id" title="var">istrunc_unfold</span></span> lets us treat any proof of truncation as a function.  For <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-2</span>, it produces the contracting homotopy. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">istrunc_fun</span> {<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">istrunc</span> : <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>, <span class="id" title="var">istrunc_codomain_fam</span> <span class="id" title="var">istrunc</span> <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (@<span class="id" title="var">contr</span> <span class="id" title="var">A</span> <span class="id" title="var">istrunc</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">istrunc_unfold</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">istrunc</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We add this as a coercion. 
</div>
<div class="code">
#[<span class="id" title="var">warning</span>="-uniform-inheritance"] <br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">istrunc_fun</span> : <span class="id" title="var">IsTrunc</span> &gt;-&gt; <span class="id" title="var">Funclass</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab353"></a><h3 class="section">Truncated relations</h3>

<div class="paragraph"> </div>

 Hprop-valued relations.  Making this a <span class="inlinecode"><span class="id" title="keyword">Notation</span></span> rather than a <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> enables typeclass resolution to pick it up easily.  We include the base type <span class="inlinecode"><span class="id" title="var">A</span></span> in the notation since otherwise e.g. <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">z</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span>),</span> <span class="inlinecode"><span class="id" title="var">IsHProp</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode"><span class="id" title="var">z</span>)</span> will get displayed as <span class="inlinecode"><span class="id" title="keyword">forall</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>),</span> <span class="inlinecode"><span class="id" title="var">is_mere_relation</span></span> <span class="inlinecode">(<span class="id" title="var">C</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span>.  
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <span class="id" title="var">is_mere_relation</span> <span class="id" title="var">A</span> <span class="id" title="var">R</span> := (<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>), <span class="id" title="var">IsHProp</span> (<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)).<br/>

<br/>
</div>

<div class="doc">
<a id="lab354"></a><h2 class="section">Natural numbers</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">nat</span> : <span class="id" title="var">Type0</span> :=<br/>
| <span class="id" title="var">O</span> : <span class="id" title="var">nat</span><br/>
| <span class="id" title="var">S</span> : <span class="id" title="var">nat</span> -&gt; <span class="id" title="var">nat</span>.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">nat_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">nat</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">nat_rect</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">nat</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">nat_rec</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">nat</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Declare Scope</span> <span class="id" title="var">nat_scope</span>.<br/>
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">nat_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Bind Scope</span> <span class="id" title="var">nat_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">S</span> <span class="id" title="var">_</span>%<span class="id" title="var">_nat</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab355"></a><h2 class="section">Misc</h2>

<div class="paragraph"> </div>

 We put <span class="inlinecode"><span class="id" title="var">Empty</span></span> here, instead of in <span class="inlinecode"><span class="id" title="var">Empty.v</span></span>, because <span class="inlinecode"><span class="id" title="keyword">Ltac</span></span> <span class="inlinecode"><span class="id" title="var">done</span></span> uses it. 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Empty</span> : <span class="id" title="var">Type0</span> := .<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">Empty</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.False.type</span>.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">Empty_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">Empty</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">Empty_rec</span> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <span class="id" title="var">Empty</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Empty_rect</span> := <span class="id" title="var">Empty_ind</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">not</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) := <span class="id" title="var">A</span> -&gt; <span class="id" title="var">Empty</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;~ x" := (<span class="id" title="var">not</span> <span class="id" title="var">x</span>) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;~~ x" := (~ ~<span class="id" title="var">x</span>) : <span class="id" title="var">type_scope</span>.<br/>
#[<span class="id" title="var">export</span>]<br/>
<span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Unfold</span> <span class="id" title="var">not</span>: <span class="id" title="var">core</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;&gt; y  :&gt;  T" := (<span class="id" title="var">not</span> (<span class="id" title="var">x</span> = <span class="id" title="var">y</span> :&gt; <span class="id" title="var">T</span>)) : <span class="id" title="var">type_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> &quot;x &lt;&gt; y" := (<span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">y</span> :&gt; <span class="id" title="var">_</span>) : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">symmetric_neq</span> {<span class="id" title="var">A</span>} {<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">A</span>} : <span class="id" title="var">x</span> &lt;&gt; <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> &lt;&gt; <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">fun</span> <span class="id" title="var">np</span> <span class="id" title="var">p</span> =&gt; <span class="id" title="var">np</span> (<span class="id" title="var">p</span>^).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">complement</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span>) : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; ~ (<span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>).<br/>

<br/>
#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Typeclasses</span> <span class="id" title="keyword">Opaque</span> <span class="id" title="var">complement</span>.<br/>

<br/>
<span class="id" title="keyword">Class</span> <span class="id" title="var">Irreflexive</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">irreflexivity</span> : <span class="id" title="var">Reflexive</span> (<span class="id" title="var">complement</span> <span class="id" title="var">R</span>).<br/>

<br/>
<span class="id" title="keyword">Class</span> <span class="id" title="var">Asymmetric</span> {<span class="id" title="var">A</span>} (<span class="id" title="var">R</span> : <span class="id" title="var">Relation</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="var">asymmetry</span> : <span class="id" title="keyword">forall</span> {<span class="id" title="var">x</span> <span class="id" title="var">y</span>}, <span class="id" title="var">R</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> -&gt; (<span class="id" title="var">complement</span> <span class="id" title="var">R</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> : <span class="id" title="keyword">Type</span>).<br/>

<br/>
</div>

<div class="doc">
Likewise, we put <span class="inlinecode"><span class="id" title="var">Unit</span></span> here, instead of in <span class="inlinecode"><span class="id" title="var">Unit.v</span></span>, because <span class="inlinecode"><span class="id" title="var">Trunc</span></span> uses it. 
</div>
<div class="code">
<span class="id" title="keyword">Inductive</span> <span class="id" title="var">Unit</span> : <span class="id" title="var">Type0</span> := <span class="id" title="var">tt</span> : <span class="id" title="var">Unit</span>.<br/>

<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">Unit_ind</span> := <span class="id" title="keyword">Induction</span> <span class="id" title="keyword">for</span> <span class="id" title="var">Unit</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Scheme</span> <span class="id" title="var">Unit_rec</span> := <span class="id" title="var">Minimality</span> <span class="id" title="keyword">for</span> <span class="id" title="var">Unit</span> <span class="id" title="keyword">Sort</span> <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Unit_rect</span> := <span class="id" title="var">Unit_ind</span>.<br/>

<br/>
</div>

<div class="doc">
A <span class="inlinecode"><span class="id" title="var">Unit</span></span> goal should be resolved by <span class="inlinecode"><span class="id" title="tactic">auto</span></span> and <span class="inlinecode"><span class="id" title="tactic">trivial</span></span>. 
</div>
<div class="code">
#[<span class="id" title="var">export</span>]<br/>
<span class="id" title="keyword">Hint</span> <span class="id" title="keyword">Resolve</span> <span class="id" title="var">tt</span> : <span class="id" title="var">core</span>.<br/>

<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">Unit</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.IDProp.type</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">Unit</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.True.type</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">tt</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.IDProp.idProp</span>.<br/>
<span class="id" title="keyword">Register</span> <span class="id" title="var">tt</span> <span class="id" title="keyword">as</span> <span class="id" title="var">core.True.I</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab356"></a><h3 class="section">Pointed types</h3>

<div class="paragraph"> </div>

 A space is pointed if that space has a point. 
</div>
<div class="code">
<span class="id" title="keyword">Class</span> <span class="id" title="var">IsPointed</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) := <span class="id" title="var">point</span> : <span class="id" title="var">A</span>.<br/>

<br/>
#[<span class="id" title="var">global</span>] <span class="id" title="keyword">Typeclasses</span> <span class="id" title="keyword">Transparent</span> <span class="id" title="var">IsPointed</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">point</span> <span class="id" title="var">A</span> {<span class="id" title="var">_</span>}.<br/>

<br/>
<span class="id" title="keyword">Record</span> <span class="id" title="var">pType</span> :=<br/>
&nbsp;&nbsp;{ <span class="id" title="var">pointed_type</span> : <span class="id" title="keyword">Type</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ispointed_type</span> : <span class="id" title="var">IsPointed</span> <span class="id" title="var">pointed_type</span> }.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">pointed_type</span> : <span class="id" title="var">pType</span> &gt;-&gt; <span class="id" title="var">Sortclass</span>.<br/>

<br/>
<span class="id" title="keyword">Global Existing Instance</span> <span class="id" title="var">ispointed_type</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab357"></a><h3 class="section">Homotopy fibers</h3>

<div class="paragraph"> </div>

 Homotopy fibers are homotopical inverse images of points.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hfiber</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">B</span>) := { <span class="id" title="var">x</span> : <span class="id" title="var">A</span> &amp; <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">y</span> }.<br/>

<br/>
<span class="id" title="keyword">Global Arguments</span> <span class="id" title="var">hfiber</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}%<span class="id" title="var">_type_scope</span> <span class="id" title="var">f</span>%<span class="id" title="var">_function_scope</span> <span class="id" title="var">y</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab358"></a><h2 class="section">Smallness</h2>

<div class="paragraph"> </div>

 We say that <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>}</span> is small (relative to Type@{i}) if it is equivalent to a type in <span class="inlinecode"><span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>}</span>.  We use a record to avoid an extra universe variable.  This version has no constraints on <span class="inlinecode"><span class="id" title="var">i</span></span> and <span class="inlinecode"><span class="id" title="var">j</span></span>.  It lands in <span class="inlinecode"><span class="id" title="var">max</span>(<span class="id" title="var">i</span>+1,<span class="id" title="var">j</span>)</span>, as expected.  We mark the <span class="inlinecode"><span class="id" title="var">i</span></span> variable as being invariant, so that Coq is better at guessing universe variables when this is used. 
</div>
<div class="code">
<span class="id" title="keyword">Class</span> <span class="id" title="var">IsSmall@</span>{=<span class="id" title="var">i</span> <span class="id" title="var">j</span> | } (<span class="id" title="var">X</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>}) := {<br/>
&nbsp;&nbsp;<span class="id" title="var">smalltype</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">i</span>} ;<br/>
&nbsp;&nbsp;<span class="id" title="var">equiv_smalltype</span> : <span class="id" title="var">smalltype</span> &lt;~&gt; <span class="id" title="var">X</span> ;<br/>
}.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">smalltype</span> <span class="id" title="var">X</span> {<span class="id" title="var">_</span>}.<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">equiv_smalltype</span> <span class="id" title="var">X</span> {<span class="id" title="var">_</span>}.<br/>

<br/>
</div>

<div class="doc">
<a id="lab359"></a><h3 class="section">Propositional resizing</h3>

<div class="paragraph"> </div>

 See the note by <span class="inlinecode"><span class="id" title="var">Funext</span></span> above regarding classes for axioms. 
</div>
<div class="code">
<span class="id" title="keyword">Monomorphic Axiom</span> <span class="id" title="var">PropResizing</span> : <span class="id" title="var">Type0</span>.<br/>
<span class="id" title="keyword">Existing Class</span> <span class="id" title="var">PropResizing</span>.<br/>

<br/>
</div>

<div class="doc">
Propositional resizing says that every (-1)-truncated type is small. 
</div>
<div class="code">
<span class="id" title="keyword">Axiom</span> <span class="id" title="var">issmall_hprop@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span> | } : <span class="id" title="keyword">forall</span> `{<span class="id" title="var">PropResizing</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">Type@</span>{<span class="id" title="var">j</span>})<br/>
&nbsp;&nbsp;(<span class="id" title="var">T</span> : <span class="id" title="var">IsHProp</span> <span class="id" title="var">X</span>), <span class="id" title="var">IsSmall@</span>{<span class="id" title="var">i</span> <span class="id" title="var">j</span>} <span class="id" title="var">X</span>.<br/>
<span class="id" title="keyword">Existing Instance</span> <span class="id" title="var">issmall_hprop</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>