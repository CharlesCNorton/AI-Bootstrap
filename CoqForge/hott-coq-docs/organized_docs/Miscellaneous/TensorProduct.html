<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>TensorProduct</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library TensorProduct</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Basics.Overture</span> <span class="id" title="var">Basics.Tactics</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Types.Forall</span> <span class="id" title="var">Types.Sigma</span> <span class="id" title="var">Types.Prod</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">WildCat.Core</span> <span class="id" title="var">WildCat.Equiv</span> <span class="id" title="var">WildCat.Monoidal</span> <span class="id" title="var">WildCat.Bifunctor</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">WildCat.NatTrans</span> <span class="id" title="var">WildCat.MonoidalTwistConstruction</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Algebra.Groups.Group</span> <span class="id" title="var">Algebra.Groups.QuotientGroup</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Algebra.AbGroups.AbelianGroup</span> <span class="id" title="var">Algebra.AbGroups.Biproduct</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Algebra.AbGroups.AbHom</span> <span class="id" title="var">Algebra.AbGroups.FreeAbelianGroup</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Algebra.AbGroups.Abelianization</span> <span class="id" title="var">Algebra</span> <span class="id" title="var">Algebra.Groups.FreeGroup</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Colimits.Quotient</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Spaces.List.Core</span> <span class="id" title="var">Spaces.Int</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">AbGroups.Z</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Truncations</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">mc_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">mc_add_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab115"></a><h1 class="section">The Tensor Product of Abelian Groups</h1>

<div class="paragraph"> </div>

 Various maps <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span></span> from the cartesian product of two abelian groups to another abelian group are "biadditive" (also called "bilinear"), meaning that they are group homomorphisms when we fix the left or right argument.

<div class="paragraph"> </div>

The tensor product of abelian groups is a construction that produces an abelian group <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">B</span></span> along with a biadditive map <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">B</span></span> which is initial among biadditive maps from <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span>.  This means that any biadditive map <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span></span> factors uniquely through the tensor product via a group homomorphism <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">C</span></span>.

<div class="paragraph"> </div>

Biadditive functions appear in all sorts of contexts ranging from linear algebra to analysis. Therefore having a way to systematically study them is very useful. 
<div class="paragraph"> </div>

<a id="lab116"></a><h2 class="section">Construction</h2>

<div class="paragraph"> </div>

 We define the tensor product of abelian groups as a quotient of the free abelian group on pairs of elements of the two groups by the subgroup generated by the biadditive pairs. 
<div class="paragraph"> </div>

 Here we define the subgroup of biadditive pairs in two steps. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">family_biadditive_pairs</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">FreeAbGroup</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>) -&gt; <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> ((<span class="id" title="tactic">exists</span> (<span class="id" title="var">a1</span> <span class="id" title="var">a2</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>), <span class="id" title="var">_</span>) + <span class="id" title="tactic">exists</span> (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b1</span> <span class="id" title="var">b2</span> : <span class="id" title="var">B</span>), <span class="id" title="var">_</span>)%<span class="id" title="keyword">type</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (- <span class="id" title="var">_</span> + (<span class="id" title="var">_</span> + <span class="id" title="var">_</span>) = <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1-3: <span class="id" title="tactic">apply</span> <span class="id" title="var">freeabgroup_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">a1</span> + <span class="id" title="var">a2</span>, <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">a1</span>, <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">a2</span>, <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">refine</span> (- <span class="id" title="var">_</span> + (<span class="id" title="var">_</span> + <span class="id" title="var">_</span>) = <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1-3: <span class="id" title="tactic">apply</span> <span class="id" title="var">freeabgroup_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">a</span>, <span class="id" title="var">b1</span> + <span class="id" title="var">b2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">a</span>, <span class="id" title="var">b1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">a</span>, <span class="id" title="var">b2</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">subgroup_biadditive_pairs</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">Subgroup</span> (<span class="id" title="var">FreeAbGroup</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>))<br/>
&nbsp;&nbsp;:= <span class="id" title="var">subgroup_generated</span> <span class="id" title="var">family_biadditive_pairs</span>.<br/>

<br/>
</div>

<div class="doc">
The tensor product <span class="inlinecode"><span class="id" title="var">ab_tensor_prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> of two abelian groups <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span> is defined to be a quotient of the free abelian group on pairs of elements <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">B</span></span> by the subgroup of biadditive pairs. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>) : <span class="id" title="var">AbGroup</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">QuotientAbGroup</span> (<span class="id" title="var">FreeAbGroup</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>)) <span class="id" title="var">subgroup_biadditive_pairs</span>.<br/>

<br/>
<span class="id" title="keyword">Arguments</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="tactic">simpl</span> <span class="id" title="var">never</span>.<br/>

<br/>
</div>

<div class="doc">
The tensor product of <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span> contains formal sums and differences of pairs of elements from <span class="inlinecode"><span class="id" title="var">A</span></span> and <span class="inlinecode"><span class="id" title="var">B</span></span>. We denote these pairs as "simple tensors" and name them <span class="inlinecode"><span class="id" title="var">tensor</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">grp_quotient_map</span> (<span class="id" title="var">freeabgroup_in</span> (<span class="id" title="var">a</span>, <span class="id" title="var">b</span>)).<br/>

<br/>
</div>

<div class="doc">
<a id="lab117"></a><h2 class="section">Properties of tensors</h2>

<div class="paragraph"> </div>

 The characterizing property of simple tensors are that they are biadditive in their arguments. 
<div class="paragraph"> </div>

 A <span class="inlinecode"><span class="id" title="var">tensor</span></span> of a sum distributes over the sum on the left. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_dist_l</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> <span class="id" title="var">b'</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">b</span> + <span class="id" title="var">b'</span>) = <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">qglue</span>, <span class="id" title="var">tr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">sgt_in</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">right</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">exists</span> <span class="id" title="var">a</span>, <span class="id" title="var">b</span>, <span class="id" title="var">b'</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
A <span class="inlinecode"><span class="id" title="var">tensor</span></span> of a sum distributes over the sum on the right. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_dist_r</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">a</span> <span class="id" title="var">a'</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> (<span class="id" title="var">a</span> + <span class="id" title="var">a'</span>) <span class="id" title="var">b</span> = <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">tensor</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">qglue</span>, <span class="id" title="var">tr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">sgt_in</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">left</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">exists</span> <span class="id" title="var">a</span>, <span class="id" title="var">a'</span>, <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Tensoring on the left is a group homomorphism. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">grp_homo_tensor_l</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_GroupHomomorphism</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Tensoring on the right is a group homomorphism. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">grp_homo_tensor_r</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_GroupHomomorphism</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Tensors preserve negation in the left argument. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_neg_l</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> (-<span class="id" title="var">a</span>) <span class="id" title="var">b</span> = - <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">grp_homo_inv</span> (<span class="id" title="var">grp_homo_tensor_r</span> <span class="id" title="var">b</span>) <span class="id" title="var">a</span>.<br/>

<br/>
</div>

<div class="doc">
Tensors preserve negation in the right argument. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_neg_r</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (-<span class="id" title="var">b</span>) = - <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">grp_homo_inv</span> (<span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">a</span>) <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
Tensoring by zero on the left is zero. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_zero_l</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">A</span>) 0 <span class="id" title="var">b</span> = 0<br/>
&nbsp;&nbsp;:= <span class="id" title="var">grp_homo_unit</span> (<span class="id" title="var">grp_homo_tensor_r</span> <span class="id" title="var">b</span>).<br/>

<br/>
</div>

<div class="doc">
Tensoring by zero on the right is zero. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_zero_r</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> (<span class="id" title="var">B</span>:=<span class="id" title="var">B</span>) <span class="id" title="var">a</span> 0 = 0<br/>
&nbsp;&nbsp;:= <span class="id" title="var">grp_homo_unit</span> (<span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">a</span>).<br/>

<br/>
</div>

<div class="doc">
The <span class="inlinecode"><span class="id" title="var">tensor</span></span> map is biadditive and therefore can be written in a curried form using the internal abelian group hom. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">grp_homo_tensor</span> `{<span class="id" title="var">Funext</span>} {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">ab_hom</span> <span class="id" title="var">B</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_GroupHomomorphism</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_GroupHomomorphism</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">equiv_path_grouphomomorphism</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab118"></a><h2 class="section">Induction principles</h2>

<div class="paragraph"> </div>

 Here we write down some induction principles to help us prove lemmas about the tensor product. Some of these are quite specialised but are patterns that appear often in practice. 
<div class="paragraph"> </div>

 Our main recursion principle states that in order to build a homomorphism out of the tensor product, it is sufficient to provide a map out of the direct product which is biadditive, that is, a map that preserves addition in each argument of the product. 
<div class="paragraph"> </div>

 We separate out the proof of this part, so we can make it opaque. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_rec_helper</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span>, <span class="id" title="var">f</span> <span class="id" title="var">a</span> (<span class="id" title="var">b</span> + <span class="id" title="var">b'</span>) = <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b'</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">r</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>, <span class="id" title="var">f</span> (<span class="id" title="var">a</span> + <span class="id" title="var">a'</span>) <span class="id" title="var">b</span> = <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">f</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">x</span> : <span class="id" title="var">FreeAbGroup</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>)) (<span class="id" title="var">insg</span> : <span class="id" title="var">subgroup_biadditive_pairs</span> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">grp_homo_abel_rec</span> (<span class="id" title="var">FreeGroup_rec</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>) <span class="id" title="var">C</span> (<span class="id" title="var">uncurry</span> <span class="id" title="var">f</span>)) <span class="id" title="var">x</span> = <span class="id" title="var">mon_unit</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">abel_rec</span> := <span class="id" title="var">grp_homo_abel_rec</span> (<span class="id" title="var">FreeGroup_rec</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>) <span class="id" title="var">C</span> (<span class="id" title="var">uncurry</span> <span class="id" title="var">f</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="var">strip_truncations</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">insg</span> <span class="id" title="keyword">as</span> [ <span class="id" title="var">x</span> <span class="id" title="var">biad</span> | | <span class="id" title="var">g</span> <span class="id" title="var">h</span> <span class="id" title="var">insg_g</span> <span class="id" title="var">IHg</span> <span class="id" title="var">insg_h</span> <span class="id" title="var">IHh</span> ].<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">destruct</span> <span class="id" title="var">biad</span> <span class="id" title="keyword">as</span> [ [ <span class="id" title="var">a</span> [ <span class="id" title="var">a'</span> [ <span class="id" title="var">b</span> <span class="id" title="var">p</span> ] ] ] | [ <span class="id" title="var">a</span> [ <span class="id" title="var">b</span> [ <span class="id" title="var">b'</span> <span class="id" title="var">p</span> ] ] ] ].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span>: <span class="id" title="tactic">destruct</span> <span class="id" title="var">p</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">all</span>: <span class="id" title="tactic">apply</span> <span class="id" title="var">grp_moveL_M1</span>^-1%<span class="id" title="var">equiv</span>; <span class="id" title="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="tactic">apply</span> <span class="id" title="var">r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">l</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">nrapply</span> <span class="id" title="var">grp_homo_unit</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">rewrite</span> <span class="id" title="var">grp_homo_op</span>, <span class="id" title="var">grp_homo_inv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">grp_moveL_1M</span>^-1.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">IHg</span> @ <span class="id" title="var">IHh</span>^).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Opaque</span> <span class="id" title="var">ab_tensor_prod_rec_helper</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_rec</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span>, <span class="id" title="var">f</span> <span class="id" title="var">a</span> (<span class="id" title="var">b</span> + <span class="id" title="var">b'</span>) = <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b'</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">r</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>, <span class="id" title="var">f</span> (<span class="id" title="var">a</span> + <span class="id" title="var">a'</span>) <span class="id" title="var">b</span> = <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">f</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>) <br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">grp_quotient_rec</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">FreeAbGroup_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">uncurry</span> <span class="id" title="var">f</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">unfold</span> <span class="id" title="var">normalsubgroup_subgroup</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ab_tensor_prod_rec_helper</span>; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
A special case that arises. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_rec'</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">l</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>, <span class="id" title="var">f</span> (<span class="id" title="var">a</span> + <span class="id" title="var">a'</span>) <span class="id" title="var">b</span> = <span class="id" title="var">f</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">f</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ab_tensor_prod_rec</span> <span class="id" title="var">f</span> <span class="id" title="var">_</span> <span class="id" title="var">l</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">grp_homo_op</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We give an induction principle for an hprop-valued type family <span class="inlinecode"><span class="id" title="var">P</span></span>.  It may be surprising at first that we only require <span class="inlinecode"><span class="id" title="var">P</span></span> to hold for the simple tensors <span class="inlinecode"><span class="id" title="var">tensor</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> and be closed under addition.  It automatically follows that <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">0</span> holds (since <span class="inlinecode"><span class="id" title="var">tensor</span></span> <span class="inlinecode">0</span> <span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>) and that <span class="inlinecode"><span class="id" title="var">P</span></span> is closed under negation (since <span class="inlinecode"><span class="id" title="var">tensor</span></span> <span class="inlinecode">-<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-</span> <span class="inlinecode"><span class="id" title="var">tensor</span></span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">b</span></span>). This induction principle says that the simple tensors generate the tensor product as a semigroup. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_ind_hprop</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;{<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">IsHProp</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>)}<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hin</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">P</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hop</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> + <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">grp_quotient_ind_hprop</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">Abel_ind_hprop</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">tensor_in</span> := <span class="id" title="var">grp_quotient_map</span> $<span class="id" title="var">o</span> <span class="id" title="var">abel_unit</span> : <span class="id" title="var">FreeGroup</span> (<span class="id" title="var">A</span> * <span class="id" title="var">B</span>) $-&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> (<span class="id" title="var">tensor_in</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">FreeGroup_ind_hprop'</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">w</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">w</span>.<br/>
&nbsp;&nbsp;- <span class="comment">(*&nbsp;The&nbsp;goal&nbsp;here&nbsp;is&nbsp;<span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">0</span>,&nbsp;so&nbsp;we&nbsp;use&nbsp;<span class="inlinecode"><span class="id" title="var">Hin</span></span> <span class="inlinecode">0</span> <span class="inlinecode">0</span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">(<span class="id" title="var">tensor</span></span> <span class="inlinecode">0</span> <span class="inlinecode">0)</span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">transport</span> <span class="id" title="var">P</span> (<span class="id" title="var">tensor_zero_l</span> 0) (<span class="id" title="var">Hin</span> 0 0)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">change</span> (<span class="id" title="var">P</span> (<span class="id" title="var">tensor_in</span> (<span class="id" title="var">freegroup_eta</span> [<span class="id" title="var">a</span>]%<span class="id" title="var">list</span> + <span class="id" title="var">freegroup_eta</span> <span class="id" title="var">w</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>&nbsp;is&nbsp;<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>,&nbsp;but&nbsp;the&nbsp;<span class="inlinecode"><span class="id" title="keyword">Defined</span></span>&nbsp;is&nbsp;slow&nbsp;if&nbsp;<span class="inlinecode"><span class="id" title="tactic">change</span></span>&nbsp;is&nbsp;used&nbsp;instead.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">grp_homo_op</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">a</span> <span class="id" title="keyword">as</span> [[<span class="id" title="var">a</span> <span class="id" title="var">b</span>]|[<span class="id" title="var">a</span> <span class="id" title="var">b</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">change</span> (<span class="id" title="var">P</span> (<span class="id" title="var">tensor_in</span> (<span class="id" title="var">freegroup_in</span> (<span class="id" title="var">a</span>, <span class="id" title="var">b</span>)) + <span class="id" title="var">tensor_in</span> (<span class="id" title="var">freegroup_eta</span> <span class="id" title="var">w</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Hop</span>; <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Hin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">change</span> (<span class="id" title="var">P</span> (<span class="id" title="var">tensor_in</span> (- <span class="id" title="var">freegroup_in</span> (<span class="id" title="var">a</span>, <span class="id" title="var">b</span>)) + <span class="id" title="var">tensor_in</span> (<span class="id" title="var">freegroup_eta</span> <span class="id" title="var">w</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;<span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>&nbsp;is&nbsp;also&nbsp;reflexivity.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">grp_homo_inv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Hop</span>; <span class="id" title="tactic">trivial</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">tensor_neg_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Hin</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
As a commonly occuring special case of the above induction principle, we have the case when the predicate in question is showing that two group homomorphisms out of the tensor product are homotopic. In order to do this, it suffices to show it only for simple tensors. The homotopy is closed under addition, so we don't need to hypothesise anything else. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">G</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> <span class="id" title="var">f'</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">G</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">f</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) = <span class="id" title="var">f'</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="var">f</span> $== <span class="id" title="var">f'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_prod_ind_hprop</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">grp_homo_op_agree</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
As an even more specialised case, we occasionally have the second homomorphism being a sum of abelian group homomorphisms. In those cases, it is easier to use this specialised lemma. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_plus</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">G</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> <span class="id" title="var">f'</span> <span class="id" title="var">f''</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">G</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">f</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) = <span class="id" title="var">f'</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) + <span class="id" title="var">f''</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">f</span> <span class="id" title="var">x</span> = <span class="id" title="var">f'</span> <span class="id" title="var">x</span> + <span class="id" title="var">f''</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;:= <span class="id" title="var">ab_tensor_prod_ind_homotopy</span> (<span class="id" title="var">f'</span>:=<span class="id" title="var">ab_homo_add</span> <span class="id" title="var">f'</span> <span class="id" title="var">f''</span>) <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
Here we give an induction principle for a triple tensor, a.k.a a dependent trilinear function. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_ind_hprop_triple</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">IsHProp</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hin</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">P</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>)))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hop</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> + <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">ab_tensor_prod_ind_hprop</span> <span class="id" title="var">P</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">ab_tensor_prod_ind_hprop</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">nrapply</span> <span class="id" title="var">Hin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">Hx</span> <span class="id" title="var">Hy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">Hop</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">Hop</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Similar to before, we specialise the triple tensor induction principle for proving homotopies of trilinear/triadditive functions. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_triple</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">G</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> <span class="id" title="var">f'</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>) $-&gt; <span class="id" title="var">G</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>, <span class="id" title="var">f</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>)) = <span class="id" title="var">f'</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>)))<br/>
&nbsp;&nbsp;: <span class="id" title="var">f</span> $== <span class="id" title="var">f'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_prod_ind_hprop_triple</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">grp_homo_op_agree</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
As explained for the biadditive and triadditive cases, we also derive an induction principle for quadruple tensors giving us dependent quadrilinear maps. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_ind_hprop_quad</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">P</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>)) -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">IsHProp</span> (<span class="id" title="var">P</span> <span class="id" title="var">x</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hin</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>, <span class="id" title="var">P</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>))))<br/>
&nbsp;&nbsp;(<span class="id" title="var">Hop</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span> -&gt; <span class="id" title="var">P</span> <span class="id" title="var">y</span> -&gt; <span class="id" title="var">P</span> (<span class="id" title="var">x</span> + <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">ab_tensor_prod_ind_hprop</span> <span class="id" title="var">P</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> (<span class="id" title="var">ab_tensor_prod_ind_hprop_triple</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">P</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">_</span> <span class="id" title="var">x</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">nrapply</span> <span class="id" title="var">Hin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">Hx</span> <span class="id" title="var">Hy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">Hop</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">Hop</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
To construct a homotopy between quadrilinear maps we need only check equality for the quadruple simple tensors. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_quad</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span> <span class="id" title="var">G</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> <span class="id" title="var">f'</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>)) $-&gt; <span class="id" title="var">G</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">H</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>, <span class="id" title="var">f</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>)))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">f'</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>))))<br/>
&nbsp;&nbsp;: <span class="id" title="var">f</span> $== <span class="id" title="var">f'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> (<span class="id" title="var">ab_tensor_prod_ind_hprop_quad</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> =&gt; <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">grp_homo_op_agree</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab119"></a><h2 class="section">Universal Property of the Tensor Product</h2>

<div class="paragraph"> </div>

 A function of two variables is biadditive if it preserves the operation in each variable. 
</div>
<div class="code">
<span class="id" title="keyword">Class</span> <span class="id" title="var">IsBiadditive</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} `{<span class="id" title="var">SgOp</span> <span class="id" title="var">A</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">B</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">C</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>) := {<br/>
&nbsp;&nbsp;<span class="id" title="var">isbiadditive_l</span> :: <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, <span class="id" title="var">IsSemiGroupPreserving</span> (<span class="id" title="var">flip</span> <span class="id" title="var">f</span> <span class="id" title="var">b</span>);<br/>
&nbsp;&nbsp;<span class="id" title="var">isbiadditive_r</span> :: <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsSemiGroupPreserving</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>);  <br/>
}.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">issig_IsBiadditive</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} `{<span class="id" title="var">SgOp</span> <span class="id" title="var">A</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">B</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">C</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">_</span> &lt;~&gt; <span class="id" title="var">IsBiadditive</span> <span class="id" title="var">f</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">issig</span>).<br/>

<br/>
</div>

<div class="doc">
The truncation level of the <span class="inlinecode"><span class="id" title="var">IsBiadditive</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> predicate is determined by the truncation level of the codomain. This will almost always be a hset. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">istrunc_isbiadditive</span> `{<span class="id" title="var">Funext</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} `{<span class="id" title="var">SgOp</span> <span class="id" title="var">A</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">B</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">C</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>) <span class="id" title="var">n</span> `{<span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">C</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsTrunc</span> <span class="id" title="var">n</span> (<span class="id" title="var">IsBiadditive</span> <span class="id" title="var">f</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">istrunc_equiv_istrunc</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="var">rapply</span> <span class="id" title="var">issig_IsBiadditive</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">IsSemiGroupPreserving</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The simple tensor map is biadditive. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">isbiadditive_tensor</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsBiadditive</span> (@<span class="id" title="var">tensor</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) := {|<br/>
&nbsp;&nbsp;<span class="id" title="var">isbiadditive_l</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> =&gt; <span class="id" title="var">tensor_dist_r</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">isbiadditive_r</span> := <span class="id" title="var">tensor_dist_l</span>;<br/>
|}.<br/>

<br/>
</div>

<div class="doc">
The type of biadditive maps. 
</div>
<div class="code">
<span class="id" title="keyword">Record</span> <span class="id" title="var">Biadditive</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>) `{<span class="id" title="var">SgOp</span> <span class="id" title="var">A</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">B</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">C</span>} := {<br/>
&nbsp;&nbsp;<span class="id" title="var">biadditive_fun</span> :&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">C</span>;<br/>
&nbsp;&nbsp;<span class="id" title="var">biadditive_isbiadditive</span> :: <span class="id" title="var">IsBiadditive</span> <span class="id" title="var">biadditive_fun</span>;<br/>
}.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">issig_Biadditive</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>} `{<span class="id" title="var">SgOp</span> <span class="id" title="var">A</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">B</span>, <span class="id" title="var">SgOp</span> <span class="id" title="var">C</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">_</span> &lt;~&gt; <span class="id" title="var">Biadditive</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;:= <span class="id" title="keyword">ltac</span>:(<span class="id" title="var">issig</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">biadditive_ab_tensor_prod</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;: (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>) -&gt; <span class="id" title="var">Biadditive</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exists</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">f</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_IsBiadditive</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">f</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">grp_homo_op</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">f</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">grp_homo_op</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The universal property of the tensor product is that biadditive maps between abelian groups are in one-to-one corresondance with maps out of the tensor product. In this sense, the tensor product is the most perfect object describing biadditive maps between two abelian groups. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_ab_tensor_prod_rec</span> `{<span class="id" title="var">Funext</span>} (<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">Biadditive</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> &lt;~&gt; (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">equiv_adjointify</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">f</span> [<span class="id" title="var">l</span> <span class="id" title="var">r</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">ab_tensor_prod_rec</span> <span class="id" title="var">f</span> <span class="id" title="var">r</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">l</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">biadditive_ab_tensor_prod</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">equiv_path_grouphomomorphism</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">f</span> [<span class="id" title="var">l</span> <span class="id" title="var">r</span>]].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> (<span class="id" title="var">equiv_ap_inv'</span> <span class="id" title="var">issig_Biadditive</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">path_sigma_hprop</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab120"></a><h2 class="section">Functoriality of the Tensor Product</h2>

<div class="paragraph"> </div>

 The tensor product produces a bifunctor and we will later show that it gives a symmetric monoidal structure on the category of abelian groups. 
<div class="paragraph"> </div>

 Given a pair of maps, we can produce a homomorphism between the pairwise tensor products of the domains and codomains. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">functor_ab_tensor_prod</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">A'</span> <span class="id" title="var">B'</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">A'</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">B'</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A'</span> <span class="id" title="var">B'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec'</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intro</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">grp_homo_tensor_l</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) $<span class="id" title="var">o</span> <span class="id" title="var">g</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">hnf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">grp_homo_op</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
2-functoriality of the tensor product. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">functor2_ab_tensor_prod</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">A'</span> <span class="id" title="var">B'</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">f</span> <span class="id" title="var">f'</span> : <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">A'</span>} (<span class="id" title="var">p</span> : <span class="id" title="var">f</span> $== <span class="id" title="var">f'</span>) {<span class="id" title="var">g</span> <span class="id" title="var">g'</span> : <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">B'</span>} (<span class="id" title="var">q</span> : <span class="id" title="var">g</span> $== <span class="id" title="var">g'</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">functor_ab_tensor_prod</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> $== <span class="id" title="var">functor_ab_tensor_prod</span> <span class="id" title="var">f'</span> <span class="id" title="var">g'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">ap011</span> <span class="id" title="var">tensor</span> (<span class="id" title="var">p</span> <span class="id" title="var">_</span>) (<span class="id" title="var">q</span> <span class="id" title="var">_</span>)).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The tensor product functor preserves identity morphisms. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">functor_ab_tensor_prod_id</span> (<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">functor_ab_tensor_prod</span> (<span class="id" title="var">Id</span> <span class="id" title="var">A</span>) (<span class="id" title="var">Id</span> <span class="id" title="var">B</span>) $== <span class="id" title="var">Id</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The tensor product functor preserves composition. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">functor_ab_tensor_prod_compose</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">A'</span> <span class="id" title="var">B'</span> <span class="id" title="var">C'</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">B</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>) (<span class="id" title="var">f'</span> : <span class="id" title="var">A'</span> $-&gt; <span class="id" title="var">B'</span>) (<span class="id" title="var">g'</span> : <span class="id" title="var">B'</span> $-&gt; <span class="id" title="var">C'</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">functor_ab_tensor_prod</span> (<span class="id" title="var">g</span> $<span class="id" title="var">o</span> <span class="id" title="var">f</span>) (<span class="id" title="var">g'</span> $<span class="id" title="var">o</span> <span class="id" title="var">f'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;$== <span class="id" title="var">functor_ab_tensor_prod</span> <span class="id" title="var">g</span> <span class="id" title="var">g'</span> $<span class="id" title="var">o</span> <span class="id" title="var">functor_ab_tensor_prod</span> <span class="id" title="var">f</span> <span class="id" title="var">f'</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The tensor product functor is a 0-bifunctor. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is0bifunctor_ab_tensor_prod</span> : <span class="id" title="var">Is0Bifunctor</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">Build_Is0Bifunctor'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_Is0Functor</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">A</span> <span class="id" title="var">B</span>] [<span class="id" title="var">A'</span> <span class="id" title="var">B'</span>] [<span class="id" title="var">f</span> <span class="id" title="var">g</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">functor_ab_tensor_prod</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The tensor product functor is a bifunctor. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">is1bifunctor_ab_tensor_prod</span> : <span class="id" title="var">Is1Bifunctor</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">Build_Is1Bifunctor'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_Is1Functor</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">AB</span> <span class="id" title="var">A'B'</span> <span class="id" title="var">fg</span> <span class="id" title="var">f'g'</span> [<span class="id" title="var">p</span> <span class="id" title="var">q</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">functor2_ab_tensor_prod</span> <span class="id" title="var">p</span> <span class="id" title="var">q</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> [<span class="id" title="var">A</span> <span class="id" title="var">B</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">functor_ab_tensor_prod_id</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">AA'</span> <span class="id" title="var">BB'</span> <span class="id" title="var">CC'</span> [<span class="id" title="var">f</span> <span class="id" title="var">g</span>] [<span class="id" title="var">f'</span> <span class="id" title="var">g'</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">functor_ab_tensor_prod_compose</span> <span class="id" title="var">f</span> <span class="id" title="var">f'</span> <span class="id" title="var">g</span> <span class="id" title="var">g'</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab121"></a><h2 class="section">Symmetry of the Tensor Product</h2>

<div class="paragraph"> </div>

 The tensor product is symmetric in that the order in which we take the tensor shouldn't matter upto isomorphism. 
<div class="paragraph"> </div>

 We can define a swap map which swaps the order of simple tensors. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_swap</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> (<span class="id" title="var">flip</span> <span class="id" title="var">tensor</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">ab_tensor_swap</span></span> is involutive. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_swap_swap</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_swap</span> $<span class="id" title="var">o</span> @<span class="id" title="var">ab_tensor_swap</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> $== <span class="id" title="var">Id</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">ab_tensor_swap</span></span> is natural in both arguments. This means that it also acts on tensor functors. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_swap_natural</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">A'</span> <span class="id" title="var">B'</span>} (<span class="id" title="var">f</span> : <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">A'</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">B'</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_swap</span> $<span class="id" title="var">o</span> <span class="id" title="var">functor_ab_tensor_prod</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;$== <span class="id" title="var">functor_ab_tensor_prod</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> $<span class="id" title="var">o</span> <span class="id" title="var">ab_tensor_swap</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="comment">(*&nbsp;This&nbsp;speeds&nbsp;up&nbsp;the&nbsp;<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>&nbsp;and&nbsp;the&nbsp;<span class="inlinecode"><span class="id" title="keyword">Defined</span></span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The swap map gives us a symmetric braiding on the category of abelian groups. We will later show it is a full symmetric monoidal category. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">symmetricbraiding_ab_tensor_prod</span> : <span class="id" title="var">SymmetricBraiding</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_SymmetricBraiding</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">Build_NatTrans</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intro</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">ab_tensor_swap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">snrapply</span> <span class="id" title="var">Build_Is1Natural</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span>; <span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_swap_natural</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>; <span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_swap_swap</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab122"></a><h2 class="section">Twisting Triple Tensors</h2>

<div class="paragraph"> </div>

 In order to construct the symmetric monoidal category, we will use what is termed the "Twist construction" in Monoidal.v. This simplifies the data of a symmetric monoidal category by constructing it from simpler parts. For instance, instead of having to prove full associativity <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">C</span></span> <span class="inlinecode">$-&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span>, we can provide a twist map <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span> <span class="inlinecode">$-&gt;</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">⊗</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span> and use the symmetric braiding we have so far to prove associativity. 
<div class="paragraph"> </div>

 In order to be more efficient whilst unfolding definitions, we break up the definition of a twist map into its components. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Local Definition</span> <span class="id" title="var">ab_tensor_prod_twist_map</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> $-&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">C</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec'</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">b</span> $<span class="id" title="var">o</span> <span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">a</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">b'</span> <span class="id" title="var">c</span>; <span class="id" title="tactic">hnf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Local Definition</span> <span class="id" title="var">ab_tensor_prod_twist_map_additive_l</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">a</span> <span class="id" title="var">a'</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod_twist_map</span> (<span class="id" title="var">a</span> + <span class="id" title="var">a'</span>) <span class="id" title="var">b</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">ab_tensor_prod_twist_map</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> + <span class="id" title="var">ab_tensor_prod_twist_map</span> <span class="id" title="var">a'</span> <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_plus</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span> (<span class="id" title="var">tensor</span> (<span class="id" title="var">a</span> + <span class="id" title="var">a'</span>) <span class="id" title="var">c</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;= <span class="id" title="var">tensor</span> <span class="id" title="var">b</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">c</span>) + <span class="id" title="var">tensor</span> <span class="id" title="var">b</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a'</span> <span class="id" title="var">c</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">rhs_V</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> (<span class="id" title="var">ap</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">b</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Given a triple tensor product, we have a twist map which permutes the first two components. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_twist</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>) $-&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">C</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec'</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">ab_tensor_prod_twist_map</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> <span class="id" title="var">ab_tensor_prod_twist_map_additive_l</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The twist map is involutive. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_twist_twist</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod_twist</span> $<span class="id" title="var">o</span> @<span class="id" title="var">ab_tensor_prod_twist</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> $== <span class="id" title="var">Id</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_triple</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The twist map is natural in all 3 arguments. This means that the twist map acts on the triple tensor functor in the same way. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_twist_natural</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">A'</span> <span class="id" title="var">B'</span> <span class="id" title="var">C'</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">f</span> : <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">A'</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">B'</span>) (<span class="id" title="var">h</span> : <span class="id" title="var">C</span> $-&gt; <span class="id" title="var">C'</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod_twist</span> $<span class="id" title="var">o</span> <span class="id" title="var">fmap11</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">f</span> (<span class="id" title="var">fmap11</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;$== <span class="id" title="var">fmap11</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">g</span> (<span class="id" title="var">fmap11</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">f</span> <span class="id" title="var">h</span>) $<span class="id" title="var">o</span> <span class="id" title="var">ab_tensor_prod_twist</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_triple</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;This&nbsp;<span class="inlinecode"><span class="id" title="tactic">change</span></span>&nbsp;speeds&nbsp;up&nbsp;the&nbsp;<span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span>.&nbsp;&nbsp;<span class="inlinecode"><span class="id" title="tactic">simpl</span></span>&nbsp;produces&nbsp;a&nbsp;goal&nbsp;that&nbsp;looks&nbsp;the&nbsp;same,&nbsp;but&nbsp;is&nbsp;still&nbsp;slow.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">tensor</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) (<span class="id" title="var">tensor</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<span class="id" title="var">h</span> <span class="id" title="var">c</span>)) = <span class="id" title="var">tensor</span> (<span class="id" title="var">g</span> <span class="id" title="var">b</span>) (<span class="id" title="var">tensor</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) (<span class="id" title="var">h</span> <span class="id" title="var">c</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab123"></a><h2 class="section">Unitality of <span class="inlinecode"><span class="id" title="var">abgroup_Z</span></span></h2>

<div class="paragraph"> </div>

 In the symmetric monoidal structure on abelian groups, <span class="inlinecode"><span class="id" title="var">abgroup_Z</span></span> is the unit. We show that tensoring with <span class="inlinecode"><span class="id" title="var">abgroup_Z</span></span> on the right is isomorphic to the original group. 
<div class="paragraph"> </div>

 First we characterise the action of integers via <span class="inlinecode"><span class="id" title="var">grp_pow</span></span> and their interaction on tensors. This is just a generalisation of the distributivity laws for tensors. 
<div class="paragraph"> </div>

 Multiplication in the first factor can be factored out. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_ab_mul_l</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">z</span> : <span class="id" title="var">Int</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> (<span class="id" title="var">ab_mul</span> <span class="id" title="var">z</span> <span class="id" title="var">a</span>) <span class="id" title="var">b</span> = <span class="id" title="var">ab_mul</span> <span class="id" title="var">z</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">ab_mul_natural</span> (<span class="id" title="var">grp_homo_tensor_r</span> <span class="id" title="var">b</span>) <span class="id" title="var">z</span> <span class="id" title="var">a</span>.<br/>

<br/>
</div>

<div class="doc">
Multiplication in the second factor can be factored out. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_ab_mul_r</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">z</span> : <span class="id" title="var">Int</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">ab_mul</span> <span class="id" title="var">z</span> <span class="id" title="var">b</span>) = <span class="id" title="var">ab_mul</span> <span class="id" title="var">z</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)<br/>
&nbsp;&nbsp;:= <span class="id" title="var">ab_mul_natural</span> (<span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">a</span>) <span class="id" title="var">z</span> <span class="id" title="var">b</span>.<br/>

<br/>
</div>

<div class="doc">
Multiplication can be transferred from one factor to the other. The tensor product of <span class="inlinecode"><span class="id" title="var">R</span></span>-modules will include this as an extra axiom, but here we have <span class="inlinecode"><span class="id" title="var">Z</span></span>-modules and we can prove it. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tensor_ab_mul</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="var">AbGroup</span>} (<span class="id" title="var">z</span> : <span class="id" title="var">Int</span>) (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">b</span> : <span class="id" title="var">B</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">tensor</span> (<span class="id" title="var">ab_mul</span> <span class="id" title="var">z</span> <span class="id" title="var">a</span>) <span class="id" title="var">b</span> = <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">ab_mul</span> <span class="id" title="var">z</span> <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_ab_mul_r</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_ab_mul_l</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">abgroup_Z</span></span> is a right identity for the tensor product. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_Z_r</span> {<span class="id" title="var">A</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">abgroup_Z</span> $&lt;~&gt; <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">
Checking that the inverse map is a homomorphism is easier. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_GroupIsomorphism</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">nrapply</span> <span class="id" title="var">grp_homo_tensor_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> 1%<span class="id" title="var">int</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">isequiv_adjointify</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">exact</span> <span class="id" title="var">grp_pow_homo</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">z</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> (<span class="id" title="var">grp_homo_op</span> (<span class="id" title="var">ab_mul</span> <span class="id" title="var">z</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">hnf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> : ?<span class="id" title="var">A</span>, (<span class="id" title="var">grp_homo_map</span> ?<span class="id" title="var">f</span>) ((<span class="id" title="var">grp_homo_map</span> ?<span class="id" title="var">g</span>) <span class="id" title="var">x</span>) = <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">with</span> (<span class="id" title="var">f</span> $<span class="id" title="var">o</span> <span class="id" title="var">g</span> $== <span class="id" title="var">Id</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">tensor</span> (<span class="id" title="var">B</span>:=<span class="id" title="var">abgroup_Z</span>) (<span class="id" title="var">grp_pow</span> <span class="id" title="var">a</span> <span class="id" title="var">z</span>) 1%<span class="id" title="var">int</span> = <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">z</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_ab_mul</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">abgroup_Z_ab_mul</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">int_mul_1_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> <span class="id" title="var">grp_unit_r</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We have a right unitor for the tensor product given by unit <span class="inlinecode"><span class="id" title="var">abgroup_Z</span></span>. Naturality of <span class="inlinecode"><span class="id" title="var">ab_tensor_prod_Z_r</span></span> is straightforward to prove. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">rightunitor_ab_tensor_prod</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">RightUnitor</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">abgroup_Z</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_NatEquiv</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">ab_tensor_prod_Z_r</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">Build_Is1Natural</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">A'</span> <span class="id" title="var">f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">grp_pow</span> (<span class="id" title="var">f</span> <span class="id" title="var">a</span>) <span class="id" title="var">z</span> = <span class="id" title="var">f</span> (<span class="id" title="var">grp_pow</span> <span class="id" title="var">a</span> <span class="id" title="var">z</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">grp_pow_natural</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)^.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Since we have symmetry of the tensor product, we get left unitality for free. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">left_unitor_ab_tensor_prod</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">LeftUnitor</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">abgroup_Z</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">left_unitor_twist</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab124"></a><h2 class="section">Symmetric Monoidal Structure of Tensor Product</h2>

<div class="paragraph"> </div>

 Using the twist construction we can derive an associator for the tensor product. In other words, we have associativity of the tensor product of abelian groups natural in each factor. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">associator_ab_tensor_prod</span> : <span class="id" title="var">Associator</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">associator_twist</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">exact</span> @<span class="id" title="var">ab_tensor_prod_twist</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>; <span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_prod_twist_twist</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intros</span>; <span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_prod_twist_natural</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The triangle identity is straightforward to prove using the custom induction principles we proved earlier. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">triangle_ab_tensor_prod</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">TriangleIdentity</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">abgroup_Z</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">triangle_twist</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_triple</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">tensor_ab_mul</span> <span class="id" title="var">z</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)^.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The hexagon identity is also straighforward to prove. We simply have to reduce all the involved functions on the simple tensors using our custom triple tensor induction principle. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">hexagon_ab_tensor_prod</span> : <span class="id" title="var">HexagonIdentity</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">hexagon_twist</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_triple</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span> <span class="id" title="var">a</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">c</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) = <span class="id" title="var">tensor</span> <span class="id" title="var">c</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Finally, we can prove the pentagon identity using the quadruple tensor induction principle. As we did before, the work only involves reducing the involved functions on the simple tensor redexes. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">pentagon_ab_tensor_prod</span> : <span class="id" title="var">PentagonIdentity</span> <span class="id" title="var">ab_tensor_prod</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">pentagon_twist</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> <span class="id" title="var">D</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy_quad</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span> <span class="id" title="var">d</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">c</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">d</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>)) = <span class="id" title="var">tensor</span> <span class="id" title="var">c</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">d</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
We therefore have all the data of a monoidal category. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">ismonoidal_ab_tensor_prod</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">IsMonoidal</span> <span class="id" title="var">AbGroup</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">abgroup_Z</span><br/>
&nbsp;&nbsp;:= {}.<br/>

<br/>
</div>

<div class="doc">
And furthermore, all the data of a symmetric monoidal category. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">issymmmetricmonoidal_ab_tensor_prod</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">IsSymmetricMonoidal</span> <span class="id" title="var">AbGroup</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">abgroup_Z</span><br/>
&nbsp;&nbsp;:= {}.<br/>

<br/>
</div>

<div class="doc">
<a id="lab125"></a><h2 class="section">Preservation of Coequalizers</h2>

<div class="paragraph"> </div>

 The tensor product of abelian groups preserves coequalizers, meaning that the coequalizer of two tensored groups is the tensor of the coequalizer. We show this is the case on the left and the right. 
<div class="paragraph"> </div>

 Tensor products preserve coequalizers on the right. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">grp_iso_ab_tensor_prod_coeq_l</span> <span class="id" title="var">A</span> {<span class="id" title="var">B</span> <span class="id" title="var">C</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_coeq</span> (<span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span>) (<span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;$&lt;~&gt; <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> (<span class="id" title="var">ab_coeq</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">cate_adjointify</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_coeq_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">ab_coeq_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span>^$ $@ <span class="id" title="var">fmap02</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> $@ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,3: <span class="id" title="var">rapply</span> <span class="id" title="var">fmap01_comp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">ab_coeq_glue</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">functor_ab_coeq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,2: <span class="id" title="var">snrapply</span> (<span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,2: <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">ab_coeq_ind_hprop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">ap</span> (<span class="id" title="var">ab_coeq_in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">f</span>:=<span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">g</span>:=<span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">g</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">tensor_dist_r</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">x</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">ab_coeq_ind_hprop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">c</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_coeq_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The equivalence respects the natural maps from <span class="inlinecode"><span class="id" title="var">ab_tensor_prod</span></span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_coeq_l_triangle</span> <span class="id" title="var">A</span> {<span class="id" title="var">B</span> <span class="id" title="var">C</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">B</span> $-&gt; <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">grp_iso_ab_tensor_prod_coeq_l</span> <span class="id" title="var">A</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> $<span class="id" title="var">o</span> <span class="id" title="var">ab_coeq_in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;$== <span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">ab_coeq_in</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Tensor products preserve coequalizers on the left. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">grp_iso_ab_tensor_prod_coeq_r</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">B</span>) <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_coeq</span> (<span class="id" title="var">fmap10</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">f</span> <span class="id" title="var">C</span>) (<span class="id" title="var">fmap10</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">g</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;$&lt;~&gt; <span class="id" title="var">ab_tensor_prod</span> (<span class="id" title="var">ab_coeq</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span>) <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">braide</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> $<span class="id" title="var">oE</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">nrefine</span> (<span class="id" title="var">grp_iso_ab_tensor_prod_coeq_l</span> <span class="id" title="var">_</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> $<span class="id" title="var">oE</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">grp_iso_ab_coeq</span>.<br/>
&nbsp;&nbsp;1,2: <span class="id" title="var">rapply</span> <span class="id" title="var">braide</span>.<br/>
&nbsp;&nbsp;1,2: <span class="id" title="tactic">symmetry</span>; <span class="id" title="var">nrapply</span> <span class="id" title="var">ab_tensor_swap_natural</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The equivalence respects the natural maps from <span class="inlinecode"><span class="id" title="var">ab_tensor_prod</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">C</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_coeq_r_triangle</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span>} (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">A</span> $-&gt; <span class="id" title="var">B</span>) <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">grp_iso_ab_tensor_prod_coeq_r</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">C</span> $<span class="id" title="var">o</span> <span class="id" title="var">ab_coeq_in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;$== <span class="id" title="var">fmap10</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">ab_coeq_in</span> <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab126"></a><h2 class="section">Tensor Product of Free Abelian Groups</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_ab_tensor_prod_freeabgroup</span> <span class="id" title="var">X</span> <span class="id" title="var">Y</span><br/>
&nbsp;&nbsp;: <span class="id" title="var">FreeAbGroup</span> (<span class="id" title="var">X</span> * <span class="id" title="var">Y</span>) $&lt;~&gt; <span class="id" title="var">ab_tensor_prod</span> (<span class="id" title="var">FreeAbGroup</span> <span class="id" title="var">X</span>) (<span class="id" title="var">FreeAbGroup</span> <span class="id" title="var">Y</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srefine</span> (<span class="id" title="keyword">let</span> <span class="id" title="var">f</span>:=<span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <span class="id" title="keyword">let</span> <span class="id" title="var">g</span>:=<span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <span class="id" title="var">cate_adjointify</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">FreeAbGroup_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [<span class="id" title="var">x</span> <span class="id" title="var">y</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">tensor</span> (<span class="id" title="var">freeabgroup_in</span> <span class="id" title="var">x</span>) (<span class="id" title="var">freeabgroup_in</span> <span class="id" title="var">y</span>)).<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">FreeAbGroup_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">FreeAbGroup</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">FreeAbGroup_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">abel_unit</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">freegroup_in</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">x</span>, <span class="id" title="var">y</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">y'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">grp_homo_op</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">x'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">Abel_ind_hprop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> (<span class="id" title="var">FreeGroup_ind_homotopy</span> <span class="id" title="var">_</span> (<span class="id" title="var">f'</span> := <span class="id" title="var">ab_homo_add</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">FreeGroup_rec_beta</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">grp_homo_op</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> (<span class="id" title="var">ap011</span> (+) <span class="id" title="var">_</span>^ <span class="id" title="var">_</span>^).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1,2: <span class="id" title="var">nrapply</span> <span class="id" title="var">FreeGroup_rec_beta</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">f</span> $<span class="id" title="var">o</span> <span class="id" title="var">g</span> $<span class="id" title="var">o</span> <span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">x</span> $== <span class="id" title="var">grp_homo_tensor_l</span> <span class="id" title="var">x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">Abel_ind_hprop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (@<span class="id" title="var">abel_in</span> ?<span class="id" title="var">G</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">grp_homo_map</span> (@<span class="id" title="var">abel_unit</span> <span class="id" title="var">G</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">change</span> (<span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">AbGroup</span>) ?<span class="id" title="var">f</span> ?<span class="id" title="var">g</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) <span class="id" title="var">f</span> <span class="id" title="var">g</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span>, <span class="id" title="var">grp_homo_map</span> ?<span class="id" title="var">f</span> (<span class="id" title="var">abel_unit</span> <span class="id" title="var">y</span>) = <span class="id" title="var">grp_homo_map</span> ?<span class="id" title="var">g</span> (<span class="id" title="var">abel_unit</span> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">with</span> (<span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) <span class="id" title="var">f</span> <span class="id" title="var">abel_unit</span> $== <span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) <span class="id" title="var">g</span> <span class="id" title="var">abel_unit</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">FreeGroup_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">y</span>; <span class="id" title="var">revert</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">f</span> $<span class="id" title="var">o</span> <span class="id" title="var">g</span> $<span class="id" title="var">o</span> <span class="id" title="var">grp_homo_tensor_r</span> (<span class="id" title="var">freeabgroup_in</span> <span class="id" title="var">y</span>) $== <span class="id" title="var">grp_homo_tensor_r</span> (<span class="id" title="var">freeabgroup_in</span> <span class="id" title="var">y</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">Abel_ind_hprop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (@<span class="id" title="var">abel_in</span> ?<span class="id" title="var">G</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">grp_homo_map</span> (@<span class="id" title="var">abel_unit</span> <span class="id" title="var">G</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">repeat</span> <span class="id" title="tactic">change</span> (<span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">AbGroup</span>) ?<span class="id" title="var">f</span> ?<span class="id" title="var">g</span>) <span class="id" title="keyword">with</span> (<span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) <span class="id" title="var">f</span> <span class="id" title="var">g</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="keyword">forall</span> <span class="id" title="var">y</span>, <span class="id" title="var">grp_homo_map</span> ?<span class="id" title="var">f</span> (<span class="id" title="var">abel_unit</span> <span class="id" title="var">y</span>) = <span class="id" title="var">grp_homo_map</span> ?<span class="id" title="var">g</span> (<span class="id" title="var">abel_unit</span> <span class="id" title="var">y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">with</span> (<span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) <span class="id" title="var">f</span> <span class="id" title="var">abel_unit</span> $== <span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) <span class="id" title="var">g</span> <span class="id" title="var">abel_unit</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">FreeGroup_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">rapply</span> <span class="id" title="var">Abel_ind_hprop</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">change</span> (<span class="id" title="var">GpdHom</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Hom</span>(<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) (<span class="id" title="var">FreeGroup</span> (<span class="id" title="var">X</span> * <span class="id" title="var">Y</span>)) <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">cat_comp</span> (<span class="id" title="var">A</span>:=<span class="id" title="var">Group</span>) (<span class="id" title="var">g</span> $<span class="id" title="var">o</span> <span class="id" title="var">f</span>) (@<span class="id" title="var">abel_unit</span> (<span class="id" title="var">FreeGroup</span> (<span class="id" title="var">X</span> * <span class="id" title="var">Y</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(@<span class="id" title="var">abel_unit</span> (<span class="id" title="var">FreeGroup</span> (<span class="id" title="var">X</span> * <span class="id" title="var">Y</span>)))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">FreeGroup_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab127"></a><h2 class="section">Tensor products distribute over direct sums</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_dist_l</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> (<span class="id" title="var">ab_biprod</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;$&lt;~&gt; <span class="id" title="var">ab_biprod</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">C</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> (<span class="id" title="keyword">let</span> <span class="id" title="var">f</span> := <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <span class="id" title="keyword">let</span> <span class="id" title="var">g</span> := <span class="id" title="var">_</span> <span class="id" title="tactic">in</span> <span class="id" title="var">cate_adjointify</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">bc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">fst</span> <span class="id" title="var">bc</span>), <span class="id" title="var">tensor</span> <span class="id" title="var">a</span> (<span class="id" title="var">snd</span> <span class="id" title="var">bc</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">bc</span> <span class="id" title="var">bc'</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">path_prod'</span>; <span class="id" title="var">snrapply</span> <span class="id" title="var">tensor_dist_l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">a'</span> <span class="id" title="var">bc</span>; <span class="id" title="var">cbn</span> <span class="id" title="keyword">beta</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">path_prod</span>; <span class="id" title="var">snrapply</span> <span class="id" title="var">tensor_dist_r</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_biprod_rec</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">ab_biprod_inl</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">fmap01</span> <span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">ab_biprod_inr</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_biprod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">refine</span> (<span class="id" title="var">cat_assoc</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> $@ (<span class="id" title="var">_</span> $@<span class="id" title="var">L</span> <span class="id" title="var">_</span>) $@ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_biprod_rec_beta_inl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">path_prod</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="var">snrapply</span> <span class="id" title="var">tensor_zero_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">refine</span> (<span class="id" title="var">cat_assoc</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> $@ (<span class="id" title="var">_</span> $@<span class="id" title="var">L</span> <span class="id" title="var">_</span>) $@ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_biprod_rec_beta_inr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">path_prod</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="var">snrapply</span> <span class="id" title="var">tensor_zero_r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_ind_homotopy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> [<span class="id" title="var">b</span> <span class="id" title="var">c</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs_V</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">tensor_dist_l</span>; <span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">grp_prod_decompose</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">ab_tensor_prod_dist_r</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="var">AbGroup</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">ab_tensor_prod</span> (<span class="id" title="var">ab_biprod</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>) <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;$&lt;~&gt; <span class="id" title="var">ab_biprod</span> (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">A</span> <span class="id" title="var">C</span>) (<span class="id" title="var">ab_tensor_prod</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">emap11</span> <span class="id" title="var">ab_biprod</span> (<span class="id" title="var">braide</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<span class="id" title="var">braide</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;$<span class="id" title="var">oE</span> <span class="id" title="var">_</span> $<span class="id" title="var">oE</span> <span class="id" title="var">braide</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">ab_tensor_prod_dist_l</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
TODO: Show that the category of abelian groups is symmetric closed and therefore we have adjoint pair with the tensor and internal hom. This should allow us to prove lemmas such as tensors distributing over coproducts. 
</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>