<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>Hopf</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library Hopf</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="keyword">Types</span> <span class="id" title="var">Basics</span> <span class="id" title="var">Pointed</span> <span class="id" title="var">Truncations</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">HSpace</span> <span class="id" title="var">Suspension</span> <span class="id" title="var">ExactSequence</span> <span class="id" title="var">HomotopyGroup</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">WildCat.Core</span> <span class="id" title="var">WildCat.Universe</span> <span class="id" title="var">WildCat.Equiv</span> <span class="id" title="var">Modalities.ReflectiveSubuniverse</span> <span class="id" title="var">Modalities.Descent</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">HSet</span> <span class="id" title="var">Spaces.Nat.Core</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Homotopy.Join</span> <span class="id" title="var">Colimits.Pushout</span>.<br/>

<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">pointed_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">trunc_scope</span>.<br/>
<span class="id" title="keyword">Local Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">mc_mult_scope</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1126"></a><h1 class="section">The Hopf construction</h1>

<div class="paragraph"> </div>

 We define the Hopf construction associated to a left-invertible H-space, and use it to prove that H-spaces satisfy a strengthened version of Freudenthal's theorem (see <span class="inlinecode"><span class="id" title="var">freudenthal_hspace</span></span> below). 
<div class="paragraph"> </div>

 The Hopf construction associated to a left-invertible H-space (Definition 8.5.6 in the HoTT book). 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hopf_construction</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>} `{<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">a</span> *.)}<br/>
&nbsp;&nbsp;: <span class="id" title="var">pFam</span> (<span class="id" title="var">psusp</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">Build_pFam</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> (<span class="id" title="var">Susp_rec</span> (<span class="id" title="var">Y</span>:=<span class="id" title="keyword">Type</span>) <span class="id" title="var">X</span> <span class="id" title="var">X</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">path_universe</span> (<span class="id" title="var">x</span> *.)).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">exact</span> <span class="id" title="var">pt</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1127"></a><h3 class="section">Total space of the Hopf construction</h3>

<div class="paragraph"> </div>

 The total space of the Hopf construction on <span class="inlinecode"><span class="id" title="var">Susp</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> is the join of <span class="inlinecode"><span class="id" title="var">X</span></span> with itself. Note that we need both left and right multiplication to be equivalences. This is true when <span class="inlinecode"><span class="id" title="var">X</span></span> is a 0-connected H-space for example. (This is lemma 8.5.7 in the HoTT book). 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_hopf_total_join</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>} `{<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">a</span> *.)} `{<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsEquiv</span> (.* <span class="id" title="var">a</span>)}<br/>
&nbsp;&nbsp;: <span class="id" title="var">psigma</span> (<span class="id" title="var">hopf_construction</span> <span class="id" title="var">X</span>) &lt;~&gt;* <span class="id" title="var">pjoin</span> <span class="id" title="var">X</span> <span class="id" title="var">X</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_pEquiv'</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <span class="id" title="var">oE</span> <span class="id" title="var">equiv_pushout_flatten</span> (<span class="id" title="var">f</span> := <span class="id" title="var">const_tt</span> <span class="id" title="var">X</span>) (<span class="id" title="var">g</span> := <span class="id" title="var">const_tt</span> <span class="id" title="var">X</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Unit_ind</span> (<span class="id" title="var">pointed_type</span> <span class="id" title="var">X</span>)) (<span class="id" title="var">Unit_ind</span> (<span class="id" title="var">pointed_type</span> <span class="id" title="var">X</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> =&gt; <span class="id" title="var">Build_Equiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">x</span> *.) (<span class="id" title="var">H1</span> <span class="id" title="var">x</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">equiv_pushout</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;equivalence&nbsp;<span class="inlinecode">{<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">&amp;</span> <span class="inlinecode"><span class="id" title="var">X</span>}</span> <span class="inlinecode">&lt;~&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">*</span> <span class="inlinecode"><span class="id" title="var">X</span></span>&nbsp;that&nbsp;we&nbsp;need&nbsp;sends&nbsp;<span class="inlinecode">(<span class="id" title="var">x</span>;</span> <span class="inlinecode"><span class="id" title="var">y</span>)</span> <span class="inlinecode"><span class="id" title="var">to</span></span> <span class="inlinecode">(<span class="id" title="var">y</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span>*<span class="id" title="var">y</span>)</span>.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">cbn</span>. <span class="id" title="tactic">refine</span> (<span class="id" title="var">equiv_sigma_prod0</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">oE</span> <span class="id" title="var">_</span> <span class="id" title="var">oE</span> <span class="id" title="var">equiv_sigma_symm0</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">equiv_functor_sigma_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">Build_Equiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (.* <span class="id" title="var">x</span>) <span class="id" title="var">_</span>). }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1,2: <span class="id" title="var">rapply</span> (<span class="id" title="var">equiv_contr_sigma</span> (<span class="id" title="var">Unit_ind</span> (<span class="id" title="var">pointed_type</span> <span class="id" title="var">X</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1,2: <span class="id" title="tactic">reflexivity</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab1128"></a><h2 class="section">Miscellaneous lemmas and corollaries about the Hopf construction</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">transport_hopf_construction</span> `{<span class="id" title="var">Univalence</span>} {<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>}<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>} `{<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">a</span> *.)}<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">X</span>, <span class="id" title="var">transport</span> (<span class="id" title="var">hopf_construction</span> <span class="id" title="var">X</span>) (<span class="id" title="var">merid</span> <span class="id" title="var">x</span>) <span class="id" title="var">y</span> = <span class="id" title="var">x</span> * <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">transport_to_ap</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ap</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> =&gt; <span class="id" title="var">transport</span> <span class="id" title="var">idmap</span> <span class="id" title="var">z</span> <span class="id" title="var">y</span>) <span class="id" title="var">_</span> @ <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">apply</span> <span class="id" title="var">Susp_rec_beta_merid</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">transport_path_universe</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
The connecting map associated to the Hopf construction of <span class="inlinecode"><span class="id" title="var">X</span></span> is a retraction of <span class="inlinecode"><span class="id" title="var">loop_susp_unit</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> (Proposition 2.19 in https://arxiv.org/abs/2301.02636v1). 
</div>
<div class="code">
<span class="id" title="keyword">Proposition</span> <span class="id" title="var">hopf_retraction</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>} `{<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">a</span> *.)}<br/>
&nbsp;&nbsp;: <span class="id" title="var">connecting_map_family</span> (<span class="id" title="var">hopf_construction</span> <span class="id" title="var">X</span>) <span class="id" title="var">o</span>* <span class="id" title="var">loop_susp_unit</span> <span class="id" title="var">X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;==* <span class="id" title="var">pmap_idmap</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">hspace_phomotopy_from_homotopy</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="var">cbn</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">transport_pp</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> @ <span class="id" title="var">_</span>); <span class="id" title="tactic">unfold</span> <span class="id" title="var">dpoint</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">moveR_transport_V</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">transport_hopf_construction</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@ <span class="id" title="var">_</span> @ (<span class="id" title="var">transport_hopf_construction</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)^).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">right_identity</span> <span class="id" title="var">_</span> @ (<span class="id" title="var">left_identity</span> <span class="id" title="var">_</span>)^).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
It follows from <span class="inlinecode"><span class="id" title="var">hopf_retraction</span></span> and Freudenthal's theorem that <span class="inlinecode"><span class="id" title="var">loop_susp_unit</span></span> induces an equivalence on <span class="inlinecode"><span class="id" title="var">Pi</span></span> <span class="inlinecode">(2<span class="id" title="var">n</span>+1)</span> for <span class="inlinecode"><span class="id" title="var">n</span></span>-connected H-spaces (with n &gt;= 0). Note that <span class="inlinecode"><span class="id" title="var">X</span></span> is automatically left-invertible. 
</div>
<div class="code">
<span class="id" title="keyword">Proposition</span> <span class="id" title="var">isequiv_Pi_connected_hspace</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span> <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pPi</span> (<span class="id" title="var">n</span> + <span class="id" title="var">n</span>).+1) (<span class="id" title="var">loop_susp_unit</span> <span class="id" title="var">X</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">isequiv_surj_emb</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">issurj_pi_connmap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> (<span class="id" title="var">conn_map_loop_susp_unit</span> (-1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">trunc_index_add_nat_add</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span> (<span class="id" title="var">conn_map_loop_susp_unit</span>).<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">pose</span> (<span class="id" title="var">is0connected_isconnected</span> <span class="id" title="var">n</span>.-2 <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">isembedding_pi_psect</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">hopf_retraction</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
By Freudenthal, <span class="inlinecode"><span class="id" title="var">loop_susp_unit</span></span> induces an equivalence on lower homotopy groups as well, so it is a (2n+1)-equivalence.  We formalize it below with <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>-1</span>, and allow <span class="inlinecode"><span class="id" title="var">n</span></span> to start at <span class="inlinecode">-1</span>.  We prove it using a more general result about reflective subuniverses, <span class="inlinecode"><span class="id" title="var">OO_inverts_conn_map_factor_conn_map</span></span>, but one could also use homotopy groups and the truncated Whitehead theorem. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">freudenthal_hspace'</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">m</span> : <span class="id" title="var">trunc_index</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span>.+1 <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>} `{<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">IsEquiv</span> (<span class="id" title="var">a</span> *.)}<br/>
&nbsp;&nbsp;: <span class="id" title="var">O_inverts</span> (<span class="id" title="var">Tr</span> (<span class="id" title="var">m</span> +2+ <span class="id" title="var">m</span>).+1) (<span class="id" title="var">loop_susp_unit</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">r</span>:=<span class="id" title="var">connecting_map_family</span> (<span class="id" title="var">hopf_construction</span> <span class="id" title="var">X</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> (<span class="id" title="var">OO_inverts_conn_map_factor_conn_map</span> <span class="id" title="var">_</span> (<span class="id" title="var">m</span> +2+ <span class="id" title="var">m</span>) <span class="id" title="var">_</span> <span class="id" title="var">r</span>).<br/>
&nbsp;&nbsp;2, 4: <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="tactic">apply</span> <span class="id" title="var">O_lex_leq_Tr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">conn_map_homotopic</span> <span class="id" title="var">_</span> <span class="id" title="var">equiv_idmap</span> (<span class="id" title="var">r</span> <span class="id" title="var">o</span> <span class="id" title="var">loop_susp_unit</span> <span class="id" title="var">X</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">symmetry</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">hopf_retraction</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Note that we don't really need the assumption that <span class="inlinecode"><span class="id" title="var">X</span></span> is left-invertible in the previous result; for <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode">-1</span>, it follows from connectivity.  And for <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-2</span>, the conclusion is trivial. Here we state the version for <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&gt;=</span> <span class="inlinecode">-1</span> without left-invertibility. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">freudenthal_hspace</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">m</span> : <span class="id" title="var">trunc_index</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span>.+2 <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;`{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">O_inverts</span> (<span class="id" title="var">Tr</span> (<span class="id" title="var">m</span>.+1 +2+ <span class="id" title="var">m</span>.+1).+1) (<span class="id" title="var">loop_susp_unit</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">is0connected_isconnected</span> <span class="id" title="var">m</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">freudenthal_hspace'</span> (<span class="id" title="var">m</span>:=<span class="id" title="var">m</span>.+1) <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Here we give a generalization of a result from Eilenberg-MacLane Spaces in Homotopy Type Theory, Dan Licata and Eric Finster.  Their version corresponds to <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode">-2</span> in our version.  Their encode-decode proof was formalized in this library in EMSpace.v until this shorter and more general approach was found. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">licata_finster</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">m</span> : <span class="id" title="var">trunc_index</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">m</span>.+2 <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;(<span class="id" title="var">k</span> := (<span class="id" title="var">m</span>.+1 +2+ <span class="id" title="var">m</span>.+1).+1) `{<span class="id" title="var">IsHSpace</span> <span class="id" title="var">X</span>} `{<span class="id" title="var">IsTrunc</span> <span class="id" title="var">k</span> <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">X</span> &lt;~&gt;* <span class="id" title="var">pTr</span> <span class="id" title="var">k</span> (<span class="id" title="var">loops</span> (<span class="id" title="var">psusp</span> <span class="id" title="var">X</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <span class="id" title="var">o</span>*<span class="id" title="var">E</span> <span class="id" title="var">pequiv_ptr</span> (<span class="id" title="var">n</span>:=<span class="id" title="var">k</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">nrefine</span> (<span class="id" title="var">pequiv_O_inverts</span> <span class="id" title="var">k</span> (<span class="id" title="var">loop_susp_unit</span> <span class="id" title="var">X</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">freudenthal_hspace</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Since <span class="inlinecode"><span class="id" title="var">loops</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> is an H-space, the Hopf construction provides a map <span class="inlinecode"><span class="id" title="var">Join</span></span> <span class="inlinecode">(<span class="id" title="var">loops</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span> <span class="inlinecode">(<span class="id" title="var">loops</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">Susp</span></span> <span class="inlinecode">(<span class="id" title="var">loops</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span>.  We show that this map is equivalent to the fiber of <span class="inlinecode"><span class="id" title="var">loop_susp_counit</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">Susp</span></span> <span class="inlinecode">(<span class="id" title="var">loops</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span> <span class="inlinecode">-&gt;</span> <span class="inlinecode"><span class="id" title="var">X</span></span> over the base point, up to the automorphism of <span class="inlinecode"><span class="id" title="var">Susp</span></span> <span class="inlinecode">(<span class="id" title="var">loops</span></span> <span class="inlinecode"><span class="id" title="var">X</span>)</span> induced by inverting loops. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_pfiber_loops_susp_counit_join</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">pfiber</span> (<span class="id" title="var">loop_susp_counit</span> <span class="id" title="var">X</span>) &lt;~&gt;* <span class="id" title="var">pjoin</span> (<span class="id" title="var">loops</span> <span class="id" title="var">X</span>) (<span class="id" title="var">loops</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrefine</span> (<span class="id" title="var">pequiv_hopf_total_join</span> (<span class="id" title="var">loops</span> <span class="id" title="var">X</span>) <span class="id" title="var">o</span>*<span class="id" title="var">E</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;2: <span class="id" title="var">rapply</span> <span class="id" title="var">ishspace_loops</span>.<br/>
&nbsp;&nbsp;2,3: <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_pEquiv'</span>.<br/>
&nbsp;&nbsp;{ <span class="id" title="var">snrapply</span> <span class="id" title="var">equiv_functor_sigma'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="tactic">exact</span> (<span class="id" title="var">emap</span> <span class="id" title="var">psusp</span> (<span class="id" title="var">equiv_path_inverse</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Susp_ind</span>; <span class="id" title="tactic">hnf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;1,2: <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">path_equiv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">funext</span> <span class="id" title="var">q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">rapply</span> (<span class="id" title="var">transport_equiv</span> (<span class="id" title="var">merid</span> <span class="id" title="var">p</span>) <span class="id" title="var">_</span> <span class="id" title="var">q</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">transport_paths_Fl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">whiskerR</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> (<span class="id" title="var">ap</span> <span class="id" title="var">inverse</span> (<span class="id" title="var">ap_V</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">rapply</span> <span class="id" title="var">inv_V</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Susp_rec_beta_merid</span>. } }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> (<span class="id" title="var">transport_idmap_ap</span> <span class="id" title="var">_</span> (<span class="id" title="var">merid</span> <span class="id" title="var">p</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> (<span class="id" title="var">transport2</span> <span class="id" title="var">idmap</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">ap_compose</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1: <span class="id" title="tactic">apply</span> <span class="id" title="var">functor_susp_beta_merid</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Susp_rec_beta_merid</span>. }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">lhs</span> <span class="id" title="var">nrapply</span> <span class="id" title="var">transport_path_universe</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">concat_V_pp</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
As a corollary we get 2n-connectivity of <span class="inlinecode"><span class="id" title="var">loop_susp_counit</span></span> <span class="inlinecode"><span class="id" title="var">X</span></span> for an n-connected <span class="inlinecode"><span class="id" title="var">X</span></span>. 
</div>
<div class="code">
<span class="id" title="keyword">Global Instance</span> <span class="id" title="var">conn_map_loop_susp_counit</span> `{<span class="id" title="var">Univalence</span>}<br/>
&nbsp;&nbsp;{<span class="id" title="var">n</span> : <span class="id" title="var">trunc_index</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">IsConnMap</span> (<span class="id" title="var">n</span> +2+ <span class="id" title="var">n</span>) (<span class="id" title="var">loop_susp_counit</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="tactic">intro</span> <span class="id" title="var">x</span>; <span class="id" title="tactic">hnf</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;- <span class="id" title="var">snrapply</span> (<span class="id" title="var">conn_point_elim</span> (-1)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> (<span class="id" title="var">isconnected_pred_add'</span> <span class="id" title="var">n</span> 0 <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;+ <span class="id" title="var">nrapply</span> (<span class="id" title="var">isconnected_equiv'</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> (<span class="id" title="var">pequiv_pfiber_loops_susp_counit_join</span> <span class="id" title="var">X</span>)^-1).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">isconnected_join</span>; <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
In particular, we get the following result.  All we are really using is that <span class="inlinecode"><span class="id" title="var">n</span>.+2</span> <span class="inlinecode">&lt;=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+2+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, but because of the use of <span class="inlinecode"><span class="id" title="var">isconnmap_pred_add</span></span>, the proof is a bit more specific to this case. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pequiv_ptr_psusp_loops</span> `{<span class="id" title="var">Univalence</span>} (<span class="id" title="var">X</span> : <span class="id" title="var">pType</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) `{<span class="id" title="var">IsConnected</span> <span class="id" title="var">n</span>.+1 <span class="id" title="var">X</span>}<br/>
&nbsp;&nbsp;: <span class="id" title="var">pTr</span> <span class="id" title="var">n</span>.+2 (<span class="id" title="var">psusp</span> (<span class="id" title="var">loops</span> <span class="id" title="var">X</span>)) &lt;~&gt;* <span class="id" title="var">pTr</span> <span class="id" title="var">n</span>.+2 <span class="id" title="var">X</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">snrapply</span> <span class="id" title="var">Build_pEquiv</span>.<br/>
&nbsp;&nbsp;1: <span class="id" title="var">rapply</span> (<span class="id" title="var">fmap</span> (<span class="id" title="var">pTr</span> <span class="id" title="var">_</span>) (<span class="id" title="var">loop_susp_counit</span> <span class="id" title="var">_</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> <span class="id" title="var">O_inverts_conn_map</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">nrapply</span> (<span class="id" title="var">isconnmap_pred_add</span> <span class="id" title="var">n</span>.-2).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> 2 <span class="id" title="var">trunc_index_add_succ</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> (<span class="id" title="var">conn_map_loop_susp_counit</span> <span class="id" title="var">X</span>).<br/>
<span class="id" title="keyword">Defined</span>.<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>