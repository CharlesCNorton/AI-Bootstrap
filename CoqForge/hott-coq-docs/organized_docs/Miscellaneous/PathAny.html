<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>PathAny</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library PathAny</h1>

<div class="code">
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Basics</span> <span class="id" title="keyword">Types</span>.<br/>

<br/>
</div>

<div class="doc">
A nice method for proving characterizations of path-types of nested sigma-types, due to Rijke. 
<div class="paragraph"> </div>

 To show that the based path-type of <span class="inlinecode"><span class="id" title="var">A</span></span> is equivalent to some specified family <span class="inlinecode"><span class="id" title="var">P</span></span>, it suffices to show that <span class="inlinecode"><span class="id" title="var">P</span></span> is reflexive and its total space is contractible. This is part of Theorem 5.8.2, namely (iv) implies (iii). 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_path_from_contr</span> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Prefl</span> : <span class="id" title="var">P</span> <span class="id" title="var">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">cp</span> : <span class="id" title="var">Contr</span> {<span class="id" title="var">y</span>:<span class="id" title="var">A</span> &amp; <span class="id" title="var">P</span> <span class="id" title="var">y</span>} )<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">b</span> : <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">P</span> <span class="id" title="var">b</span> &lt;~&gt; <span class="id" title="var">a</span> = <span class="id" title="var">b</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">equiv_inverse</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srefine</span> (<span class="id" title="var">Build_Equiv</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;{ <span class="id" title="tactic">intros</span> []; <span class="id" title="tactic">apply</span> <span class="id" title="var">Prefl</span>. }<br/>
&nbsp;&nbsp;<span class="id" title="var">revert</span> <span class="id" title="var">b</span>; <span class="id" title="tactic">apply</span> <span class="id" title="var">isequiv_from_functor_sigma</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">rapply</span> <span class="id" title="var">isequiv_contr_contr</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
See Homotopy/EncodeDecode.v for a related characterization of identity types. 
<div class="paragraph"> </div>

 This is another result for characterizing the path type of <span class="inlinecode"><span class="id" title="var">A</span></span> when given an equivalence <span class="inlinecode"><span class="id" title="var">e</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">&lt;~&gt;</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, such as an <span class="inlinecode"><span class="id" title="var">issig</span></span> lemma for <span class="inlinecode"><span class="id" title="var">A</span></span>. It can help Coq to deduce the type family <span class="inlinecode"><span class="id" title="var">P</span></span> if <span class="inlinecode"><span class="id" title="var">revert</span></span> is used to move <span class="inlinecode"><span class="id" title="var">a0</span></span> and <span class="inlinecode"><span class="id" title="var">a1</span></span> into the goal, if needed. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_path_along_equiv</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">e</span> : <span class="id" title="var">B</span> &lt;~&gt; <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">K</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b0</span> <span class="id" title="var">b1</span> : <span class="id" title="var">B</span>, <span class="id" title="var">P</span> (<span class="id" title="var">e</span> <span class="id" title="var">b0</span>) (<span class="id" title="var">e</span> <span class="id" title="var">b1</span>) &lt;~&gt; <span class="id" title="var">b0</span> = <span class="id" title="var">b1</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">a0</span> <span class="id" title="var">a1</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">a0</span> <span class="id" title="var">a1</span> &lt;~&gt; <span class="id" title="var">a0</span> = <span class="id" title="var">a1</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">equiv_intros</span> <span class="id" title="var">e</span> <span class="id" title="var">b0</span> <span class="id" title="var">b1</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">_</span> <span class="id" title="var">oE</span> <span class="id" title="var">K</span> <span class="id" title="var">b0</span> <span class="id" title="var">b1</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">equiv_ap'</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
This simply combines the two previous results, a common idiom. Again, it can help Coq to deduce the type family <span class="inlinecode"><span class="id" title="var">P</span></span> if <span class="inlinecode"><span class="id" title="var">revert</span></span> is used to move <span class="inlinecode"><span class="id" title="var">a0</span></span> and <span class="inlinecode"><span class="id" title="var">a1</span></span> into the goal, if needed. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">equiv_path_issig_contr</span> {<span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>} {<span class="id" title="var">P</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">e</span> : <span class="id" title="var">B</span> &lt;~&gt; <span class="id" title="var">A</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">Prefl</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, <span class="id" title="var">P</span> (<span class="id" title="var">e</span> <span class="id" title="var">b</span>) (<span class="id" title="var">e</span> <span class="id" title="var">b</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">cp</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">b1</span>, <span class="id" title="var">Contr</span> {<span class="id" title="var">b2</span> : <span class="id" title="var">B</span> &amp; <span class="id" title="var">P</span> (<span class="id" title="var">e</span> <span class="id" title="var">b1</span>) (<span class="id" title="var">e</span> <span class="id" title="var">b2</span>)})<br/>
&nbsp;&nbsp;: <span class="id" title="keyword">forall</span> <span class="id" title="var">a0</span> <span class="id" title="var">a1</span> : <span class="id" title="var">A</span>, <span class="id" title="var">P</span> <span class="id" title="var">a0</span> <span class="id" title="var">a1</span> &lt;~&gt; <span class="id" title="var">a0</span> = <span class="id" title="var">a1</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">equiv_path_along_equiv</span> <span class="id" title="var">e</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intro</span> <span class="id" title="var">a0</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">srapply</span> <span class="id" title="var">equiv_path_from_contr</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">Prefl</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
After <span class="inlinecode"><span class="id" title="var">equiv_path_issig_contr</span></span>, we are left showing the contractibility of a sigma-type whose base and fibers are large nested sigma-types of the same depth.  Moreover, we expect that the types appearing in those two large nested sigma-types "pair up" to form contractible based "path-types".  The following lemma "peels off" the first such pair, whose contractibility can often be found with typeclass search.  The remaining contractibility goal is then simplified by substituting the center of contraction of that first based "path-type", or more precisely a *specific* center that may or may not be the one given by the contractibility instance; the latter freedom sometimes makes things faster and simpler. 
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">contr_sigma_sigma</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">B</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">C</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span>) (<span class="id" title="var">D</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">B</span> <span class="id" title="var">a</span> -&gt; <span class="id" title="var">C</span> <span class="id" title="var">a</span> -&gt; <span class="id" title="keyword">Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">cac</span> : <span class="id" title="var">Contr</span> {<span class="id" title="var">x</span>:<span class="id" title="var">A</span> &amp; <span class="id" title="var">C</span> <span class="id" title="var">x</span>} }<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">a</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">c</span> : <span class="id" title="var">C</span> <span class="id" title="var">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<span class="id" title="var">ccd</span> : <span class="id" title="var">Contr</span> {<span class="id" title="var">y</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> &amp; <span class="id" title="var">D</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">c</span> } }<br/>
&nbsp;&nbsp;: <span class="id" title="var">Contr</span> {<span class="id" title="var">ab</span> : {<span class="id" title="var">x</span>:<span class="id" title="var">A</span> &amp; <span class="id" title="var">B</span> <span class="id" title="var">x</span>} &amp; {<span class="id" title="var">y</span>:<span class="id" title="var">C</span> <span class="id" title="var">ab</span>.1 &amp; <span class="id" title="var">D</span> <span class="id" title="var">ab</span>.1 <span class="id" title="var">ab</span>.2 <span class="id" title="var">y</span>} }.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">d</span> := (<span class="id" title="var">center</span> {<span class="id" title="var">y</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> &amp; <span class="id" title="var">D</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">c</span>}).2).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">set</span> (<span class="id" title="var">b</span> := (<span class="id" title="var">center</span> {<span class="id" title="var">y</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> &amp; <span class="id" title="var">D</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">c</span>}).1) <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">apply</span> (<span class="id" title="var">Build_Contr</span> <span class="id" title="var">_</span> ((<span class="id" title="var">a</span>;<span class="id" title="var">b</span>);(<span class="id" title="var">c</span>;<span class="id" title="var">d</span>))).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> [[<span class="id" title="var">a'</span> <span class="id" title="var">b'</span>] [<span class="id" title="var">c'</span> <span class="id" title="var">d'</span>]]; <span class="id" title="var">cbn</span> <span class="id" title="tactic">in</span> *.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">ac'</span> := (<span class="id" title="var">a'</span>;<span class="id" title="var">c'</span>)).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">bd'</span> := (<span class="id" title="var">b'</span>;<span class="id" title="var">d'</span>) : {<span class="id" title="var">y</span>:<span class="id" title="var">B</span> <span class="id" title="var">ac'</span>.1 &amp; <span class="id" title="var">D</span> <span class="id" title="var">ac'</span>.1 <span class="id" title="var">y</span> <span class="id" title="var">ac'</span>.2}).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">change</span> (((<span class="id" title="var">a</span>;<span class="id" title="var">b</span>);(<span class="id" title="var">c</span>;<span class="id" title="var">d</span>)) = ((<span class="id" title="var">ac'</span>.1;<span class="id" title="var">bd'</span>.1);(<span class="id" title="var">ac'</span>.2;<span class="id" title="var">bd'</span>.2))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:&gt; {<span class="id" title="var">ab</span> : {<span class="id" title="var">x</span>:<span class="id" title="var">A</span> &amp; <span class="id" title="var">B</span> <span class="id" title="var">x</span>} &amp; {<span class="id" title="var">y</span>:<span class="id" title="var">C</span> <span class="id" title="var">ab</span>.1 &amp; <span class="id" title="var">D</span> <span class="id" title="var">ab</span>.1 <span class="id" title="var">ab</span>.2 <span class="id" title="var">y</span>} }).<br/>
&nbsp;&nbsp;<span class="id" title="var">clearbody</span> <span class="id" title="var">ac'</span> <span class="id" title="var">bd'</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">a'</span> <span class="id" title="var">b'</span> <span class="id" title="var">c'</span> <span class="id" title="var">d'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (@<span class="id" title="var">path_contr</span> {<span class="id" title="var">x</span>:<span class="id" title="var">A</span> &amp; <span class="id" title="var">C</span> <span class="id" title="var">x</span>} <span class="id" title="var">_</span> (<span class="id" title="var">a</span>;<span class="id" title="var">c</span>) <span class="id" title="var">ac'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (@<span class="id" title="var">path_contr</span> {<span class="id" title="var">y</span>:<span class="id" title="var">B</span> <span class="id" title="var">a</span> &amp; <span class="id" title="var">D</span> <span class="id" title="var">a</span> <span class="id" title="var">y</span> <span class="id" title="var">c</span>} <span class="id" title="var">_</span> (<span class="id" title="var">b</span>;<span class="id" title="var">d</span>) <span class="id" title="var">bd'</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
This tactic just applies the previous lemma, using a match to figure out the appropriate type families so the user doesn't have to specify them. 
</div>
<div class="code">
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">contr_sigsig</span> <span class="id" title="var">a</span> <span class="id" title="var">c</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="keyword">goal</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| [ |- <span class="id" title="var">Contr</span> (@<span class="id" title="var">sig</span> (@<span class="id" title="var">sig</span> ?<span class="id" title="var">A</span> ?<span class="id" title="var">B</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">ab</span> =&gt; @<span class="id" title="var">sig</span> (@?<span class="id" title="var">C</span> <span class="id" title="var">ab</span>) (@?<span class="id" title="var">D</span> <span class="id" title="var">ab</span>))) ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;lemma&nbsp;only&nbsp;applies&nbsp;when&nbsp;C&nbsp;depends&nbsp;only&nbsp;on&nbsp;the&nbsp;first&nbsp;component&nbsp;of&nbsp;ab,&nbsp;so&nbsp;we&nbsp;need&nbsp;to&nbsp;factor&nbsp;it&nbsp;somehow&nbsp;through&nbsp;pr1.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">C'</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">transparent</span> <span class="id" title="tactic">assert</span> (<span class="id" title="var">C'</span> : {<span class="id" title="var">C'</span> : <span class="id" title="var">A</span> -&gt; <span class="id" title="keyword">Type</span> &amp; <span class="id" title="keyword">forall</span> <span class="id" title="var">ab</span>, <span class="id" title="var">C'</span> <span class="id" title="var">ab</span>.1 = <span class="id" title="var">C</span> <span class="id" title="var">ab</span>});<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">eexists</span>; <span class="id" title="tactic">intros</span> <span class="id" title="var">ab</span>; <span class="id" title="tactic">reflexivity</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nrefine</span> (<span class="id" title="var">contr_sigma_sigma</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C'</span>.1 (<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> =&gt; <span class="id" title="var">D</span> (<span class="id" title="var">a</span>;<span class="id" title="var">b</span>)) <span class="id" title="var">a</span> <span class="id" title="var">c</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>

<div class="doc">
In practice, usually the first <span class="inlinecode"><span class="id" title="var">Contr</span></span> hypothesis can be found by typeclass search, so we try that.  But we don't try on the second one, since often it can't be, and trying can be slow. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">try</span> <span class="id" title="tactic">exact</span> <span class="id" title="var">_</span> | <span class="id" title="tactic">subst</span> <span class="id" title="var">C'</span> ] ]<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
For examples of the use of this tactic, see for instance <span class="inlinecode"><span class="id" title="var">Factorization</span></span> and <span class="inlinecode"><span class="id" title="var">Idempotents</span></span>. 
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>