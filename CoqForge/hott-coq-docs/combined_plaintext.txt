--- Algebra\AbelianGroup.html ---
AbelianGroupLibrary AbelianGroupRequireImportBasicsTypes.RequireImportSpaces.Nat.CoreSpaces.Int.RequireExportClasses.interfaces.canonical_names(Zero,zero,Plus).RequireExportClasses.interfaces.abstract_algebra(IsAbGroup(..),abgroup_group,abgroup_commutative).RequireExportAlgebra.Groups.Group.RequireExportAlgebra.Groups.Subgroup.RequireImportAlgebra.Groups.QuotientGroup.RequireImportWildCat.LocalSetPolymorphicInductiveCumulativity.Local OpenScopemc_scope.Local OpenScopemc_add_scope.Abelian groupsDefinition of an abelian groupRecordAbGroup:= {abgroup_group:Group;abgroup_commutative:Commutative(@group_sgopabgroup_group);}.Coercionabgroup_group:AbGroup>->Group.Global Existing Instanceabgroup_commutative.Global Instanceisabgroup_abgroup{A:AbGroup} :IsAbGroupA.Proof.split;exact_.Defined.Easier way to build abelian groups without redundant information.DefinitionBuild_AbGroup'(G:Type)`{ZeroG,NegateG,PlusG,IsHSetG}(comm:Commutative(A:=G) (+))(assoc:Associative(A:=G) (+))(unit_l:LeftIdentity(A:=G) (+) 0)(inv_l:LeftInverse(A:=G) (+) (-) 0):AbGroup.Proof.snrapplyBuild_AbGroup.-(* TODO: introduce smart constructor forBuild_Group*)rapply(Build_GroupG).repeatsplit;only1-3, 5:exact_.+introsx.lhsnrapplycomm.exact(unit_lx).+introsx.lhsnrapplycomm.exact(inv_lx).-exactcomm.Defined.Definitionissig_abgroup:_<~>AbGroup:=ltac:(issig).Global Instancezero_abgroup(A:AbGroup) :ZeroA:=group_unit.Global Instanceplus_abgroup(A:AbGroup) :PlusA:=group_sgop.Global Instancenegate_abgroup(A:AbGroup) :NegateA:=group_inverse.Definitionab_comm{A:AbGroup} (xy:A) :x+y=y+x:=commutativityxy.Definitionab_neg_op{A:AbGroup} (xy:A) : - (x+y) = -x-y.Proof.lhsnrapplygrp_inv_op.applyab_comm.Defined.Paths between abelian groupsDefinitionequiv_path_abgroup`{Univalence} {AB:AbGroup@{u}}:GroupIsomorphismAB<~> (A=B).Proof.refine(equiv_ap_invissig_abgroup__oE_).refine(equiv_path_sigma_hprop__oE_).exactequiv_path_group.Defined.Definitionequiv_path_abgroup_group`{Univalence} {AB:AbGroup}: (A=B:>AbGroup) <~> (A=B:>Group):=equiv_path_groupoEequiv_path_abgroup^-1.Subgroups of abelian groupsSubgroups of abelian groups are abelianGlobal Instanceisabgroup_subgroup(G:AbGroup) (H:SubgroupG):IsAbGroupH.Proof.nrapplyBuild_IsAbGroup.1:exact_.introsxy.applypath_sigma_hprop.cbn.applycommutativity.Defined.Given any subgroup of an abelian group, we can coerce it to an abelian group. Note that Coq complains this coercion doesn't satisfy the uniform-inheritance condition, but in practice it works and doesn't cause any issue, so we ignore it.Definitionabgroup_subgroup(G:AbGroup) :SubgroupG->AbGroup:=funH=>Build_AbGroupH_.#[warnings="-uniform-inheritance"]Coercionabgroup_subgroup:Subgroup>->AbGroup.Global Instanceisnormal_ab_subgroup(G:AbGroup) (H:SubgroupG):IsNormalSubgroupH.Proof.introsxyh.byrewriteab_comm.Defined.Quotients of abelian groupsGlobal Instanceisabgroup_quotient(G:AbGroup) (H:SubgroupG):IsAbGroup(QuotientGroup'GH(isnormal_ab_subgroupGH)).Proof.nrapplyBuild_IsAbGroup.1:exact_.srapplyQuotient_ind2_hprop;introsxy.apply(ap(class_of_)).applycommutativity.Defined.DefinitionQuotientAbGroup(G:AbGroup) (H:SubgroupG) :AbGroup:= (Build_AbGroup(QuotientGroup'GH(isnormal_ab_subgroupGH))_).ArgumentsQuotientAbGroupGH:simplnever.Definitionquotient_abgroup_rec{G:AbGroup}(N:SubgroupG) (H:AbGroup)(f:GroupHomomorphismGH) (h:foralln:G,Nn->fn=mon_unit):GroupHomomorphism(QuotientAbGroupGN)H:=grp_quotient_recG(Build_NormalSubgroupGN_)fh.Theoremequiv_quotient_abgroup_ump{F:Funext} {G:AbGroup}(N:SubgroupG) (H:Group): {f:GroupHomomorphismGH&forall(n:G),Nn->fn=mon_unit}<~> (GroupHomomorphism(QuotientAbGroupGN)H).Proof.exact(equiv_grp_quotient_ump(Build_NormalSubgroupGN_)_).Defined.The wild category of abelian groupsGlobal Instanceisgraph_abgroup:IsGraphAbGroup:=isgraph_inducedabgroup_group.Global Instanceis01cat_abgroup:Is01CatAbGroup:=is01cat_inducedabgroup_group.Global Instanceis01cat_grouphomomorphism{AB:AbGroup} :Is01Cat(A$->B):=is01cat_induced(@grp_homo_mapAB).Global Instanceis0gpd_grouphomomorphism{AB:AbGroup} :Is0Gpd(A$->B):=is0gpd_induced(@grp_homo_mapAB).Global Instanceis2graph_abgroup:Is2GraphAbGroup:=is2graph_inducedabgroup_group.AbGroup forms a 1CatGlobal Instanceis1cat_abgroup:Is1CatAbGroup:=is1cat_induced_.Global Instancehasmorext_abgroup`{Funext} :HasMorExtAbGroup:=hasmorext_induced_.Global Instancehasequivs_abgroup:HasEquivsAbGroup:=hasequivs_induced_.Zero object of AbGroupDefinitionabgroup_trivial:AbGroup.Proof.rapply(Build_AbGroupgrp_trivial).byintros[].Defined.AbGroup is a pointed categoryGlobal Instanceispointedcat_abgroup:IsPointedCatAbGroup.Proof.applyBuild_IsPointedCatwithabgroup_trivial.all:introA;applyispointedcat_group.Defined.Image of group homomorphisms between abelian groupsDefinitionabgroup_image{AB:AbGroup} (f:A$->B) :AbGroup:=Build_AbGroup(grp_imagef)_.First isomorphism theorem of abelian groupsDefinitionabgroup_first_iso`{Funext} {AB:AbGroup} (f:A$->B):GroupIsomorphism(QuotientAbGroupA(grp_kernelf)) (abgroup_imagef).Proof.etransitivity.2:rapplygrp_first_iso.applygrp_iso_quotient_normal.Defined.Kernels of abelian groupsDefinitionab_kernel{AB:AbGroup} (f:A$->B) :AbGroup:=Build_AbGroup(grp_kernelf)_.Transporting in families related to abelian groupsLemmatransport_abgrouphomomorphism_from_const`{Univalence} {ABB':AbGroup}(p:B=B') (f:GroupHomomorphismAB):transport(HomA)pf=grp_homo_compose(equiv_path_abgroup^-1p)f.Proof.inductionp.byapplyequiv_path_grouphomomorphism.Defined.Lemmatransport_iso_abgrouphomomorphism_from_const`{Univalence} {ABB':AbGroup}(phi:GroupIsomorphismBB') (f:GroupHomomorphismAB):transport(HomA) (equiv_path_abgroupphi)f=grp_homo_composephif.Proof.refine(transport_abgrouphomomorphism_from_const__@_).byrewriteeissect.Defined.Lemmatransport_abgrouphomomorphism_to_const`{Univalence} {AA'B:AbGroup}(p:A=A') (f:GroupHomomorphismAB):transport(funG=>HomGB)pf=grp_homo_composef(grp_iso_inverse(equiv_path_abgroup^-1p)).Proof.inductionp;cbn.byapplyequiv_path_grouphomomorphism.Defined.Lemmatransport_iso_abgrouphomomorphism_to_const`{Univalence} {AA'B:AbGroup}(phi:GroupIsomorphismAA') (f:GroupHomomorphismAB):transport(funG=>HomGB) (equiv_path_abgroupphi)f=grp_homo_composef(grp_iso_inversephi).Proof.refine(transport_abgrouphomomorphism_to_const__@_).byrewriteeissect.Defined.Operations on abelian groupsThe negation automorphism of an abelian groupDefinitionab_homo_negation{A:AbGroup} :GroupIsomorphismAA.Proof.snrapplyBuild_GroupIsomorphism.-snrapplyBuild_GroupHomomorphism.+exact(funa=> -a).+introsxy.refine(grp_inv_opxy@_).applycommutativity.-srapplyisequiv_adjointify.1:exact(funa=> -a).1-2:exactnegate_involutive.Defined.Multiplication byn:Intdefines an endomorphism of any abelian groupA.Definitionab_mul{A:AbGroup} (n:Int) :GroupHomomorphismAA.Proof.snrapplyBuild_GroupHomomorphism.1:exact(funa=>grp_powan).introsab.applygrp_pow_mul,ab_comm.Defined.ab_mulnis natural.Definitionab_mul_natural{AB:AbGroup}(f:GroupHomomorphismAB) (n:Int):foab_muln==ab_mulnof:=grp_pow_naturalfn.The image of an inclusion is a normal subgroup.Definitionab_image_embedding{AB:AbGroup} (f:A$->B) `{IsEmbeddingf} :NormalSubgroupB:= {|normalsubgroup_subgroup:=grp_image_embeddingf;normalsubgroup_isnormal:=_|}.Definitionab_image_in_embedding{AB:AbGroup} (f:A$->B) `{IsEmbeddingf}:GroupIsomorphismA(ab_image_embeddingf):=grp_image_in_embeddingf.The cokernel of a homomorphism into an abelian group.Definitionab_cokernel{G:Group@{u}} {A:AbGroup@{u}} (f:GroupHomomorphismGA):AbGroup:=QuotientAbGroup_(grp_imagef).Definitionab_cokernel_embedding{G:Group} {A:AbGroup} (f:G$->A) `{IsEmbeddingf}:AbGroup:=QuotientAbGroup_(grp_image_embeddingf).Definitionab_cokernel_embedding_rec{G:Group} {AB:AbGroup} (f:G$->A) `{IsEmbeddingf}(h:A$->B) (p:grp_homo_composehf$==grp_homo_const):ab_cokernel_embeddingf$->B.Proof.snrapply(grp_quotient_rec__h).introsa[gq].inductionq.exact(pg).Defined.

--- Algebra\Abelianization.html ---
AbelianizationLibrary AbelianizationRequireImportBasicsTypesTruncations.Core.RequireImportCubical.DPathWildCat.RequireImportColimits.Coeq.RequireImportAlgebra.AbGroups.AbelianGroup.RequireImportModalities.ReflectiveSubuniverse.In this file we define what it means for a group homomorphism G -> H into an abelian group H to be an abelianization. We then construct an example of an abelianization.Local OpenScopemc_scope.Local OpenScopemc_mult_scope.Local OpenScopewc_iso_scope.Definition of Abelianization.A "unit" homomorphismeta:G->G_ab, withG_ababelian, is considered an abelianization if and only if for all homomorphismsG->A, whereAis abelian, there exists a uniqueg:G_ab->Asuch thath==goetaX.   We express this in funext-free form by saying that precomposition withetain the wild 1-categoryGroupinduces an equivalence of hom 0-groupoids, in the sense of WildCat/EquivGpd.Unfortunately, ifeta:GroupHomomorphismGG_aband we writecat_precompAetathen Coq is unable to guess that the relevant 1-category isGroup.  Even writingcat_precomp(A:=Group)Aetaisn't good enough, I guess because the typeclass inference that finds the instanceis01cat_groupdoesn't happen until after the type ofetawould have to be resolved to aHomin some wild category.  However, with the following auxiliary definition we can force the typeclass inference to happen first.  (It would be worth thinking about whether the design of the wild categories library could be improved to avoid this.)Definitiongroup_precomp{ab} := @cat_precompGroup__ab.ClassIsAbelianization{G:Group} (G_ab:AbGroup)(eta:GroupHomomorphismGG_ab):=issurjinj_isabel:forall(A:AbGroup),IsSurjInj(group_precompAeta).Global Existing Instanceissurjinj_isabel.Definitionisequiv_group_precomp_isabelianization`{Funext}{G:Group} {G_ab:AbGroup} (eta:GroupHomomorphismGG_ab)`{!IsAbelianizationG_abeta} (A:AbGroup):IsEquiv(group_precompAeta).Proof.snrapplyisequiv_adjointify.-introsg.rapply(surjinj_inv(group_precompAeta)g).-introsf.snrapplyequiv_path_grouphomomorphism.exact(eisretr0gpd_inv(group_precompAeta)f).-introsf.snrapplyequiv_path_grouphomomorphism.exact(eissect0gpd_inv(group_precompAeta)f).Defined.Definitionequiv_group_precomp_isabelianization`{Funext}{G:Group} {G_ab:AbGroup} (eta:GroupHomomorphismGG_ab)`{!IsAbelianizationG_abeta} (A:AbGroup): (G_ab$->A) <~> (G$->A):=Build_Equiv___(isequiv_group_precomp_isabelianizationetaA).Here we define abelianization as a HIT. Specifically as a set-coequalizer of the following two maps: (a, b, c) |-> a (b c) and (a, b, c) |-> a (c b).From this we can show that Abel G is an abelian group.In fact this models the following HIT:HIT Abel (G : Group) := 
 | abel_in : G -> Abel G
 | abel_in_comm : forall x y z, abel_in (x * (y * z)) = abel_in (x * (z * y)).We also deriveabel_inandabel_in_commfrom our coequalizer definition, and even prove the induction and computation rules for this HIT.This HIT was suggested by Dan Christensen.SectionAbel.Let G be a group.Context(G:Group).We locally define a map uncurry2 that lets us uncurry A * B * C -> D twice.Local Definitionuncurry2{ABCD:Type}: (A->B->C->D) ->A*B*C->D.Proof.introsf[[ab]c].byapplyf.Defined.The type Abel is defined to be the set coequalizer of the following maps G^3 -> G.DefinitionAbel:=Tr0 (Coeq(uncurry2(funabc:G=>a* (b*c)))(uncurry2(funabc:G=>a* (c*b)))).We have a natural map from G to Abel G.Definitionabel_in:G->Abel.Proof.introg.applytr,coeq,g.Defined.This map satisfies the condition ab_comm.Definitionabel_in_commabc:abel_in(a* (b*c)) =abel_in(a* (c*b)).Proof.apply(aptr).exact(cglue(a,b,c)).Defined.It is clear that Abel is a set.Global Instanceistrunc_abel:IsHSetAbel:=_.We can derive the induction principle from the ones for truncation and the coequalizer.DefinitionAbel_ind(P:Abel->Type) `{forallx,IsHSet(Px)}(a:forallx,P(abel_inx))(c:forallxyz,DPathP(abel_in_commxyz) (a(x* (y*z))) (a(x* (z*y)))):forall(x:Abel),Px.Proof.srapplyTrunc_ind.srapplyCoeq_ind.1:applya.intros[[xy]z].refine(transport_compose____@_).applyc.Defined.The computation rule on point constructors holds definitionally.DefinitionAbel_ind_beta_abel_in(P:Abel->Type) `{forallx,IsHSet(Px)}(a:forallx,P(abel_inx))(c:forallxyz,DPathP(abel_in_commxyz) (a(x* (y*z))) (a(x* (z*y))))(x:G):Abel_indPac(abel_inx) =ax:=idpath.The computation rule on paths.DefinitionAbel_ind_beta_abel_in_comm(P:Abel->Type) `{forallx,IsHSet(Px)}(a:forallx,P(abel_inx))(c:forallxyz,DPathP(abel_in_commxyz) (a(x* (y*z))) (a(x* (z*y))))(xyz:G):apD(Abel_indPac) (abel_in_commxyz) =cxyz.Proof.refine(apD_compose'tr__@ap__@concat_V_pp__).rapplyCoeq_ind_beta_cglue.Defined.We also have a recursion princple.DefinitionAbel_rec(P:Type) `{IsHSetP}(a:G->P)(c:forallxyz,a(x* (y*z)) =a(x* (z*y))):Abel->P.Proof.apply(Abel_ind_a).intros;applydp_const,c.Defined.Here is a simpler version ofAbel_indwhen our target is anHProp. This lets us discard all the higher paths.DefinitionAbel_ind_hprop(P:Abel->Type) `{forallx,IsHProp(Px)}(a:forallx,P(abel_inx)):forall(x:Abel),Px.Proof.srapplyTrunc_ind.srapplyCoeq_ind_hprop.exacta.Defined.EndAbel.TheIsHPropargument ofAbel_ind_hpropcan usually be found by typeclass resolution, butsrapplyis slow, so we use this tactic instead.Local LtacAbel_ind_hpropx:=snrapplyAbel_ind_hprop; [exact_|introx].We make sure thatGis implicit in the arguments ofabel_inandabel_in_comm.Argumentsabel_in{_}.Argumentsabel_in_comm{_}.Now we can show that Abel G is in fact an abelian group.SectionAbelGroup.Context(G:Group).Firstly we derive the operation on Abel G. This is defined as follows:abel_in x + abel_in y := abel_in (x * y)But we need to also check that it preserves ab_comm in the appropriate way.Global Instanceabel_sgop:SgOp(AbelG).Proof.introa.srapplyAbel_rec.{introb.reverta.srapplyAbel_rec.{introa.exact(abel_in(a*b)). }introsacd;hnf.(* The pattern seems to be to alternate associativity and ab_comm. *)refine(ap_(associativity___)^ @_).refine(abel_in_comm___@_).refine(ap_(associativity___) @_).refine(abel_in_comm___@_).refine(ap_(associativity___)^ @_).refine(abel_in_comm___@_).refine(ap_(associativity___)). }introsbcd.reverta.Abel_ind_hpropa;simpl.refine(ap_(associativity___) @_).refine(abel_in_comm___@_).refine(ap_(associativity___)^).Defined.We can now easily show that this operation is associative by associativity in G and the fact that being associative is a proposition.Global Instanceabel_sgop_associative:Associativeabel_sgop.Proof.introsxy.Abel_ind_hpropz;reverty.Abel_ind_hpropy;revertx.Abel_ind_hpropx;simpl.applyap,associativity.Defined.From this we know that Abel G is a semigroup.Global Instanceabel_issemigroup:IsSemiGroup(AbelG) := {}.We define the unit as ab of the unit of GGlobal Instanceabel_mon_unit:MonUnit(AbelG) :=abel_inmon_unit.By using Abel_ind_hprop we can prove the left and right identity laws.Global Instanceabel_leftidentity:LeftIdentityabel_sgopabel_mon_unit.Proof.Abel_ind_hpropx.simpl;applyap,left_identity.Defined.Global Instanceabel_rightidentity:RightIdentityabel_sgopabel_mon_unit.Proof.Abel_ind_hpropx.simpl;applyap,right_identity.Defined.Hence Abel G is a monoidGlobal Instanceismonoid_abel:IsMonoid(AbelG) := {}.We can also prove that the operation is commutative! This will come in handy later.Global Instanceabel_commutative:Commutativeabel_sgop.Proof.introx.Abel_ind_hpropy.revertx.Abel_ind_hpropx.refine((apabel_in(left_identity_))^ @_).refine(_@ (apabel_in(left_identity_))).applyabel_in_comm.Defined.Now we can define the negation. This is just- (abel_in g) := abel_in (- g)However when checking that it respects ab_comm we have to show the following:abel_in (- z * - y * - x) = abel_in (- y * - z * - x)there is no obvious way to do this, but we note thatabel_in(x*y)is exactly the definition ofabel_inx+abel_iny! Hence by commutativity we can show this.Global Instanceabel_negate:Negate(AbelG).Proof.srapplyAbel_rec.{introg.exact(abel_in(-g)). }introsxyz;cbn.rewrite?negate_sg_op.change(abel_in(-z) *abel_in(-y) *abel_in(-x)=abel_in(-y) *abel_in(-z) *abel_in(-x)).byrewrite(commutativity(abel_in(-z)) (abel_in(-y))).Defined.Again by Abel_ind_hprop and the corresponding laws for G we can prove the left and right inverse laws.Global Instanceabel_leftinverse:LeftInverseabel_sgopabel_negateabel_mon_unit.Proof.Abel_ind_hpropx;simpl.applyap;applyleft_inverse.Defined.Instanceabel_rightinverse:RightInverseabel_sgopabel_negateabel_mon_unit.Proof.Abel_ind_hpropx;simpl.applyap;applyright_inverse.Defined.Thus Abel G is a groupGlobal Instanceisgroup_abel:IsGroup(AbelG) := {}.And since the operation is commutative, an abelian group.Global Instanceisabgroup_abel:IsAbGroup(AbelG) := {}.By definition, the mapabel_inis also a group homomorphism.Global Instanceissemigrouppreserving_abel_in:IsSemiGroupPreservingabel_in.Proof.byunfoldIsSemiGroupPreserving.Defined.EndAbelGroup.We can easily prove thatabel_inis a surjection.Global Instanceissurj_abel_in{G:Group} :IsSurjection(@abel_inG).Proof.applyBuildIsSurjection.Abel_ind_hpropx.cbn.applytr.existsx.reflexivity.Defined.Now we finally check that our definition of abelianization satisfies the universal property of being an abelianization.We define abel to be the abelianization of a group. This is a map from Group to AbGroup.Definitionabel:Group->AbGroup.Proof.introG.snrapplyBuild_AbGroup.-srapply(Build_Group(AbelG)).-exact_.Defined.ArgumentsabelG:simplnever.The unit of this map is the mapabel_inwhich typeclasses can pick up to be a homomorphism. We write it out explicitly here.Definitionabel_unit{G:Group}:G$-> (abelG):= @Build_GroupHomomorphismG(abelG)abel_in_.Definitiongrp_homo_abel_rec{G:Group} {A:AbGroup} (f:G$->A):abelG$->A.Proof.snrapplyBuild_GroupHomomorphism.{srapply(Abel_rec__f).introsxyz.nrapplygrp_homo_op_agree;trivial.refine(grp_homo_op___@_@ (grp_homo_op___)^).applycommutativity. }introsy.Abel_ind_hpropx;reverty.Abel_ind_hpropy.applygrp_homo_op.Defined.Definitionabel_ind_homotopy{GH:Group} {fg:Hom(A:=Group) (abelG)H}(p:f$oabel_unit$==g$oabel_unit):f$==g.Proof.rapplyAbel_ind_hprop.rapplyp.Defined.Finally we can prove that our construction abel is an abelianization.Global Instanceisabelianization_abel{G:Group}:IsAbelianization(abelG)abel_unit.Proof.introsA.constructor.{introsh.snrefine(grp_homo_abel_rech;_).cbn.reflexivity. }introsghp.Abel_ind_hpropx.exact(px).Defined.Theoremgroupiso_isabelianization{G:Group}(AB:AbGroup)(eta1:GroupHomomorphismGA)(eta2:GroupHomomorphismGB){isab1:IsAbelianizationAeta1}{isab2:IsAbelianizationBeta2}:A≅B.Proof.destruct(esssurj(group_precompBeta1)eta2)as[aac].destruct(esssurj(group_precompAeta2)eta1)as[bbc].srapply(Build_GroupIsomorphism__a).srapply(isequiv_adjointify_b).{refine(essinj(group_precompBeta2)(x:=a$ob) (y:=Id(A:=Group)B)_).introsx;cbnin*.refine(_@acx).applyap,bc. }{refine(essinj(group_precompAeta1)(x:=b$oa) (y:=Id(A:=Group)A)_).introsx;cbnin*.refine(_@bcx).applyap,ac. }Defined.Theoremhomotopic_isabelianization{G:Group} (AB:AbGroup)(eta1:GroupHomomorphismGA) (eta2:GroupHomomorphismGB){isab1:IsAbelianizationAeta1} {isab2:IsAbelianizationBeta2}:eta2==grp_homo_compose(groupiso_isabelianizationABeta1eta2)eta1.Proof.introsx.exact(((esssurj(group_precompBeta1)eta2).2x)^).Defined.Hence any abelianization is surjective.Global Instanceissurj_isabelianization{G:Group}(A:AbGroup) (eta:GroupHomomorphismGA):IsAbelianizationAeta->IsSurjectioneta.Proof.introsk.pose(homotopic_isabelianizationA(abelG)etaabel_unit)asp.exact(@cancelL_isequiv_conn_map_______(conn_map_homotopic___p_)).Defined.Global Instanceisabelianization_identity(A:AbGroup) :IsAbelianizationAgrp_homo_id.Proof.introsB.constructor.-introsh;exact(h;fun_=>idpath).-introsghp;exactp.Defined.Global Instanceisequiv_abgroup_abelianization(AB:AbGroup) (eta:GroupHomomorphismAB) {isab:IsAbelianizationBeta}:IsEquiveta.Proof.srapplyisequiv_homotopic.-srapply(groupiso_isabelianizationABgrp_homo_ideta).-exact_.-symmetry;applyhomotopic_isabelianization.Defined.FunctorialityGlobal Instanceis0functor_abel:Is0Functorabel.Proof.snrapplyBuild_Is0Functor.introsABf.snrapplygrp_homo_abel_rec.exact(abel_unit$of).Defined.Global Instanceis1functor_abel:Is1Functorabel.Proof.snrapplyBuild_Is1Functor.-introsABfgp.unfoldabel.rapplyAbel_ind_hprop.introsx.exact(apabel_in(px)).-introsA.byrapplyAbel_ind_hprop.-introsABCfg.byrapplyAbel_ind_hprop.Defined.

--- Algebra\Algebra.html ---
AlgebraLibrary AlgebraThis file definesAlgebra, which is a generalization of group,
    ring, module, etc. AnAlgebramoreover generalizes structures
    with infinitary operations, such as infinite complete lattice.LocalUnsetEliminationSchemes.RequireExportHoTT.Basics.RequireImportHoTT.Types.Declare ScopeAlgebra_scope.DelimitScopeAlgebra_scopewithAlgebra.The below definitionSymbolTypeOfis used to specify algebra
    operations. SeeSymbolTypeandOperationbelow.RecordSymbolTypeOf{Sort:Type} :=Build_SymbolTypeOf{Arity:Type;sorts_dom:Arity->Sort;sort_cod:Sort}.ArgumentsSymbolTypeOf:clearimplicits.ArgumentsBuild_SymbolTypeOf{Sort}.ASignatureis used to specifyAlgebras. A signature describes
    which operations (functions) an algebra for the signature is
    expected to provide. A signature consists ofA type ofSorts. An algebra for the signature provides
      a type for eachSortelement.A type of function symbolsSymbol. For each function symbolu:Symbol, an algebra for the signature provides a
      corresponding operation.The fieldsymbol_typesσuindicates which type the operation
      corresponding touis expected to have.RecordSignature:=Build_Signature{Sort:Type;Symbol:Type;symbol_types:Symbol->SymbolTypeOfSort;hset_sort:IsHSetSort;hset_symbol:IsHSetSymbol}.NotationSymbolTypeσ := (SymbolTypeOf(Sortσ)).Global Existing Instancehset_sort.Global Existing Instancehset_symbol.Global Coercionsymbol_types:Signature>->Funclass.EachAlgebrahas a collection of carrier typesCarriersσ,
    indexed by the type of sortsSortσ.NotationCarriersσ := (Sortσ ->Type).GivenA:Carriersσandw:SymbolTypeσ, the domain of an
    algebra operationDomOperationAwis a product of carrier types
    fromA, indexed byArityw.NotationDomOperationAw:= (foralli:Arityw,A(sorts_domwi)) (onlyparsing).Given a symbol typew:SymbolTypeσ, an algebra with carriersA:Carriersσprovides a corresponding operation of typeOperationAw. See below for definitionAlgerba.Algebra operations are developed further inHoTT.Algebra.Universal.Operation.DefinitionOperation{σ} (A:Carriersσ) (w:SymbolTypeσ) :Type:=DomOperationAw->A(sort_codw).AnAlgebraσfor a signatureσconsists of a collection of
    carriersCarriersσ, and for each symbolu:Symbolσ, an
    operation/function of typeOperationcarriers(σu),
    whereσu:SymbolTypeσis the symbol type ofu.
    Notice thatAlgebradoes not specify equations involving
    carriers and operations. Equations are defined elsewhere.RecordAlgebra{σ :Signature} :Type:=Build_Algebra{carriers:Carriersσ;operations:forall(u:Symbolσ),Operationcarriers(σu);hset_algebra:forall(s:Sortσ),IsHSet(carrierss) }.ArgumentsAlgebra:clearimplicits.ArgumentsBuild_Algebra{σ}carriersoperations{hset_algebra}.Global Existing Instancehset_algebra.Global Coercioncarriers:Algebra>->Funclass.Bind ScopeAlgebra_scopewithAlgebra.DefinitionSigAlgebra(σ :Signature) :Type:= {c:Carriersσ| {_:forall(u:Symbolσ),Operationc(σu)|forall(s:Sortσ),IsHSet(cs) } }.Lemmaissig_algebra(σ :Signature) :SigAlgebraσ <~>Algebraσ.Proof.issig.Defined.Lemmapath_algebra`{Funext} {σ :Signature} (AB:Algebraσ)(p:carriersA=carriersB)(q:transport(funi=>forallu,Operationi(σu))p(operationsA)=operationsB):A=B.Proof.apply(ap(issig_algebraσ)^-1)^-1;cbn.apply(path_sigma'_p).refine(transport_sigmap_@_).applypath_sigma_hprop.exactq.Defined.Argumentspath_algebra{_} {_} (AB)%_Algebra_scope(pq)%_path_scope.Lemmapath_ap_carriers_path_algebra`{Funext} {σ} (AB:Algebraσ)(p:carriersA=carriersB)(q:transport(funi=>forallu,Operationi(σu))p(operationsA)=operationsB):apcarriers(path_algebraABpq) =p.Proof.destructAas[Aaha],Bas[Bbhb];cbninp,q.destructp,q.unfoldpath_algebra,path_sigma_hprop,path_sigma_uncurried.cbn-[center].bydestruct(center(ha=hb)).Defined.Argumentspath_ap_carriers_path_algebra{_} {_} (AB)%_Algebra_scope(pq)%_path_scope.Lemmapath_path_algebra_issig{σ :Signature} {AB:Algebraσ} (pq:A=B)(r:ap(issig_algebraσ)^-1p=ap(issig_algebraσ)^-1q):p=q.Proof.set(e:= (equiv_ap(issig_algebraσ)^-1AB)).byapply(@equiv_inv__(ape) (Equivalences.isequiv_ap__)).Defined.Argumentspath_path_algebra_issig{_} {AB}%_Algebra_scope(pqr)%_path_scope.Lemmapath_path_algebra`{Funext} {σ} {AB:Algebraσ}(pq:A=B) (r:apcarriersp=apcarriersq):p=q.Proof.applypath_path_algebra_issig.unshelveeapplypath_path_sigma.-transitivity(apcarriersp); [bydestructp|].transitivity(apcarriersq); [exactr|bydestructq].-applypath_ishprop.Defined.Argumentspath_path_algebra{_} {σ} {AB}%_Algebra_scope(pqr)%_path_scope.Global Notation"u .# A" := (operationsAu) :Algebra_scope.

--- Algebra\Groups.html ---
groupsLibrary groupsRequireImportHoTT.Classes.interfaces.abstract_algebra.Local OpenScopemc_mult_scope.Generalizable VariablesGHABCfg.Sectiongroup_props.Context`{IsGroupG}.Group inverses are involutiveGlobal Instancenegate_involutive:Involutive(-).Proof.introsx.transitivity(mon_unit*x).2:applyleft_identity.transitivity((- -x* -x) *x).2:apply(@ap__(funy=>y*x)),left_inverse.transitivity(- -x* (-x*x)).2:applyassociativity.transitivity(- -x*mon_unit).2:applyap,symmetry,left_inverse.applysymmetry,right_identity.Qed.Global Instanceisinj_group_negate:IsInjective(-).Proof.introsxyE.refine((involutivex)^ @_@involutivey).applyap,E.Qed.Lemmanegate_mon_unit: -mon_unit=mon_unit.Proof.change((funx=> -mon_unit=x)mon_unit).apply(transport_(left_inversemon_unit)).applysymmetry,right_identity.Qed.Global Instancegroup_cancelL:forallz:G,LeftCancellation(.*.)z.Proof.introszxyE.rhs_Vrapplyleft_identity.rhs_Vrapply(ap(.*y) (left_inversez)).rhs_Vrapplysimple_associativity.rhs_Vrapply(ap(-z*.)E).symmetry.lhsrapplysimple_associativity.lhsrapply(ap(.*x) (left_inversez)).applyleft_identity.Defined.Global Instancegroup_cancelR:forallz:G,RightCancellation(.*.)z.Proof.introszxyE.rewrite<-(right_identityx).rewrite<-(right_inverse(unit:=mon_unit)z).rewriteassociativity.rewriteE.rewrite<-(associativityy),right_inverse,right_identity.reflexivity.Qed.Lemmanegate_sg_opxy: - (x*y) = -y* -x.Proof.rewrite<- (left_identity(-y* -x)).rewrite<- (left_inverse(unit:=mon_unit) (x*y)).rewrite<-simple_associativity.rewrite<-simple_associativity.rewrite(associativityy).rewriteright_inverse.rewrite(left_identity(-x)).rewriteright_inverse.applysymmetry,right_identity.Qed.Endgroup_props.Sectionabgroup_props.Lemmanegate_sg_op_distr`{IsAbGroupG}xy: -(x*y) = -x* -y.Proof.path_via(-y* -x).-applynegate_sg_op.-applycommutativity.Qed.Endabgroup_props.Sectiongroupmor_props.Context`{IsGroupA} `{IsGroupB} {f:A->B} `{!IsMonoidPreservingf}.Lemmapreserves_negatex:f(-x) = -fx.Proof.apply(left_cancellation(.*.) (fx)).rewrite<-preserves_sg_op.rewrite2!right_inverse.applypreserves_mon_unit.Qed.Endgroupmor_props.Sectionfrom_another_sg.Context`{IsSemiGroupA} `{IsHSetB}`{Bop:SgOpB} (f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x*y) =fx*fy).Lemmaprojected_sg:IsSemiGroupB.Proof.split.-apply_.-repeatintro;apply(injectivef).rewrite!op_correct.applyassociativity.Qed.Endfrom_another_sg.Sectionfrom_another_com.Context`{SgOpA} `{!Commutative(A:=A)sg_op} {B}`{Bop:SgOpB} (f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x*y) =fx*fy).Lemmaprojected_comm:Commutative(A:=B)sg_op.Proof.introsxy.apply(injectivef).rewrite2!op_correct.applycommutativity.Qed.Endfrom_another_com.Sectionfrom_another_com_sg.Context`{IsCommutativeSemiGroupA} `{IsHSetB}`{Bop:SgOpB} (f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x*y) =fx*fy).Lemmaprojected_com_sg:IsCommutativeSemiGroupB.Proof.split.-apply(projected_sgf);assumption.-apply(projected_commf);assumption.Qed.Endfrom_another_com_sg.Sectionfrom_another_monoid.Context`{IsMonoidA} `{IsHSetB}`{Bop:SgOpB} `{Bunit:MonUnitB} (f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x*y) =fx*fy) (unit_correct:fmon_unit=mon_unit).Lemmaprojected_monoid:IsMonoidB.Proof.split.-apply(projected_sgf).assumption.-repeatintro;apply(injectivef).rewriteop_correct,unit_correct,left_identity.reflexivity.-repeatintro;apply(injectivef).rewriteop_correct,unit_correct,right_identity.reflexivity.Qed.Endfrom_another_monoid.Sectionfrom_another_com_monoid.Context`{IsCommutativeMonoidA} `{IsHSetB}`{Bop:SgOpB} `{Bunit:MonUnitB} (f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x*y) =fx*fy)(unit_correct:fmon_unit=mon_unit).Lemmaprojected_com_monoid:IsCommutativeMonoidB.Proof.split.-apply(projected_monoidf);assumption.-apply(projected_commf);assumption.Qed.Endfrom_another_com_monoid.Sectionfrom_another_group.Context`{IsGroupA} `{IsHSetB}`{Bop:SgOpB} `{Bunit:MonUnitB} `{Bnegate:NegateB}(f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x*y) =fx*fy)(unit_correct:fmon_unit=mon_unit)(negate_correct:forallx,f(-x) = -fx).Lemmaprojected_group:IsGroupB.Proof.split.-apply(projected_monoidf);assumption.-repeatintro;apply(injectivef).rewriteop_correct,negate_correct,unit_correct,left_inverse.applyreflexivity.-repeatintro;apply(injectivef).rewriteop_correct,negate_correct,unit_correct,right_inverse.reflexivity.Qed.Endfrom_another_group.Sectionfrom_another_ab_group.Context`{IsAbGroupA} `{IsHSetB}`{Bop:SgOpB} `{Bunit:MonUnitB} `{Bnegate:NegateB}(f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x*y) =fx*fy)(unit_correct:fmon_unit=mon_unit)(negate_correct:forallx,f(-x) = -fx).Lemmaprojected_ab_group:IsAbGroupB.Proof.split.-apply(projected_groupf);assumption.-apply(projected_commf);assumption.Qed.Endfrom_another_ab_group.

--- Algebra\Rings.html ---
ringsLibrary ringsRequireImportHoTT.Classes.theory.groupsHoTT.Classes.theory.apartness.RequireImportHoTT.Classes.interfaces.abstract_algebra.Generalizable VariablesRABCfz.Definitionis_ne_0`(x:R) `{ZeroR} `{p:PropHolds(x<> 0)}:x<> 0 :=p.Definitionis_nonneg`(x:R) `{LeR} `{ZeroR} `{p:PropHolds(0 ≤x)}: 0 ≤x:=p.Definitionis_pos`(x:R) `{LtR} `{ZeroR} `{p:PropHolds(0 <x)}: 0 <x:=p.(* Lemma stdlib_semiring_theory R `{SemiRing R}: Ring_theory.semi_ring_theory 0 1 (+) (.*.) (=).Proof.Qed.*)(* We cannot applyleft_cancellation(.*.)zdirectly in case we havenoPropHolds(0<>z)instance in the context. *)Sectioncancellation.Context`(op:A->A->A) `{!ZeroA}.Lemmaleft_cancellation_ne_0`{forallz,PropHolds(z<> 0) ->LeftCancellationopz}z:z<> 0 ->LeftCancellationopz.Proof.auto.Qed.Lemmaright_cancellation_ne_0`{forallz,PropHolds(z<> 0) ->RightCancellationopz}z:z<> 0 ->RightCancellationopz.Proof.auto.Qed.Lemmaright_cancel_from_left`{!Commutativeop} `{!LeftCancellationopz}:RightCancellationopz.Proof.introsxyE.apply(left_cancellationopz).rewrite2!(commutativity(f:=op)z_).assumption.Qed.Endcancellation.Sectionstrong_cancellation.Context`{IsApartA} (op:A->A->A).Lemmastrong_right_cancel_from_left`{!Commutativeop}`{!StrongLeftCancellationopz}:StrongRightCancellationopz.Proof.introsxyE.rewrite2!(commutativity_z).apply(strong_left_cancellationopz);trivial.Qed.Global Instancestrong_left_cancellation_cancel`{!StrongLeftCancellationopz}:LeftCancellationopz| 20.Proof.introsxyE1.applytight_apartinE1;applytight_apart;introsE2.applyE1.apply(strong_left_cancellationop);trivial.Qed.Global Instancestrong_right_cancellation_cancel`{!StrongRightCancellationopz}:RightCancellationopz| 20.Proof.introsxyE1.applytight_apartinE1;applytight_apart;introsE2.applyE1.apply(strong_right_cancellationop);trivial.Qed.Endstrong_cancellation.Sectionsemiring_props.Context`{IsSemiCRingR}.(*   Add Ring SR : (stdlib_semiring_theory R). *)Instancemult_ne_0`{!NoZeroDivisorsR}xy:PropHolds(x<> 0) ->PropHolds(y<> 0) ->PropHolds(x*y<> 0).Proof.introsExEyExy.unfoldPropHoldsin*.apply(no_zero_divisorsx);split;eauto.Qed.Global Instanceplus_0_r:RightIdentity(+) 0 :=right_identity.Global Instanceplus_0_l:LeftIdentity(+) 0 :=left_identity.Global Instancemult_1_l:LeftIdentity(.*.) 1 :=left_identity.Global Instancemult_1_r:RightIdentity(.*.) 1 :=right_identity.Global Instanceplus_assoc:Associative(+) :=simple_associativity.Global Instancemult_assoc:Associative(.*.) :=simple_associativity.Global Instanceplus_comm:Commutative(+) :=commutativity.Global Instancemult_comm:Commutative(.*.) :=commutativity.Global Instancemult_0_l:LeftAbsorb(.*.) 0 :=left_absorb.Global Instancemult_0_r:RightAbsorb(.*.) 0.Proof.intro.path_via(0 *x).-applymult_comm.-applyleft_absorb.Qed.Global Instanceplus_mult_distr_r:RightDistribute(.*.) (+).Proof.introsxyz.etransitivity;[|etransitivity].-applymult_comm.-applydistribute_l.-applyap011;applymult_comm.Qed.Lemmaplus_mult_distr_l:LeftDistribute(.*.) (+).Proof.apply_.Qed.Global Instance:forallr:R, @IsMonoidPreservingRR(+) (+) 0 0 (r*.).Proof.repeat(constructor;tryapply_).-red.applydistribute_l.-applyright_absorb.Qed.Endsemiring_props.(* Due to bug 2528 *)#[export]HintExtern3 (PropHolds(_*_<> 0)) =>eapply@mult_ne_0:typeclass_instances.Sectionsemiringmor_props.Context`{IsSemiRingPreservingABf}.Lemmapreserves_0:f0 = 0.Proof.applypreserves_mon_unit.Qed.Lemmapreserves_1:f1 = 1.Proof.applypreserves_mon_unit.Qed.Lemmapreserves_mult:forallxy,f(x*y) =fx*fy.Proof.intros.applypreserves_sg_op.Qed.Lemmapreserves_plus:forallxy,f(x+y) =fx+fy.Proof.intros.applypreserves_sg_op.Qed.Lemmapreserves_2:f2 = 2.Proof.rewritepreserves_plus.rewritepreserves_1.reflexivity.Qed.Lemmapreserves_3:f3 = 3.Proof.rewrite?preserves_plus, ?preserves_1.reflexivity.Qed.Lemmapreserves_4:f4 = 4.Proof.rewrite?preserves_plus, ?preserves_1.reflexivity.Qed.Context`{!IsInjectivef}.Instanceisinjective_ne_0x:PropHolds(x<> 0) ->PropHolds(fx<> 0).Proof.intros.rewrite<-preserves_0.apply(neq_isinjf).assumption.Qed.Lemmainjective_ne_1x:x<> 1 ->fx<> 1.Proof.intros.rewrite<-preserves_1.apply(neq_isinjf).assumption.Qed.Endsemiringmor_props.(* Due to bug 2528 *)#[export]HintExtern12 (PropHolds(__<> 0)) =>eapply@isinjective_ne_0:typeclass_instances.(* Lemma stdlib_ring_theory R `{Ring R} :Ring_theory.ring_theory 0 1 (+) (.*.) (fun x y => x - y) (-) (=).Proof.Qed.*)Sectioncring_props.Context`{IsCRingR}.Instance:LeftAbsorb(.*.) 0.Proof.intro.rewrite(commutativity(f:=(.*.)) 0).apply(left_cancellation(+) (y* 0)).path_via(y* 0);[|applysymmetry,right_identity].path_via(y* (0 + 0)).-applysymmetry,distribute_l.-applyap.applyright_identity.Qed.Global InstanceCRing_Semi:IsSemiCRingR.Proof.repeat(constructor;tryapply_).Qed.Endcring_props.Sectionring_props.Context`{IsRingR}.Global Instancemult_left_absorb:LeftAbsorb(.*.) 0.Proof.introy.rapply(right_cancellation(+) (0 *y)).lhs_Vrapplysimple_distribute_r.rhsrapplyleft_identity.nrapply(ap(.*y)).applyleft_identity.Defined.Global Instancemult_right_absorb:RightAbsorb(.*.) 0.Proof.introx.rapply(right_cancellation(+) (x* 0)).lhs_Vrapplysimple_distribute_l.rhsrapplyleft_identity.nrapply(ap(x*.)).applyleft_identity.Defined.Definitionnegate_involutivex: - -x=x:=groups.negate_involutivex.(* alias for convenience *)Lemmaplus_negate_r:forallx,x+ -x= 0.Proof.exactright_inverse.Qed.Lemmaplus_negate_l:forallx, -x+x= 0.Proof.exactleft_inverse.Qed.Lemmanegate_swap_r:forallxy,x-y= -(y-x).Proof.intros.rewritegroups.negate_sg_op.rewriteinvolutive.reflexivity.Qed.Lemmanegate_swap_lxy: -x+y= -(x-y).Proof.rewritegroups.negate_sg_op_distr,involutive.reflexivity.Qed.Lemmanegate_plus_distr:forallxy, -(x+y) = -x+ -y.Proof.exactgroups.negate_sg_op_distr.Qed.Lemmanegate_mult_lx: -x= - 1 *x.Proof.apply(left_cancellation(+)x).path_via0.-applyright_inverse.-path_via(1 *x+ (- 1) *x).+applysymmetry.rewrite<-distribute_r.rewriteright_inverse.applyleft_absorb.+applyap011;tryreflexivity.applyleft_identity.Qed.Lemmanegate_mult_rx: -x=x* -1.Proof.apply(right_cancellation(+)x).transitivity(x* -1 +x* 1).-lhsapplyleft_inverse.rhs_Vrapplysimple_distribute_l.lhs_Vrapply(right_absorbx).apply(ap(x*.)).symmetry.applyleft_inverse.-f_ap.applyright_identity.Defined.Lemmanegate_mult_distr_lxy: -(x*y) = -x*y.Proof.lhsnrapplynegate_mult_l.lhsrapply(simple_associativity(f:= (.*.)) (-1)xy).apply(ap(.*y)).symmetry.applynegate_mult_l.Defined.Lemmanegate_mult_distr_rxy: -(x*y) =x* -y.Proof.lhsnrapplynegate_mult_r.lhs_Vrapply(simple_associativity(f:= (.*.))xy).apply(ap(x*.)).symmetry.applynegate_mult_r.Defined.Lemmanegate_mult_negatexy: -x* -y=x*y.Proof.rewrite<-negate_mult_distr_l, <-negate_mult_distr_r.applyinvolutive.Qed.Lemmanegate_0: -0 = 0.Proof.exactgroups.negate_mon_unit.Qed.Global Instanceminus_0_r:RightIdentity(funxy=>x-y) 0.Proof.introx;rewritenegate_0.applyright_identity.Qed.Lemmaequal_by_zero_sumxy:x-y= 0 <->x=y.Proof.split;introsE.-rewrite<- (left_identityy).change(sg_op?x?y)with(0 +y).rewrite<-E.rewrite<-simple_associativity.rewriteleft_inverse.applysymmetry,right_identity.-rewriteE.applyright_inverse.Qed.Lemmaflip_negatexy: -x=y<->x= -y.Proof.split;introsE.-rewrite<-E,involutive.trivial.-rewriteE,involutive.trivial.Qed.Lemmaflip_negate_0x: -x= 0 <->x= 0.Proof.etransitivity.-applyflip_negate.-rewritenegate_0.applyreflexivity.Qed.Lemmaflip_negate_ne_0x: -x<> 0 <->x<> 0.Proof.split;introsE?;applyE;applyflip_negate_0;trivial.path_viax.applyinvolutive.Qed.Lemmanegate_zero_prod_lxy: -x*y= 0 <->x*y= 0.Proof.split;introsE.-apply(injective(-)).rewritenegate_mult_distr_l,negate_0.trivial.-apply(injective(-)).rewritenegate_mult_distr_l,negate_involutive,negate_0.trivial.Qed.Lemmanegate_zero_prod_rxy:x* -y= 0 <->x*y= 0.Proof.etransitivity.2:applynegate_zero_prod_l.split.-introsE.lhs_Vnrapplynegate_mult_distr_l.lhsnrapplynegate_mult_distr_r.exactE.-introsE.lhs_Vnrapplynegate_mult_distr_r.lhsnrapplynegate_mult_distr_l.exactE.Defined.Context`{!NoZeroDivisorsR} `{forallxy:R,Stable(x=y)}.Global Instancemult_left_cancel:forallz,PropHolds(z<> 0) ->LeftCancellation(.*.)z.Proof.introszz_nonzeroxyE.applystable.introU.apply(mult_ne_0z(x-y) (is_ne_0z)).-intro.applyU.applyequal_by_zero_sum.trivial.-rewritedistribute_l,E.rewrite<-simple_distribute_l,right_inverse.applyright_absorb.Qed.Instancemult_ne_0'`{!NoZeroDivisorsR}xy:PropHolds(x<> 0) ->PropHolds(y<> 0) ->PropHolds(x*y<> 0).Proof.introsExEyExy.unfoldPropHoldsin*.apply(no_zero_divisorsx);split;eauto.Qed.Global Instancemult_right_cancel:forallz,PropHolds(z<> 0) ->RightCancellation(.*.)z.Proof.introsz?xyp.applystable.introU.nrapply(mult_ne_0'(x-y)z).-exact_.-introsr.applyU,equal_by_zero_sum,r.-exact_.-lhsrapplyring_dist_right.rewrite<-negate_mult_distr_l.applyequal_by_zero_suminp.exactp.Defined.Lemmaplus_conjugatexy:x=y+x-y.Proof.rewrite(commutativity(f:= (+))yx),<- (simple_associativity(f:= (+))xy(-y)),right_inverse,right_identity.reflexivity.Qed.Lemmaplus_conjugate_altxy:x=y+ (x-y).Proof.rewrite(simple_associativity(f:= (+))).applyplus_conjugate.Qed.Endring_props.Sectionintegral_domain_props.Context`{IsIntegralDomainR}.Instanceintdom_nontrivial_apart`{ApartR} `{!TrivialApartR} :PropHolds(1 ≶ 0).Proof.applyapartness.ne_apart.solve_propholds.Qed.Endintegral_domain_props.(* Due to bug 2528 *)#[export]HintExtern6 (PropHolds(1 ≶ 0)) =>eapply@intdom_nontrivial_apart:typeclass_instances.Sectionringmor_props.Context`{IsRingA} `{IsRingB} `{!IsSemiRingPreserving(f:A->B)}.Definitionpreserves_negatex:f(-x) = -fx:=groups.preserves_negatex.(* alias for convenience *)Lemmapreserves_minusxy:f(x-y) =fx-fy.Proof.rewrite<-preserves_negate.applypreserves_plus.Qed.Lemmainjective_preserves_0: (forallx,fx= 0 ->x= 0) ->IsInjectivef.Proof.introsE1xyE.applyequal_by_zero_sum.applyE1.rewritepreserves_minus,E.applyright_inverse.Qed.Endringmor_props.Sectionfrom_another_ring.Context`{IsCRingA} `{IsHSetB}`{Bplus:PlusB} `{ZeroB} `{Bmult:MultB} `{OneB} `{Bnegate:NegateB}(f:B->A) `{!IsInjectivef}(plus_correct:forallxy,f(x+y) =fx+fy) (zero_correct:f0 = 0)(mult_correct:forallxy,f(x*y) =fx*fy) (one_correct:f1 = 1)(negate_correct:forallx,f(-x) = -fx).Lemmaprojected_ring:IsCRingB.Proof.split.-apply(groups.projected_ab_groupf);assumption.-apply(groups.projected_com_monoidfmult_correctone_correct);assumption.-repeatintro;apply(injectivef).rewriteplus_correct, !mult_correct,plus_correct.applydistribute_l.Qed.Endfrom_another_ring.(* Section from_stdlib_semiring_theory.Context`(H: @semi_ring_theory R Rzero Rone Rplus Rmult Re)`{!@Setoid R Re}`{!Proper (Re ==> Re ==> Re) Rplus}`{!Proper (Re ==> Re ==> Re) Rmult}.Add Ring R2: H.Definition from_stdlib_semiring_theory: @SemiRing R Re Rplus Rmult Rzero Rone.Proof.repeat (constructor; try assumption); repeat intro; unfold equiv, mon_unit, sg_op, zero_is_mon_unit, plus_is_sg_op,one_is_mon_unit, mult_is_sg_op, zero, mult, plus; ring.Qed.End from_stdlib_semiring_theory.Section from_stdlib_ring_theory.Context`(H: @ring_theory R Rzero Rone Rplus Rmult Rminus Rnegate Re)`{!@Setoid R Re}`{!Proper (Re ==> Re ==> Re) Rplus}`{!Proper (Re ==> Re ==> Re) Rmult}`{!Proper (Re ==> Re) Rnegate}.Add Ring R3: H.Definition from_stdlib_ring_theory: @Ring R Re Rplus Rmult Rzero Rone Rnegate.Proof.repeat (constructor; try assumption); repeat intro; unfold equiv, mon_unit, sg_op, zero_is_mon_unit, plus_is_sg_op,one_is_mon_unit, mult_is_sg_op, mult, plus, negate; ring.Qed.End from_stdlib_ring_theory. *)Global Instanceid_sr_morphism`{IsSemiCRingA}:IsSemiRingPreserving(@idA) := {}.Sectionmorphism_composition.Context`{MultA} `{PlusA} `{OneA} `{ZeroA}`{MultB} `{PlusB} `{OneB} `{ZeroB}`{MultC} `{PlusC} `{OneC} `{ZeroC}(f:A->B) (g:B->C).Instancecompose_sr_morphism:IsSemiRingPreservingf->IsSemiRingPreservingg->IsSemiRingPreserving(g∘f).Proof.split;apply_.Qed.Instanceinvert_sr_morphism:forall`{!IsEquivf},IsSemiRingPreservingf->IsSemiRingPreserving(f^-1).Proof.split;apply_.Qed.Endmorphism_composition.#[export]HintExtern4 (IsSemiRingPreserving(_∘_)) =>class_apply@compose_sr_morphism:typeclass_instances.#[export]HintExtern4 (IsSemiRingPreserving(_^-1)) =>class_apply@invert_sr_morphism:typeclass_instances.

--- Basics\Basics.html ---
BasicsLibrary BasicsRequireExportBasics.Overture.RequireExportBasics.PathGroupoids.RequireExportBasics.Contractible.RequireExportBasics.Equivalences.RequireExportBasics.Trunc.RequireExportBasics.Decidable.RequireExportBasics.Utf8.RequireExportBasics.Notations.RequireExportBasics.Tactics.RequireExportBasics.Classes.RequireExportBasics.Iff.RequireExportBasics.Nat.RequireExportBasics.Numeral.

--- Basics\Overture.html ---
OvertureLibrary OvertureBasic definitions of homotopy type theoryThis file defines some of the most basic types and type formers, such as sums, products, Sigma types and path types.  It defines the action of functions on pathsap, transport, equivalences, and function extensionality.  It also defines truncatedness, and a number of other fundamental definitions used throughout the library.Import the file of reserved notations so we maintain consistent level notations throughout the library.RequireExportBasics.SettingsBasics.Notations.LocalSetPolymorphicInductiveCumulativity.This command prevents Coq from automatically defining the eliminator functions for inductive types.  We will define them ourselves to match the naming scheme of the HoTT Book.  In principle we ought to make thisGlobal, but unfortunately the tacticsinductionandelimassume that the eliminators are named in Coq's way, e.g.thing_rect, so making it global could cause unpleasant surprises for people defining new inductive types.  However, when you do define your own inductive types you are encouraged to also doLocalUnsetEliminationSchemesand then useSchemeto definething_ind,thing_rec, and (for compatibility withinductionandelim)thing_rect, as we have done below forpaths,Empty,Unit, etc.  We are hoping that this will be fixed eventually; see https://github.com/coq/coq/issues/3745.LocalUnsetEliminationSchemes.DatatypesFunctionsNotation for non-dependent function typesNotation"A -> B" := (forall(_:A),B) :type_scope.Option typeoptionAis the extension ofAwith an extra elementNoneInductiveoption(A:Type) :Type:=|Some:A->optionA|None:optionA.Schemeoption_rect:=InductionforoptionSortType.ArgumentsSome{A}a.ArgumentsNone{A}.Registeroptionascore.option.type.Sum typesumAB, writtenA+B, is the disjoint sum ofAandBInductivesum(AB:Type) :Type:=|inl:A->sumAB|inr:B->sumAB.Schemesum_rect:=InductionforsumSortType.Schemesum_ind:=InductionforsumSortType.Argumentssum_ind{AB}Pfg:rename.Notation"x + y" := (sumxy) :type_scope.Argumentsinl{AB}_, [A]B_.Argumentsinr{AB}_,A[B]_.(* A notation for coproduct that's less overloaded than+*)Notation"x |_| y" := (sumxy) (onlyparsing) :type_scope.Product typeprodAB, writtenA*B, is the product ofAandB;
    the pairpairABabofaandbis abbreviated(a,b)Recordprod(AB:Type) :=pair{fst:A;snd:B}.Schemeprod_rect:=InductionforprodSortType.Schemeprod_ind:=InductionforprodSortType.Argumentsprod_ind{AB}P_.Argumentspair{AB}__.Argumentsfst{AB}_/ .Argumentssnd{AB}_/ .AddPrintingLetprod.Notation"x * y" := (prodxy) :type_scope.Notation"( x , y , .. , z )" := (pair.. (pairxy) ..z) :core_scope.Notation"A /\ B" := (prodAB) (onlyparsing) :type_scope.Notationand:=prod(onlyparsing).Notationconj:=pair(onlyparsing).#[export]HintResolvepairinlinr:core.Type classesThis command prevents Coq from trying to guess the values of existential variables while doing typeclass resolution.  If you don't know what that means, ignore it.LocalSetTypeclassesStrictResolution.DefinitionRelation(A:Type) :=A->A->Type.ClassReflexive{A} (R:RelationA) :=reflexivity:forallx:A,Rxx.ClassSymmetric{A} (R:RelationA) :=symmetry:forallxy,Rxy->Ryx.ClassTransitive{A} (R:RelationA) :=transitivity:forallxyz,Rxy->Ryz->Rxz.APreOrderis both Reflexive and Transitive.ClassPreOrder{A} (R:RelationA) :={PreOrder_Reflexive:ReflexiveR| 2 ;PreOrder_Transitive:TransitiveR| 2 }.Global Existing InstancePreOrder_Reflexive.Global Existing InstancePreOrder_Transitive.Argumentsreflexivity{AR_} /_.Argumentssymmetry{AR_} /___.Argumentstransitivity{AR_} / {___}__.Above, we have madereflexivity,symmetry, andtransitivityreduce undercbn/simplto their underlying instances.  This allows the tactics to build proof terms referencing, e.g.,concat.  We usechangeafter the fact to make sure that we didn'tcbnaway the original form of the relation.If we want to remove the use ofcbn, we can play tricks withModuleTypes andModules to declareinversedirectly as an instance ofSymmetricwithout changing its type.  Then we can simplyunfoldsymmetry.  See the comments around the definition ofinverse.Overwritereflexivityso that we use our version ofReflexiverather than having the tactic look for it in the standard library.  We make use of the built-in reflexivity to handle, e.g., single-constructor inductives.Ltacold_reflexivity:=reflexivity.Tactic Notation"reflexivity" :=old_reflexivity|| (intros;letR:=matchgoalwith|- ?R?x?y=>constr:(R)endinletpre_proof_term_head:=constr:(@reflexivity_R_)inletproof_term_head:= (evalcbninpre_proof_term_head)inapply(proof_term_head:forallx,Rxx)).Even if we weren't usingcbn, we would have to redefine symmetry, since the built-in Coq version is sometimes too smart for its own good, and will occasionally fail when it should not.Tactic Notation"symmetry" :=letR:=matchgoalwith|- ?R?x?y=>constr:(R)endinletx:=matchgoalwith|- ?R?x?y=>constr:(x)endinlety:=matchgoalwith|- ?R?x?y=>constr:(y)endinletpre_proof_term_head:=constr:(@symmetry_R_)inletproof_term_head:= (evalcbninpre_proof_term_head)inrefine(proof_term_headyx_);change(Ryx).Tactic Notation"etransitivity"open_constr(y) :=letR:=matchgoalwith|- ?R?x?z=>constr:(R)endinletx:=matchgoalwith|- ?R?x?z=>constr:(x)endinletz:=matchgoalwith|- ?R?x?z=>constr:(z)endinletpre_proof_term_head:=constr:(@transitivity_R_)inletproof_term_head:= (evalcbninpre_proof_term_head)inrefine(proof_term_headxyz__); [change(Rxy) |change(Ryz) ].Tactic Notation"etransitivity" :=etransitivity_.We redefinetransitivityto work without needing to includeSetoidor be using Leibniz equality, and to give proofs that unfold toconcat.Tactic Notation"transitivity"constr(x) :=etransitivityx.Basic definitionsDefine an alias forSet, which is reallyType₀.NotationType0:=Set.We make the identity map a notation so we do not have to unfold it,
    or complicate matters with its type.Notationidmap:= (funx=>x).Constant functionsDefinitionconst{AB} (b:B) :=funx:A=>b.Sigma types(sigAP), or more suggestively{x:A&(Px)}is a Sigma-type.Recordsig{A} (P:A->Type) :=exist{proj1:A;proj2:Pproj1;}.Schemesig_rect:=InductionforsigSortType.Schemesig_ind:=InductionforsigSortType.Schemesig_rec:=MinimalityforsigSortType.Argumentssig_ind{__}.Argumentssig_rec{___}.We make the parameters maximally inserted so that we can pass aroundpr1as a function and have it actually mean "first projection" in, e.g.,ap.Argumentsexist{A}%_typeP%_type__.Argumentsproj1{AP}_/ .Argumentsproj2{AP}_/ .Argumentssig(AP)%_type.Notation"{ x | P }" := (sig(funx=>P)) :type_scope.Notation"{ x : A | P }" := (sig(A:=A) (funx=>P)) :type_scope.Notation"'exists' x .. y , p" := (sig(funx=> .. (sig(funy=>p)) ..)) :type_scope.Notation"{ x : A  & P }" := (sig(funx:A=>P)) :type_scope.This lets us pattern match sigma types in let expressionsAddPrintingLetsig.Registersigascore.sigT.type.Registerexistascore.sigT.intro.Registersig_rectascore.sigT.rect.Registerproj1ascore.sigT.proj1.Registerproj2ascore.sigT.proj2.#[export]HintResolveexist:core.We define notation for dependent pairs because it is too annoying to write and seeexistPxyall the time.  However, we put it in its own scope, because sometimes it is necessary to give the particular dependent type, so we'd like to be able to turn off this notation selectively.Notation"( x ; y )" := (exist_xy) :fibration_scope.Notation"( x ; .. ; y ; z )" := (exist_x.. (exist_yz) ..) :fibration_scope.We bindfibration_scopewithsigso that we are automatically infibration_scopewhen we are passing an argument of typesig.Bind Scopefibration_scopewithsig.Notationpr1:=proj1.Notationpr2:=proj2.The following notation is very convenient, although it unfortunately clashes with Proof General's "electric period".  We have addedformatspecifiers in Notations.v so that it will display without an extra space, asx.1rather than asx.1.Notation"x .1" := (pr1x) :fibration_scope.Notation"x .2" := (pr2x) :fibration_scope.Definitionuncurry{ABC} (f:A->B->C) (p:A*B) :C:=f(fstp) (sndp).Argumentsuncurry{ABC}f%_function_scopep/.Composition of functions.Notationcompose:= (fungfx=>g(fx)).We put the following notation in a scope because leaving it unscoped causes it to override identical notations in other scopes.  It's convenient to use the same notation for, e.g., function composition, morphism composition in a category, and functor composition, and let Coq automatically infer which one we mean by scopes.  We can't do this if this notation isn't scoped.  Unfortunately, Coq doesn't have a built-infunction_scopeliketype_scope;type_scopeis automatically opened wherever Coq is expecting aSort, and it would be nice iffunction_scopewere automatically opened whenever Coq expects a thing of typeforall_,_or_->_.  To work around this, we openfunction_scopeglobally.We allow writing(fog)%functionto forcefunction_scopeover, e.g.,morphism_scope.Notation"g 'o' f" := (composeg%functionf%function) :function_scope.This definition helps guide typeclass inference.DefinitionCompose{ABC:Type} (g:B->C) (f:A->B) :A->C:=composegf.Dependent composition of functions.DefinitioncomposeD{ABC} (g:forallb,Cb) (f:A->B) :=funx:A=>g(fx).Global ArgumentscomposeD{ABC}%_type_scope(gf)%_function_scopex.#[export]HintUnfoldcomposeD:core.Notation"g 'oD' f" := (composeDgf) :function_scope.The groupoid structure of identity types.The results in this file are used everywhere else, so we need to be extra careful about how we define and prove things.  We prefer hand-written terms, or at least tactics that allow us to retain clear control over the proof-term produced.We define our own identity type, rather than using the one in the Coq standard library, so as to have more control over transitivity, symmetry and inverse.  It seems impossible to change these for the standard eq/identity type (or its Type-valued version) because it breaks various other standard things.  Merely changing notations also doesn't seem to quite work.Inductivepaths{A:Type} (a:A) :A->Type:=idpath:pathsaa.Argumentsidpath{Aa} , [A]a.#[export]HintResolveidpath:core.Schemepaths_ind:=InductionforpathsSortType.Argumentspaths_ind[A]aPfyp:rename.Schemepaths_rec:=MinimalityforpathsSortType.Argumentspaths_rec[A]aPfyp:rename.(* See comment above about the tacticinduction. *)Definitionpaths_rect:=paths_ind.Registerpathsascore.identity.type.Registeridpathascore.identity.refl.Registerpaths_rectascore.identity.ind.Notation"x = y :> A" := (@pathsAxy) :type_scope.Notation"x = y" := (x=y:>_) :type_scope.Global Instancereflexive_paths{A} :Reflexive(@pathsA) | 0 := @idpathA.Argumentsreflexive_paths/ .Our identity type is the Paulin-Mohring style.  We derive the Martin-Lof eliminator.Definitionpaths_ind'{A:Type} (P:forall(ab:A), (a=b) ->Type): (forall(a:A),Paaidpath) ->forall(ab:A) (p:a=b),Pabp.Proof.introsH? ? [].applyH.Defined.And here's the "right-sided" Paulin-Mohring eliminator.Definitionpaths_ind_r{A:Type} (a:A)(P:forallb:A,b=a->Type) (u:Paidpath):forall(y:A) (p:y=a),Pyp.Proof.introsyp.destructp.exactu.Defined.We declare a scope in which we shall place path notations. This way they can be turned on and off by the user.We bindpath_scopetopathsso that when we are constructing arguments to things likeconcat, we automatically are inpath_scope.Bind Scopepath_scopewithpaths.Local OpenScopepath_scope.The inverse of a path.Definitioninverse{A:Type} {xy:A} (p:x=y) :y=x:=matchpwithidpath=>idpathend.Registerinverseascore.identity.sym.Declaring this assimplnomatchprevents the tacticsimplfrom expanding it out intomatchstatements.  We only wantinverseto simplify when applied to an identity path.Argumentsinverse{Axy}p:simplnomatch.Global Instancesymmetric_paths{A} :Symmetric(@pathsA) | 0 := @inverseA.Argumentssymmetric_paths/ .If we wanted to not have the constantsymmetric_pathsfloating around, and wanted to resolveinversedirectly, instead, we could play this trick, discovered by Georges Gonthier to fool Coq's restriction onIdentityCoercions:Module Export inverse.
  Definition inverse {A : Type} {x y : A} (p : x = y) : y = x
    := match p with idpath => idpath end.
End inverse.

Module Type inverseT.
  Parameter inverse : forall {A}, Symmetric (@paths A).
End inverseT.

Module inverseSymmetric (inverse : inverseT).
  Global Existing Instance inverse.inverse.
End inverseSymmetric.

Module Export symmetric_paths := inverseSymmetric inverse.We define equality concatenation by destructing on both its arguments, so that it only computes when both arguments areidpath.  This makes proofs more robust and symmetrical.  Compare with the definition ofidentity_trans.Definitionconcat{A:Type} {xyz:A} (p:x=y) (q:y=z) :x=z:=matchp,qwithidpath,idpath=>idpathend.See above for the meaning ofsimplnomatch.Argumentsconcat{Axyz}pq:simplnomatch.Global Instancetransitive_paths{A} :Transitive(@pathsA) | 0 := @concatA.Argumentstransitive_paths/ .Registerconcatascore.identity.trans.Note that you can use the Coq tacticsreflexivity,transitivity,etransitivity, andsymmetrywhen working with paths; we've redefined them above to use typeclasses and to unfold the instances so you get proof terms withconcatandinverse.The identity path.Notation"1" :=idpath:path_scope.The composition of two paths.  We putpandqinpath_scopeexplicitly.  This is a partial work-around for https://coq.inria.fr/bugs/show_bug.cgi?id=3990, which is that implicitly bound scopes don't nest well.Notation"p @ q" := (concatp%pathq%path) :path_scope.The inverse of a path.  See above about explicitly placingpinpath_scope.Notation"p ^" := (inversep%path) :path_scope.An alternative notation which puts each path on its own line, via theformatspecification in Notations.v.  Useful as a temporary device during proofs of equalities between very long composites; to turn it on inside a section, sayOpenScopelong_path_scope.Notation"p @' q" := (concatpq) :long_path_scope.An important instance ofpaths_indis that given any dependent type, one cantransportelements of instances of the type along equalities in the base:transportPputransportsu:PxtoPyalongp:x=y.Definitiontransport{A:Type} (P:A->Type) {xy:A} (p:x=y) (u:Px) :Py:=matchpwithidpath=>uend.See above for the meaning ofsimplnomatch.Argumentstransport{A}%_type_scopeP%_function_scope{xy}p%_path_scopeu:simplnomatch.Transport is very common so it is worth introducing a parsing notation for it.  However, we do not use the notation for output because it hides the fibration, and so makes it very hard to read involved transport expression.Notation"p # u" := (transport_pu) (onlyparsing) :path_scope.The first timerewriteis used in each direction, it creates transport lemmas calledinternal_paths_rewandinternal_paths_rew_r.  See ../Tactics.v for how these compare totransport.  We userewritehere to trigger the creation of these lemmas.  This ensures that they are defined outside of sections, so they are not unnecessarily polymorphic.  The lemmas below are not used in the library.  TODO: If Coq PR18299 is merged (possibly in Coq 8.20), then we can instead register wrappers for [transport] to be used for rewriting.  See the comment by Dan Christensen in that PR for how to do this.  Then the tactics [internal_paths_rew_to_transport] and [rewrite_to_transport] can be removed from ../Tactics.v.Local Lemmadefine_internal_paths_rewAxyP(u:Px) (H:x=y:>A) :Py.Proof.rewrite<-H.exactu.Defined.Local Lemmadefine_internal_paths_rew_rAxyP(u:Py) (H:x=y:>A) :Px.Proof.rewrite->H.exactu.Defined.Argumentsinternal_paths_rew{A%_type_scope} {a}P%_function_scopef{a0}p.Argumentsinternal_paths_rew_r{A%_type_scope} {ay}P%_function_scopeHCX.Having defined transport, we can use it to talk about what a homotopy theorist might see as "paths in a fibration over paths in the base"; and what a type theorist might see as "heterogeneous equality in a dependent type".  We will first see this appearing in the type ofapD.Functions act on paths: iff:A->Bandp:x=yis a path inA, thenapfp:fx=fy.  We typically pronounceapas a single syllable, short for "application"; but it may also be considered as an acronym, "action on paths".Definitionap{AB:Type} (f:A->B) {xy:A} (p:x=y) :fx=fy:=matchpwithidpath=>idpathend.Global Argumentsap{AB}%_type_scopef%_function_scope{xy}p%_path_scope:simplnomatch.Registerapascore.identity.congr.We introduce the convention thatapKNdenotes the application of a K-path between functions to an N-path between elements, where a 0-path is simply a function or an element. Thus,apis a shorthand forap01.Notationap01:=ap(onlyparsing).Similarly, dependent functions act on paths; but the type is a bit more subtle. Iff:foralla:A,Baandp:x=yis a path inA, thenapDfpshould somehow be a path betweenfx:Bxandfy:By. Since these live in different types, we use transport alongpto make them comparable:apDfp:p#fx=fy.The typep#fx=fycan profitably be considered as a heterogeneous or dependent equality type, of "paths fromfxtofyoverp".DefinitionapD{A:Type} {B:A->Type} (f:foralla:A,Ba) {xy:A} (p:x=y):p# (fx) =fy:=matchpwithidpath=>idpathend.See above for the meaning ofsimplnomatch.ArgumentsapD{A%_type_scopeB}f%_function_scope{xy}p%_path_scope:simplnomatch.Homotopies between functionsDefinitionpointwise_pathsA(P:A->Type) (fg:forallx,Px):=forallx,fx=gx.Definitionpointwise_paths_concat{A} {P:A->Type} {fgh:forallx,Px}:pointwise_pathsAPfg->pointwise_pathsAPgh->pointwise_pathsAPfh:=funpqx=>px@qx.Global Instancereflexive_pointwise_pathsAP:Reflexive(pointwise_pathsAP).Proof.intros? ?;reflexivity.Defined.Global Instancetransitive_pointwise_pathsAP:Transitive(pointwise_pathsAP).Proof.introsfgh.applypointwise_paths_concat.Defined.Global Instancesymmetric_pointwise_pathsAP:Symmetric(pointwise_pathsAP).Proof.intros? ?p?;symmetry;applyp.Defined.Global Argumentspointwise_paths{A}%_type_scope{P} (fg)%_function_scope.Global Argumentsreflexive_pointwise_paths/.Global Argumentstransitive_pointwise_paths/.Global Argumentssymmetric_pointwise_paths/.#[export]HintUnfoldpointwise_paths:typeclass_instances.Notation"f == g" := (pointwise_pathsfg) :type_scope.DefinitionapD10{A} {B:A->Type} {fg:forallx,Bx} (h:f=g):f==g:=funx=>matchhwithidpath=> 1end.Global ArgumentsapD10{A%_type_scopeB} {fg}%_function_scopeh%_path_scope_.Definitionap10{AB} {fg:A->B} (h:f=g) :f==g:=apD10h.Global Argumentsap10{AB}%_type_scope{fg}%_function_scopeh%_path_scope_.For the benefit of readers of the HoTT Book:Notationhapply:=ap10(onlyparsing).Definitionap11{AB} {fg:A->B} (h:f=g) {xy:A} (p:x=y) :fx=gy.Proof.caseh,p;reflexivity.Defined.Global Argumentsap11{AB}%_type_scope{fg}%_function_scopeh%_path_scope{xy}p%_path_scope.EquivalencesHomotopy equivalences are a central concept in homotopy type theory. Before we define equivalences, let us consider when two typesAandBshould be considered "the same".The first option is to require existence off:A->Bandg:B->Awhich are inverses of each other, up to homotopy.  Homotopically speaking, we should also require a certain condition on these homotopies, which is one of the triangle identities for adjunctions in category theory.  Thus, we call this notion an *adjoint equivalence*.The other triangle identity is provable from the first one, along with all the higher coherences, so it is reasonable to only assume one of them.  Moreover, as we will see, if we have maps which are inverses up to homotopy, it is always possible to make the triangle identity hold by modifying one of the homotopies.The second option is to use Vladimir Voevodsky's definition of an equivalence as a map whose homotopy fibers are contractible.  We call this notion a *homotopy bijection*.An interesting third option was suggested by André Joyal: a mapfwhich has separate left and right homotopy inverses.  We call this notion a *homotopy isomorphism*.While the second option was the one used originally, and it is the most concise one, it makes more sense to use the first one in a formalized development, since it exposes most directly equivalence as a structure.  In particular, it is easier to extract directly from it the data of a homotopy inverse tof, which is what we care about having most in practice.  Thus, adjoint equivalences are what we will refer to merely as *equivalences*.Naming convention: we useequivandEquivsystematically to denote types of equivalences, andisequivandIsEquivsystematically to denote the assertion that a given map is an equivalence.A typeclass that includes the data makingfinto an adjoint equivalence.ClassIsEquiv{AB:Type} (f:A->B) := {equiv_inv:B->A;eisretr:foequiv_inv==idmap;eissect:equiv_invof==idmap;eisadj:forallx:A,eisretr(fx) =apf(eissectx) ;}.Argumentseisretr{AB}%_type_scopef%_function_scope{_}_.Argumentseissect{AB}%_type_scopef%_function_scope{_}_.Argumentseisadj{AB}%_type_scopef%_function_scope{_}_.ArgumentsIsEquiv{AB}%_type_scopef%_function_scope.We markeisadjas Opaque to deter Coq from unfolding it when simplifying. Since proofs ofeisadjtypically have larger proofs than the rest of the equivalence data, we gain some speed up as a result.Global Opaqueeisadj.A record that includes all the data of an adjoint equivalence.RecordEquivAB:= {equiv_fun:A->B;equiv_isequiv:IsEquivequiv_fun}.Coercionequiv_fun:Equiv>->Funclass.Global Existing Instanceequiv_isequiv.Argumentsequiv_fun{AB}__.Argumentsequiv_isequiv{AB}_.Bind Scopeequiv_scopewithEquiv.Notation"A <~> B" := (EquivAB) :type_scope.A notation for the inverse of an equivalence.  We can apply this to a function as long as there is a typeclass instance asserting it to be an equivalence.  We can also apply it to an element ofA<~>B, since there is an implicit coercion toA->Band also an existing instance ofIsEquiv.Notation"f ^-1" := (@equiv_inv__f_) :function_scope.A shorthand for applying paths between equivalences like functions.Definitionap10_equiv{AB:Type} {fg:A<~>B} (h:f=g) :f==g:=ap10(apequiv_funh).Function extensionalityFunction extensionality is stated as the axiomisequiv_apD10.  In order to track where it is used, we create an empty typeFunextand require a term of that type in order to applyisequiv_apD10.  Since there are no terms of that type, any definition that uses function extensionality (directly or indirectly) must haveFunextas a hypothesis.  This is done by adding`{Funext}to the argument list.  You can also assume it for an entire Section withContext`{Funext}.  SinceFunextis aClass, the provided argument will be found by typeclass search.This approach also has the advantage that it lets us useisequiv_apD10at multiple universe levels, with a single assumption.To get rid of unneeded universe variables, we putFunextinType0and make itMonomorphic.Monomorphic AxiomFunext:Type0.Existing ClassFunext.Axiomisequiv_apD10:forall`{Funext} (A:Type) (P:A->Type)fg,IsEquiv(@apD10APfg).Global Existing Instanceisequiv_apD10.Definitionpath_forall`{Funext} {A:Type} {P:A->Type} (fg:forallx:A,Px):f==g->f=g:= (@apD10APfg)^-1.Global Argumentspath_forall{_A%_type_scopeP} (fg)%_function_scope_.Contractibility and truncation levelsTruncation measures how complicated a type is in terms of higher path types. The (-2)-truncated types are the contractible ones, whose homotopy is completely trivial.  More precisely, a typeAis contractible if there is a pointx:Aand a (pointwise) homotopy connecting the identity onAto the constant map atx.The (n+1)-truncated types are those whose path types are n-truncated.Thus, (-1)-truncated means "the type of paths between any two points is contractible". Such a type is necessarily a sub-singleton: any two points are connected by a path which is unique up to homotopy. In other words, (-1)-truncated types are truth values.  We call such types "propositions" or "h-propositions".Next, 0-truncated means "the type of paths between any two points is a sub-singleton". Thus, two points might not have any paths between them, or they have a unique path. Such a type may have many points but it is discrete in the sense that all paths are trivial. We call such types "sets" or "h-sets".In this library, a witness that a type is n-truncated is formalized by theIsTruncntypeclass.  In many cases, the typeclass machinery of Coq can automatically infer a witness for a type being n-truncated.  BecauseIsTruncnAitself has no computational content (that is, all witnesses of n-truncation of a type are provably equal), it does not matter much which witness Coq infers.  Therefore, the primary concerns in making use of the typeclass machinery are coverage (how many goals can be automatically solved) and speed (how long does it take to solve a goal, and how long does it take to error on a goal we cannot automatically solve).  Careful use of typeclass instances and priorities, which determine the order of typeclass resolution, can be used to effectively increase both the coverage and the speed in cases where the goal is solvable.  Unfortunately, typeclass resolution tends to spin for a while before failing unless you're very, very, very careful.  We currently aim to achieve moderate coverage and fast speed in solvable cases.  How long it takes to fail typeclass resolution is not currently considered, though it would be nice someday to be even more careful about things.In order to achieve moderate coverage and speedy resolution, we currently follow the following principles.  They set up a kind of directed flow of information, intended to prevent cycles and potentially infinite chains, which are often the ways that typeclass resolution gets stuck.We prefer to reason aboutIsTrunc(Sn)Arather thanIsTruncn(@pathsAab).  Whenever we see a statement (or goal) about truncation of paths, we try to turn it into a statement (or goal) about truncation of a (non-paths) type.  We do not allow typeclass resolution to go in the reverse direction fromIsTrunc(Sn)Atoforallab:A,IsTruncn(a=b).We prefer to reason about syntactically smaller types.  That is, typeclass instances should turn goals of typeIsTruncn(foralla:A,Pa)into goals of typeforalla:A,IsTruncn(Pa); and goals of typeIsTruncn(A*B)into the pair of goals of typeIsTruncnAandIsTruncnB; rather than the other way around.  Ideally, we would add similar rules to transform hypotheses in the cases where we can do so.  This rule is not always the one we want, but it seems to heuristically capture the shape of most cases that we want the typeclass machinery to automatically infer.  That is, we often want to inferIsTruncn(A*B)fromIsTruncnAandIsTruncnB, but we (probably) don't often need to do other simple things withIsTruncn(A*B)which are broken by that reduction.We begin by defining the type that indexes the truncation levels.Inductivetrunc_index:Type0:=|minus_two:trunc_index|trunc_S:trunc_index->trunc_index.Schemetrunc_index_ind:=Inductionfortrunc_indexSortType.Schemetrunc_index_rec:=Minimalityfortrunc_indexSortType.(* See comment above about the tacticinduction. *)Definitiontrunc_index_rect:=trunc_index_ind.We will useNotationfortrunc_indexes, so define a scope for them here. Numeral notation fortrunc_indexes is set up in Basics/Trunc.v.Bind Scopetrunc_scopewithtrunc_index.Argumentstrunc_S_%_trunc_scope.Notation"n .+1" := (trunc_Sn) :trunc_scope.Notation"n .+2" := (n.+1.+1)%trunc:trunc_scope.Notation"n .+3" := (n.+1.+2)%trunc:trunc_scope.Notation"n .+4" := (n.+1.+3)%trunc:trunc_scope.Notation"n .+5" := (n.+1.+4)%trunc:trunc_scope.Local OpenScopetrunc_scope.We define truncatedness using an inductive typeIsTrunc_internalAn.  We use a notationIsTruncnAsimply to swap the orders of arguments, and notationsContr,IsHPropandIsHSetwhich specialize tonbeing-2,-1and0, respectively.  An alternative is to use aFixpoint, and that was done in the past.  The advantages of the inductive approach are:IsTrunc_internalis cumulative; typeclass inherence works smoothly; the library builds faster.  Some disadvantages are that we need to manually apply the constructors when proving that something is truncated, and that the induction principle is awkward to work with.InductiveIsTrunc_internal(A:Type@{u}) :trunc_index->Type@{u} :=|Build_Contr:forall(center:A) (contr:forally,center=y),IsTrunc_internalAminus_two|istrunc_S:forall{n:trunc_index}, (forallxy:A,IsTrunc_internal(x=y)n) ->IsTrunc_internalA(trunc_Sn).Existing ClassIsTrunc_internal.NotationIsTruncnA:= (IsTrunc_internalAn).SchemeIsTrunc_internal_ind:=InductionforIsTrunc_internalSortType.SchemeIsTrunc_internal_rec:=MinimalityforIsTrunc_internalSortType.DefinitionIsTrunc_internal_rect:=IsTrunc_internal_ind.DefinitionIsTrunc_unfolded(n:trunc_index) (A:Type):=matchnwith|minus_two=> {center:A&forally,center=y}|n.+1 =>forallxy:A,IsTruncn(x=y)end.Definitionistrunc_unfold(n:trunc_index) (A:Type):IsTruncnA->IsTrunc_unfoldednA.Proof.intros[centercontr|kistrunc].-exact(center;contr).-exactistrunc.Defined.Definitionisequiv_istrunc_unfold(n:trunc_index) (A:Type):IsEquiv(istrunc_unfoldnA).Proof.simplerefine(Build_IsEquiv__(istrunc_unfoldnA)____).-destructn.+intros[centercontr];exact(Build_Contr_centercontr).+introsH.exact(istrunc_S_H).-destructn;reflexivity.-intros[centercontr|kistrunc];reflexivity.-intros[centercontr|kistrunc];reflexivity.Defined.Definitionequiv_istrunc_unfold(n:trunc_index) (A:Type):=Build_Equiv___(isequiv_istrunc_unfoldnA).A version ofistrunc_unfoldfor successors.Global Instanceistrunc_paths(A:Type)n`{H:IsTruncn.+1A} (xy:A):IsTruncn(x=y):=istrunc_unfoldn.+1AHxy.NotationContrA:= (IsTruncminus_twoA).NotationIsHPropA:= (IsTruncminus_two.+1A).NotationIsHSetA:= (IsTruncminus_two.+2A).Definitioncenter(A:Type) {H:ContrA} :A:=pr1(istrunc_unfold__H).Definitioncontr{A:Type} {H:ContrA} (y:A) :centerA=y:=pr2(istrunc_unfold__H)y.We define a slight variation ofistrunc_unfold, which differs only it what it does forn=-2.  It will produce a section of the following type family.Definitionistrunc_codomain_fam{n:trunc_index} {A:Type} (istrunc:IsTruncnA) :A->Type.Proof.introy.destructn.-exact(centerA=y).-exact(forallx:A,IsTruncn(y=x)).Defined.The variant ofistrunc_unfoldlets us treat any proof of truncation as a function.  Forn=-2, it produces the contracting homotopy.Definitionistrunc_fun{n:trunc_index} {A:Type} (istrunc:IsTruncnA):forally:A,istrunc_codomain_famistruncy.Proof.destructn.-exact(@contrAistrunc).-exact(istrunc_unfold__istrunc).Defined.We add this as a coercion.#[warning="-uniform-inheritance"]Coercionistrunc_fun:IsTrunc>->Funclass.Truncated relationsHprop-valued relations.  Making this aNotationrather than aDefinitionenables typeclass resolution to pick it up easily.  We include the base typeAin the notation since otherwise e.g.forall(xy:A)(z:Bxy),IsHProp(Cxyz)will get displayed asforall(x:A),is_mere_relation(Cx).Notationis_mere_relationAR:= (forall(xy:A),IsHProp(Rxy)).Natural numbersInductivenat:Type0:=|O:nat|S:nat->nat.Schemenat_ind:=InductionfornatSortType.Schemenat_rect:=InductionfornatSortType.Schemenat_rec:=InductionfornatSortType.Declare Scopenat_scope.DelimitScopenat_scopewithnat.Bind Scopenat_scopewithnat.ArgumentsS_%_nat.MiscWe putEmptyhere, instead of inEmpty.v, becauseLtacdoneuses it.InductiveEmpty:Type0:= .RegisterEmptyascore.False.type.SchemeEmpty_ind:=InductionforEmptySortType.SchemeEmpty_rec:=MinimalityforEmptySortType.DefinitionEmpty_rect:=Empty_ind.Definitionnot(A:Type) :=A->Empty.Notation"~ x" := (notx) :type_scope.Notation"~~ x" := (~ ~x) :type_scope.#[export]HintUnfoldnot:core.Notation"x <> y  :>  T" := (not(x=y:>T)) :type_scope.Notation"x <> y" := (x<>y:>_) :type_scope.Definitionsymmetric_neq{A} {xy:A} :x<>y->y<>x:=funnpp=>np(p^).Definitioncomplement{A} (R:RelationA) :RelationA:=funxy=> ~ (Rxy).#[global]TypeclassesOpaquecomplement.ClassIrreflexive{A} (R:RelationA) :=irreflexivity:Reflexive(complementR).ClassAsymmetric{A} (R:RelationA) :=asymmetry:forall{xy},Rxy-> (complementRyx:Type).Likewise, we putUnithere, instead of inUnit.v, becauseTruncuses it.InductiveUnit:Type0:=tt:Unit.SchemeUnit_ind:=InductionforUnitSortType.SchemeUnit_rec:=MinimalityforUnitSortType.DefinitionUnit_rect:=Unit_ind.AUnitgoal should be resolved byautoandtrivial.#[export]HintResolvett:core.RegisterUnitascore.IDProp.type.RegisterUnitascore.True.type.Registerttascore.IDProp.idProp.Registerttascore.True.I.Pointed typesA space is pointed if that space has a point.ClassIsPointed(A:Type) :=point:A.#[global]TypeclassesTransparentIsPointed.ArgumentspointA{_}.RecordpType:={pointed_type:Type;ispointed_type:IsPointedpointed_type}.Coercionpointed_type:pType>->Sortclass.Global Existing Instanceispointed_type.Homotopy fibersHomotopy fibers are homotopical inverse images of points.Definitionhfiber{AB:Type} (f:A->B) (y:B) := {x:A&fx=y}.Global Argumentshfiber{AB}%_type_scopef%_function_scopey.SmallnessWe say thatX:Type@{j}is small (relative to Type@{i}) if it is equivalent to a type inType@{i}.  We use a record to avoid an extra universe variable.  This version has no constraints oniandj.  It lands inmax(i+1,j), as expected.  We mark theivariable as being invariant, so that Coq is better at guessing universe variables when this is used.ClassIsSmall@{=ij| } (X:Type@{j}) := {smalltype:Type@{i} ;equiv_smalltype:smalltype<~>X;}.ArgumentssmalltypeX{_}.Argumentsequiv_smalltypeX{_}.Propositional resizingSee the note byFunextabove regarding classes for axioms.Monomorphic AxiomPropResizing:Type0.Existing ClassPropResizing.Propositional resizing says that every (-1)-truncated type is small.Axiomissmall_hprop@{ij| } :forall`{PropResizing} (X:Type@{j})(T:IsHPropX),IsSmall@{ij}X.Existing Instanceissmall_hprop.

--- Basics\Tactics.html ---
TacticsLibrary TacticsRequireImportHoTT.BasicsFin.TacticsLtacFinIndOnX:=repeatmatchtypeofXwith|Fin0 =>destructX|Empty=>destructX|Unit=>destructX|Fin?n=>destructXas[X|X]| ?L+Unit=>destructXas[X|X]end.This tactic can be used to generate n cases from a goal like forall (x : Fin n), _LtacFinInd:=letX:=fresh"X"inintroX;FinIndOnX.

--- Basics\Utf8.html ---
Utf8Library Utf8RequireImportStructure.Core.RequireExportStructure.Notations.RequireImportBasics.Utf8.Notation"a ≤_{ x } b" := (a<=_{x}b)%long_structure:long_structure_scope.Notation"a ≤ b" := (a<=b)%structure:structure_scope.

--- Categories\Category.html ---
CategoryLibrary CategoryCategoriesWe collect here all of the files about categories.  Since there are only notations inCategory.Notations, we can just export those.RequireExportCategory.Notations.Definition of precategoriesRequireCategory.Core.Opposite precategoriesRequireCategory.Dual.Morphisms in precategoriesRequireCategory.Morphisms.Classification of path spaceRequireCategory.Paths.Universal objectsRequireCategory.Objects.Product precategoriesRequireCategory.Prod.Dependent product precategoriesRequireCategory.Pi.∑-precategoriesRequireCategory.Sigma.Strict categoriesRequireCategory.Strict.Coproduct precategoriesRequireCategory.Sum.Categories (univalent or saturated)RequireCategory.Univalent.LocalSetWarningsAppend"-notation-overridden".IncludeCategory.Core.IncludeCategory.Dual.IncludeCategory.Morphisms.IncludeCategory.Paths.IncludeCategory.Objects.IncludeCategory.Prod.IncludeCategory.Pi.We use theSigmafolder only to allow us to split up the various files and group conceptually similar lemmas, but not for namespacing.  So we include the main file in it.IncludeCategory.Sigma.IncludeCategory.Strict.IncludeCategory.Sum.IncludeCategory.Univalent.We don't want to make utf-8 notations the default, so we don't export them.SubcategoriesFor the subfolders, we need to re-create the module structure.  Alas, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.RequireCategory.Subcategory.

--- Categories\Functor.html ---
FunctorLibrary FunctorFunctorsSince there are only notations inFunctor.Notations, we can just export those.RequireExportFunctor.Notations.DefinitionRequireFunctor.Core.CompositionRequireFunctor.Composition.Core.DualsRequireFunctor.Dual.IdentityRequireFunctor.Identity.Classification of path spaceRequireFunctor.Paths.Product functorsRequireFunctor.Prod.Core.Coproduct functorsRequireFunctor.Sum.Full, Faithful, Fully FaithfulRequireFunctor.Attributes.Pointwise functors (functoriality of functor category construction)RequireFunctor.Pointwise.Core.IncludeFunctor.Composition.Core.IncludeFunctor.Core.IncludeFunctor.Dual.IncludeFunctor.Identity.IncludeFunctor.Paths.IncludeFunctor.Prod.Core.IncludeFunctor.Sum.IncludeFunctor.Attributes.IncludeFunctor.Pointwise.Core.We want to have the following as subdirectories/modules, not at top level.  Unfortunately, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.RequireFunctor.Pointwise.We don't want to make utf-8 notations the default, so we don't export them.

--- Categories\Grothendieck.html ---
GrothendieckLibrary GrothendieckGrothendieck ConstructionWe want to have the following as subdirectories/modules, not at top level.  Unfortunately, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.of a functor to SetRequireGrothendieck.ToSet.of a pseudofunctor to CatRequireGrothendieck.PseudofunctorToCat.of a functor to CatRequireGrothendieck.ToCat.

--- Categories\Limits.html ---
LimitsLibrary LimitsLimits and ColimitsDefinitionsRequireLimits.Core.(co)limits assemble into functorswhich are adjoints to ΔRequireLimits.Functors.IncludeLimits.Core.IncludeLimits.Functors.

--- HIT\Interval.html ---
IntervalLibrary IntervalTheorems about the homotopical interval.RequireImportBasics.OvertureBasics.PathGroupoids.RequireImportTypes.Paths.Local OpenScopepath_scope.ModuleExportInterval.Private Inductiveinterval:Type0:=|zero:interval|one:interval.Axiomseg:zero=one.Definitioninterval_ind(P:interval->Type)(a:Pzero) (b:Pone) (p:seg#a=b):forallx:interval,Px:=funx=> (matchxreturn_->Pxwith|zero=>fun_=>a|one=>fun_=>bend)p.Axiominterval_ind_beta_seg:forall(P:interval->Type)(a:Pzero) (b:Pone) (p:seg#a=b),apD(interval_indPabp)seg=p.EndInterval.Definitioninterval_rec(P:Type) (ab:P) (p:a=b):interval->P:=interval_ind(fun_=>P)ab(transport_const__@p).Definitioninterval_rec_beta_seg(P:Type) (ab:P) (p:a=b):ap(interval_recPabp)seg=p.Proof.refine(cancelL(transport_constsega)___).refine((apD_const(interval_ind(fun_=>P)ab_)seg)^ @_).refine(interval_ind_beta_seg(fun_=>P)___).Defined.The interval is contractible.Global Instancecontr_interval:Contrinterval| 0.Proof.apply(Build_Contr_zero).refine(interval_ind_1seg_).refine(transport_paths_r__@concat_1p_).Defined.

--- HIT\Quotient.html ---
quotientLibrary quotientRequireImportHoTT.BasicsHoTT.Types.RequireImportHSetTruncType.RequireImportTruncations.Core.Local OpenScopepath_scope.The set-quotient of a type by an hprop-valued relationWe aim to model:Inductive quotient : Type :=
   | class_of : A -> quotient
   | related_classes_eq : forall x y, (R x y), class_of x = class_of y
   | quotient_set : IsHSet quotientTODO:  This development should be further connected with the sections in the book; see below.  And it should be merged with Colimits.Quotient. Currently this file is only used in Classes/implementations/natpair_integers.v and Classes/implementations/field_of_fractions.v, so it shouldn't be too hard to switch to Colimits.Quotient.ModuleExportQuotient.SectionDomain.Universesiju.Constrainti<=u,j<=u.Context{A:Type@{i}} (R:Relation@{ij}A) {sR:is_mere_relation_R}.We choose to let the definition of quotient depend on the proof thatRis a set-relations.  Alternatively, we could have defined it for all relations and only develop the theory for set-relations.  The former seems more natural.We do not requireRto be an equivalence relation, but implicitly consider its transitive-reflexive closure.This definition has a parametersRthat shadows the ambient one in the Context in order to ensure that it actually ends up depending on everything in the Context when the section is closed, since its definition doesn't actually refer to any of them.Private Inductivequotient{sR:is_mere_relation_R} :Type@{u} :=|class_of:A->quotient.The path constructors.Axiomrelated_classes_eq:forall{xy:A},Rxy->class_ofx=class_ofy.Axiomquotient_set:IsHSet(@quotientsR).Global Existing Instancequotient_set.Definitionquotient_ind(P: (@quotientsR) ->Type) {sP:forallx,IsHSet(Px)}(dclass:forallx,P(class_ofx))(dequiv: (forallxy(H:Rxy), (related_classes_eqH) # (dclassx) =dclassy)):forallq,Pq:=funq=>matchqwithclass_ofa=>fun__=>dclassaendsPdequiv.Definitionquotient_ind_compute{PsP}dclassdequivx: @quotient_indPsPdclassdequiv(class_ofx) =dclassx.Proof.reflexivity.Defined.Again equality of paths needs to be postulatedAxiomquotient_ind_compute_path:forallPsPdclassdequiv,forallxy(H:Rxy),apD(@quotient_indPsPdclassdequiv) (related_classes_eqH)=dequivxyH.EndDomain.EndQuotient.SectionEquiv.Context`{Univalence}.Context{A:Type} (R:RelationA) {sR:is_mere_relation_R}{Htrans:TransitiveR} {Hsymm:SymmetricR}.Lemmaquotient_path2:forall{xy:quotientR} (pq:x=y),p=q.Proof.apply@hset_path2.apply_.Defined.Definitionin_class:quotientR->A->HProp.Proof.refine(quotient_indR(fun_=>A->HProp) (funab=>Build_HProp(Rab))_).intros.eapplyconcat;[applytransport_const|].applypath_forall.introz.applypath_hprop;simpl.apply@equiv_iff_hprop;eauto.Defined.Context{Hrefl:ReflexiveR}.Lemmain_class_pr:forallxy, (in_class(class_ofRx)y:Type) =Rxy.Proof.reflexivity.Defined.Lemmaquotient_ind_prop(P:quotientR->Type)`{forallx,IsHProp(Px)} :foralldclass:forallx,P(class_ofRx),forallq,Pq.Proof.intros.apply(quotient_indRPdclass).intros.applypath_ishprop.Defined.Global Instancedecidable_in_class`{forallxy,Decidable(Rxy)}:forallxa,Decidable(in_classxa).Proof.refine(quotient_ind_prop__).introsab;exact(transportDecidable(in_class_prab)_).Defined.Lemmaclass_of_repr:forallqx,in_classqx->q=class_ofRx.Proof.apply(quotient_indR(funq:quotientR=>forallx,in_classqx->q=class_of_x)(funxyH=>related_classes_eqRH)).intros.applypath_forall.introz.applypath_forall;introH'.applyquotient_path2.Defined.Lemmaclasses_eq_related:forallxy,class_ofRx=class_ofRy->Rxy.Proof.introsxyH'.pattern(Rxy).eapplytransport.-applyin_class_pr.-pattern(class_ofRx).apply(transport_(H'^)).applyHrefl.Defined.Thm 10.1.8Theoremsets_exact:forallxy, (class_ofRx=class_ofRy) <~>Rxy.intros??.applyequiv_iff_hprop.-applyclasses_eq_related.-applyrelated_classes_eq.Defined.Definitionquotient_rec{B:Type} {sB:IsHSetB}(dclass: (forallx:A,B))(dequiv: (forallxy,Rxy->dclassx=dclassy)):quotientR->B.Proof.apply(quotient_indR(fun_:quotient_=>B))withdclass.intros??H'.destruct(related_classes_eqRH').byapplydequiv.Defined.Definitionquotient_rec2{B:HSet} {dclass: (A->A->B)}:foralldequiv: (forallxx',Rxx'->forallyy',Ryy'->dclassxy=dclassx'y'),quotientR->quotientR->B.Proof.intro.assert(dequiv0:forallxx0y:A,Rx0y->dclassxx0=dclassxy)by(intros? ? ?Hx;applydequiv;[applyHrefl|done]).refine(quotient_rec(funx=>quotient_rec(dclassx) (dequiv0x))_).introsxx'Hx.applypath_forall.red.assert(dequiv1:forally:A,quotient_rec(dclassx) (dequiv0x) (class_of_y) =quotient_rec(dclassx') (dequiv0x') (class_of_y))by(intros;byapplydequiv).refine(quotient_indR(funq=>quotient_rec(dclassx) (dequiv0x)q=quotient_rec(dclassx') (dequiv0x')q)dequiv1_).intros.applypath_ishprop.Defined.Definitionquotient_ind_prop':forallP:quotientR->Type,forall(Hprop':forallx,IsHProp(P(class_of_x))),(forallx,P(class_of_x)) ->forally,Py.Proof.intros? ?dclass.applyquotient_indwithdclass.-simplerefine(quotient_indR(funx=>IsHSet(Px))__);cbnbeta;tryexact_.intros;applypath_ishprop.-intros.applypath_ishprop.Defined.From Ch6Theoremquotient_surjective:IsSurjection(class_ofR).Proof.applyBuildIsSurjection.apply(quotient_ind_prop(funy=>merely(hfiber(class_ofR)y)));tryexact_.introx.applytr.byexistsx.Defined.From Ch10Definitionquotient_ump'(B:HSet): (quotientR->B) ->(sig(funf:A->B=> (forallaa0:A,Raa0->fa=fa0))).introf.exists(composef(class_ofR) ).intros.f_ap.byapplyrelated_classes_eq.Defined.Definitionquotient_ump''(B:HSet): (sig(funf:A->B=> (forallaa0:A,Raa0->fa=fa0)))->quotientR->B.intros[fH'].apply(quotient_rec_H').Defined.Theoremquotient_ump(B:HSet): (quotientR->B) <~>(sig(funf:A->B=> (forallaa0:A,Raa0->fa=fa0))).Proof.refine(equiv_adjointify(quotient_ump'B) (quotient_ump''B)__).-intros[fHf].byapplyequiv_path_sigma_hprop.-introsf.applypath_forall.red.applyquotient_ind_prop';[apply_|reflexivity].Defined.MissingThe equivalence with VVquotientA//R.This should lead to the unnamed theorem:10.1.10. Equivalence relations are effective and there is an equivalenceA/R<~>A//R.The theory of canonical quotients is developed by C.Cohen:
  http://perso.crans.org/cohen/work/quotients/EndEquiv.SectionFunctoriality.Definitionquotient_functor{A:Type} (R:RelationA) {sR:is_mere_relation_R}{B:Type} (S:RelationB) {sS:is_mere_relation_S}(f:A->B) (fresp:forallxy,Rxy->S(fx) (fy)):quotientR->quotientS.Proof.refine(quotient_recR(class_ofSof)_).introsxyr.applyrelated_classes_eq,fresp,r.Defined.Context{A:Type} (R:RelationA) {sR:is_mere_relation_R}{B:Type} (S:RelationB) {sS:is_mere_relation_S}.Global Instancequotient_functor_isequiv(f:A->B) (fresp:forallxy,Rxy<->S(fx) (fy))`{IsEquiv__f}:IsEquiv(quotient_functorRSf(funxy=>fst(frespxy))).Proof.simplerefine(isequiv_adjointify_(quotient_functorSRf^-1_)__).-introsuvs.apply(snd(fresp__)).abstract(do2rewriteeisretr;applys).-introsx;revertx;simplerefine(quotient_indS___).+introsb;simpl.applyap,eisretr.+intros;applypath_ishprop.-introsx;revertx;simplerefine(quotient_indR___).+introsa;simpl.applyap,eissect.+intros;applypath_ishprop.Defined.Definitionquotient_functor_equiv(f:A->B) (fresp:forallxy,Rxy<->S(fx) (fy))`{IsEquiv__f}:quotientR<~>quotientS:=Build_Equiv__(quotient_functorRSf(funxy=>fst(frespxy)))_.Definitionquotient_functor_equiv'(f:A<~>B) (fresp:forallxy,Rxy<->S(fx) (fy)):quotientR<~>quotientS:=quotient_functor_equivffresp.EndFunctoriality.SectionKernel.Quotients of kernels of maps to sets give a surjection/mono factorization.Context{fs:Funext}.A function we want to factor.Context{AB:Type} `{IsHSetB} (f:A->B).A mere relation equivalent to its kernel.Context(R:RelationA) {sR:is_mere_relation_R}.Context(is_ker:forallxy,fx=fy<~>Rxy).Theoremquotient_kernel_factor:exists(C:Type) (e:A->C) (m:C->B),IsHSetC*IsSurjectione*IsEmbeddingm* (f=moe).Proof.pose(C:=quotientR).(* We put this explicitly in the context so that typeclass resolution will pick it up. *)assert(IsHSetC)by(unfoldC;apply_).existsC.pose(e:=class_ofR).existse.transparentassert(m: (C->B)).{applyquotient_indwithf;tryexact_.introsxyH.transitivity(fx).-applytransport_const.-exact((is_kerxy) ^-1H). }existsm.split;[split;[split|]|].-assumption.-applyquotient_surjective.-introu.applyhprop_allpath.assert(H:forall(xy:C) (p:mx=u) (p':my=u),x=y).{simplerefine(quotient_indR___).-introa.simplerefine(quotient_indR___).+introsa'pp';foldeinp,p'.*applyrelated_classes_eq.refine(is_keraa'_).change(m(ea) =m(ea')).exact(p@p'^).+intros;applypath_ishprop.-intros;applypath_ishprop. }intros[xp] [yp'].applypath_sigma_hprop;simpl.exact(Hxypp').-reflexivity.Defined.EndKernel.

--- HIT\SetCone.html ---
SetConeLibrary SetConeRequireImportHoTT.BasicsTypes.Unit.RequireImportColimits.Pushout.RequireImportTruncations.Core.Cones of HSetsSectionSetCone.Context{AB:HSet} (f:A->B).Definitionsetcone:=Trunc0 (Pushout@{__Set_}f(const_ttA)).Global Instanceistrunc_setcone:IsHSetsetcone:=_.Definitionsetcone_point:setcone:=tr(push(inrtt)).EndSetCone.

--- Homotopy\PathGroupoids.html ---
PathGroupoidsLibrary PathGroupoidsThe groupid structure of pathsRequireImportBasics.OvertureBasics.Tactics.Local OpenScopepath_scope.Naming conventionsWe need good naming conventions that allow us to name theorems without looking them up. The names should indicate the structure of the theorem, but they may sometimes be ambiguous, in which case you just have to know what is going on.    We shall adopt the following principles:we are not afraid of long nameswe are not afraid of short names when they are used frequentlywe use underscoresname of theorems and lemmas are lower-caserecords and other types may be upper or lower caseTheorems about concatenation of paths are calledconcat_XXXwhereXXXtells us what is on the left-hand side of the equation. You have to guess the right-hand side. We use the following symbols inXXX:1means the identity pathpmeans 'the path'Vmeans 'the inverse path'Ameans 'ap'Mmeans the thing we are moving across equalityxmeans 'the point' which is not a path, e.g. intransportpx2means relating to 2-dimensional paths3means relating to 3-dimensional paths, and so onAssociativity is indicated with an underscore. Here are some examples of how the name gives hints about the left-hand side of the equation.concat_1pmeans1*pconcat_Vpmeansp^*pconcat_p_ppmeansp*(q*r)concat_pp_pmeans(p*q)*rconcat_V_ppmeansp^*(p*q)concat_pV_pmeans(q*p^)*por(p*p^)*q, but probably the former because for the latter you could just useconcat_pV.Laws about inverse of something are of the forminv_XXX, and those aboutapare of the formap_XXX, and so on. For example:inv_ppis about(p@q)^inv_Vis about(p^)^inv_Ais about(apfp)^ap_Vis aboutapf(p^)ap_ppis aboutapf(p@q)ap_idmapis aboutapidmappap_1is aboutapf1ap02_p2pis aboutap02f(p@@q)Then we have laws which move things around in an equation. The naming scheme here ismoveD_XXX. The directionDindicates where to move to:Lmeans that we move something to the left-hand side, whereasRmeans we are moving something to the right-hand side. The partXXXdescribes the shape of the sidefromwhich we are moving where the thing that is getting moves is calledM.  The presence of 1 next to anMgenerally indicates an *implied* identity path which is inserted automatically after the movement.  Examples:moveL_pMmeans that we transformp=q@rtop@r^=qbecause we are moving something to the left-hand side, and we are
     moving the right argument of concat.moveR_Mpmeans that we transformp@q=rtoq=p^@rbecause we move to the right-hand side, and we are moving the left
     argument of concat.moveR_1Mmeans that we transformp=q(rather thanp=1@q) top*q^=1.There are also cancellation laws calledcancelRandcancelL, which are inverse to the 2-dimensional 'whiskering' operationswhiskerRandwhiskerL.We may now proceed with the groupoid structure proper.The 1-dimensional groupoid structure.concat, with arguments flipped. Useful mainly in the idiomapply(concatR(expression)). Given as a notation not a definition so that the resultant terms are literally instances ofconcat, with no unfolding required.NotationconcatR:= (funpq=>concatqp).The identity path is a right unit.Definitionconcat_p1{A:Type} {xy:A} (p:x=y) :p@ 1 =p:=matchpwithidpath=> 1end.The identity is a left unit.Definitionconcat_1p{A:Type} {xy:A} (p:x=y) :1 @p=p:=matchpwithidpath=> 1end.It's common to need to use both.Definitionconcat_p1_1p{A:Type} {xy:A} (p:x=y):p@ 1 = 1 @p:=concat_p1p@ (concat_1pp)^.Definitionconcat_1p_p1{A:Type} {xy:A} (p:x=y): 1 @p=p@ 1:=concat_1pp@ (concat_p1p)^.Concatenation is associative.Definitionconcat_p_pp{A:Type} {xyzt:A} (p:x=y) (q:y=z) (r:z=t) :p@ (q@r) = (p@q) @r:=matchrwithidpath=>matchqwithidpath=>matchpwithidpath=> 1endendend.Definitionconcat_pp_p{A:Type} {xyzt:A} (p:x=y) (q:y=z) (r:z=t) :(p@q) @r=p@ (q@r) :=matchrwithidpath=>matchqwithidpath=>matchpwithidpath=> 1endendend.The left inverse law.Definitionconcat_pV{A:Type} {xy:A} (p:x=y) :p@p^ = 1:=matchpwithidpath=> 1end.The right inverse law.Definitionconcat_Vp{A:Type} {xy:A} (p:x=y) :p^ @p= 1:=matchpwithidpath=> 1end.Several auxiliary theorems about canceling inverses across associativity.  These are somewhat redundant, following from earlier theorems.Definitionconcat_V_pp{A:Type} {xyz:A} (p:x=y) (q:y=z) :p^ @ (p@q) =q:=matchqwithidpath=>matchpwithidpath=> 1endend.Definitionconcat_p_Vp{A:Type} {xyz:A} (p:x=y) (q:x=z) :p@ (p^ @q) =q:=matchqwithidpath=>matchpwithidpath=> 1endend.Definitionconcat_pp_V{A:Type} {xyz:A} (p:x=y) (q:y=z) :(p@q) @q^ =p:=matchqwithidpath=>matchpwithidpath=> 1endend.Definitionconcat_pV_p{A:Type} {xyz:A} (p:x=z) (q:y=z) :(p@q^) @q=p:=(matchqasireturnforallp, (p@i^) @i=pwithidpath=>funp=>matchpwithidpath=> 1endend)p.Inverse distributes over concatenationDefinitioninv_pp{A:Type} {xyz:A} (p:x=y) (q:y=z) :(p@q)^ =q^ @p^:=matchqwithidpath=>matchpwithidpath=> 1endend.Definitioninv_Vp{A:Type} {xyz:A} (p:y=x) (q:y=z) :(p^ @q)^ =q^ @p:=matchqwithidpath=>matchpwithidpath=> 1endend.Definitioninv_pV{A:Type} {xyz:A} (p:x=y) (q:z=y) :(p@q^)^ =q@p^.Proof.destructp.destructq.reflexivity.Defined.Definitioninv_VV{A:Type} {xyz:A} (p:y=x) (q:z=y) :(p^ @q^)^ =q@p.Proof.destructp.destructq.reflexivity.Defined.Inverse is an involution.Definitioninv_V{A:Type} {xy:A} (p:x=y) :p^^ =p:=matchpwithidpath=> 1end.Theorems for moving things around in equations.DefinitionmoveR_Mp{A:Type} {xyz:A} (p:x=z) (q:y=z) (r:y=x) :p=r^ @q->r@p=q.Proof.destructr.introh.exact(concat_1p_@h@concat_1p_).Defined.DefinitionmoveR_pM{A:Type} {xyz:A} (p:x=z) (q:y=z) (r:y=x) :r=q@p^ ->r@p=q.Proof.destructp.introh.exact(concat_p1_@h@concat_p1_).Defined.DefinitionmoveR_Vp{A:Type} {xyz:A} (p:x=z) (q:y=z) (r:x=y) :p=r@q->r^ @p=q.Proof.destructr.introh.exact(concat_1p_@h@concat_1p_).Defined.DefinitionmoveR_pV{A:Type} {xyz:A} (p:z=x) (q:y=z) (r:y=x) :r=q@p->r@p^ =q.Proof.destructp.introh.exact(concat_p1_@h@concat_p1_).Defined.DefinitionmoveL_Mp{A:Type} {xyz:A} (p:x=z) (q:y=z) (r:y=x) :r^ @q=p->q=r@p.Proof.destructr.introh.exact((concat_1p_)^ @h@ (concat_1p_)^).Defined.DefinitionmoveL_pM{A:Type} {xyz:A} (p:x=z) (q:y=z) (r:y=x) :q@p^ =r->q=r@p.Proof.destructp.introh.exact((concat_p1_)^ @h@ (concat_p1_)^).Defined.DefinitionmoveL_Vp{A:Type} {xyz:A} (p:x=z) (q:y=z) (r:x=y) :r@q=p->q=r^ @p.Proof.destructr.introh.exact((concat_1p_)^ @h@ (concat_1p_)^).Defined.DefinitionmoveL_pV{A:Type} {xyz:A} (p:z=x) (q:y=z) (r:y=x) :q@p=r->q=r@p^.Proof.destructp.introh.exact((concat_p1_)^ @h@ (concat_p1_)^).Defined.DefinitionmoveL_1M{A:Type} {xy:A} (pq:x=y) :p@q^ = 1 ->p=q.Proof.destructq.introh.exact((concat_p1_)^ @h).Defined.DefinitionmoveL_M1{A:Type} {xy:A} (pq:x=y) :q^ @p= 1 ->p=q.Proof.destructq.introh.exact((concat_1p_)^ @h).Defined.DefinitionmoveL_1V{A:Type} {xy:A} (p:x=y) (q:y=x) :p@q= 1 ->p=q^.Proof.destructq.introh.exact((concat_p1_)^ @h).Defined.DefinitionmoveL_V1{A:Type} {xy:A} (p:x=y) (q:y=x) :q@p= 1 ->p=q^.Proof.destructq.introh.exact((concat_1p_)^ @h).Defined.DefinitionmoveR_M1{A:Type} {xy:A} (pq:x=y) :1 =p^ @q->p=q.Proof.destructp.introh.exact(h@ (concat_1p_)).Defined.DefinitionmoveR_1M{A:Type} {xy:A} (pq:x=y) :1 =q@p^ ->p=q.Proof.destructp.introh.exact(h@ (concat_p1_)).Defined.DefinitionmoveR_1V{A:Type} {xy:A} (p:x=y) (q:y=x) :1 =q@p->p^ =q.Proof.destructp.introh.exact(h@ (concat_p1_)).Defined.DefinitionmoveR_V1{A:Type} {xy:A} (p:x=y) (q:y=x) :1 =p@q->p^ =q.Proof.destructp.introh.exact(h@ (concat_1p_)).Defined.(* In general, the path we want to move might be arbitrarily deeply nested at the beginning of a long concatenation.  Thus, instead of defining functions such asmoveL_Mp_p, we define a tactical that can repeatedly rewrite with associativity to expose it. *)Ltacwith_rassoctac:=repeatrewriteconcat_pp_p;tac;(* After moving, we reassociate to the left (the canonical direction for paths). *)repeatrewriteconcat_p_pp.Ltacrewrite_moveL_Mp_p:=with_rassocltac:(applymoveL_Mp).Ltacrewrite_moveL_Vp_p:=with_rassocltac:(applymoveL_Vp).Ltacrewrite_moveR_Mp_p:=with_rassocltac:(applymoveR_Mp).Ltacrewrite_moveR_Vp_p:=with_rassocltac:(applymoveR_Vp).DefinitionmoveR_transport_p{A:Type} (P:A->Type) {xy:A}(p:x=y) (u:Px) (v:Py):u=p^ #v->p#u=v.Proof.destructp.exactidmap.Defined.DefinitionmoveR_transport_V{A:Type} (P:A->Type) {xy:A}(p:y=x) (u:Px) (v:Py):u=p#v->p^ #u=v.Proof.destructp.exactidmap.Defined.DefinitionmoveL_transport_V{A:Type} (P:A->Type) {xy:A}(p:x=y) (u:Px) (v:Py):p#u=v->u=p^ #v.Proof.destructp.exactidmap.Defined.DefinitionmoveL_transport_p{A:Type} (P:A->Type) {xy:A}(p:y=x) (u:Px) (v:Py):p^ #u=v->u=p#v.Proof.destructp.exactidmap.Defined.(* We have some coherences between those proofs. *)DefinitionmoveR_transport_p_V{A:Type} (P:A->Type) {xy:A}(p:x=y) (u:Px) (v:Py) (q:u=p^ #v): (moveR_transport_pPpuvq)^ =moveL_transport_pPpvuq^.Proof.destructp;reflexivity.Defined.DefinitionmoveR_transport_V_V{A:Type} (P:A->Type) {xy:A}(p:y=x) (u:Px) (v:Py) (q:u=p#v): (moveR_transport_VPpuvq)^ =moveL_transport_VPpvuq^.Proof.destructp;reflexivity.Defined.DefinitionmoveL_transport_V_V{A:Type} (P:A->Type) {xy:A}(p:x=y) (u:Px) (v:Py) (q:p#u=v): (moveL_transport_VPpuvq)^ =moveR_transport_VPpvuq^.Proof.destructp;reflexivity.Defined.DefinitionmoveL_transport_p_V{A:Type} (P:A->Type) {xy:A}(p:y=x) (u:Px) (v:Py) (q:p^ #u=v): (moveL_transport_pPpuvq)^ =moveR_transport_pPpvuq^.Proof.destructp;reflexivity.Defined.Functoriality of functionsHere we prove that functions behave like functors between groupoids, and thatapitself is functorial.Functions take identity paths to identity paths.Definitionap_1{AB:Type} (x:A) (f:A->B) :apf1 = 1 :> (fx=fx):=1.DefinitionapD_1{AB} (x:A) (f:forallx:A,Bx) :apDf1 = 1 :> (fx=fx):=1.Functions commute with concatenation.Definitionap_pp{AB:Type} (f:A->B) {xyz:A} (p:x=y) (q:y=z) :apf(p@q) = (apfp) @ (apfq):=matchqwithidpath=>matchpwithidpath=> 1endend.Definitionap_p_pp{AB:Type} (f:A->B) {w:B} {xyz:A}(r:w=fx) (p:x=y) (q:y=z) :r@ (apf(p@q)) = (r@apfp) @ (apfq).Proof.destructp,q.simpl.exact(concat_p_ppr1 1).Defined.Definitionap_pp_p{AB:Type} (f:A->B) {xyz:A} {w:B}(p:x=y) (q:y=z) (r:fz=w) :(apf(p@q)) @r= (apfp) @ (apfq@r).Proof.destructp,q.simpl.exact(concat_pp_p1 1r).Defined.Functions commute with path inverses.Definitioninverse_ap{AB:Type} (f:A->B) {xy:A} (p:x=y) :(apfp)^ =apf(p^):=matchpwithidpath=> 1end.Definitionap_V{AB:Type} (f:A->B) {xy:A} (p:x=y) :apf(p^) = (apfp)^:=matchpwithidpath=> 1end.apitself is functorial in the first argument.Definitionap_idmap{A:Type} {xy:A} (p:x=y) :apidmapp=p:=matchpwithidpath=> 1end.Definitionap_compose{ABC:Type} (f:A->B) (g:B->C) {xy:A} (p:x=y) :ap(gof)p=apg(apfp):=matchpwithidpath=> 1end.(* Sometimes we don't have the actual functioncompose. *)Definitionap_compose'{ABC:Type} (f:A->B) (g:B->C) {xy:A} (p:x=y) :ap(funa=>g(fa))p=apg(apfp):=matchpwithidpath=> 1end.The action of constant maps.Definitionap_const{AB:Type} {xy:A} (p:x=y) (z:B) :ap(fun_=>z)p= 1:=matchpwithidpath=>idpathend.Naturality ofap.Definitionconcat_Ap{AB:Type} {fg:A->B} (p:forallx,fx=gx) {xy:A} (q:x=y) :(apfq) @ (py) = (px) @ (apgq):=matchqwith|idpath=>concat_1p_p1_end.(* A useful variant of concat_Ap. *)Definitionap_homotopic{AB:Type} {fg:A->B} (p:forallx,fx=gx) {xy:A} (q:x=y): (apfq) = (px) @ (apgq) @ (py)^.Proof.applymoveL_pV.applyconcat_Ap.Defined.Naturality ofapat identity.Definitionconcat_A1p{A:Type} {f:A->A} (p:forallx,fx=x) {xy:A} (q:x=y) :(apfq) @ (py) = (px) @q:=matchqwith|idpath=>concat_1p_p1_end.(* The corresponding variant of concat_A1p. *)Definitionap_homotopic_id{A:Type} {f:A->A} (p:forallx,fx=x) {xy:A} (q:x=y): (apfq) = (px) @q@ (py)^.Proof.applymoveL_pV.applyconcat_A1p.Defined.Definitionconcat_pA1{A:Type} {f:A->A} (p:forallx,x=fx) {xy:A} (q:x=y) :(px) @ (apfq) =q@ (py):=matchqasiin(_=y)return(px@apfi=i@py)with|idpath=>concat_p1_1p_end.DefinitionapD_homotopic{A:Type} {B:A->Type} {fg:forallx,Bx}(p:forallx,fx=gx) {xy:A} (q:x=y):apDfq=ap(transportBq) (px) @apDgq@ (py)^.Proof.applymoveL_pV.destructq;unfoldapD,transport.symmetry.exact(concat_p1_@ap_idmap_@ (concat_1p_)^).Defined.Naturality with other paths hanging around.Definitionconcat_pA_pp{AB:Type} {fg:A->B} (p:forallx,fx=gx){xy:A} (q:x=y){wz:B} (r:w=fx) (s:gy=z):(r@apfq) @ (py@s) = (r@px) @ (apgq@s).Proof.destructq,s;simpl.induction(px).reflexivity.Defined.Definitionconcat_pA_p{AB:Type} {fg:A->B} (p:forallx,fx=gx){xy:A} (q:x=y){w:B} (r:w=fx):(r@apfq) @py= (r@px) @apgq.Proof.destructq;simpl.induction(px).reflexivity.Defined.Definitionconcat_A_pp{AB:Type} {fg:A->B} (p:forallx,fx=gx){xy:A} (q:x=y){z:B} (s:gy=z):(apfq) @ (py@s) = (px) @ (apgq@s).Proof.destructq,s;cbn.applyconcat_1p.Defined.Definitionconcat_pA1_pp{A:Type} {f:A->A} (p:forallx,fx=x){xy:A} (q:x=y){wz:A} (r:w=fx) (s:y=z):(r@apfq) @ (py@s) = (r@px) @ (q@s).Proof.destructq,s;simpl.induction(px).reflexivity.Defined.Definitionconcat_pp_A1p{A:Type} {g:A->A} (p:forallx,x=gx){xy:A} (q:x=y){wz:A} (r:w=x) (s:gy=z):(r@px) @ (apgq@s) = (r@q) @ (py@s).Proof.destructq,s;simpl.induction(px).reflexivity.Defined.Definitionconcat_pA1_p{A:Type} {f:A->A} (p:forallx,fx=x){xy:A} (q:x=y){w:A} (r:w=fx):(r@apfq) @py= (r@px) @q.Proof.destructq;simpl.induction(px).reflexivity.Defined.Definitionconcat_A1_pp{A:Type} {f:A->A} (p:forallx,fx=x){xy:A} (q:x=y){z:A} (s:y=z):(apfq) @ (py@s) = (px) @ (q@s).Proof.destructq,s;cbn.applyconcat_1p.Defined.Definitionconcat_pp_A1{A:Type} {g:A->A} (p:forallx,x=gx){xy:A} (q:x=y){w:A} (r:w=x):(r@px) @apgq= (r@q) @py.Proof.destructq;simpl.induction(px).reflexivity.Defined.Definitionconcat_p_A1p{A:Type} {g:A->A} (p:forallx,x=gx){xy:A} (q:x=y){z:A} (s:gy=z):px@ (apgq@s) =q@ (py@s).Proof.destructq,s;simpl.symmetry;applyconcat_1p.Defined.Some coherence lemmas for functorialityLemmaconcat_1p_1{A} {x:A} (p:x=x) (q:p= 1):concat_1pp@q=ap(funp'=> 1 @p')q.Proof.rewrite<- (inv_Vq).set(r:=q^).clearbodyr;clearq;destructr.reflexivity.Defined.Lemmaconcat_p1_1{A} {x:A} (p:x=x) (q:p= 1):concat_p1p@q=ap(funp'=>p'@ 1)q.Proof.rewrite<- (inv_Vq).set(r:=q^).clearbodyr;clearq;destructr.reflexivity.Defined.Action ofapD10andap10on paths.Application of paths between functions preserves the groupoid structureDefinitionapD10_1{A} {B:A->Type} (f:forallx,Bx) (x:A):apD10(idpathf)x= 1:= 1.DefinitionapD10_pp{A} {B:A->Type} {ff'f'':forallx,Bx}(h:f=f') (h':f'=f'') (x:A):apD10(h@h')x=apD10hx@apD10h'x.Proof.caseh,h';reflexivity.Defined.DefinitionapD10_V{A} {B:A->Type} {fg:forallx,Bx} (h:f=g) (x:A):apD10(h^)x= (apD10hx)^:=matchhwithidpath=> 1end.Definitionap10_1{AB} {f:A->B} (x:A) :ap10(idpathf)x= 1:= 1.Definitionap10_pp{AB} {ff'f'':A->B} (h:f=f') (h':f'=f'') (x:A):ap10(h@h')x=ap10hx@ap10h'x:=apD10_pphh'x.Definitionap10_V{AB} {fg:A->B} (h:f=g) (x:A):ap10(h^)x= (ap10hx)^:=apD10_Vhx.apD10andap10also behave nicely on paths produced byapDefinitionapD10_ap_precompose{ABC} (f:A->B) {gg':forallx:B,Cx} (p:g=g')a:apD10(ap(funh:forallx:B,Cx=>hoDf)p)a=apD10p(fa).Proof.destructp;reflexivity.Defined.Definitionap10_ap_precompose{ABC} (f:A->B) {gg':B->C} (p:g=g')a:ap10(ap(funh:B->C=>hof)p)a=ap10p(fa):=apD10_ap_precomposefpa.DefinitionapD10_ap_postcompose{ABC} (f:forallx,Bx->C) {gg':forallx:A,Bx} (p:g=g')a:apD10(ap(funh:forallx:A,Bx=>funx=>fx(hx))p)a=ap(fa) (apD10pa).Proof.destructp;reflexivity.Defined.Definitionap10_ap_postcompose{ABC} (f:B->C) {gg':A->B} (p:g=g')a:ap10(ap(funh:A->B=>foh)p)a=apf(ap10pa):=apD10_ap_postcompose(funa=>f)pa.Definitionap100{XYZ:Type} {fg:X->Y->Z} (p:f=g) (x:X) (y:Y):fxy=gxy:= (ap10(ap10px)y).Transport and the groupoid structure of pathsDefinitiontransport_1{A:Type} (P:A->Type) {x:A} (u:Px): 1 #u=u:= 1.Definitiontransport_pp{A:Type} (P:A->Type) {xyz:A} (p:x=y) (q:y=z) (u:Px) :p@q#u=q#p#u:=matchqwithidpath=>matchpwithidpath=> 1endend.Definitiontransport_pV{A:Type} (P:A->Type) {xy:A} (p:x=y) (z:Py):p#p^ #z=z:= (transport_ppPp^pz)^@ap(funr=>transportPrz) (concat_Vpp).Definitiontransport_Vp{A:Type} (P:A->Type) {xy:A} (p:x=y) (z:Px):p^ #p#z=z:= (transport_ppPpp^z)^@ap(funr=>transportPrz) (concat_pVp).In the future, we may expect to need some higher coherence for transport:
  for instance, that transport acting on the associator is trivial.Definitiontransport_p_pp{A:Type} (P:A->Type){xyzw:A} (p:x=y) (q:y=z) (r:z=w)(u:Px):ap(fune=>e#u) (concat_p_pppqr)@ (transport_ppP(p@q)ru) @ap(transportPr) (transport_ppPpqu)= (transport_ppPp(q@r)u) @ (transport_ppPqr(p#u)):> ((p@ (q@r)) #u=r#q#p#u) .Proof.destructp,q,r.simpl.exact1.Defined.(* Here are other coherence lemmas for transport. *)Definitiontransport_pVp{A} (P:A->Type) {xy:A} (p:x=y) (z:Px):transport_pVPp(transportPpz)=ap(transportPp) (transport_VpPpz).Proof.destructp;reflexivity.Defined.Definitiontransport_VpV{A} (P:A->Type) {xy:A} (p:x=y) (z:Py):transport_VpPp(transportPp^z)=ap(transportPp^) (transport_pVPpz).Proof.destructp;reflexivity.Defined.Definitionap_transport_transport_pV{A} (P:A->Type) {xy:A}(p:x=y) (u:Px) (v:Py) (e:transportPpu=v):ap(transportPp) (moveL_transport_VPpuve)@transport_pVPpv=e.Proof.bydestructe,p.Defined.DefinitionmoveL_transport_V_1{A} (P:A->Type) {xy:A}(p:x=y) (u:Px):moveL_transport_VPpu(p#u) 1 = (transport_VpPpu)^.(* moveL_transport_V P p (transport P p^ v) (transport P p (transport P p^ v)) 1 *)(* = ap (transport P p^) (transport_pV P p v)^. *)Proof.(* pose (u := p^  v).  *)(* assert (moveL_transport_V P p u (p  u) 1 = (transport_Vp P p u)^). *)destructp;reflexivity.(* subst u. rewrite X. *)Defined.Occasionally the induction principles for the identity type show up explicitly; these let us turn them into transport.Definitionpaths_rect_transport{A:Type} (P:A->Type) {xy:A}(p:x=y) (u:Px):paths_rectAx(funa_=>Pa)uyp=transportPpu:= 1.Definitionpaths_ind_transport{A:Type} (P:A->Type) {xy:A}(p:x=y) (u:Px):paths_indx(funa_=>Pa)uyp=transportPpu:= 1.Definitionpaths_ind_r_transport{A:Type} (P:A->Type) {xy:A}(p:x=y) (u:Py):paths_ind_ry(funb_=>Pb)uxp=transportPp^u.Proof.bydestructp.Defined.ap11Definitionap11_is_ap10_ap01{AB} {fg:A->B} (h:f=g) {xy:A} (p:x=y):ap11hp=ap10hx@apgp.Proof.bypath_induction.Defined.Dependent transport in doubly dependent types and more.DefinitiontransportD{A:Type} (B:A->Type) (C:foralla:A,Ba->Type){x1x2:A} (p:x1=x2) (y:Bx1) (z:Cx1y):Cx2(p#y):=matchpwithidpath=>zend.DefinitiontransportD2{A:Type} (BC:A->Type) (D:foralla:A,Ba->Ca->Type){x1x2:A} (p:x1=x2) (y:Bx1) (z:Cx1) (w:Dx1yz):Dx2(p#y) (p#z):=matchpwithidpath=>wend.apfor curried two variable functionsDefinitionap011{ABC} (f:A->B->C) {xx'yy'} (p:x=x') (q:y=y'):fxy=fx'y'.Proof.destructp.applyap.exactq.Defined.Definitionap011_V{ABC} (f:A->B->C) {xx'yy'} (p:x=x') (q:y=y'):ap011fp^q^ = (ap011fpq)^.Proof.destructp.applyap_V.Defined.Definitionap011_pp{ABC} (f:A->B->C) {xx'x''yy'y''}(p:x=x') (p':x'=x'') (q:y=y') (q':y'=y''):ap011f(p@p') (q@q') =ap011fpq@ap011fp'q'.Proof.destructp,p'.applyap_pp.Defined.Definitionap011_compose{ABCD} (f:A->B->C) (g:C->D) {xx'yy'}(p:x=x') (q:y=y'):ap011(funxy=>g(fxy))pq=apg(ap011fpq).Proof.destructp;simpl.applyap_compose.Defined.Definitionap011_compose'{ABCDE} (f:A->B->C) (g:D->A) (h:E->B){xx'yy'}(p:x=x') (q:y=y'):ap011(funxy=>f(gx) (hy))pq=ap011f(apgp) (aphq).Proof.destructp;simpl.applyap_compose.Defined.Definitionap011_is_ap{ABC} (f:A->B->C) {xx':A} {yy':B} (p:x=x') (q:y=y'):ap011fpq=ap(funx=>fxy)p@ap(funy=>fx'y)q.Proof.destructp.symmetry.applyconcat_1p.Defined.It would be nice to have a consistent way to name the different ways in which this can be dependent.  The following are a sort of half-hearted attempt.Definitionap011D{ABC} (f:forall(a:A),Ba->C){xx'} (p:x=x') {yy'} (q:p#y=y'):fxy=fx'y'.Proof.destructp,q;reflexivity.Defined.Definitionap01D1{ABC} (f:forall(a:A),Ba->Ca){xx'} (p:x=x') {yy'} (q:p#y=y'):transportCp(fxy) =fx'y'.Proof.destructp,q;reflexivity.Defined.DefinitionapD011{ABC} (f:forall(a:A) (b:Ba),Cab){xx'} (p:x=x') {yy'} (q:p#y=y'):transport(Cx')q(transportDBCpy(fxy)) =fx'y'.Proof.destructp,q;reflexivity.Defined.Transporting along two 1-dimensional pathsDefinitiontransport011{AB} (P:A->B->Type) {x1x2:A} {y1y2:B}(p:x1=x2) (q:y1=y2) (z:Px1y1):Px2y2:=transport(funx=>Pxy2)p(transport(funy=>Px1y)qz).Definitiontransport011_pp{AB} (P:A->B->Type) {x1x2x3:A} {y1y2y3:B}(p1:x1=x2) (p2:x2=x3) (q1:y1=y2) (q2:y2=y3) (z:Px1y1):transport011P(p1@p2) (q1@q2)z=transport011Pp2q2(transport011Pp1q1z).Proof.destructp1,p2,q1,q2;reflexivity.Defined.Definitiontransport011_compose{ABA'B'} (P:A->B->Type) (f:A'->A) (g:B'->B){x1x2:A'} {y1y2:B'} (p:x1=x2) (q:y1=y2) (z:P(fx1) (gy1)):transport011(funxy=>P(fx) (gy))pqz=transport011P(apfp) (apgq)z.Proof.destructp,q;reflexivity.Defined.Naturality oftransport011.Definitionap_transport011{AB} {PQ:A->B->Type}{a1a2:A} {b1b2:B} (p:a1=a2) (q:b1=b2)(f:forall{ab},Pab->Qab) (x:Pa1b1):f(transport011Ppqx) =transport011Qpq(fx).Proof.destructp,q;reflexivity.Defined.Transporting along higher-dimensional pathsDefinitiontransport2{A:Type} (P:A->Type) {xy:A} {pq:x=y}(r:p=q) (z:Px):p#z=q#z:=ap(funp'=>p'#z)r.An alternative definition.Definitiontransport2_is_ap10{A:Type} (Q:A->Type) {xy:A} {pq:x=y}(r:p=q) (z:Qx):transport2Qrz=ap10(ap(transportQ)r)z:=matchrwithidpath=> 1end.Definitiontransport2_p2p{A:Type} (P:A->Type) {xy:A} {p1p2p3:x=y}(r1:p1=p2) (r2:p2=p3) (z:Px):transport2P(r1@r2)z=transport2Pr1z@transport2Pr2z.Proof.destructr1,r2;reflexivity.Defined.Definitiontransport2_V{A:Type} (Q:A->Type) {xy:A} {pq:x=y}(r:p=q) (z:Qx):transport2Q(r^)z= (transport2Qrz)^:=matchrwithidpath=> 1end.Definitionconcat_AT{A:Type} (P:A->Type) {xy:A} {pq:x=y}{zw:Px} (r:p=q) (s:z=w):ap(transportPp)s@transport2Prw=transport2Prz@ap(transportPq)s:=matchrwithidpath=> (concat_p1_1p_)end.Definitiontransport_pp_1{A:Type} (P:A->Type) {ab:A} (p:a=b) (x:Pa):transport_ppPp1x=transport2P(concat_p1p)x.Proof.byinductionp.Defined.(* TODO: What should this be called? *)Lemmaap_transport{A} {PQ:A->Type} {xy:A} (p:x=y) (f:forallx,Px->Qx) (z:Px) :fy(p#z) = (p# (fxz)).Proof.byinductionp.Defined.Lemmaap_transportD{A:Type}(B:A->Type) (C1C2:foralla:A,Ba->Type)(f:forallab,C1ab->C2ab){x1x2:A} (p:x1=x2) (y:Bx1) (z:C1x1y):fx2(p#y) (transportDBC1pyz)=transportDBC2py(fx1yz).Proof.byinductionp.Defined.Lemmaap_transportD2{A:Type}(BC:A->Type) (D1D2:foralla,Ba->Ca->Type)(f:forallabc,D1abc->D2abc){x1x2:A} (p:x1=x2) (y:Bx1) (z:Cx1) (w:D1x1yz):fx2(p#y) (p#z) (transportD2BCD1pyzw)=transportD2BCD2pyz(fx1yzw).Proof.byinductionp.Defined.(* TODO: What should this be called? *)Lemmaap_transport_pV{X} (Y:X->Type) {x1x2:X} (p:x1=x2){y1y2:Yx2} (q:y1=y2):ap(transportYp) (ap(transportYp^)q) =transport_pVYpy1@q@ (transport_pVYpy2)^.Proof.destructp,q;reflexivity.Defined.(* TODO: And this? *)Definitiontransport_pV_ap{X} (P:X->Type) (f:forallx,Px){x1x2:X} (p:x1=x2):ap(transportPp) (apDfp^) @apDfp=transport_pVPp(fx2).Proof.destructp;reflexivity.Defined.DefinitionapD_pp{A} {P:A->Type} (f:forallx,Px){xyz:A} (p:x=y) (q:y=z):apDf(p@q)=transport_ppPpq(fx) @ap(transportPq) (apDfp) @apDfq.Proof.destructp,q;reflexivity.Defined.DefinitionapD_V{A} {P:A->Type} (f:forallx,Px){xy:A} (p:x=y):apDfp^ =moveR_transport_V____(apDfp)^.Proof.destructp;reflexivity.Defined.Transporting in particular fibrations.One frequently needs lemmas showing that transport in a certain dependent type is equal to some more explicitly defined operation, defined according to the structure of that dependent type.  For most dependent types, we prove these lemmas in the appropriate file in the types/ subdirectory.  Here we consider only the most basic cases.Transporting in a constant fibration.Definitiontransport_const{AB:Type} {x1x2:A} (p:x1=x2) (y:B):transport(funx=>B)py=y.Proof.destructp.exact1.Defined.Definitiontransport2_const{AB:Type} {x1x2:A} {pq:x1=x2}(r:p=q) (y:B):transport_constpy=transport2(fun_=>B)ry@transport_constqy:=matchrwithidpath=> (concat_1p_)^end.Transporting in a pulled back fibration.Lemmatransport_compose{AB} {xy:A} (P:B->Type) (f:A->B)(p:x=y) (z:P(fx)):transport(funx=>P(fx))pz=transportP(apfp)z.Proof.destructp;reflexivity.Defined.LemmatransportD_compose{AA'}B{xx':A} (C:forallx:A',Bx->Type) (f:A->A')(p:x=x')y(z:C(fx)y):transportD(Bof) (CoDf)pyz=transport(C(fx')) (transport_composeBfpy)^ (transportDBC(apfp)yz).Proof.destructp;reflexivity.Defined.(* TODO: Is there a lemma liketransportD_compose, but forapD, which subsumes this? *)Lemmatransport_apD_transportD{A}B(f:forallx:A,Bx) (C:forallx,Bx->Type){x1x2:A} (p:x1=x2) (z:Cx1(fx1)):apDfp#transportDBCp_z=transport(funx=>Cx(fx))pz.Proof.destructp;reflexivity.Defined.Lemmatransport_precompose{ABC} (f:A->B) (gg':B->C) (p:g=g'):transport(funh:B->C=>gof=hof)p1 =ap(funh=>hof)p.Proof.destructp;reflexivity.Defined.A special case oftransport_composewhich seems to come up a lot.Definitiontransport_idmap_ap{A} (P:A->Type) {xy:A} (p:x=y) (u:Px):transportPpu=transportidmap(apPp)u:=matchpwithidpath=>idpathend.Sometimes, it's useful to have the goal be in terms ofap, so we can use lemmas aboutap.  However, we can't justrewrite!transport_idmap_ap, as that's likely to loop.  So, instead, we provide a tactictransport_to_ap, that replaces alltransportPpuwithtransportidmap(apPp)ufor non-idmapP.Ltactransport_to_ap:=repeatmatchgoalwith| [ |-context[transport?P?p?u] ]=>matchPwith|idmap=>fail1(* we don't want to turntransportidmap(ap__)intotransportidmap(apidmap(ap__))*)|_=>idtacend;progressrewrite(transport_idmap_apPpu)end.Transporting in a fibration dependent on two independent types commutes.Definitiontransport_transport{AB} (C:A->B->Type){x1x2:A} (p:x1=x2) {y1y2:B} (q:y1=y2)(c:Cx1y1):transport(Cx2)q(transport(funx=>Cxy1)pc)=transport(funx=>Cxy2)p(transport(Cx1)qc).Proof.destructp,q;reflexivity.Defined.The behavior ofapandapD.In a constant fibration,apDreduces toap, modulotransport_const.LemmaapD_const{AB} {xy:A} (f:A->B) (p:x=y) :apDfp=transport_constp(fx) @apfp.Proof.destructp;reflexivity.Defined.DefinitionapD_compose{AA':Type} {B:A'->Type} (g:A->A')(f:foralla,Ba) {xy:A} (p:x=y):apD(fog)p= (transport_compose____) @apDf(apgp).Proof.bydestructp.Defined.DefinitionapD_compose'{AA':Type} {B:A'->Type} (g:A->A')(f:foralla,Ba) {xy:A} (p:x=y):apDf(apgp) = (transport_composeB___)^ @apD(fog)p.Proof.bydestructp.Defined.The 2-dimensional groupoid structureHorizontal composition of 2-dimensional paths.Definitionconcat2{A} {xyz:A} {pp':x=y} {qq':y=z} (h:p=p') (h':q=q'):p@q=p'@q':=matchh,h'withidpath,idpath=> 1end.Notation"p @@ q" := (concat2pq)%path:path_scope.Argumentsconcat2:simplnomatch.Lemmaconcat2_ap_ap{AB:Type} {x'y'z':B}(f:A-> (x'=y')) (g:A-> (y'=z')){xy:A} (p:x=y): (apfp) @@ (apgp) =ap(funu=>fu@gu)p.Proof.bypath_induction.Defined.2-dimensional path inversionDefinitioninverse2{A:Type} {xy:A} {pq:x=y} (h:p=q):p^ =q^:=apinverseh.Some higher coherencesLemmaap_pp_concat_p1{AB} (f:A->B) {ab:A} (p:a=b):ap_ppfp1 @concat_p1(apfp) =ap(apf) (concat_p1p).Proof.destructp;reflexivity.Defined.Lemmaap_pp_concat_1p{AB} (f:A->B) {ab:A} (p:a=b):ap_ppf1p@concat_1p(apfp) =ap(apf) (concat_1pp).Proof.destructp;reflexivity.Defined.Lemmaap_pp_concat_pV{AB} (f:A->B) {xy:A} (p:x=y):ap_ppfpp^ @ ((1 @@ap_Vfp) @concat_pV(apfp))=ap(apf) (concat_pVp).Proof.destructp;reflexivity.Defined.Lemmaap_pp_concat_Vp{AB} (f:A->B) {xy:A} (p:x=y):ap_ppfp^p@ ((ap_Vfp@@ 1) @concat_Vp(apfp))=ap(apf) (concat_Vpp).Proof.destructp;reflexivity.Defined.Lemmaconcat_pV_inverse2{A} {xy:A} (pq:x=y) (r:p=q): (r@@inverse2r) @concat_pVq=concat_pVp.Proof.destructr,p;reflexivity.Defined.Lemmaconcat_Vp_inverse2{A} {xy:A} (pq:x=y) (r:p=q): (inverse2r@@r) @concat_Vpq=concat_Vpp.Proof.destructr,p;reflexivity.Defined.WhiskeringDefinitionwhiskerL{A:Type} {xyz:A} (p:x=y){qr:y=z} (h:q=r) :p@q=p@r:= 1 @@h.DefinitionwhiskerR{A:Type} {xyz:A} {pq:x=y}(h:p=q) (r:y=z) :p@r=q@r:=h@@ 1.Unwhiskering, a.k.a. cancelling.DefinitioncancelL{A} {xyz:A} (p:x=y) (qr:y=z): (p@q=p@r) -> (q=r):=funh=> (concat_V_pppq)^ @whiskerLp^h@ (concat_V_pppr).DefinitioncancelR{A} {xyz:A} (pq:x=y) (r:y=z): (p@r=q@r) -> (p=q):=funh=> (concat_pp_Vpr)^ @whiskerRhr^ @ (concat_pp_Vqr).Whiskering and identity paths.DefinitionwhiskerR_p1{A:Type} {xy:A} {pq:x=y} (h:p=q) :(concat_p1p)^ @whiskerRh1 @concat_p1q=h:=matchhwithidpath=>matchpwithidpath=>1endend.DefinitionwhiskerR_1p{A:Type} {xyz:A} (p:x=y) (q:y=z) :whiskerR1q= 1 :> (p@q=p@q):=matchqwithidpath=> 1end.DefinitionwhiskerL_p1{A:Type} {xyz:A} (p:x=y) (q:y=z) :whiskerLp1 = 1 :> (p@q=p@q):=matchqwithidpath=> 1end.DefinitionwhiskerL_1p{A:Type} {xy:A} {pq:x=y} (h:p=q) :(concat_1pp) ^ @whiskerL1h@concat_1pq=h:=matchhwithidpath=>matchpwithidpath=>1endend.DefinitionwhiskerR_p1_1{A} {x:A} (h:idpathx=idpathx):whiskerRh1 =h.Proof.refine(_@whiskerR_p1h);simpl.symmetry;refine(concat_p1_@concat_1p_).Defined.DefinitionwhiskerL_1p_1{A} {x:A} (h:idpathx=idpathx):whiskerL1h=h.Proof.refine(_@whiskerL_1ph);simpl.symmetry;refine(concat_p1_@concat_1p_).Defined.Definitioncancel2L{A:Type} {xyz:A} {pp':x=y} {qq':y=z}(g:p=p') (hk:q=q'): (g@@h=g@@k) -> (h=k).Proof.intror.inductiong,p,q.refine((whiskerL_1ph)^ @_).refine(_@ (whiskerL_1pk)).refine(whiskerR__).refine(whiskerL__).applyr.Defined.Definitioncancel2R{A:Type} {xyz:A} {pp':x=y} {qq':y=z}(gh:p=p') (k:q=q'): (g@@k=h@@k) -> (g=h).Proof.intror.inductionk,p,q.refine((whiskerR_p1g)^ @_).refine(_@ (whiskerR_p1h)).refine(whiskerR__).refine(whiskerL__).applyr.Defined.Whiskering and composition(* The naming scheme for these is a little unclear; shouldpprefer to concatenation of the 2-paths being whiskered or of the paths we are whiskering by? *)DefinitionwhiskerL_pp{A} {xyz:A} (p:x=y) {qq'q'':y=z}(r:q=q') (s:q'=q''):whiskerLp(r@s) =whiskerLpr@whiskerLps.Proof.destructp,r,s;reflexivity.Defined.DefinitionwhiskerR_pp{A} {xyz:A} {pp'p'':x=y} (q:y=z)(r:p=p') (s:p'=p''):whiskerR(r@s)q=whiskerRrq@whiskerRsq.Proof.destructq,r,s;reflexivity.Defined.(* For now, I've put anLorRto mark when we're referring to the whiskering paths. *)DefinitionwhiskerL_VpL{A} {xyz:A} (p:x=y){qq':y=z} (r:q=q'): (concat_V_pppq)^ @whiskerLp^ (whiskerLpr) @concat_V_pppq'=r.Proof.destructp,r,q.reflexivity.Defined.DefinitionwhiskerL_pVL{A} {xyz:A} (p:y=x){qq':y=z} (r:q=q'): (concat_p_Vppq)^ @whiskerLp(whiskerLp^r) @concat_p_Vppq'=r.Proof.destructp,r,q.reflexivity.Defined.DefinitionwhiskerR_pVR{A} {xyz:A} {pp':x=y}(r:p=p') (q:y=z): (concat_pp_Vpq)^ @whiskerR(whiskerRrq)q^ @concat_pp_Vp'q=r.Proof.destructp,r,q.reflexivity.Defined.DefinitionwhiskerR_VpR{A} {xyz:A} {pp':x=y}(r:p=p') (q:z=y): (concat_pV_ppq)^ @whiskerR(whiskerRrq^)q@concat_pV_pp'q=r.Proof.destructp,r,q.reflexivity.Defined.Naturality ofconcat_p_ppin left-most argument.Definitionconcat_p_pp_nat_l{A} {wxyz:A}{pp':w=x} (h:p=p') (q:x=y) (r:y=z):whiskerRh(q@r) @concat_p_ppp'qr=concat_p_pppqr@whiskerR(whiskerRhq)r.Proof.bydestructh,p,q,r.Defined.Naturality ofconcat_p_ppin middle argument.Definitionconcat_p_pp_nat_m{A} {wxyz:A}(p:w=x) {qq':x=y} (h:q=q') (r:y=z):whiskerLp(whiskerRhr) @concat_p_pppq'r=concat_p_pppqr@whiskerR(whiskerLph)r.Proof.bydestructh,p,q,r.Defined.Naturality ofconcat_p_ppin right-most argument.Definitionconcat_p_pp_nat_r{A} {wxyz:A}(p:w=x) (q:x=y) {rr':y=z} (h:r=r'):whiskerLp(whiskerLqh) @concat_p_pppqr'=concat_p_pppqr@whiskerL(p@q)h.Proof.bydestructh,p,q,r.Defined.The interchange law for concatenation.Definitionconcat_concat2{A:Type} {xyz:A} {pp'p'':x=y} {qq'q'':y=z}(a:p=p') (b:p'=p'') (c:q=q') (d:q'=q'') :(a@@c) @ (b@@d) = (a@b) @@ (c@d).Proof.cased.casec.caseb.casea.reflexivity.Defined.The interchange law for whiskering.  Special case ofconcat_concat2.Definitionconcat_whisker{A} {xyz:A} (pp':x=y) (qq':y=z) (a:p=p') (b:q=q') :(whiskerRaq) @ (whiskerLp'b) = (whiskerLpb) @ (whiskerRaq'):=matchbwithidpath=>matchawithidpath=>(concat_1p_)^endend.Structure corresponding to the coherence equations of a bicategory.The "pentagonator": the 3-cell witnessing the associativity pentagon.Definitionpentagon{A:Type} {vwxyz:A} (p:v=w) (q:w=x) (r:x=y) (s:y=z):whiskerLp(concat_p_ppqrs)@concat_p_ppp(q@r)s@whiskerR(concat_p_pppqr)s=concat_p_pppq(r@s) @concat_p_pp(p@q)rs.Proof.casep,q,r,s.reflexivity.Defined.The 3-cell witnessing the left unit triangle.Definitiontriangulator{A:Type} {xyz:A} (p:x=y) (q:y=z):concat_p_ppp1q@whiskerR(concat_p1p)q=whiskerLp(concat_1pq).Proof.casep,q.reflexivity.Defined.The Eckmann-Hilton argumentDefinitioneckmann_hilton{A:Type} {x:A} (pq: 1 = 1 :> (x=x)) :p@q=q@p:=(whiskerR_p1p@@whiskerL_1pq)^@ (concat_p1_@@concat_p1_)@ (concat_1p_@@concat_1p_)@ (concat_whisker____pq)@ (concat_1p_@@concat_1p_)^@ (concat_p1_@@concat_p1_)^@ (whiskerL_1pq@@whiskerR_p1p).The action of functions on 2-dimensional pathsDefinitionap02{AB:Type} (f:A->B) {xy:A} {pq:x=y} (r:p=q) :apfp=apfq:=ap(apf)r.Definitionap02_pp{AB} (f:A->B) {xy:A} {pp'p'':x=y} (r:p=p') (r':p'=p''):ap02f(r@r') =ap02fr@ap02fr':=ap_pp(apf)rr'.Definitionap02_p2p{AB} (f:A->B) {xyz:A} {pp':x=y} {qq':y=z} (r:p=p') (s:q=q'):ap02f(r@@s) =ap_ppfpq@ (ap02fr@@ap02fs)@ (ap_ppfp'q')^.Proof.caser,s,p,q.reflexivity.Defined.DefinitionapD02{A:Type} {B:A->Type} {xy:A} {pq:x=y}(f:forallx,Bx) (r:p=q):apDfp=transport2Br(fx) @apDfq:=matchrwithidpath=> (concat_1p_)^end.DefinitionapD02_const{AB:Type} (f:A->B) {xy:A} {pq:x=y} (r:p=q):apD02fr= (apD_constfp)@ (transport2_constr(fx) @@ap02fr)@ (concat_p_pp___)^@ (whiskerL(transport2_r(fx)) (apD_constfq)^):=matchrwithidpath=>matchpwithidpath=> 1endend.(* And now for a lemma whose statement is much longer than its proof. *)DefinitionapD02_pp{A} (B:A->Type) (f:forallx:A,Bx) {xy:A}{p1p2p3:x=y} (r1:p1=p2) (r2:p2=p3):apD02f(r1@r2)=apD02fr1@whiskerL(transport2Br1(fx)) (apD02fr2)@concat_p_pp___@ (whiskerR(transport2_p2pBr1r2(fx))^ (apDfp3)).Proof.destructr1,r2.destructp1.reflexivity.Defined.Definitionap022{ABC} (f:A->B->C) {xx'yy'}{pp':x=x'} (r:p=p') {qq':y=y'} (s:q=q'):ap011fpq=ap011fp'q'.Proof.destructr,p.applyap02.exacts.Defined.These lemmas need better names.Definitionap_transport_Vp_idmap{AB} (pq:A=B) (r:q=p) (z:A):ap(transportidmapq^) (ap(funs=>transportidmapsz)r)@ap(funs=>transportidmaps(p#z)) (inverse2r)@transport_Vpidmappz=transport_Vpidmapqz.Proof.bypath_induction.Defined.Definitionap_transport_pV_idmap{AB} (pq:A=B) (r:q=p) (z:B):ap(transportidmapq) (ap(funs=>transportidmaps^z)r)@ap(funs=>transportidmaps(p^ #z))r@transport_pVidmappz=transport_pVidmapqz.Proof.bypath_induction.Defined.HintsWe declare some moreHintResolvehints, now in the "hint database"path_hints.  In general various hints (resolve, rewrite, unfold hints) can be grouped into "databases". This is necessary as sometimes different kinds of hints cannot be mixed, for example because they would cause a combinatorial explosion or rewriting cycles.  A specificHintResolvedatabasedbcan be used withautowithdb.The hints inpath_hintsare designed to push concatenation *outwards*, eliminate identities and inverses, and associate to the left as far as possible.#[export]HintResolveinverseconcat_1pconcat_p1concat_p_ppinv_ppinv_V:path_hints.(* First try at a paths db.  We want the RHS of the equation to become strictly simpler. *)#[export]HintRewrite@concat_p1@concat_1p@concat_p_pp(* there is a choice here !*)@concat_pV@concat_Vp@concat_V_pp@concat_p_Vp@concat_pp_V@concat_pV_p(*@inv_pp*)(* I am not sure about this one *)@inv_V@moveR_Mp@moveR_pM@moveL_Mp@moveL_pM@moveL_1M@moveL_M1@moveR_M1@moveR_1M@ap_1(* @ap_pp@ap_p_pp ?*)@inverse_ap@ap_idmap(* @ap_compose@ap_compose'*)@ap_const(* Unsure about naturality ofap, was absent in the old implementation. *)@apD10_1:paths.Ltachott_simpl:=autorewritewithpathsin* |- * ;autowithpath_hints.

--- Homotopy\Suspension.html ---
SuspensionLibrary SuspensionRequireImportBasics.RequireImportTypes.RequireImportCubical.DPathCubical.DPathSquare.RequireImportWildCat.RequireImportColimits.Pushout.RequireImportNullHomotopy.RequireImportTruncations.Core.RequireImportModalities.Modality.RequireImportExtensions.The suspension of a typeGeneralizable VariablesXABfgn.Local OpenScopepath_scope.(* ** Definition of suspension *)We define the suspension of a type X as the pushout of 1 <- X -> 1DefinitionSusp(X:Type) :=Pushout@{_SetSet_} (const_ttX) (const_ttX).DefinitionNorth{X} :SuspX:=pushltt.DefinitionSouth{X} :SuspX:=pushrtt.Definitionmerid{X} (x:X) :North=South:=pgluex.We think of this as the HIT with two pointsNorthandSouthand a pathmeridbetween themWe can derive an induction principle for the suspensionDefinitionSusp_ind{X:Type} (P:SuspX->Type)(H_N:PNorth) (H_S:PSouth)(H_merid:forallx:X, (meridx) #H_N=H_S):forall(y:SuspX),Py.Proof.srapplyPushout_ind.-exact(Unit_indH_N).-exact(Unit_indH_S).-exact(H_merid).Defined.We can also derive the computation ruleDefinitionSusp_ind_beta_merid{X:Type}(P:SuspX->Type) (H_N:PNorth) (H_S:PSouth)(H_merid:forallx:X, (meridx) #H_N=H_S) (x:X):apD(Susp_indPH_NH_SH_merid) (meridx) =H_meridx.Proof.srapplyPushout_ind_beta_pglue.Defined.We want to allow the user to forget that we've defined suspension as a pushout and make it look like it was defined directly as a HIT. This has the advantage of not having to assume any new HITs but allowing us to have conceptual clarity.ArgumentsSusp:simplnever.ArgumentsNorth:simplnever.ArgumentsSouth:simplnever.Argumentsmerid:simplnever.ArgumentsSusp_ind_beta_merid:simplnever.A version ofSusp_indspecifically for proving that two functions defined on a suspension are homotopic.DefinitionSusp_ind_FlFr{XY:Type} (fg:SuspX->Y)(HN:fNorth=gNorth)(HS:fSouth=gSouth)(Hmerid:forallx,apf(meridx) @HS=HN@apg(meridx)):f==g.Proof.snrapplySusp_ind.-exactHN.-exactHS.-introx.nrapplytransport_paths_FlFr'.applyHmerid.Defined.(* ** Non-dependent eliminator. *)DefinitionSusp_rec{XY:Type}(H_NH_S:Y) (H_merid:X->H_N=H_S):SuspX->Y:=Pushout_rec(f:=const_ttX) (g:=const_ttX)Y(Unit_indH_N) (Unit_indH_S)H_merid.Global ArgumentsSusp_rec{XY}%_type_scopeH_NH_SH_merid%_function_scope_.DefinitionSusp_rec_beta_merid{XY:Type}{H_NH_S:Y} {H_merid:X->H_N=H_S} (x:X):ap(Susp_recH_NH_SH_merid) (meridx) =H_meridx.Proof.srapplyPushout_rec_beta_pglue.Defined.Eta-rule.The eta-rule for suspension states that any function out of a suspension is equal to one defined bySusp_indin the obvious way. We give it first in a weak form, producing just a pointwise equality, and then turn this into an actual equality usingFunext.DefinitionSusp_ind_eta_homotopic{X:Type} {P:SuspX->Type} (f:forally,Py):f==Susp_indP(fNorth) (fSouth) (funx=>apDf(meridx)).Proof.unfoldpointwise_paths.refine(Susp_ind_1 1_).introsx.refine(transport_paths_FlFr_D(g:=Susp_indP(fNorth) (fSouth) (funx:X=>apDf(meridx)))__@_);simpl.applymoveR_pM.applyequiv_p1_1q.applyap,inverse.refine(Susp_ind_beta_merid_____).Defined.DefinitionSusp_rec_eta_homotopic{XY:Type} (f:SuspX->Y):f==Susp_rec(fNorth) (fSouth) (funx=>apf(meridx)).Proof.snrapplySusp_ind_FlFr.1, 2:reflexivity.introx.applyequiv_p1_1q.exact(Susp_rec_beta_merid_)^.Defined.DefinitionSusp_ind_eta`{Funext}{X:Type} {P:SuspX->Type} (f:forally,Py):f=Susp_indP(fNorth) (fSouth) (funx=>apDf(meridx)):=path_forall__(Susp_ind_eta_homotopicf).DefinitionSusp_rec_eta`{Funext} {XY:Type} (f:SuspX->Y):f=Susp_rec(fNorth) (fSouth) (funx=>apf(meridx)):=path_forall__(Susp_rec_eta_homotopicf).FunctorialityDefinitionfunctor_susp{XY:Type} (f:X->Y):SuspX->SuspY.Proof.srapplySusp_rec.-exactNorth.-exactSouth.-introsx;exact(merid(fx)).Defined.Definitionfunctor_susp_beta_merid{XY:Type} (f:X->Y) (x:X):ap(functor_suspf) (meridx) =merid(fx).Proof.srapplySusp_rec_beta_merid.Defined.Definitionfunctor_susp_compose{XYZ}(f:X->Y) (g:Y->Z):functor_susp(gof) ==functor_suspgofunctor_suspf.Proof.snrapplySusp_ind_FlFr.1,2:reflexivity.introx.applyequiv_p1_1q.lhsnrapplyfunctor_susp_beta_merid;symmetry.lhsnrefine(ap_compose(functor_suspf)_(meridx)).lhsnrefine(ap_(functor_susp_beta_merid__)).applyfunctor_susp_beta_merid.Defined.Definitionfunctor_susp_idmap{X}:functor_suspidmap== (idmap:SuspX->SuspX).Proof.snrapplySusp_ind_FlFr.1,2:reflexivity.introx.applyequiv_p1_1q.lhsnrapplyfunctor_susp_beta_merid.symmetry;applyap_idmap.Defined.Definitionfunctor2_susp{XY} {fg:X->Y} (h:f==g):functor_suspf==functor_suspg.Proof.srapplySusp_ind_FlFr.1, 2:reflexivity.introx.applyequiv_p1_1q.lhsnrapply(functor_susp_beta_meridf).rhsnrapply(functor_susp_beta_meridg).applyap,h.Defined.Global Instanceis0functor_susp:Is0FunctorSusp:=Build_Is0Functor____Susp(@functor_susp).Global Instanceis1functor_susp:Is1FunctorSusp:=Build_Is1Functor__________Susp_(@functor2_susp) (@functor_susp_idmap) (@functor_susp_compose).Universal propertyDefinitionequiv_Susp_rec`{Funext} (XY:Type): (SuspX->Y) <~> {NS:Y*Y&X->fstNS=sndNS}.Proof.snrapplyequiv_adjointify.-introsf.exists(fNorth,fSouth).introsx;exact(apf(meridx)).-intros[[NS]m].exact(Susp_recNSm).-intros[[NS]m].applyap,path_arrow.introsx;applySusp_rec_beta_merid.-introsf.symmetry;applySusp_rec_eta.Defined.Using wild 0-groupoids, the universal property can be proven without funext.  A simple equivalence of 0-groupoids betweenSuspX->Yand{NS:Y*Y&X->fstNS=sndNS}would not carry all the higher-dimensional information, but if we generalize it to dependent functions, then it does suffice.SectionUnivProp.Context(X:Type) (P:SuspX->Type).Here is the domain of the equivalence: sections ofPoverSuspX.DefinitionSusp_ind_type:=forallz:SuspX,Pz.isgraph_pathsis not a global instance, so we define this by hand.  The fact that this is a 01cat and a 0gpd is obtained using global instances.Local Instanceisgraph_Susp_ind_type:IsGraphSusp_ind_type.Proof.applyisgraph_forall;intros;applyisgraph_paths.Defined.The codomain is a sigma-groupoid of this family, consisting of input data forSusp_ind.DefinitionSusp_ind_data'(NS:PNorth*PSouth):=forallx:X,DPathP(meridx) (fstNS) (sndNS).Again, the rest of the wild category structure is obtained using global instances.Local Instanceisgraph_Susp_ind_data'NS:IsGraph(Susp_ind_data'NS).Proof.applyisgraph_forall;intros;applyisgraph_paths.Defined.Here is the codomain itself.  This is a 01cat and a 0gpd via global instances.DefinitionSusp_ind_data:=sigSusp_ind_data'.Here is the functor.DefinitionSusp_ind_inv:Susp_ind_type->Susp_ind_data.Proof.introsf.exists(fNorth,fSouth).introsx.exact(apDf(meridx)).Defined.Local Instanceis0functor_susp_ind_inv:Is0FunctorSusp_ind_inv.Proof.constructor;unfoldSusp_ind_type;cbn.introsfgp.unshelveeconstructor.-applypath_prod;applyp.-introsx.rewritetransport_path_prod, !transport_forall_constant;cbn.applyds_transport_dpath.exact(dp_apD_natp(meridx)).Defined.And now we can prove that it's an equivalence of 0-groupoids, using the definition from WildCat/EquivGpd.Definitionissurjinj_Susp_ind_inv:IsSurjInjSusp_ind_inv.Proof.constructor.-intros[[ns]g].exists(Susp_indPnsg);cbn.existsidpath.introsx;cbn.applySusp_ind_beta_merid.-introsfg[pq];cbnin*.srapplySusp_ind;cbn.1:exact(apfstp).1:exact(apsndp).introsx;specialize(qx).applyds_dp.applyds_transport_dpath.rewritetransport_forall_constantinq.rewrite<- (eta_path_prodp)inq.rewritetransport_path_prodinq.exactq.Defined.EndUnivProp.The full non-funext version of the universal property should be formulated with respect to a notion of "wild hom-oo-groupoid", which we don't currently have.  However, we can deduce statements about full higher universal properties that we do have, for instance the statement that a type is local forfunctor_suspf-- expressed in terms ofooExtendableAlong-- if and only if all its identity types are local forf.  (We will use this inModalities.Localizationfor separated subuniverses.)  To prove this, we again generalize it to the case of dependent types, starting with naturality of the above 0-dimensional universal property.SectionUnivPropNat.We will show thatSusp_ind_invforXandYcommute with precomposition withfandfunctor_suspf.Context{XY:Type} (f:X->Y) (P:SuspY->Type).We recall these instances from the previous section.Local Existing Instancesisgraph_Susp_ind_typeisgraph_Susp_ind_data'.Here is an intermediate family of groupoids that we have to use, since precomposition withfdoesn't land in quite the right place.DefinitionSusp_ind_data''(NS:PNorth*PSouth):=forallx:X,DPathP(merid(fx)) (fstNS) (sndNS).This is a 01cat and a 0gpd via global instances.Local Instanceisgraph_Susp_ind_data''NS:IsGraph(Susp_ind_data''NS).Proof.applyisgraph_forall;intros;applyisgraph_paths.Defined.We decompose "precomposition withf" into a functor_sigma of two fiberwise functors.  Here is the first.Definitionfunctor_Susp_ind_data''(NS:PNorth*PSouth):Susp_ind_data'YPNS->Susp_ind_data''NS:=fungx=>g(fx).Local Instanceis0functor_functor_Susp_ind_data''NS:Is0Functor(functor_Susp_ind_data''NS).Proof.constructor.introsghpa.exact(p(fa)).Defined.And here is the second.  This one is actually a fiberwise equivalence of types at eachx.Definitionequiv_Susp_ind_data'(NS:PNorth*PSouth) (x:X):DPathP(merid(fx)) (fstNS) (sndNS)<~>DPath(Pofunctor_suspf) (meridx) (fstNS) (sndNS).Proof.etransitivity.-nrapply(equiv_transport(funp=>DPathPp(fstNS) (sndNS))).symmetry;applyfunctor_susp_beta_merid.-symmetry.apply(dp_compose(functor_suspf)P(meridx)).Defined.Definitionfunctor_Susp_ind_data'(NS:PNorth*PSouth):Susp_ind_data''NS->Susp_ind_data'X(Pofunctor_suspf)NS.Proof.srapply(functor_forallidmap);introsx.applyequiv_Susp_ind_data'.Defined.Local Instanceis0functor_functor_Susp_ind_data'NS:Is0Functor(functor_Susp_ind_data'NS).Proof.constructor.introsghqx.cbn;applyap,ap.exact(qx).Defined.And therefore a fiberwise equivalence of 0-groupoids.Local Instanceissurjinj_functor_Susp_ind_data'NS:IsSurjInj(functor_Susp_ind_data'NS).Proof.constructor.-introsg.unshelveeconstructor.+introsx.apply((equiv_Susp_ind_data'NSx)^-1).exact(gx).+introsx.applyeisretr.-introsghpx.apply(equiv_inj(equiv_Susp_ind_data'NSx)).exact(px).Defined.Now we put them together.Definitionfunctor_Susp_ind_data:Susp_ind_dataYP->Susp_ind_dataX(Pofunctor_suspf):=funNSg=> (NSg.1 ; (functor_Susp_ind_data'NSg.1o(functor_Susp_ind_data''NSg.1))NSg.2).Local Instanceis0functor_functor_Susp_ind_data:Is0Functorfunctor_Susp_ind_data.Proof.refine(is0functor_sigma__(funNS=>functor_Susp_ind_data'NSofunctor_Susp_ind_data''NS)).Defined.Here is the "precomposition withfunctor_suspf" functor.Definitionfunctor_Susp_ind_type:Susp_ind_typeYP->Susp_ind_typeX(Pofunctor_suspf):=fung=>gofunctor_suspf.Local Instanceis0functor_functor_Susp_ind_type:Is0Functorfunctor_Susp_ind_type.Proof.constructor.introsghpa.exact(p(functor_suspfa)).Defined.And here is the desired naturality square.DefinitionSusp_ind_inv_nat: (Susp_ind_invX(Pofunctor_suspf))ofunctor_Susp_ind_type$=>functor_Susp_ind_datao(Susp_ind_invYP).Proof.introsg;existsidpath;introsx.change(apD(funx0:SuspX=>g(functor_suspfx0)) (meridx) =(functor_Susp_ind_data(Susp_ind_invYPg)).2x).refine(dp_apD_compose(functor_suspf)P(meridx)g@_).cbn;applyap.apply(moveL_transport_V(funp=>DPathPp(gNorth) (gSouth))).exact(apD(apDg) (functor_susp_beta_meridfx)).Defined.From this we can deduce a equivalence between extendability, which is definitionally equal to split essential surjectivity of a functor between forall 0-groupoids.Definitionextension_iff_functor_susp: (forallg,ExtensionAlong(functor_suspf)Pg)<-> (forallNSg,ExtensionAlongf(funx=>DPathP(meridx) (fstNS) (sndNS))g).Proof.The proof is by chaining logical equivalences.transitivity(SplEssSurjfunctor_Susp_ind_type).{reflexivity. }etransitivity.{refine(isesssurj_iff_commsqSusp_ind_inv_nat);tryexact_.all:applyissurjinj_Susp_ind_inv. }etransitivity.{refine(isesssurj_iff_sigma__(funNS=>functor_Susp_ind_data'NSofunctor_Susp_ind_data''NS)). }applyiff_functor_forall;intros[NS];cbn.etransitivity.{applyiffL_isesssurj;exact_. }reflexivity.Defined.We have to close the section now because we have to generalizeextension_iff_functor_suspoverP.EndUnivPropNat.Now we can iterate, deducingn-extendability.Definitionextendable_iff_functor_susp{XY:Type} (f:X->Y) (P:SuspY->Type) (n:nat): (ExtendableAlongn(functor_suspf)P)<-> (forallNS,ExtendableAlongnf(funx=>DPathP(meridx) (fstNS) (sndNS))).Proof.revertP.inductionnas[|nIHn];introsP; [split;intros;exacttt| ].It would be nice to be able to do this proof by chaining logical equivalences too, especially since the two parts seem very similar.  But I haven't managed to make that work.split.-intros[e1en] [NS];split.+applyextension_iff_functor_susp.exacte1.+cbn;introshk.pose(h':=Susp_indPNSh).pose(k':=Susp_indPNSk).specialize(enh'k').assert(IH:=fst(IHn_)en(1,1));clearIHnen.cbninIH.refine(extendable_postcompose'n__f_IH);clearIH.introsy.etransitivity.1:nrapplyds_dp.etransitivity.1:applyds_transport_dpath.substh'k';cbn.applyequiv_concat_lr.*symmetry.exact(Susp_ind_beta_meridPNShy).*exact(Susp_ind_beta_meridPNSky).-introse;split.+applyextension_iff_functor_susp.introsNS;exact(fst(eNS)).+introshk.apply(IHn_).intros[pq].specialize(e(hNorth,kSouth)).cbnin*;applysndine.refine(extendable_postcompose'n__f_(e__));introsy.symmetry.etransitivity.1:nrapplyds_dp.etransitivity.1:applyds_transport_dpath.etransitivity.1:reflexivity.symmetry.apply(equiv_moveR_transport_p(funy0:PNorth=>DPathP(meridy)y0(kSouth))).Defined.As usual, deducing oo-extendability is trivial.Definitionooextendable_iff_functor_susp{XY:Type} (f:X->Y) (P:SuspY->Type): (ooExtendableAlong(functor_suspf)P)<-> (forallNS,ooExtendableAlongf(funx=>DPathP(meridx) (fstNS) (sndNS))).Proof.split;introse.-introsNSn.applyextendable_iff_functor_susp.exact(en).-introsn.applyextendable_iff_functor_susp.introsNS;exact(eNSn).Defined.Nullhomotopies of maps out of suspensionsDefinitionnullhomot_susp_from_paths{XZ:Type} (f:SuspX->Z)(n:NullHomotopy(funx=>apf(meridx))):NullHomotopyf.Proof.exists(fNorth).refine(Susp_ind_1n.1^_);introsx.refine(transport_paths_Fl__@_).apply(concat(concat_p1_)),ap.applyn.2.Defined.Definitionnullhomot_paths_from_susp{XZ:Type} (H_NH_S:Z) (f:X->H_N=H_S)(n:NullHomotopy(Susp_recH_NH_Sf)):NullHomotopyf.Proof.exists(n.2North@ (n.2South)^).introx.applymoveL_pV.transitivity(ap(Susp_recH_NH_Sf) (meridx) @n.2South).-applywhiskerR,inverse,Susp_rec_beta_merid.-refine(concat_Apn.2 (meridx) @_).apply(concatR(concat_p1_)),whiskerL.applyap_const.Defined.Contractibility of the suspensionGlobal Instancecontr_susp(A:Type) `{ContrA}:Contr(SuspA).Proof.unfoldSusp;exact_.Defined.Connectedness of the suspensionGlobal Instanceisconnected_susp{n:trunc_index} {X:Type}`{H:IsConnectednX} :IsConnectedn.+1 (SuspX).Proof.applyisconnected_from_elim.introsCH'f.exists(fNorth).assert({p0:fNorth=fSouth&forallx:X,apf(meridx) =p0})as[p0allpath_p0]by(apply(isconnected_elimn);rapplyH').apply(Susp_ind(funa=>fa=fNorth) 1p0^).introsx.apply(concat(transport_paths_Fl__)).apply(concat(concat_p1_)).applyap,allpath_p0.Defined.

--- Homotopy\WhiteheadsPrinciple.html ---
WhiteheadsPrincipleLibrary WhiteheadsPrincipleRequireImportBasicsTypes.RequireImportPointed.RequireImportWildCat.CoreHFiber.RequireImportTruncations.RequireImportAlgebra.Groups.Group.RequireImportHomotopy.HomotopyGroup.Local OpenScopepointed_scope.Local OpenScopenat_scope.8.8.1Definitionisequiv_issurj_tr0_isequiv_ap`{Univalence} {AB:Type} (f:A->B){i:IsSurjection(Trunc_functor0f)}{ii:forallxy,IsEquiv(@ap__fxy)}:IsEquivf.Proof.apply(equiv_isequiv_ap_isembeddingf)^-1inii.srapplyisequiv_surj_emb.srapplyBuildIsSurjection.cbn;introb.poseproof(@center_(i(trb)))asp.revertp.applyTrunc_functor.applysig_ind.srapplyTrunc_ind.introsap.apply(equiv_path_Tr__)^-1inp.strip_truncations.existsa.exactp.Defined.8.8.2Definitionisequiv_isbij_tr0_isequiv_loops`{Univalence} {AB:Type} (f:A->B){i:IsEquiv(Trunc_functor0f)}{ii:forallx,IsEquiv(fmaploops(pmap_from_pointfx)) }:IsEquivf.Proof.srapply(isequiv_issurj_tr0_isequiv_apf).introsxy.applyisequiv_inhab_codomain.introp.apply(ap(@tr0_))inp.apply(@equiv_inj___i(trx) (try))inp.apply(equiv_path_Tr__)^-1inp.strip_truncations.destructp.cbninii.snrapply(isequiv_homotopic_(H:=iix)).exact(fun_=>concat_1p_@concat_p1_).Defined.When the types are 0-connected and the map is pointed, just oneloops_functorneeds to be checked.Definitionisequiv_is0connected_isequiv_loops`{Univalence} {AB:pType} `{IsConnected0A} `{IsConnected0B}(f:A->*B)(e:IsEquiv(fmaploopsf)):IsEquivf.Proof.applyisequiv_isbij_tr0_isequiv_loops.The pi_0 condition is trivial becauseAandBare 0-connected.1:applyisequiv_contr_contr.SinceAis 0-connected, it's enough to check theloops_functorcondition for the basepoint.rapplyconn_point_elim.Theloops_functorcondition forpmap_from_pointf_is equivalent to theloops_functorcondition forfwith its given pointing.srapplyisequiv_homotopic'.-exact(equiv_concat_lr(point_eqf) (point_eqf)^oE(Build_Equiv___e)).-intror.simpl.hott_simpl.Defined.Truncated Whitehead's principle (8.8.3)Definitionwhiteheads_principle{ua:Univalence} {AB:Type} {f:A->B}(n:trunc_index) {H0:IsTruncnA} {H1:IsTruncnB}{i:IsEquiv(Trunc_functor0f)}{ii:forall(x:A) (k:nat),IsEquiv(fmap(Pik.+1) (pmap_from_pointfx)) }:IsEquivf.Proof.revertABH0H1fiii.inductionnas[|nIHn].1:intros;applyisequiv_contr_contr.introsABH0H1fiii.nrefine(@isequiv_isbij_tr0_isequiv_loopsua__fi_).introx.nrefine(isequiv_homotopic(@ap__fxx)_).2:{introsp;cbn.symmetry;exact(concat_1p_@concat_p1_). }poseproof(@istrunc_paths__H0xx)ash0.poseproof(@istrunc_paths__H1(fx) (fx))ash1.nrefine(IHn(x=x) (fx=fx)h0h1(@ap__fxx)__).-poseproof(iix0)ash2.unfoldis0functor_piinh2;cbninh2.refine(@isequiv_homotopic____h2_).apply(O_functor_homotopy(Tr0));introsp.exact(concat_1p_@concat_p1_).-introspk;revertp.assert(h3:forall(y:A) (q:x=y),IsEquiv(fmap(Pik.+1) (pmap_from_point(@ap__fxy)q))).2:exact(h3x).introsyq.destructq.snrefine(isequiv_homotopic__).1:exact(fmap(Pik.+1) (fmaploops(pmap_from_pointfx))).2:{rapply(fmap2(Pik.+1));srefine(Build_pHomotopy__).-introsp;cbn.refine(concat_1p_@concat_p1_).-reflexivity. }nrefine(isequiv_commsq____(fmap_pi_loopsk.+1 (pmap_from_pointfx))).2-3:refine(equiv_isequiv(pi_loops__)).exact(iixk.+1).Defined.

--- Miscellaneous\AbGroups.html ---
AbGroupsLibrary AbGroupsTheoryRequireExportHoTT.Algebra.Groups.RequireExportHoTT.Algebra.AbGroups.AbelianGroup.RequireExportHoTT.Algebra.AbGroups.Abelianization.RequireExportHoTT.Algebra.AbGroups.AbPullback.RequireExportHoTT.Algebra.AbGroups.AbPushout.RequireExportHoTT.Algebra.AbGroups.Biproduct.RequireExportHoTT.Algebra.AbGroups.AbHom.RequireExportHoTT.Algebra.AbGroups.Cyclic.RequireExportHoTT.Algebra.AbGroups.Centralizer.RequireExportHoTT.Algebra.AbGroups.FiniteSum.(* The theory of Ext groups of abelian groups is in HoTT.Algebra.AbSES. *)ExamplesRequireExportHoTT.Algebra.AbGroups.Z.

--- Miscellaneous\AbHom.html ---
AbHomLibrary AbHomRequireImportBasicsTypes.RequireImportWildCatHSetTruncations.CoreModalities.ReflectiveSubuniverse.RequireImportGroups.QuotientGroupAbelianGroupBiproduct.Local OpenScopemc_scope.Local OpenScopemc_add_scope.Homomorphisms from a group to an abelian group form an abelian group.We can add group homomorphisms.Definitionab_homo_add{A:Group} {B:AbGroup} (fg:A$->B):A$->B.Proof.refine(grp_homo_composeab_codiagonal_).funa=>f(a)+g(a)exact(grp_prod_corecfg).Defined.We can negate a group homomorphism by composing withab_homo_negation.Global Instancenegate_hom{A:Group} {B:AbGroup}:Negate(@HomGroup_AB) :=grp_homo_composeab_homo_negation.ForAandBgroups, withBabelian, homomorphismsA$->Bform an abelian group.Definitiongrp_hom`{Funext} (A:Group) (B:AbGroup) :Group.Proof.nrefine(Build_Group(GroupHomomorphismAB)ab_homo_addgrp_homo_constnegate_hom_).repeatsplit.1:exact_.all:hnf;intros;applyequiv_path_grouphomomorphism;intro;cbn.+applyassociativity.+applyleft_identity.+applyright_identity.+applyleft_inverse.+applyright_inverse.Defined.Definitionab_hom`{Funext} (A:Group) (B:AbGroup) :AbGroup.Proof.snrapply(Build_AbGroup(grp_homAB)).introsfg;cbn.applyequiv_path_grouphomomorphism;introx;cbn.applycommutativity.Defined.CoequalizersUsing the cokernel and addition and negation for the homs of abelian groups, we can define the coequalizer of two group homomorphisms as the cokernel of their difference.Definitionab_coeq{AB:AbGroup} (fg:GroupHomomorphismAB):=ab_cokernel(ab_homo_add(negate_homf)g).Definitionab_coeq_in{AB} {fg:A$->B} :B$->ab_coeqfg.Proof.snrapplygrp_quotient_map.Defined.Definitionab_coeq_glue{AB} {fg:A$->B}:ab_coeq_in(f:=f) (g:=g) $of$==ab_coeq_in$og.Proof.introsx.nrapplyqglue.applytr.byexistsx.Defined.Definitionab_coeq_rec{AB:AbGroup} {fg:A$->B}{C:AbGroup} (i:B$->C) (p:i$of$==i$og):ab_coeqfg$->C.Proof.snrapply(grp_quotient_rec__i).cbn.introsbH.strip_truncations.destructHas[aq].destructq;simpl.lhsnrapplygrp_homo_op.lhsnrapply(ap(.*_)).1:applygrp_homo_inv.applygrp_moveL_M1^-1.exact(pa)^.Defined.Definitionab_coeq_rec_beta_in{AB:AbGroup} {fg:A$->B}{C:AbGroup} (i:B$->C) (p:i$of$==i$og):ab_coeq_recip$oab_coeq_in$==i:=fun_=>idpath.Definitionab_coeq_ind_hprop{ABfg} (P: @ab_coeqABfg->Type)`{forallx,IsHProp(Px)}(i:forallb,P(ab_coeq_inb)):forallx,Px.Proof.rapplyQuotient_ind_hprop.exacti.Defined.Definitionab_coeq_ind_homotopy{ABCfg}{lr: @ab_coeqABfg$->C}(p:l$oab_coeq_in$==r$oab_coeq_in):l$==r.Proof.srapplyab_coeq_ind_hprop.exactp.Defined.Definitionfunctor_ab_coeq{AB} {fg:A$->B} {A'B'} {f'g':A'$->B'}(a:A$->A') (b:B$->B') (p:f'$oa$==b$of) (q:g'$oa$==b$og):ab_coeqfg$->ab_coeqf'g'.Proof.snrapplyab_coeq_rec.1:exact(ab_coeq_in$ob).refine(cat_assoc___$@_$@cat_assoc_opp___).refine((_$@Lp^$) $@_$@ (_$@Lq)).refine(cat_assoc_opp___$@ (_$@Ra) $@cat_assoc___).nrapplyab_coeq_glue.Defined.Definitionfunctor2_ab_coeq{AB} {fg:A$->B} {A'B'} {f'g':A'$->B'}{aa':A$->A'} {bb':B$->B'}(p:f'$oa$==b$of) (q:g'$oa$==b$og)(p':f'$oa'$==b'$of) (q':g'$oa'$==b'$og)(s:b$==b'):functor_ab_coeqabpq$==functor_ab_coeqa'b'p'q'.Proof.snrapplyab_coeq_ind_homotopy.introsx.exact(apab_coeq_in(sx)).Defined.Definitionfunctor_ab_coeq_compose{AB} {fg:A$->B}{A'B'} {f'g':A'$->B'}(a:A$->A') (b:B$->B') (p:f'$oa$==b$of) (q:g'$oa$==b$og){A''B''} {f''g'':A''$->B''}(a':A'$->A'') (b':B'$->B'')(p':f''$oa'$==b'$of') (q':g''$oa'$==b'$og'):functor_ab_coeqa'b'p'q'$ofunctor_ab_coeqabpq$==functor_ab_coeq(a'$oa) (b'$ob) (hconcatpp') (hconcatqq').Proof.snrapplyab_coeq_ind_homotopy.simpl;reflexivity.Defined.Definitionfunctor_ab_coeq_id{AB} (fg:A$->B):functor_ab_coeq(f:=f) (g:=g) (Id_) (Id_) (hrefl_) (hrefl_) $==Id_.Proof.snrapplyab_coeq_ind_homotopy.reflexivity.Defined.Definitiongrp_iso_ab_coeq{AB} {fg:A$->B} {A'B'} {f'g':A'$->B'}(a:A$<~>A') (b:B$<~>B') (p:f'$oa$==b$of) (q:g'$oa$==b$og):ab_coeqfg$<~>ab_coeqf'g'.Proof.snrapplycate_adjointify.-exact(functor_ab_coeqabpq).-exact(functor_ab_coeqa^-1$b^-1$ (hinverse__p) (hinverse__q)).-nrefine(functor_ab_coeq_compose________$@functor2_ab_coeq_____$@functor_ab_coeq_id__).rapplycate_isretr.-nrefine(functor_ab_coeq_compose________$@functor2_ab_coeq_____$@functor_ab_coeq_id__).rapplycate_issect.Defined.The bifunctorab_homGlobal Instanceis0functor_ab_hom01`{Funext} {A:Group^op}:Is0Functor(ab_homA).Proof.snrapply(Build_Is0Functor_AbGroup);introsBB'f.snrapplyBuild_GroupHomomorphism.1:exact(fung=>grp_homo_composefg).introsphipsi.applyequiv_path_grouphomomorphism;introa;cbn.exact(grp_homo_opf__).Defined.Global Instanceis0functor_ab_hom10`{Funext} {B:AbGroup@{u}}:Is0Functor(flip(ab_hom:Group^op->AbGroup->AbGroup)B).Proof.snrapply(Build_Is0Functor(Group^op)AbGroup);introsAA'f.snrapplyBuild_GroupHomomorphism.1:exact(fung=>grp_homo_composegf).introsphipsi.byapplyequiv_path_grouphomomorphism.Defined.Global Instanceis1functor_ab_hom01`{Funext} {A:Group^op}:Is1Functor(ab_homA).Proof.nrapplyBuild_Is1Functor.-introsBB'fgpphi.applyequiv_path_grouphomomorphism;introa;cbn.exact(p(phia)).-introsBphi.byapplyequiv_path_grouphomomorphism.-introsBCDfgphi.byapplyequiv_path_grouphomomorphism.Defined.Global Instanceis1functor_ab_hom10`{Funext} {B:AbGroup@{u}}:Is1Functor(flip(ab_hom:Group^op->AbGroup->AbGroup)B).Proof.nrapplyBuild_Is1Functor.-introsAA'fgpphi.applyequiv_path_grouphomomorphism;introa;cbn.exact(apphi(pa)).-introsAphi.byapplyequiv_path_grouphomomorphism.-introsACDfgphi.byapplyequiv_path_grouphomomorphism.Defined.Global Instanceis0bifunctor_ab_hom`{Funext}:Is0Bifunctor(ab_hom:Group^op->AbGroup->AbGroup).Proof.rapplyBuild_Is0Bifunctor''.Defined.Global Instanceis1bifunctor_ab_hom`{Funext}:Is1Bifunctor(ab_hom:Group^op->AbGroup->AbGroup).Proof.nrapplyBuild_Is1Bifunctor''.1,2:exact_.introsAA'fBB'gphi;cbn.byapplyequiv_path_grouphomomorphism.Defined.Properties ofab_homPrecomposition with a surjection is an embedding.(* This could be deduced fromisembedding_precompose_surjection_hset, but relating precomposition of homomorphisms with precomposition of the underlying maps is tedious, so we give a direct proof. *)Global Instanceisembedding_precompose_surjection_ab`{Funext} {ABC:AbGroup}(f:A$->B) `{IsSurjectionf}:IsEmbedding(fmap10(A:=Group^op)ab_homfC).Proof.applyisembedding_isinj_hset;introsg0g1p.applyequiv_path_grouphomomorphism.rapply(conn_map_elim(Tr(-1))f).exact(equiv_path_grouphomomorphism^-1p).Defined.

--- Miscellaneous\AbProjective.html ---
AbProjectiveLibrary AbProjectiveRequireImportBasicsTypesAbelianGroupAbPullbackWildCat.CoreLimits.PullbackReflectiveSubuniverseTruncations.Core.Projective abelian groupsWe define projective abelian groups and show thatPis projective if and only if every epimorphismA->Pmerely splits.An abelian groupPis projective if for any mapP->Band epimorphismA->B, there merely exists a liftP->Amaking the following triangle commute:A
            ^ |
         l /  |
              | e
         /    |
              V
       P ---> B
          fClassIsAbProjective@{u+} (P:AbGroup@{u}) :Type:=isabprojective:forall(AB:AbGroup@{u}),forall(e:A$->B),forall(f:P$->B),IsSurjectione->merely(existsl:P$->A,e$ol==f).An abelian group is projective iff epis into it merely split.Propositioniff_isabprojective_surjections_split(P:AbGroup):IsAbProjectiveP<-> (forallA,forallp:A$->P,IsSurjectionp->merely(existss:P$->A,p$os==grp_homo_id)).Proof.split.-introsHAB.applyH.-introsHABefH1.poseproof(s:=H(ab_pullbackfe) (grp_pullback_pr1fe)(conn_map_pullback_fe)).strip_truncations.destructsas[sh].refine(tr((grp_pullback_pr2fe) $os;_));introx.refine((pullback_commsqfe_)^ @_).exact(apf(hx)).Defined.

--- Miscellaneous\AbPullback.html ---
AbPullbackLibrary AbPullbackRequireImportBasics.RequireImportLimits.PullbackCubical.PathSquare.RequireExportAlgebra.Groups.GrpPullback.RequireImportAlgebra.AbGroups.AbelianGroup.RequireImportWildCat.Core.Pullbacks of abelian groupsSectionAbPullback.(* Variables are named to correspond with Limits.Pullback. *)Context{ABC:AbGroup} (f:B$->A) (g:C$->A).Global Instanceab_pullback_commutative:Commutative(@group_sgop(grp_pullbackfg)).Proof.unfoldCommutative.intros[b[cp]] [d[eq]].applyequiv_path_pullback;simpl.refine(commutativity__;commutativity__;_).applyequiv_sq_path.applypath_ishprop.Defined.Global Instanceisabgroup_ab_pullback:IsAbGroup(grp_pullbackfg) := {}.Definitionab_pullback:AbGroup:=Build_AbGroup(grp_pullbackfg)_.The corecursion principle is inherited from Groups; use grp_pullback_corec and friends from Groups/GrpPullback.v.EndAbPullback.

--- Miscellaneous\AbPushout.html ---
AbPushoutLibrary AbPushoutRequireImportBasicsTypesTruncations.Core.RequireImportWildCat.CoreHSet.RequireExportAlgebra.Groups.ImageAlgebra.Groups.QuotientGroup.RequireImportAbGroups.AbelianGroupAbGroups.Biproduct.Local OpenScopemc_scope.Local OpenScopemc_add_scope.Pushouts of abelian groups.The pushout of two morphismsf:A$->Bandg:A$->Cis constructed as the quotient of the biproductB+Cby the image off-g. Since this image comes up repeatedly, we name it.Definitionab_pushout_subgroup{ABC:AbGroup} (f:A$->B) (g:A$->C):Subgroup(ab_biprodBC):=grp_image(ab_biprod_corec(ab_homo_negation$of)g).Definitionab_pushout{ABC:AbGroup}(f:A$->B) (g:A$->C) :AbGroup:=QuotientAbGroup(ab_biprodBC) (ab_pushout_subgroupfg).Recursion principle.Theoremab_pushout_rec{ABCY:AbGroup} {f:A$->B} {g:A$->C}(b:B$->Y) (c:C$->Y) (p:bof==cog):ab_pushoutfg$->Y.Proof.srapplygrp_quotient_rec.-exact(ab_biprod_recbc).-intros[xy]q;strip_truncations;simpl.destructqas[aq].cbninq.refine(ap(uncurry(funxy=>bx+cy))q^ @_).cbn.refine(ap011sg_op(preserves_negate_) (pa)^ @_).exact(left_inverse_).Defined.Corollaryab_pushout_rec_uncurried{ABC:AbGroup}(f:A$->B) (g:A$->C) (Y:AbGroup): {b:B$->Y& {c:C$->Y&bof==cog}}-> (ab_pushoutfg$->Y).Proof.intros[b[cp]];exact(ab_pushout_recbcp).Defined.Definitionab_pushout_inl{ABC:AbGroup} {f:A$->B} {g:A$->C}:B$->ab_pushoutfg:=grp_quotient_map$ogrp_prod_inl.Definitionab_pushout_inr{ABC:AbGroup} {f:A$->B} {g:A$->C}:C$->ab_pushoutfg:=grp_quotient_map$ogrp_prod_inr.Propositionab_pushout_commsq{ABC:AbGroup} {f:A$->B} {g:A$->C}: (@ab_pushout_inlABCfg) $of==ab_pushout_inr$og.Proof.introa.applyqglue;cbn.applytr.existsa.applypath_prod;simpl.-exact(right_identity_)^.-rewritenegate_mon_unit.exact(left_identity_)^.Defined.A map out of the pushout induces itself after restricting along the inclusions.Propositionab_pushout_rec_beta`{Funext} {ABCY:AbGroup}{f:A$->B} {g:A$->C}(phi:ab_pushoutfg$->Y):ab_pushout_rec(phi$oab_pushout_inl) (phi$oab_pushout_inr)(funa:A=>apphi(ab_pushout_commsqa)) =phi.Proof.rapply(equiv_ap'(equiv_quotient_abgroup_ump(G:=ab_biprodBC)_Y)^-1%equiv__)^-1.srapplypath_sigma_hprop.refine(grp_quotient_rec_beta_Y__@_).applyequiv_path_grouphomomorphism;introbc.exact(ab_biprod_rec_eta(phi$ogrp_quotient_map)bc).Defined.Restrictingab_pushout_recalongab_pushout_inlrecovers the left inducing map.Lemmaab_pushout_rec_beta_left{ABCY:AbGroup}(f:A$->B) (g:A$->C)(l:B$->Y) (r:C$->Y) (p:lof==rog):ab_pushout_reclrp$oab_pushout_inl==l.Proof.introx;simpl.rewrite(grp_homo_unitr).applyright_identity.Defined.Lemmaab_pushout_rec_beta_right{ABCY:AbGroup}(f:A$->B) (g:A$->C)(l:B$->Y) (r:C$->Y) (p:lof==rog):ab_pushout_reclrp$oab_pushout_inr==r.Proof.introx;simpl.rewrite(grp_homo_unitl).applyleft_identity.Defined.Theoremisequiv_ab_pushout_rec`{Funext} {ABCY:AbGroup}{f:A$->B} {g:A$->C}:IsEquiv(ab_pushout_rec_uncurriedfgY).Proof.srapplyisequiv_adjointify.-introphi.refine(phi$oab_pushout_inl;phi$oab_pushout_inr;_).introa.apply(apphi).exact(ab_pushout_commsqa).-introphi.exact(ab_pushout_rec_betaphi).-intros[b[cp]].srapplypath_sigma.+applyequiv_path_grouphomomorphism.introx;simpl.refine(ap(funk=>bx+k) (grp_homo_unitc) @_).applyright_identity.+refine(transport_sigma'__@_).applypath_sigma_hprop;simpl.applyequiv_path_grouphomomorphism.introy;simpl.refine(ap(funk=>k+cy) (grp_homo_unitb) @_).applyleft_identity.Defined.Definitionpath_ab_pushout`{Univalence} {ABC:AbGroup} (f:A$->B) (g:A$->C)(bc0bc1:ab_biprodBC): @in_cosetL(ab_biprodBC) (ab_pushout_subgroupfg)bc0bc1<~> (grp_quotient_mapbc0=grp_quotient_mapbc1:>ab_pushoutfg).Proof.rapplypath_quotient.Defined.The pushout of an embedding is an embedding.Definitionab_pushout_embedding_inl`{Univalence} {ABC:AbGroup}(f:A$->B) (g:A$->C) `{IsEmbeddingg}:IsEmbedding(ab_pushout_inl(f:=f) (g:=g)).Proof.applyisembedding_isinj_hset.introsc0c1.refine(_o(path_ab_pushoutfg(grp_prod_inlc0) (grp_prod_inlc1))^-1).rapplyTrunc_ind.cbn;intros[ap].assert(z:a=mon_unit).-rapply(isinj_embeddingg).refine(apsndp@_);cbn.exact(left_inversemon_unit@ (grp_homo_unitg)^).-apply(grp_moveR_M1).refine(_@apfstp);cbn;symmetry.refine(_@negate_mon_unit).refine(ap__).exact(apfz@grp_homo_unitf).Defined.Functoriality of pushoutsDefinitionfunctor_ab_pushout{AA'BB'CC':AbGroup}(f:A$->B) (f':A'$->B')(g:A$->C) (g':A'$->C')(alpha:A$->A') (beta:B$->B') (gamma:C$->C')(h:beta$of==f'$oalpha) (k:g'$oalpha==gamma$og):ab_pushoutfg$->ab_pushoutf'g'.Proof.srapplyab_pushout_rec.-exact(ab_pushout_inl$obeta).-exact(ab_pushout_inr$ogamma).-introa.refine(apab_pushout_inl(ha) @_@apab_pushout_inr(ka)).exact(ab_pushout_commsq(alphaa)).Defined.Properties of pushouts of mapsThe pushout of an epimorphism is an epimorphism.Global Instanceab_pushout_surjection_inr{ABC:AbGroup}(f:A$->B) (g:A$->C) `{S:IsSurjectionf}:IsSurjection(ab_pushout_inr(f:=f) (g:=g)).Proof.introx.rapplycontr_inhabited_hprop.(* To find a preimage ofx, we may first choose a representativex'. *)assert(x':merely(hfibergrp_quotient_mapx)).1:applycenter,issurj_class_of.strip_truncations;destructx'as[[bc]p].(* Nowx=b+cin the quotient. We find a preimage ofa. *)assert(a:merely(hfiberfb)).1:applycenter,S.strip_truncations;destructaas[aq].refine(tr(ga+c;_)).refine(grp_homo_op___@_).refine(ap(funz=>sg_opz_)_^ @_).{refine(_^ @ab_pushout_commsq_).exact(ap_q). }refine(apgrp_quotient_map_@p).applypath_prod';cbn.-applyright_identity.-applyleft_identity.Defined.

--- Miscellaneous\AbSES.html ---
AbSESLibrary AbSESRequireExportAbSES.Core.RequireExportAbSES.Ext.RequireExportAbSES.Pullback.RequireExportAbSES.PullbackFiberSequence.RequireExportAbSES.Pushout.RequireExportAbSES.BaerSum.RequireExportAbSES.DirectSum.RequireExportAbSES.SixTerm.

--- Miscellaneous\abstract_algebra.html ---
abstract_algebraLibrary abstract_algebraRequireExportBasics.ClassesBasics.Overture.RequireImportSpaces.Nat.Core.RequireExportHoTT.Classes.interfaces.canonical_names.RequireImportModalities.ReflectiveSubuniverse.LocalSetPolymorphicInductiveCumulativity.Generalizable VariablesABCfgxy.(*For various structures we omit declaration of substructures. For example, if wesay:Class Setoid_Morphism :={ setoidmor_a : Setoid A; setoidmor_b : Setoid B; sm_proper : Proper ((=) ==> (=)) f }.[export] Existing Instances setoidmor_a setoidmor_b sm_proper.

then each time a Setoid instance is required, Coq will try to prove that a
Setoid_Morphism exists. This obviously results in an enormous blow-up of the
search space. Moreover, one should be careful to declare a Setoid_Morphisms
as a substructure. Consider [f t1 t2], now if we want to perform setoid rewriting
in [t2] Coq will first attempt to prove that [f t1] is Proper, for which it will 
attempt to prove [Setoid_Morphism (f t1)]. If many structures declare
Setoid_Morphism as a substructure, setoid rewriting will become horribly slow.
*)(* An unbundled variant of the former CoRN CSetoid. We do notinclude a proof that A is a Setoid because it can be derived. *)ClassIsApartA{Aap:ApartA} :Type:={apart_set:IsHSetA;apart_mere:is_mere_relation_apart;apart_symmetric:Symmetric(≶);apart_cotrans:CoTransitive(≶);tight_apart:forallxy, ~(x≶y) <->x=y}.#[export]ExistingInstancesapart_setapart_mereapart_symmetricapart_cotrans.Global Instanceapart_irrefl`{IsApartA} :Irreflexive(≶).Proof.introsxap.apply(tight_apartxx).-reflexivity.-assumption.Qed.Argumentstight_apart{AAapIsApart}__.Sectionsetoid_morphisms.Context{AB} {Aap:ApartA} {Bap:ApartB} (f:A->B).ClassStrongExtensionality:=strong_extensionality:forallxy,fx≶fy->x≶y.Endsetoid_morphisms.(* HOTT TODO check if this is ok/useful *)#[export]HintExtern4 (?f_= ?f_) =>eapply(apf) :core.Sectionsetoid_binary_morphisms.Context{ABC} {Aap:ApartA}{Bap:ApartB} {Cap:ApartC} (f:A->B->C).ClassStrongBinaryExtensionality:=strong_binary_extensionality:forallx₁y₁x₂y₂,fx₁y₁≶fx₂y₂->hor(x₁≶x₂) (y₁≶y₂).Endsetoid_binary_morphisms.(*Since apartness usually only becomes relevant when considering fields (e.g. thereal numbers), we do not include it in the lower part of the algebraic hierarchy(as opposed to CoRN).*)Sectionupper_classes.Universei.Context(A:Type@{i}).Local OpenScopemc_mult_scope.ClassIsSemiGroup{Aop:SgOpA} :={sg_set:IsHSetA;sg_ass:Associative(.*.) }.#[export]ExistingInstancessg_setsg_ass.ClassIsCommutativeSemiGroup{Aop:SgOpA} :={comsg_sg: @IsSemiGroup(.*.);comsg_comm:Commutative(.*.) }.#[export]ExistingInstancescomsg_sgcomsg_comm.ClassIsSemiLattice{Aop:SgOpA} :={semilattice_sg: @IsCommutativeSemiGroup(.*.);semilattice_idempotent:BinaryIdempotent(.*.)}.#[export]ExistingInstancessemilattice_sgsemilattice_idempotent.ClassIsMonoid{Aop:SgOpA} {Aunit:MonUnitA} :={monoid_semigroup:IsSemiGroup;monoid_left_id:LeftIdentity(.*.)mon_unit;monoid_right_id:RightIdentity(.*.)mon_unit}.#[export]ExistingInstancesmonoid_semigroupmonoid_left_idmonoid_right_id.ClassIsCommutativeMonoid{Aop:SgOpA} {Aunit:MonUnitA} :={commonoid_mon: @IsMonoid(.*.)Aunit;commonoid_commutative:Commutative(.*.) }.#[export]ExistingInstancescommonoid_moncommonoid_commutative.ClassIsGroup{Aop:SgOpA} {Aunit:MonUnitA} {Anegate:NegateA} :={group_monoid: @IsMonoid(.*.)Aunit;negate_l:LeftInverse(.*.) (-)mon_unit;negate_r:RightInverse(.*.) (-)mon_unit}.#[export]ExistingInstancesgroup_monoidnegate_lnegate_r.ClassIsBoundedSemiLattice{Aop:SgOpA} {Aunit:MonUnitA} :={bounded_semilattice_mon: @IsCommutativeMonoid(.*.)Aunit;bounded_semilattice_idempotent:BinaryIdempotent(.*.)}.#[export]ExistingInstancesbounded_semilattice_monbounded_semilattice_idempotent.ClassIsAbGroup{Aop:SgOpA} {Aunit:MonUnitA} {Anegate:NegateA} :={abgroup_group: @IsGroup(.*.)AunitAnegate;abgroup_commutative:Commutative(.*.) }.#[export]ExistingInstancesabgroup_groupabgroup_commutative.CloseScopemc_mult_scope.Context{Aplus:PlusA} {Amult:MultA} {Azero:ZeroA} {Aone:OneA}.ClassIsSemiCRing:={semiplus_monoid: @IsCommutativeMonoidplus_is_sg_opzero_is_mon_unit;semimult_monoid: @IsCommutativeMonoidmult_is_sg_opone_is_mon_unit;semiring_distr:LeftDistribute(.*.) (+);semiring_left_absorb:LeftAbsorb(.*.) 0 }.#[export]ExistingInstancessemiplus_monoidsemimult_monoidsemiring_distrsemiring_left_absorb.Context{Anegate:NegateA}.ClassIsRing:= {ring_abgroup:: @IsAbGroupplus_is_sg_opzero_is_mon_unit_;ring_monoid:: @IsMonoidmult_is_sg_opone_is_mon_unit;ring_dist_left::LeftDistribute(.*.) (+);ring_dist_right::RightDistribute(.*.) (+);}.ClassIsCRing:={cring_group: @IsAbGroupplus_is_sg_opzero_is_mon_unit_;cring_monoid: @IsCommutativeMonoidmult_is_sg_opone_is_mon_unit;cring_dist:LeftDistribute(.*.) (+) }.#[export]ExistingInstancescring_groupcring_monoidcring_dist.Global Instanceisring_iscring:IsCRing->IsRing.Proof.introsH.econstructor;tryexact_.introsabc.lhsrapplycommutativity.lhsrapplydistribute_l.f_ap;applycommutativity.Defined.ClassIsIntegralDomain:={intdom_ring:IsCRing;intdom_nontrivial:PropHolds(not(1 = 0));intdom_nozeroes:NoZeroDivisorsA}.#[export]ExistingInstancesintdom_nozeroes.(* We do not include strong extensionality for (-) and (/)because it can de derived *)ClassIsField{Aap:ApartA} {Arecip:RecipA} :={field_ring:IsCRing;field_apart:IsApartA;field_plus_ext:StrongBinaryExtensionality(+);field_mult_ext:StrongBinaryExtensionality(.*.);field_nontrivial:PropHolds(1 ≶ 0);recip_inverse:forallx,x.1 //x= 1 }.#[export]ExistingInstancesfield_ringfield_apartfield_plus_extfield_mult_ext.(* We let /0 = 0 so properties as Injective (/),f (/x) = / (f x), / /x = x, /x * /y = /(x * y)hold without any additional assumptions *)ClassIsDecField{Adec_recip:DecRecipA} :={decfield_ring:IsCRing;decfield_nontrivial:PropHolds(1 <> 0);dec_recip_0: /0 = 0;dec_recip_inverse:forallx,x<> 0 ->x/x= 1 }.#[export]ExistingInstancesdecfield_ring.ClassFieldCharacteristic@{j} {Aap:Apart@{ij}A} (k:nat) :Type@{j}:=field_characteristic:foralln:nat,Nat.Core.lt0n->iff@{jjj} (forallm:nat,not@{j} (paths@{Set}n(nat_mulkm)))(@apartAAap(nat_itern(1 +) 0) 0).Endupper_classes.(* Due to bug 2528 *)#[export]HintExtern4 (PropHolds(1 <> 0)) =>eapply@intdom_nontrivial:typeclass_instances.#[export]HintExtern5 (PropHolds(1 ≶ 0)) =>eapply@field_nontrivial:typeclass_instances.#[export]HintExtern5 (PropHolds(1 <> 0)) =>eapply@decfield_nontrivial:typeclass_instances.(*For a strange reason IsCRing instances of Integers are sometimes obtained byIntegers -> IntegralDomain -> Ring and sometimes directly. Making this aninstance with a low priority instead of using intdom_ring:> IsCRing forces Coq totake the right way*)#[export]HintExtern10 (IsCRing_) =>apply@intdom_ring:typeclass_instances.Argumentsrecip_inverse{AAplusAmultAzeroAoneAnegateAapArecipIsField}_.Argumentsdec_recip_inverse{AAplusAmultAzeroAoneAnegateAdec_recipIsDecField}__.Argumentsdec_recip_0{AAplusAmultAzeroAoneAnegateAdec_recipIsDecField}.Sectionlattice.ContextA{Ajoin:JoinA} {Ameet:MeetA} {Abottom:BottomA} {Atop:TopA}.ClassIsJoinSemiLattice:=join_semilattice: @IsSemiLatticeAjoin_is_sg_op.#[export]ExistingInstancejoin_semilattice.ClassIsBoundedJoinSemiLattice:=bounded_join_semilattice: @IsBoundedSemiLatticeAjoin_is_sg_opbottom_is_mon_unit.#[export]ExistingInstancebounded_join_semilattice.ClassIsMeetSemiLattice:=meet_semilattice: @IsSemiLatticeAmeet_is_sg_op.#[export]ExistingInstancemeet_semilattice.ClassIsBoundedMeetSemiLattice:=bounded_meet_semilattice: @IsBoundedSemiLatticeAmeet_is_sg_optop_is_mon_unit.#[export]ExistingInstancebounded_meet_semilattice.ClassIsLattice:={lattice_join:IsJoinSemiLattice;lattice_meet:IsMeetSemiLattice;join_meet_absorption:Absorption(⊔) (⊓);meet_join_absorption:Absorption(⊓) (⊔) }.#[export]ExistingInstanceslattice_joinlattice_meetjoin_meet_absorptionmeet_join_absorption.ClassIsBoundedLattice:={boundedlattice_join:IsBoundedJoinSemiLattice;boundedlattice_meet:IsBoundedMeetSemiLattice;boundedjoin_meet_absorption:Absorption(⊔) (⊓);boundedmeet_join_absorption:Absorption(⊓) (⊔)}.#[export]ExistingInstancesboundedlattice_joinboundedlattice_meetboundedjoin_meet_absorptionboundedmeet_join_absorption.ClassIsDistributiveLattice:={distr_lattice_lattice:IsLattice;join_meet_distr_l:LeftDistribute(⊔) (⊓) }.#[export]ExistingInstancesdistr_lattice_latticejoin_meet_distr_l.Endlattice.Sectionmorphism_classes.Sectionsgmorphism_classes.Context{AB:Type} {Aop:SgOpA} {Bop:SgOpB}{Aunit:MonUnitA} {Bunit:MonUnitB}.Local OpenScopemc_mult_scope.ClassIsSemiGroupPreserving(f:A->B) :=preserves_sg_op:forallxy,f(x*y) =fx*fy.ClassIsUnitPreserving(f:A->B) :=preserves_mon_unit:fmon_unit=mon_unit.ClassIsMonoidPreserving(f:A->B) :={monmor_sgmor:IsSemiGroupPreservingf;monmor_unitmor:IsUnitPreservingf}.#[export]ExistingInstancesmonmor_sgmormonmor_unitmor.Endsgmorphism_classes.Sectionringmorphism_classes.Context{AB:Type} {Aplus:PlusA} {Bplus:PlusB}{Amult:MultA} {Bmult:MultB} {Azero:ZeroA} {Bzero:ZeroB}{Aone:OneA} {Bone:OneB}.ClassIsSemiRingPreserving(f:A->B) :={semiringmor_plus_mor: @IsMonoidPreservingABplus_is_sg_opplus_is_sg_opzero_is_mon_unitzero_is_mon_unitf;semiringmor_mult_mor: @IsMonoidPreservingABmult_is_sg_opmult_is_sg_opone_is_mon_unitone_is_mon_unitf}.#[export]ExistingInstancessemiringmor_plus_morsemiringmor_mult_mor.Context{Aap:ApartA} {Bap:ApartB}.ClassIsSemiRingStrongPreserving(f:A->B) :={strong_semiringmor_sr_mor:IsSemiRingPreservingf;strong_semiringmor_strong_mor:StrongExtensionalityf}.#[export]ExistingInstancesstrong_semiringmor_sr_morstrong_semiringmor_strong_mor.Endringmorphism_classes.Sectionlatticemorphism_classes.Context{AB:Type} {Ajoin:JoinA} {Bjoin:JoinB}{Ameet:MeetA} {Bmeet:MeetB}.ClassIsJoinPreserving(f:A->B) :=join_slmor_sgmor: @IsSemiGroupPreservingABjoin_is_sg_opjoin_is_sg_opf.#[export]ExistingInstancesjoin_slmor_sgmor.ClassIsMeetPreserving(f:A->B) :=meet_slmor_sgmor: @IsSemiGroupPreservingABmeet_is_sg_opmeet_is_sg_opf.#[export]ExistingInstancesmeet_slmor_sgmor.Context{Abottom:BottomA} {Bbottom:BottomB}.ClassIsBoundedJoinPreserving(f:A->B) :=bounded_join_slmor_monmor: @IsMonoidPreservingABjoin_is_sg_opjoin_is_sg_opbottom_is_mon_unitbottom_is_mon_unitf.#[export]ExistingInstancesbounded_join_slmor_monmor.ClassIsLatticePreserving(f:A->B) :={latticemor_join_mor:IsJoinPreservingf;latticemor_meet_mor:IsMeetPreservingf}.#[export]ExistingInstanceslatticemor_join_morlatticemor_meet_mor.Endlatticemorphism_classes.Endmorphism_classes.Sectionid_mor.Context`{SgOpA} `{MonUnitA}.Global Instanceid_sg_morphism:IsSemiGroupPreserving(@idA).Proof.split.Defined.Global Instanceid_monoid_morphism:IsMonoidPreserving(@idA).Proof.split;split.Defined.Endid_mor.Sectioncompose_mor.Context`{SgOpA} `{MonUnitA}`{SgOpB} `{MonUnitB}`{SgOpC} `{MonUnitC}(f:A->B) (g:B->C).Making these global instances causes typeclass loops.  Instead they are declared below asHintExterns that apply only when the goal has the specified form.Local Instancecompose_sg_morphism:IsSemiGroupPreservingf->IsSemiGroupPreservingg->IsSemiGroupPreserving(g∘f).Proof.red;introsfpgpxy.unfoldCompose.refine((apg_) @_).-applyfp.-applygp.Defined.Local Instancecompose_monoid_morphism:IsMonoidPreservingf->IsMonoidPreservingg->IsMonoidPreserving(g∘f).Proof.intros;split.-apply_.-red;unfoldCompose.etransitivity;[|apply(preserves_mon_unit(f:=g))].applyap,preserves_mon_unit.Defined.Endcompose_mor.Sectioninvert_mor.Context`{SgOpA} `{MonUnitA}`{SgOpB} `{MonUnitB}(f:A->B).Local Instanceinvert_sg_morphism:forall`{!IsEquivf},IsSemiGroupPreservingf->IsSemiGroupPreserving(f^-1).Proof.red;introsEfpxy.apply(equiv_injf).refine(_@_@_@_)^.-applyfp.(* We could useapplyap2;applyeisretrhere, but it is convenientto have things in terms of ap. *)-refine(ap(funz=>sg_opz_)_);applyeisretr.-refine(ap(funz=>sg_op_z)_);applyeisretr.-symmetry;applyeisretr.Defined.Local Instanceinvert_monoid_morphism:forall`{!IsEquivf},IsMonoidPreservingf->IsMonoidPreserving(f^-1).Proof.intros;split.-apply_.-apply(equiv_injf).refine(_@_).+applyeisretr.+symmetry;applypreserves_mon_unit.Defined.Endinvert_mor.#[export]HintExtern4 (IsSemiGroupPreserving(_∘_)) =>class_apply@compose_sg_morphism:typeclass_instances.#[export]HintExtern4 (IsMonoidPreserving(_∘_)) =>class_apply@compose_monoid_morphism:typeclass_instances.#[export]HintExtern4 (IsSemiGroupPreserving(_o_)) =>class_apply@compose_sg_morphism:typeclass_instances.#[export]HintExtern4 (IsMonoidPreserving(_o_)) =>class_apply@compose_monoid_morphism:typeclass_instances.#[export]HintExtern4 (IsSemiGroupPreserving(_^-1)) =>class_apply@invert_sg_morphism:typeclass_instances.#[export]HintExtern4 (IsMonoidPreserving(_^-1)) =>class_apply@invert_monoid_morphism:typeclass_instances.#[export]Instanceisinjective_mapinO_tr{AB:Type} (f:A->B){p:MapIn(Tr(-1))f} :IsInjectivef:=funxypfeq=>appr1(@center_(p(fy) (x;pfeq) (y;idpath))).Sectionstrong_injective.Context{AB} {Aap:ApartA} {Bap:ApartB} (f:A->B) .ClassIsStrongInjective:={strong_injective:forallxy,x≶y->fx≶fy;strong_injective_mor:StrongExtensionalityf}.Endstrong_injective.Sectionextras.ClassCutMinusSpecA(cm:CutMinusA) `{ZeroA} `{PlusA} `{LeA} := {cut_minus_le:forallxy,y≤x->x∸y+y=x;cut_minus_0:forallxy,x≤y->x∸y= 0}.Global Instanceishprop_issemigrouppreserving`{Funext} {AB:Type} `{IsHSetB}`{SgOpA} `{SgOpB} {f:A->B} :IsHProp(IsSemiGroupPreservingf).Proof.unfoldIsSemiGroupPreserving;exact_.Defined.Definitionissig_IsSemiRingPreserving{AB:Type}`{PlusA,PlusB,MultA,MultB,ZeroA,ZeroB,OneA,OneB} {f:A->B}:_<~>IsSemiRingPreservingf:=ltac:(issig).Definitionissig_IsMonoidPreserving{AB:Type} `{SgOpA} `{SgOpB}`{MonUnitA} `{MonUnitB} {f:A->B} :_<~>IsMonoidPreservingf:=ltac:(issig).Global Instanceishprop_ismonoidpreserving`{Funext} {AB:Type} `{SgOpA}`{SgOpB} `{IsHSetB} `{MonUnitA} `{MonUnitB} (f:A->B):IsHProp(IsMonoidPreservingf).Proof.srapply(istrunc_equiv_istrunc_issig_IsMonoidPreserving).srapply(istrunc_equiv_istrunc_(equiv_sigma_prod0__)^-1).srapplyistrunc_prod.unfoldIsUnitPreserving.exact_.Defined.Global Instanceishprop_issemiringpreserving`{Funext} {AB:Type} `{IsHSetB}`{PlusA,PlusB,MultA,MultB,ZeroA,ZeroB,OneA,OneB}(f:A->B):IsHProp(IsSemiRingPreservingf).Proof.snrapply(istrunc_equiv_istrunc_issig_IsSemiRingPreserving).exact_.Defined.Definitionissig_issemigroupxy:_<~> @IsSemiGroupxy:=ltac:(issig).Global Instanceishprop_issemigroup`{Funext}:forallxy,IsHProp(@IsSemiGroupxy).Proof.introsxy;applyistrunc_S;introsab.rewrite<- (eisretr(issig_issemigroupxy)a).rewrite<- (eisretr(issig_issemigroupxy)b).set(a':= (issig_issemigroupxy)^-1a).set(b':= (issig_issemigroupxy)^-1b).clearbodya'b';clearab.srapply(contr_equiv_(ap(issig_issemigroupxy))).rewrite<- (eissect(equiv_sigma_prod0__)a').rewrite<- (eissect(equiv_sigma_prod0__)b').set(a:=equiv_sigma_prod0__a').set(b:=equiv_sigma_prod0__b').clearbodyab;cleara'b'.srapply(contr_equiv_(ap(equiv_sigma_prod0__)^-1)).srapply(contr_equiv_(equiv_path_prod__)).srapplycontr_prod.destructaas[a'a],bas[b'b].do3 (nrefine(contr_equiv'_(@equiv_path_forallH____));nrefine(@contr_forallH___);intro).exact_.Defined.Definitionissig_ismonoidxyz:_<~> @IsMonoidxyz:=ltac:(issig).Global Instanceishprop_ismonoid`{Funext}xyz:IsHProp(@IsMonoidxyz).Proof.applyistrunc_S.introsab.rewrite<- (eisretr(issig_ismonoidxyz)a).rewrite<- (eisretr(issig_ismonoidxyz)b).set(a':= (issig_ismonoidxyz)^-1a).set(b':= (issig_ismonoidxyz)^-1b).clearbodya'b';clearab.srapply(contr_equiv_(ap(issig_ismonoidxyz))).rewrite<- (eissect(equiv_sigma_prod0__)a').rewrite<- (eissect(equiv_sigma_prod0__)b').set(a:=equiv_sigma_prod0__a').set(b:=equiv_sigma_prod0__b').clearbodyab;cleara'b'.srapply(contr_equiv_(ap(equiv_sigma_prod0__)^-1)).srapply(contr_equiv_(equiv_path_prod__)).srapplycontr_prod.destructaas[a'a],bas[b'b];cbn.rewrite<- (eissect(equiv_sigma_prod0__)a).rewrite<- (eissect(equiv_sigma_prod0__)b).set(a'':=equiv_sigma_prod0__a).set(b'':=equiv_sigma_prod0__b).clearbodya''b'';clearab.srapply(contr_equiv_(ap(equiv_sigma_prod0__)^-1)).srapply(contr_equiv_(equiv_path_prod__)).destructa''as[aa''],b''as[bb''];cbn.snrapplycontr_prod.all:srapplycontr_paths_contr.all:srapplycontr_inhabited_hprop.all:srapplyistrunc_forall.Defined.Definitionissig_isgroupwxyz:_<~> @IsGroupwxyz:=ltac:(issig).Global Instanceishprop_isgroup`{Funext}wxyz:IsHProp(@IsGroupwxyz).Proof.applyistrunc_S.introsab.rewrite<- (eisretr(issig_isgroupwxyz)a).rewrite<- (eisretr(issig_isgroupwxyz)b).set(a':= (issig_isgroupwxyz)^-1a).set(b':= (issig_isgroupwxyz)^-1b).clearbodya'b';clearab.srapply(contr_equiv_(ap(issig_isgroupwxyz))).rewrite<- (eissect(equiv_sigma_prod0__)a').rewrite<- (eissect(equiv_sigma_prod0__)b').set(a:=equiv_sigma_prod0__a').set(b:=equiv_sigma_prod0__b').clearbodyab;cleara'b'.srapply(contr_equiv_(ap(equiv_sigma_prod0__)^-1)).srapply(contr_equiv_(equiv_path_prod__)).srapplycontr_prod.destructaas[a'a],bas[b'b];cbn.rewrite<- (eissect(equiv_sigma_prod0__)a).rewrite<- (eissect(equiv_sigma_prod0__)b).set(a'':=equiv_sigma_prod0__a).set(b'':=equiv_sigma_prod0__b).clearbodya''b'';clearab.srapply(contr_equiv_(ap(equiv_sigma_prod0__)^-1)).srapply(contr_equiv_(equiv_path_prod__)).destructa''as[aa''],b''as[bb''];cbn.srapplycontr_prod.all:srapplycontr_paths_contr.all:srapplycontr_inhabited_hprop.all:srapplyistrunc_forall.Defined.Endextras.

--- Miscellaneous\AC.html ---
ACLibrary ACFromHoTTRequireImportExcludedMiddlecanonical_names.FromHoTTRequireImportHIT.unique_choice.FromHoTTRequireImportSpaces.Card.FromHoTT.SetsRequireImportOrdinals.Local OpenScopehprop_scope.Set-theoretic formulation of the axiom of choice (AC)Monomorphic AxiomChoice:Type0.Existing ClassChoice.DefinitionChoice_type:=forall(XY:HSet) (R:X->Y->HProp), (forallx,hexists(Rx)) ->hexists(funf=>forallx,Rx(fx)).AxiomAC:forall`{Choice},Choice_type.Global Instanceis_global_axiom_propresizing:IsGlobalAxiomChoice:= {}.The well-ordering theorem implies ACLemmaWO_AC{LEM:ExcludedMiddle} :(forall(X:HSet),hexists(fun(A:Ordinal) =>InjectsIntoXA)) ->Choice_type.Proof.introsHXYRHR.specialize(HY).eapplymerely_destruct;tryapplyH.intros[AHA].eapplymerely_destruct;tryapplyHA.intros[fHf].applytr.unshelveeexists.-introsx.assert(HR':hexists(funy=>merely(Rxy*forally',Rxy'->fy<fy'\/fy=fy'))).+poseproof(HAR:=ordinal_has_minimal_hsolutionsA(funa=>Build_HProp(merely(existsy,fy=a/\Rxy)))).eapplymerely_destruct;tryapplyHAR.*eapplymerely_destruct;tryapply(HRx).intros[yHy].applytr.exists(fy).applytr.existsy.bysplit.*intros[a[H1H2]].eapplymerely_destruct;tryapplyH1.intros[y[<-Hy]].applytr.existsy.applytr.split;trivial.introsy'Hy'.applyH2.applytr.existsy'.split;trivial.+edestruct(@iotaY)as[yHy];tryexacty. 2:split;tryapplyHR'. 1:exact_.introsyy'HyHy'.eapplymerely_destruct;tryapplyHy.intros[H1H2].eapplymerely_destruct;tryapplyHy'.intros[H3H4].applyHf.eapplymerely_destruct;tryapply(H2y');trivial.intros[H5|H5];trivial.eapplymerely_destruct;tryapply(H4y);trivial.intros[H6| -> ];trivial.applyEmpty_rec.apply(irreflexive_ordinal_relation___(fy)).apply(ordinal_transitivity_(fy'));trivial.-introsx.cbn.destructiotaas[yHy].eapplymerely_destruct;tryapplyHy.byintros[].Qed.

--- Miscellaneous\Accessible.html ---
AccessibleLibrary AccessibleAccessible subuniverses and modalitiesRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensionsNullHomotopy.RequireImportModality.Local OpenScopenat_scope.Local OpenScopepath_scope.Accessible reflective subuniversesAn accessible reflective subuniverse is one that is the localization at a small family of maps.  Accessibility is necessary for some constructions, and in practice it's a reasonable hypothesis that includes most examples (though a few examples, such as double negation, may only be accessible if we assume propositional resizing).We now give the basic definitions related to accessibility, usingooExtendableAlongas our notion of equivalence as we did with reflective subuniverses.  The actual construction of a reflective subuniverse by localization will be inLocalization.RecordLocalGenerators@{a} :={lgen_indices:Type@{a} ;lgen_domain:lgen_indices->Type@{a} ;lgen_codomain:lgen_indices->Type@{a} ;lgenerator:foralli,lgen_domaini->lgen_codomaini}.Coercionlgenerator:LocalGenerators>->Funclass.We put this definition in a module so that no one outside of this file will use it accidentally.  It will be redefined inLocalizationto refer to the localization reflective subuniverse, which is judgmentally the same but will also pick up typeclass inference forIn.ModuleImportIsLocal_Internal.DefinitionIsLocalfX:=(forall(i:lgen_indicesf),ooExtendableAlong(fi) (fun_=>X)).EndIsLocal_Internal.ClassIsAccRSU@{ai} (O:Subuniverse@{i}) :={acc_lgen:LocalGenerators@{a} ;inO_iff_islocal:forall(X:Type@{i}),We calliffexplicitly to control the number of universe parameters.iff@{iii} (InOX) (IsLocalacc_lgenX) ;}.Argumentsacc_lgenO{_}.ArgumentsinO_iff_islocalO{_}X.Global InstanceO_inverts_generators{O:ReflectiveSubuniverse} `{IsAccRSUO}(i:lgen_indices(acc_lgenO)):O_invertsO(acc_lgenOi).Proof.pose(ext_dom:=fst(inO_iff_islocalO(O(lgen_domain(acc_lgenO)i)))_).pose(ext_cod:=fst(inO_iff_islocalO(O(lgen_codomain(acc_lgenO)i)))_).simplerefine(isequiv_adjointify____).-applyO_rec.exact((fst(ext_domi1%nat) (toO_)).1).-applyO_indpaths;introsx;simpl.rewriteO_rec_beta.refine((fst(snd(ext_codi2)(funx=>O_functorO(acc_lgenOi)((fst(ext_domi1%nat) (toO_)).1x))_)_).1x);introsa.rewrite((fst(ext_domi1%nat) (toO_)).2a).applyto_O_natural.-applyO_indpaths;introsx;simpl.rewrite(to_O_naturalO(acc_lgenOi)x).rewriteO_rec_beta.apply((fst(ext_domi1%nat) (toO_)).2x).Qed.The construction of the localization reflective subuniverse for any family of maps will be inLocalization.Accessible modalitiesA modality is accessible just when its underlying reflective subuniverse is accessible.  However, for modalities we have a simpler characterization in terms of families of generating connected objects rather than families of generating inverted maps.  We call an objectS-null if it is local with respect to the mapsSi->Unit.RecordNullGenerators:={ngen_indices:Type@{a} ;ngen_type:ngen_indices->Type@{a}}.Coercionngen_type:NullGenerators>->Funclass.Definitionnull_to_local_generators:NullGenerators@{a1} ->LocalGenerators@{a2}:=funS=>Build_LocalGenerators(ngen_indicesS) (ngen_typeS) (fun_=>Unit) (fun__=>tt).As withIsLocal, the real version of this notation will be defined inNullification.ModuleImportIsNull_Internal.DefinitionIsNull(S:NullGenerators@{a}) (X:Type@{i}):=IsLocal@{iia} (null_to_local_generators@{aa}S)X.EndIsNull_Internal.A central fact: if a typeXis null for all the fibers of a mapf, then it isf-local.  (NB: the converse is *not* generally true.)  TODO: Should this go inExtensions?Definitionextendable_isnull_fibers(n:nat){AB} (f:A->B) (C:B->Type): (forallb,ooExtendableAlong(const_tt(hfiberfb))(fun_=>Cb))->ExtendableAlongnfC.Proof.revertC.simple_inductionnnIHn;introsCnull; [exacttt|split].-introsg.exists(funb=> (fst(nullb1%nat) (funx=>x.2 #gx.1)).1tt).introsa.rewrite(path_unittt(const_tt_a)).exact((fst(null(fa) 1%nat)_).2 (a; 1)).-introshk.applyIHn;introsb.applyooextendable_homotopy,null.Defined.Definitionooextendable_isnull_fibers{AB} (f:A->B) (C:B->Type): (forallb,ooExtendableAlong(const_tt(hfiberfb))(fun_=>Cb))->ooExtendableAlongfC:=funnulln=>extendable_isnull_fibersnfCnull.We define a modality to be accessible if it consists of the null types for some family of generators as above.ClassIsAccModality@{ai} (O:Subuniverse@{i}) :={acc_ngen:NullGenerators@{a} ;inO_iff_isnull:forall(X:Type@{i}),iff@{iii} (InOX) (IsNullacc_ngenX) ;}.Argumentsacc_ngenO{_}.ArgumentsinO_iff_isnullO{_}X.SectionAccessibleModalities.Context(O:Modality) {acco:IsAccModalityO}.Unsurprisingly, the generators are connected.Global Instanceisconnected_acc_ngeni:IsConnectedO(acc_ngenOi).Proof.applyisconnected_from_elim_to_O.pose(H:=fst(fst(inO_iff_isnullO(O(acc_ngenOi)))_i1%nat)(toO((acc_ngenO)i))).exists(H.1tt).exact(funx=> (H.2x)^).Defined.If all the generators are inhabited, some things become a bit simpler.SectionInhabitedGenerators.Context(inhab:foralli,acc_ngenOi).For testing modal-ness of types, it suffices for all maps out of a generator to be constant.  Probably one could do withoutFunext.DefinitioninO_const_fromgen`{Funext}A(c:foralli(f:acc_ngenOi->A),NullHomotopyf):InOA.Proof.apply(snd(inO_iff_isnullOA));introsi.apply((equiv_ooextendable_isequiv__)^-1%equiv).snrapplyisequiv_adjointify.-introsf[];exact(cif).1.-introsf;applypath_arrow;introsx.simpl;unfoldcomposeD.symmetry;exact((cif).2x).-introsg;applypath_arrow;intros[].pose((ci(goD(null_to_local_generators(acc_ngenO))i)).2).simplinp;unfoldcomposeDinp.symmetry;applyp,inhab.Defined.In particular, all hprops are modal.DefinitioninO_hprop_inhab_gen`{Funext} (A:Type) `{IsHPropA}:InOA.Proof.applyinO_const_fromgen;introsif.exists(f(inhabi)).intros;applypath_ishprop.Defined.EndInhabitedGenerators.EndAccessibleModalities.We will now show that a modality is accessible in this sense if and only if its underlying reflective subuniverse is accessible in the sense previously defined.  We (almost?) never need to actually use this, though; in practice accessible modalities usually seem to be given to us with the appropriate sort of generators.One direction of this implication is trivial.Global Instanceacc_rsu_modality(O:Modality) `{IsAccModalityO}:IsAccRSUO:=Build_IsAccRSUO(null_to_local_generators(acc_ngenO)) (funX=>inO_iff_isnullOX).For the less trivial converse, the idea is as follows.  Byooextendable_isnull_fibers, we can detect locality with respect to a map by nullity with respect to its fibers.  Therefore, our first thought might be to just consider all the fibers of all the maps that we are localizing at.  However, this doesn't quite work becauseooextendable_isnull_fibersis not an if-and-only-if, so not every modal type would necessarily be null for that type family.We do know, however, that iffis anO-connected map, then anyO-modal type is null for its fibers (since they areO-connected types).  There is no *a priori* why all the maps we localize at should end up being connected for the modality; they will always be inverted, but not every inverted map is connected (unless the modality is lex).  But iff:A->BisO-inverted, then theO-connected maptoOAis (up to equivalence) the composite offwith theO-connected maptoOB.  Thus, ifXis null for the fibers oftoOAandtoOB, it will bef-local and henceO-modal, while allO-modal types will be null for these fibers since they are connected.We don't make this anInstancesince it is rarely used, and would cause loops when combined with the previous one.Definitionacc_modality_rsu(O:Modality) `{IsAccRSUO}:IsAccModalityO.Proof.unshelveeconstructor.{refine(Build_NullGenerators(  {i:lgen_indices@{a} (acc_lgenO)&O(lgen_domain@{a} (acc_lgenO)i) }+ {i:lgen_indices@{a} (acc_lgenO)&O(lgen_codomain@{a} (acc_lgenO)i) })_).intros[ [ix] | [ix] ];exact(hfiber(toO_)x). }{assert(cm:= @conn_map_to_OO).split.-introsX_inO[ [ix] | [ix] ];exact(ooextendable_const_isconnected_inOO__).-introsXnull.apply(snd(inO_iff_islocalOX));introsi.refine(cancelL_ooextendable(fun_=>X) (acc_lgenOi)(toO(lgen_codomain(acc_lgenO)i))__).+applyooextendable_isnull_fibers;introsx.exact(Xnull(inr(i;x))).+refine(ooextendable_homotopic_(O_functorO(acc_lgenOi)otoO(lgen_domain(acc_lgenO)i))__).1:applyto_O_natural.applyooextendable_compose.*applyooextendable_equiv,O_inverts_generators.*applyooextendable_isnull_fibers;introsx.exact(Xnull(inl(i;x))). }Defined.The construction of the nullification modality for any family of types will be inNullification.

--- Miscellaneous\Addition.html ---
AdditionLibrary AdditionRequireImportHoTT.BasicsHoTT.Types.RequireImportHoTT.Spaces.No.CoreHoTT.Spaces.No.Negation.Local OpenScopepath_scope.Local OpenScopesurreal_scope.Addition of surreal numbersAddition requires the option sorts to be closed under finite sums.ClassHasAddition(S:OptionSort) :={empty_options:InSortSEmptyEmpty;sum_options:forallLRL'R',InSortSLR->InSortSL'R'->InSortS(L+L') (R+R')}.Global Existing Instanceempty_options.Global Existing Instancesum_options.Global Instancehasaddition_maxsort:HasAdditionMaxSort:= {empty_options:=tt;sum_options:=fun______=>tt}.Global Instancehasaddition_ordsort:HasAdditionOrdSort:= {empty_options:=idmap;sum_options:=fun____fg=>sum_ind_fg}.Global Instancehasaddition_decsort:HasAdditionDecSort.Proof.constructor.-applyinsort_decsort.-introsLRL'R'[? ?] [? ?];split;exact_.Qed.SectionAddition.Context`{Univalence}.Universei.Context{S:OptionSort@{i}} `{HasAdditionS}.LetNo:=GenNoS.SectionInner.Context{LR:Type@{i} } {Sx:InSortSLR}(xL:L->No) (xR:R->No)(xcut:forall(l:L) (r:R),xLl<xRr).LetA:= {g:No->No&(forallxy:No,x<=y->gx<=gy) *(forallxy:No,x<y->gx<gy)}.Context(xL_plus:L->A) (xR_plus:R->A)(xL_lt_xR_plus:forall(l:L) (r:R) (x:No),(xL_plusl).1x< (xR_plusr).1x).Definitionplus_inner: {g:forall(y:No),{x_plus_y:No&(foralll, (xL_plusl).1y<x_plus_y) *(forallr,x_plus_y< (xR_plusr).1y) } &(forallyz:No,y<=z-> (gy).1 <= (gz).1) *(forallyz:No,y<z-> (gy).1 <  (gz).1) }.Proof.simplerefine(No_ind_package(funy=> {x_plus_y:No&(foralll, (xL_plusl).1y<x_plus_y) *(forallr,x_plus_y< (xR_plusr).1y) })(fun___zw=>z.1 <=w.1)(fun___zw=>z.1 <w.1)_____).-introsL'R'?yLyRycutx_plus_yLx_plus_yRx_plus_yL_lt_yR.pose(L'':=L+L').pose(R'':=R+R').pose(zL:=sum_ind(fun_=>No)(funl=> (xL_plusl).1 {{yL|yR//ycut}})(funl=> (x_plus_yLl).1):L''->No).pose(zR:=sum_ind(fun_=>No)(funr=> (xR_plusr).1 {{yL|yR//ycut}})(funr=> (x_plus_yRr).1):R''->No).assert(zcut:forall(l:L'') (r:R''),zLl<zRr).{abstract(intros[l|l] [r|r];cbn;[applyxL_lt_xR_plus|transitivity((xL_plusl).1 (yRr));[apply(snd(xL_plusl).2),lt_ropt;exact_|exact(fst(x_plus_yRr).2l) ]|transitivity((xR_plusr).1 (yLl));[exact(snd(x_plus_yLl).2r)|apply(snd(xR_plusr).2),lt_lopt;exact_]|applyx_plus_yL_lt_yR]). }assert(InSortSL''R'')by(applysum_options;exact_).exists({{zL|zR//zcut}});split.+introsl.refine(lt_loptzLzRzcut(inll)).+introsr.refine(lt_roptzLzRzcut(inlr)).-abstract(introsxy[a?] [b?]pqrs;rewritetransport_sigma;cbnin*;applypath_sigma_hprop,path_No;cbn;rewritetransport_const;assumption).-abstract(introsL'R'?yLyRycutx_plus_yLx_plus_yRx_plus_yL_lt_yRL''R''?zLzRzcutx_plus_zLx_plus_zRx_plus_zL_lt_zRyL_lt_zx_plus_yL_lt_zy_lt_zRx_plus_y_lt_zR;cbnin*;applyle_lr; [intros[l|l] |intros[r|r] ];cbn;[refine(le_lt_trans(fst(xL_plusl).2_{{zL|zR//zcut}}_)_);[by(applyle_lr;assumption)|refine(lt_lopt___(inll)) ]|exact(x_plus_yL_lt_zl)|refine(lt_le_trans_(fst(xR_plusr).2 {{yL|yR//ycut}}__));[refine(lt_ropt___(inlr))|by(applyle_lr;assumption) ]|exact(x_plus_y_lt_zRr) ] ).-abstract(introsL'R'?yLyRycutx_plus_yLx_plus_yRx_plus_yL_lt_yRL''R''?zLzRzcutx_plus_zLx_plus_zRx_plus_zL_lt_zRly_le_zLx_plus_y_le_zL;cbn;applylt_lwith(inrl);applyx_plus_y_le_zL).-abstract(introsL'R'?yLyRycutx_plus_yLx_plus_yRx_plus_yL_lt_yRL''R''?zLzRzcutx_plus_zLx_plus_zRx_plus_zL_lt_zRryR_le_zx_plus_yR_le_z;cbn;applylt_rwith(inrr);applyx_plus_yR_le_z).Defined.We now prove a computation law forplus_inner.  It holds definitionally, so we would like to prove it with just:=1and then rewrite along it later, as we did above.  However, there is a subtlety in that the output should be a surreal defined by a cut, which in particular includes a proof of cut-ness, and that proof is rather long, so we would not like to see it in the type of this lemma.  Thus, instead we assert only that there *exists* some proof of cut-ness and an equality.Definitionplus_inner_cut{L'R':Type@{i} } {Sy:InSortSL'R'}(yL:L'->No) (yR:R'->No)(ycut:forall(l:L') (r:R'),yLl<yRr):letL'':=L+L'inletR'':=R+R'inletzL:=sum_ind(fun_=>No)(funl=> (xL_plusl).1 {{yL|yR//ycut}})(funl=> (plus_inner.1 (yLl)).1):L''->NoinletzR:=sum_ind(fun_=>No)(funr=> (xR_plusr).1 {{yL|yR//ycut}})(funr=> (plus_inner.1 (yRr)).1):R''->NoinletSz:=sum_optionsLRL'R'__in{zcut:forall(l:L'') (r:R''),zLl<zRr&(plus_inner.1 {{yL|yR//ycut}}).1 = (@No_cut___SzzLzRzcut) }.Proof.Now we tell Coq that we want the equality to be definitional, and let it figure out what the proof of cut-ness has to be.eexists.Addingrel_hnfhere speeds things up considerably, possibly because it puts the terms in a form where the evar can be instantiated without unfolding or reduction, preventing backtracking across the evar instantiation.rel_hnf.reflexivity.Qed.EndInner.Definitionplus_outer: {f:No-> {g:No->No&(forallxy,x<=y->gx<=gy) *(forallxy,x<y->gx<gy) } &(forallxy,x<=y->forallz, (fx).1z<= (fy).1z) *(forallxy,x<y->forallz, (fx).1z<  (fy).1z) }.Proof.refine(No_rec_package{g:No->No&(forallxy,x<=y->gx<=gy) *(forallxy,x<y->gx<gy) }(fungh=>forallx,g.1x<=h.1x)(fungh=>forallx,g.1x<h.1x)(funLRSxxLxRxcutxL_plusxR_plusxL_lt_xR_plus=>letg:=plus_innerxL_plusxR_plusxL_lt_xR_plusin((funy=> (g.1y).1) ; (g.2)))____).-abstract(intros[g?] [h?]pq;applypath_sigma_hprop;cbnin*;applypath_arrow;introsx;applypath_No; [applyp|applyq] ).-abstract(introsLR?xLxRxcutxL_plusxR_plusxL_lt_xR_plusL'R'?yLyRycutyL_plusyR_plusyL_lt_yR_plus;introsxL_lt_yxL_lt_y_plusx_lt_yRx_lt_yR_plusz;lazybetazetain*;cbn[pr1]in*;patternz;refine(No_ind_hprop__z);introsL''R''?zLzRzcutx_le_y_plus_zLx_le_y_plus_zR;destruct(plus_inner_cutxL_plusxR_plusxL_lt_xR_pluszLzRzcut)as[xzcutp];rewritep;destruct(plus_inner_cutyL_plusyR_plusyL_lt_yR_pluszLzRzcut)as[yzcutq];rewriteq;applyle_lr; [intros[l|l] |intros[r|r] ];[x^L + z < y + zspecialize(xL_lt_y_plusl{{zL|zR//zcut}});rewriteqinxL_lt_y_plus;exactxL_lt_y_plus|x + z^L < y + zrefine(le_lt_trans(x_le_y_plus_zLl)_);refine(lt_lopt___(inrl))|x + z < y^R + zspecialize(x_lt_yR_plusr{{zL|zR//zcut}});rewritepinx_lt_yR_plus;exactx_lt_yR_plus|x + z < y + z^Rrefine(lt_le_trans_(x_le_y_plus_zRr));refine(lt_ropt___(inrr)) ]).-abstract(introsLR?xLxRxcutxL_plusxR_plusxL_lt_xR_plusL'R'?yLyRycutyL_plusyR_plusyL_lt_yR_plus;introslx_le_yLx_le_yL_plusz;lazybetazetain*;cbn[pr1]in*;patternz;refine(No_ind_hprop__z);introsL''R''?zLzRzcutx_le_y_plus_zLx_le_y_plus_zR;destruct(plus_inner_cutxL_plusxR_plusxL_lt_xR_pluszLzRzcut)as[xzcutp];rewritep;destruct(plus_inner_cutyL_plusyR_plusyL_lt_yR_pluszLzRzcut)as[yzcutq];rewriteq;refine(le_lt_trans(x_le_yL_plus{{zL|zR//zcut}})_);refine(lt_lopt___(inll)) ).-abstract(introsLR?xLxRxcutxL_plusxR_plusxL_lt_xR_plusL'R'?yLyRycutyL_plusyR_plusyL_lt_yR_plus;introsrxR_le_yxR_le_y_plusz;lazybetazetain*;cbn[pr1]in*;patternz;refine(No_ind_hprop__z);introsL''R''?zLzRzcutx_le_y_plus_zLx_le_y_plus_zR;destruct(plus_inner_cutxL_plusxR_plusxL_lt_xR_pluszLzRzcut)as[xzcutp];rewritep;destruct(plus_inner_cutyL_plusyR_plusyL_lt_yR_pluszLzRzcut)as[yzcutq];rewriteq;refine(lt_le_trans_(xR_le_y_plus{{zL|zR//zcut}}));refine(lt_ropt___(inlr)) ).Defined.Definitionplus(xy:No) :No:= (plus_outer.1x).1y.Infix"+" :=plus:surreal_scope.Definitionplus_le_l(xx'y:No) (p:x<=x'): (x+y) <= (x'+y):=fst(plus_outer.2)xx'py.Definitionplus_lt_l(xx'y:No) (p:x<x'): (x+y) < (x'+y):=snd(plus_outer.2)xx'py.Definitionplus_le_r(xyy':No) (p:y<=y'): (x+y) <= (x+y'):=fst(plus_outer.1x).2yy'p.Definitionplus_lt_r(xyy':No) (p:y<y'): (x+y) < (x+y'):=snd(plus_outer.1x).2yy'p.See the remarks aboveplus_inner_cutto explain the type of this lemma.Definitionplus_cut{LR:Type@{i} } {Sx:InSortSLR}(xL:L->No) (xR:R->No)(xcut:forall(l:L) (r:R),xLl<xRr){L'R':Type@{i} } {Sy:InSortSL'R'}(yL:L'->No) (yR:R'->No)(ycut:forall(l:L') (r:R'),yLl<yRr):letL'':= (L+L')%typeinletR'':= (R+R')%typeinletx:= {{xL|xR//xcut}}inlety:= {{yL|yR//ycut}}inletzL:=sum_ind(fun_=>No)(funl=> (xLl) +y) (funl=>x+ (yLl)):L''->NoinletzR:=sum_ind(fun_=>No)(funr=> (xRr) +y) (funr=>x+ (yRr)):R''->NoinletSz:=sum_optionsLRL'R'__in{zcut:forall(l:L'') (r:R''),zLl<zRr&x+y= @No_cut___SzzLzRzcut}:=plus_inner_cut(Sx:=Sx)(funl=>plus_outer.1 (xLl))(funr=>plus_outer.1 (xRr))(funlr=>sndplus_outer.2 (xLl) (xRr) (xcutlr))yLyRycut.Because the conclusion ofplus_cutis a sigma-type whose second component is the real equality we want to rewrite along, in order to rewrite along it we have to first destruct it.  This tactic takes care of that for us.Ltacdo_plus_cut:=repeatmatchgoalwith| [ |-contextctx[ {{ ?xL| ?xR// ?xcut}} + {{ ?yL| ?yR// ?ycut}} ] ] =>letxycut:=fresh"cut"inletp:=fresh"p"indestruct(plus_cutxLxRxcutyLyRycut)as[xycutp];rewritep;clearpend.Conway proves the basic properties of arithmetic using "one-line proofs".  We can't quite do them in one line of Ltac, but the following tactic does help a lot.  Note that it is specific to addition.  It requires the caller to specify the equivalences along which to identify the indexing types for the options, as well as a rewriting tactic for evaluating those equivalences on constructors.  Unfortunately, it doesn't usually manage to finish the whole proof, since in general it can't guess how to use the inductive hypotheses.  It's usually fairly easy to finish all the cases it leaves over, but we do generally have to refer by name to the inductive hypotheses that were automatically named byintroshere.  I haven't thought of a good solution to that.Local OpaqueNo_cutplus.(* required to makerewritefail quickly *)LocalUnsetKeyedUnification.(* shaves another second or two off ofrewrite*)Tactic Notation"one_line_proof"uconstr(eL)uconstr(eR) :=unfoldNoin*;repeat_No_ind_hprop;do_plus_cut;refine(path_No_easy____eLeR____);intros;repeatmatchgoalwith| [H: (?A+ ?B) |-_] =>destructHend;repeatmatchgoalwith| [ |-context[@equiv_fun?A?B?e?v] ]=>(* first check that we picked up eithereLoreR; we can't useunifybecause it doesn't infer holes, and we can't Ltac-match oneL/eRbecause apparently matching on uconstr doesn't work when there are holes in the uconstr *)first[letunif:=constr:(idpath:e=eL)inidtac|letunif:=constr:(idpath:e=eR)inidtac];(* assume that the term reduces to a constructor; usehnfto get that constructor *)letef:=constr:(@equiv_funABev)inletef':= (evalhnfinef)inprogresschangeefwithef'end;repeatcbn[sum_ind];(* rewrite with induction hypotheses fromrepeat_No_ind_hpropanddo_plus_cut*)repeatmatchgoalwith| [ |- ?x= ?x] =>reflexivity| [ |- ?a+_= ?a+_] =>applyap| [ |-_+ ?a=_+ ?a] =>apply(ap(funx=>x+a))| [e:Empty|-_] =>elime| [IH: (foralllr,_+_=_) |-_]=>rewriteIH;clearIH| [IH: (foralllr,_+_=_+_) |-_]=>first[rewriteIH|rewrite<-IH];clearIH| [IH: (foralllr(y:GenNo_),_+_=_+_) |-_]=>first[rewriteIH|rewrite<-IH];clearIH| [IH: (foralllr(yz:GenNo_),_+_=_+_) |-_]=>first[rewriteIH|rewrite<-IH];clearIHend.At last we are ready to prove that the surreal numbers are a commutative monoid under addition.Theoremplus_comm(xy:No) :x+y=y+x.Proof.one_line_proof(equiv_sum_symm__) (equiv_sum_symm__).Defined.Theoremplus_assoc(xyz:No) : (x+y) +z=x+ (y+z).Proof.one_line_proof(equiv_sum_assoc___) (equiv_sum_assoc___);one_line_proof1%equiv1%equiv.Defined.Theoremplus_zero(x:No) :x+zero=x.Proof.unfoldzero.one_line_proof(sum_empty_r_) (sum_empty_r_).Defined.Theoremzero_plus(x:No) :zero+x=x.Proof.unfoldzero.one_line_proof(sum_empty_l_) (sum_empty_l_).Defined.If we also have negation, we can prove that it gives additive inverses, so that we have an abelian group.Context`{HasNegationS}.Definitionplus_negate(x:No) :x+negatex=zero.Proof.unfoldNoin*;repeat_No_ind_hprop;destruct(negate_cutxLxRxcut)as[nxcutp];rewritep;clearp;do_plus_cut.applypath_No.-applyle_lr; [intros[l|r];cbn[sum_ind] |intros[] ].+unfoldzeroinIHL;rewrite<- (IHLl);clearIHL.applyplus_lt_r.refine(lt_ropt___l).+unfoldzeroinIHR;rewrite<- (IHRr);clearIHR.applyplus_lt_l.refine(lt_ropt___r).-applyle_lr; [intros[] |intros[r|l] ];cbn[sum_ind].+unfoldzeroinIHR;rewrite<- (IHRr);clearIHR.applyplus_lt_r.refine(lt_lopt___r).+unfoldzeroinIHL;rewrite<- (IHLl);clearIHL.applyplus_lt_l.refine(lt_lopt___l).Defined.Definitionsub(xy:No) :No:=x+ (negatey).Infix"-" :=sub:surreal_scope.EndAddition.

--- Miscellaneous\additional_operations.html ---
additional_operationsLibrary additional_operationsRequireImportHoTT.Classes.interfaces.canonical_names.Generalizable VariablesAR.LocalSetUniverseMinimizationToSet.Global Instancedecide_eqb`{DecidablePathsA} :EqbA:=funab=>ifdecide_relpathsabthentrueelsefalse.Lemmadecide_eqb_ok@{i} {A:Type@{i} } `{DecidablePathsA} :forallab,iff@{Setii} (eqbab=true) (a=b).Proof.unfoldeqb,decide_eqb.introsab;destruct(decide_relpathsab)as[E1|E1];split;introsE2;auto.-destruct(false_ne_trueE2).-destruct(E1E2).Qed.LemmaLT_EQ:LT<>EQ.Proof.introsE.change((funr=>matchrwithLT=>Unit|_=>Emptyend)EQ).rewrite<-E.split.Qed.LemmaLT_GT:LT<>GT.Proof.introsE.change((funr=>matchrwithLT=>Unit|_=>Emptyend)GT).rewrite<-E.split.Qed.LemmaEQ_LT:EQ<>LT.Proof.applysymmetric_neq,LT_EQ.Qed.LemmaEQ_GT:EQ<>GT.Proof.introsE.change((funr=>matchrwithEQ=>Unit|_=>Emptyend)GT).rewrite<-E.split.Qed.LemmaGT_EQ:GT<>EQ.Proof.applysymmetric_neq,EQ_GT.Qed.Global Instancecompare_eqb`{CompareA} :EqbA| 2 :=funab=>matcha?=bwith|EQ=>true|_=>falseend.Lemmacompare_eqb_eq`{CompareA} :forallab:A,a=?b=true->a?=b=EQ.Proof.unfoldeqb,compare_eqb;simpl.introsab.destruct(a?=b);trivial;introsE;destruct(false_ne_trueE).Qed.Global Instancetricho_compare`{TrichotomyAR} :CompareA| 2:=funab=>matchtrichotomyRabwith|inl_=>LT|inr(inl_) =>EQ|inr(inr_) =>GTend.Lemmatricho_compare_eq`{TrichotomyAR}:forallab:A,compareab=EQ->a=b.Proof.unfoldcompare,tricho_compare.introsab;destruct(trichotomyRab)as[E|[E|E]];auto.-introsE1;destruct(LT_EQE1).-introsE1;destruct(GT_EQE1).Qed.Lemmatricho_compare_ok`{TrichotomyAR} `{IrreflexiveAR}:forallab:A,compareab=EQ<->a=b.Proof.unfoldcompare,tricho_compare.introsab;destruct(trichotomyRab)as[E1|[E1|E1]];split;auto.-introsE2;destruct(LT_EQE2).-introsE2;rewriteE2inE1.destruct(irreflexivityR_E1).-introsE2;destruct(GT_EQE2).-introsE2;rewriteE2inE1.destruct(irreflexivityR_E1).Qed.Lemmatotal_abs_either`{AbsA} `{!TotalRelationle}:forallx:A, (0 <=x/\absx=x) |_| (x<= 0 /\absx= -x).Proof.introsx.destruct(totalle0x)as[E|E].-left.split;trivial.apply((abs_sigx).2);trivial.-right.split;trivial.apply((abs_sigx).2);trivial.Qed.

--- Miscellaneous\Adjoint.html ---
AdjointLibrary AdjointRequireImportBasics.Utf8Basics.OvertureBasics.TacticsBasics.Equivalences.RequireImportWildCat.Core.RequireImportWildCat.NatTrans.RequireImportWildCat.Equiv.RequireImportWildCat.Prod.RequireImportWildCat.Opposite.RequireImportWildCat.Yoneda.RequireImportWildCat.FunctorCat.RequireImportWildCat.Universe.RequireImportTypes.Prod.Generalizable VariablesCDFG.Notions of adjunctions in wild categories.We try to capture a wild notion of (oo,1)-adjunctions since these are the ones that commonly appear in practice. Special cases include the standard 1-categorical adjunction.There are notions of 2-adjunction/biadjunction/higher adjunction but it is not clear if this generality is useful.We will define an adjunction to be an equivalence (in Type) between corresponding hom-types. This is a more immediately useful definition than others we can consider.We should also be able to define "F having a left adjoint" as the initial object of a slice category C / F. However this seems like too much work for now, and it is not immediately obvious how it ties back to the adjunction isomorphism.In the future, it ought to be possible to generalize this definition to live inside a given bicategory, however due to current structural issues in the WildCat library, writing down a usable definition of bicategory requires a lot of effort.Definition of adjunctionDefinition of adjunctionRecordAdjunction{CD:Type} (F:C->D) (G:D->C)`{Is1CatC,Is1CatD, !Is0FunctorF, !Is0FunctorG} :={equiv_adjunction(x:C) (y:D) : (Fx$->y) <~> (x$->Gy) ;Naturality condition in both varibles seperately  The left variable is a bit trickier to state since we have opposite categories involved.is1natural_equiv_adjunction_l(y:D):Is1Natural(A:=C^op) (yonyoF)We have to explicitly give a witness to the functoriality ofyonyoF.(is0functor_F:=is0functor_compose(A:=C^op) (B:=D^op) (C:=Type)__)(yon(Gy)) (funx=>equiv_adjunction_y) ;Naturality in the right variableis1natural_equiv_adjunction_r(x:C):Is1Natural(opyon(Fx)) (opyonxoG) (equiv_adjunctionx) ;}.Argumentsequiv_adjunction{CDFGisgraph_Cis2graph_Cis01cat_Cis1cat_Cisgraph_Dis2graph_Dis01cat_Dis1cat_Dis0functor_Fis0functor_G}adjxy:rename.Argumentsis1natural_equiv_adjunction_l{CDFGisgraph_Cis2graph_Cis01cat_Cis1cat_Cisgraph_Dis2graph_Dis01cat_Dis1cat_Dis0functor_Fis0functor_G}adjy:rename.Argumentsis1natural_equiv_adjunction_r{CDFGisgraph_Cis2graph_Cis01cat_Cis1cat_Cisgraph_Dis2graph_Dis01cat_Dis1cat_Dis0functor_Fis0functor_G}adjx:rename.Global Existing Instancesis1natural_equiv_adjunction_lis1natural_equiv_adjunction_r.Notation"F ⊣ G" := (AdjunctionFG).TODO: move but where?Lemmafun01_profunctor{ABCD:Type} (F:A->B) (G:C->D)`{Is0FunctorABF,Is0FunctorCDG}:Fun01(A^op*C) (B^op*D).Proof.snrapplyBuild_Fun01.1:exact(functor_prodFG).rapplyis0functor_prod_functor.Defined.Definitionfun01_hom{C:Type} `{Is01CatC}:Fun01(C^op*C)Type:= @Build_Fun01_____is0functor_hom.Natural equivalences coming from adjunctions.There are various bits of data we would like to extract from adjunctions.SectionAdjunctionData.Context{CD:Type} {F:C->D} {G:D->C}`{Is1CatC,Is1CatD, !HasMorExtC, !HasMorExtD,!Is0FunctorF, !Is0FunctorG, !Is1FunctorF, !Is1FunctorG}(adj:AdjunctionFG).Definitionnatequiv_adjunction_l(y:D):NatEquiv(A:=C^op) (yonyoF)We have to explicitly give a witness to the functoriality ofyonyoF.(is0functor_F:=is0functor_compose(A:=C^op) (B:=D^op) (C:=Type)__)(yon(Gy)).Proof.nrapplyBuild_NatEquiv.apply(is1natural_equiv_adjunction_ladj).Defined.Definitionnatequiv_adjunction_r(x:C):NatEquiv(opyon(Fx)) (opyonxoG).Proof.nrapplyBuild_NatEquiv.apply(is1natural_equiv_adjunction_radj).Defined.We also have the natural equivalence in both arguments at the same time.  In order to manage the typeclass instances, we have to bundle them up into Fun01.Definitionnatequiv_adjunction:NatEquiv(A:=C^op*D)(fun01_composefun01_hom(fun01_profunctorFidmap))(fun01_composefun01_hom(fun01_profunctoridmapG)).Proof.snrapplyBuild_NatEquiv.1:intros[xy];exact(equiv_adjunctionadjxy).snrapplyBuild_Is1Natural.intros[ab] [a'b'] [fg]K.refine(_@ap(funx:a$->Gb'=>x$of)(is1natural_equiv_adjunction_radjabb'gK)).exact(is1natural_equiv_adjunction_ladj___f(g$oK)).Defined.The counit of an adjunctionDefinitionadjunction_counit:NatTransidmap(GoF).Proof.snrapplyBuild_NatTrans.{hnf.introsx.exact(equiv_adjunctionadjx(Fx) (Id_)). }snrapplyBuild_Is1Natural.introsxx'f.applyGpdHom_path.refine(_^ @_@_).1:exact(is1natural_equiv_adjunction_ladj___f(Id_)).2:exact(is1natural_equiv_adjunction_radj___(fmapFf) (Id_)).simpl.applyequiv_ap'.applypath_hom.applySquare.vrefl.Defined.The unit of an adjunctionDefinitionadjunction_unit:NatTrans(FoG)idmap.Proof.snrapplyBuild_NatTrans.{hnf.introsy.exact((equiv_adjunctionadj(Gy)y)^-1 (Id_)). }snrapplyBuild_Is1Natural.introsyy'f.applyGpdHom_path.refine(_^ @_@_).1:exact(is1natural_natequiv(natequiv_inverse(natequiv_adjunction_l_)) (Gy')_(fmapGf)_).2:exact(is1natural_natequiv(natequiv_inverse(natequiv_adjunction_r_))___(Id_)).simpl.applyequiv_ap_inv'.applypath_hom.applySquare.vrefl.Defined.Lemmatriangle_helper1xyf:equiv_adjunctionadjxyf=fmapGf$oadjunction_counitx.Proof.refine(_@is1natural_equiv_adjunction_radj_____).bycbv;rewrite(cat_idr_strongf).Qed.Lemmatriangle_helper2xyg: (equiv_adjunctionadjxy)^-1g=adjunction_unity$ofmapFg.Proof.epose(n1:=is1natural_natequiv(natequiv_inverse(natequiv_adjunction_l_))____).clearbodyn1;cbvinn1.refine(_@n1).byrewritecat_idl_strong.Qed.Definitionadjunction_triangle1:Transformation(nattrans_comp(nattrans_prewhiskeradjunction_unitF)(nattrans_postwhiskerFadjunction_counit))(nattrans_id_).Proof.introsc.change(?x$->_)with(x$->Id(Fc)).rewrite<- (eissect(equiv_adjunctionadj__) (Id(Fc))).cbv;rewrite<- (triangle_helper2_(Fc) (adjunction_counit_)).exact(Id_).Qed.Definitionadjunction_triangle2:Transformation(nattrans_comp(nattrans_postwhiskerGadjunction_unit)(nattrans_prewhiskeradjunction_counitG))(nattrans_id_).Proof.introsd.change(?x$->_)with(x$->Id(Gd)).rewrite<- (eisretr(equiv_adjunctionadj__) (Id(Gd))).cbv;rewrite<- (triangle_helper1(Gd)_(adjunction_unit_)).exact(Id_).Qed.EndAdjunctionData.Building adjunctionsThere are various ways to build an adjunction.A natural equivalence between functorsD->Typewhich is also natural in the left.DefinitionBuild_Adjunction_natequiv_nat_left{CD:Type} (F:C->D) (G:D->C)`{Is1CatC,Is1CatD, !Is0FunctorF, !Is0FunctorG}(e:forallx,NatEquiv(opyon(Fx)) (opyonxoG))(is1nat_e:forally,Is1Natural(A:=C^op) (yonyoF)We have to explicitly give a witness to the functoriality ofyonyoF.(is0functor_F:=is0functor_compose(A:=C^op) (B:=D^op) (C:=Type)__)(yon(Gy)) (funx=>e_y)):AdjunctionFG.Proof.snrapplyBuild_Adjunction.1:exact(funx=>ex).1:exactis1nat_e.introsx;apply(is1natural_natequiv(ex)).Defined.A natural equivalence between functorsC^op->Typewhich is also natural in the left.DefinitionBuild_Adjunction_natequiv_nat_right{CD:Type} (F:C->D) (G:D->C)`{Is1CatC,Is1CatD, !Is0FunctorF, !Is0FunctorG}(e:forally,NatEquiv(A:=C^op) (yonyoF) (yon(Gy))(is0functor_F:=is0functor_compose(A:=C^op) (B:=D^op) (C:=Type)__))(is1nat_e:forallx,Is1Natural(opyon(Fx)) (opyonxoG) (funy=>eyx)):AdjunctionFG.Proof.snrapplyBuild_Adjunction.1:exact(funxy=>eyx).1:introsy;apply(is1natural_natequiv(ey)).exactis1nat_e.Defined.TODO: A natural equivalence between functorsC^op*D->TypeSectionUnitCounitAdjunction.From the data of an adjunction: unit, counit, left triangle, right triangleContext{CD:Type} (F:C->D) (G:D->C)`{Is1CatC,Is1CatD, !Is0FunctorF, !Is0FunctorG,!Is1FunctorF, !Is1FunctorG}`{!HasMorExtC, !HasMorExtD}(ε:NatTrans(FoG)idmap)(η:NatTransidmap(GoF))(t1:Transformation(nattrans_comp(nattrans_prewhiskerεF) (nattrans_postwhiskerFη))(nattrans_id_))(t2:Transformation(nattrans_comp(nattrans_postwhiskerGε) (nattrans_prewhiskerηG))(nattrans_id_)).We can construct an equivalence between homsLocal Definitionγab: (Fa$->b) $<~> (a$->Gb).Proof.srapplyequiv_adjointify.1:exact(funx=>fmapGx$o(η:_$=>_)a).1:exact(funx=> (ε:_$=>_)b$ofmapFx).+introsf.applypath_hom;simpl.refine((fmap_compG__$@R_) $@_).refine(cat_assoc___$@_).refine((_$@L(isnatηf)^$) $@_).refine(cat_assoc_opp___$@_).refine(_$@R_$@cat_idl_).exact(t2b).+introsg.applypath_hom;simpl.refine((_$@Lfmap_compF__) $@_).refine(cat_assoc_opp___$@_).refine(((isnatεg) $@R_) $@_).refine(cat_assoc___$@_).refine(_$@L_$@cat_idr_).exact(t1a).Defined.Which is natural in the leftLemmais1natural_γ_l(y:D):Is1Natural(yonyoF) (yon(Gy))(is0functor_F:=is0functor_compose(A:=C^op) (B:=D^op) (C:=Type)__)(is0functor_G:=is0functor_yon(Gy))(funx:C^op=>γxy).Proof.nrapply(is1natural_natequiv(natequiv_inverse(Build_NatEquiv(yon(Gy)) (yonyoF) (funx=> (γxy)^-1$)_))).nrapplyis1natural_yoneda.nrapplyis1functor_compose.1:nrapplyis1functor_op;exact_.nrapplyis1functor_opyon.nrapplyhasmorext_op;exact_.Defined.And natural in the right.Lemmais1natural_γ_rx:Is1Natural(opyon(Fx)) (funx0:D=>opyonx(Gx0)) (γx).Proof.nrapplyis1natural_opyoneda.exact_.Defined.Together this constructs an adjunction.DefinitionBuild_Adjunction_unit_counit:AdjunctionFG.Proof.snrapplyBuild_Adjunction.-exactγ.-applyis1natural_γ_l.-applyis1natural_γ_r.Defined.EndUnitCounitAdjunction.Properties of adjunctionsPostcomposition adjunctionThere are at least two easy proofs of the following on paper:
 1. Using ends: Hom(F*x,y) ≃ ∫c Hom(Fxc,yc) ≃ ∫c Hom(xc,Gyc) ≃ Hom(x,G*y)
 2. 2-cat theory: postcomp (-)* is a 2-functor so preserves adjunctions.Lemmaadjunction_postcomp(CDJ:Type)`{HasEquivsC,HasEquivsD,Is01CatJ} (F:Fun11CD) (G:Fun11DC)`{!HasMorExtC, !HasMorExtD, !HasMorExt(Fun01JC), !HasMorExt(Fun01JD)}:F⊣G->fun11_fun01_postcomp(A:=J)F⊣fun11_fun01_postcomp(A:=J)G.Proof.introsadj.srapplyBuild_Adjunction_unit_counit.-snrapplyBuild_NatTrans.+introsK.exact(nattrans_prewhisker(adjunction_unitadj)K).+snrapplyBuild_Is1Natural.introsKK'θj.applyGpdHom_path.refine(_@is1natural_natequiv(natequiv_inverse(natequiv_adjunction_radj_))____).refine((is1natural_natequiv(natequiv_inverse(natequiv_adjunction_ladj_))____)^ @_).cbn;rapplyap.refine(cat_idl_strong_@_^).applycat_idr_strong.-snrapplyBuild_NatTrans.+introsK.exact(nattrans_prewhisker(adjunction_counitadj)K).+snrapplyBuild_Is1Natural.introsKK'θj.applyGpdHom_path.refine(_@is1natural_natequiv(natequiv_adjunction_radj_)____).refine((is1natural_natequiv(natequiv_adjunction_ladj_)____)^ @_).cbn;rapplyap.refine(cat_idl_strong_@_^).applycat_idr_strong.-exact(trans_prewhisker(adjunction_triangle1adj)).-exact(trans_prewhisker(adjunction_triangle2adj)).Defined.We can compose adjunctions. Notice how the middle category must have equivalences.Lemmaadjunction_compose(ABC:Type)(F:A->B) (G:B->A) (F':B->C) (G':C->B)`{Is1CatA,HasEquivsB,Is1CatC}`{!Is0FunctorF, !Is0FunctorG, !Is0FunctorF', !Is0FunctorG'}:F⊣G->F'⊣G'->F'oF⊣GoG'.Proof.introsadj1adj2.snrapplyBuild_Adjunction_natequiv_nat_right.{introsy.nrefine(natequiv_compose(natequiv_adjunction_ladj1_)_).exact(natequiv_prewhisker(A:=A^op) (B:=B^op)(natequiv_adjunction_ladj2y)F). }introsx.rapplyis1natural_comp.+rapply(is1natural_prewhiskerG'(natequiv_adjunction_radj1x)).+rapplyis1natural_equiv_adjunction_r.Defined.Replace the left functor in an adjunction by a naturally equivalent one.Lemmaadjunction_natequiv_left{CD:Type} (FF':C->D) (G:D->C)`{Is1CatC,HasEquivsD, !HasMorExtD,!Is0FunctorF, !Is0FunctorF', !Is0FunctorG}:NatEquivFF'->F⊣G->F'⊣G.Proof.introseadj.snrapplyBuild_Adjunction_natequiv_nat_right.{introsy.refine(natequiv_compose(natequiv_adjunction_ladj_)_).rapply(natequiv_postwhisker_(natequiv_ope)). }introsx.rapplyis1natural_comp.Defined.Replace the right functor in an adjunction by a naturally equivalent one.Lemmaadjunction_natequiv_right{CD:Type} (F:C->D) (GG':D->C)`{HasEquivsC,Is1CatD, !HasMorExtC,!Is0FunctorF, !Is0FunctorG, !Is0FunctorG'}:NatEquivGG'->F⊣G->F⊣G'.Proof.introseadj.snrapplyBuild_Adjunction_natequiv_nat_left.{introsx.refine(natequiv_compose_(natequiv_adjunction_radj_)).rapply(natequiv_postwhisker_e). }introsy.rapplyis1natural_comp.2:exact_.rapplyis1natural_yoneda.Defined.

--- Miscellaneous\apartness.html ---
apartnessLibrary apartnessRequireImportHoTT.Classes.interfaces.abstract_algebra.Generalizable VariablesABCfg.Sectioncontents.Context`{IsApartA}.Lemmaapart_nexy:PropHolds(x≶y) ->PropHolds(x<>y).Proof.unfoldPropHolds.introsape;revertap.applytight_apart.assumption.Qed.Global Instance:forallxy:A,Stable(x=y).Proof.introsxy.unfoldStable.introsdn.applytight_apart.introsap.applydn.applyapart_ne.assumption.Qed.Endcontents.(* Due to bug 2528 *)#[export]HintExtern3 (PropHolds(_<>_)) =>eapply@apart_ne:typeclass_instances.Lemmaprojected_strong_setoid`{IsApartB} `{ApartA} `{IsHSetA}`{is_mere_relationAapart}(f:A->B)(eq_correct:forallxy,x=y<->fx=fy)(apart_correct:forallxy,x≶y<->fx≶fy):IsApartA.Proof.split.-apply_.-apply_.-introsxyap.applyapart_correct,symmetry,apart_correct.assumption.-introsxyapz.applyapart_correctinap.apply(merely_destruct(cotransitiveap(fz))).intros[?|?];applytr;[left|right];applyapart_correct;assumption.-introsxy;split.+introsnap.applyeq_correct.applytight_apart.introsap.applynap.applyapart_correct;assumption.+introseap.applyapart_correctinap;revertap.applytight_apart.applyeq_correct;assumption.Qed.Global Instancesg_apart_mere`{IsApartA} (P:A->Type):is_mere_relation(sigP)apart.Proof.intros.unfoldapart,sig_apart.apply_.Qed.Global Instancesig_strong_setoid`{IsApartA} (P:A->Type) `{forallx,IsHProp(Px)}:IsApart(sigP).Proof.apply(projected_strong_setoid(@proj1_P)).-intros.split;applySigma.equiv_path_sigma_hprop.-intros;applyreflexivity.Qed.Sectionmorphisms.Context`{IsApartA} `{IsApartB} `{IsApartC}.Global Instancestrong_injective_injective`{!IsStrongInjective(f:A->B)} :IsInjectivef.Proof.poseproof(strong_injective_morf).intros? ?e.applytight_apart.introsap.applytight_apartine.applye.applystrong_injective;auto.Qed.(* If a morphism satisfies the binary strong extensionality property, it isstrongly extensional in both coordinates. *)Global Instancestrong_setoid_morphism_1`{!StrongBinaryExtensionality(f:A->B->C)} :forallz,StrongExtensionality(fz).Proof.introszxyE.apply(merely_destruct(strong_binary_extensionalityfzxzyE)).intros[?|?];trivial.destruct(irreflexivity(≶)z).assumption.Qed.Global Instancestrong_setoid_morphism_unary_2`{!StrongBinaryExtensionality(f:A->B->C)} :forallz,StrongExtensionality(funx=>fxz).Proof.introszxyE.apply(merely_destruct(strong_binary_extensionalityfxzyzE)).intros[?|?];trivial.destruct(irreflexivity(≶)z);assumption.Qed.(* Conversely, if a morphism is strongly extensional in both coordinates, itsatisfies the binary strong extensionality property. We don't make this aninstance in order to avoid loops. *)Lemmastrong_binary_setoid_morphism_both_coordinates`{!IsApartA} `{!IsApartB} `{!IsApartC} {f:A->B->C}`{forallz,StrongExtensionality(fz)} `{forallz,StrongExtensionality(funx=>fxz)}:StrongBinaryExtensionalityf.Proof.introsx₁y₁x₂y₂E.apply(merely_destruct(cotransitiveE(fx₂y₁))).intros[?|?];applytr.-left.apply(strong_extensionality(funx=>fxy₁));trivial.-right.apply(strong_extensionality(fx₂));trivial.Qed.Endmorphisms.Sectionmore_morphisms.Context`{IsApartA} `{IsApartB}.Lemmastrong_binary_setoid_morphism_commutative{f:A->A->B} `{!Commutativef}`{forallz,StrongExtensionality(fz)} :StrongBinaryExtensionalityf.Proof.apply@strong_binary_setoid_morphism_both_coordinates;tryapply_.introszxy.rewrite!(commutativity_z).apply(strong_extensionality(fz)).Qed.Endmore_morphisms.Sectiondefault_apart.Context`{DecidablePathsA}.Instancedefault_apart:ApartA| 20:=funxy=>matchdec(x=y)with|inl_=>false|inr_=>trueend=true.Typeclasses Opaquedefault_apart.Instancedefault_apart_trivial:TrivialApartA(Aap:=default_apart).Proof.split.-unfoldapart,default_apart.apply_.-introsxy;unfoldapart,default_apart;split.+introsE.destruct(dec(x=y)).*destruct(false_ne_trueE).*trivial.+introsE;destruct(dec(x=y))as[e|_].*destruct(Ee).*split.Qed.Enddefault_apart.(* In case we have a decidable setoid, we can construct a strong setoid. Againwe do not make this an instance as it will cause loops *)Sectiondec_setoid.Context`{TrivialApartA} `{DecidablePathsA}.(* Not Global in order to avoid loops *)Instancene_apartxy:PropHolds(x<>y) ->PropHolds(x≶y).Proof.introsap.applytrivial_apart.assumption.Qed.Global Instancedec_strong_setoid:IsApartA.Proof.split.-apply_.-apply_.-introsxyne.applytrivial_apart.applytrivial_apartinne.introse;applyne,symmetry,e.-hnf.introsxynez.applytrivial_apartinne.destruct(dec(x=z))as[e|ne'];[destruct(dec(z=y))as[e'|ne']|].+destructne.path_viaz.+applytr;right.applytrivial_apart.assumption.+applytr;left.applytrivial_apart.assumption.-introsxy;split.+introsnap.destruct(dec(x=y));auto.destructnap.applytrivial_apart;trivial.+introse.introsnap.applytrivial_apartinnap.auto.Qed.Enddec_setoid.(* And a similar result for morphisms *)Sectiondec_setoid_morphisms.Context`{IsApartA} `{!TrivialApartA} `{IsApartB}.Instancedec_strong_morphism(f:A->B) :StrongExtensionalityf.Proof.introsxyE.applytrivial_apart.introse.applytight_apartinE;auto.Qed.Context`{!TrivialApartB}.Instancedec_strong_injective(f:A->B) `{!IsInjectivef} :IsStrongInjectivef.Proof.split;tryapply_.introsxy.introsap.applytrivial_apartinap.applytrivial_apart.introse.applyap.apply(injectivef).assumption.Qed.Context`{IsApartC}.Instancedec_strong_binary_morphism(f:A->B->C) :StrongBinaryExtensionalityf.Proof.introsx1y1x2y2hap.apply(merely_destruct(cotransitivehap(fx2y1)));intros[h|h];applytr.-left.applytrivial_apart.introse.applytight_apartinh;auto.exact(ap(funx=>fxy1)e).-right.applytrivial_apart.introse.applytight_apartinh;auto.Qed.Enddec_setoid_morphisms.

--- Miscellaneous\archimedean.html ---
archimedeanLibrary archimedeanRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.interfaces.rationalsHoTT.Classes.interfaces.archimedeanHoTT.Classes.theory.fieldsHoTT.Classes.orders.rings.Generalizable VariablesQF.Sectionstrict_field_order.Context`{RationalsQ}.Context{Qmeet} {Qjoin} `{@LatticeOrderQ(_:LeQ)QmeetQjoin}.Context`{OrderedFieldF}.Context{archim:ArchimedeanPropertyQF}.Definitionqinc:CastQF:=rationals_to_fieldQF.Existing Instanceqinc.Lemmachar_minus_leftxy: -x<y-> -y<x.Proof.introsltnxy.rewrite<- (negate_involutivex).apply(snd(flip_lt_negate__)).assumption.Qed.Lemmachar_minus_rightxy:x< -y->y< -x.Proof.introsltnxy.rewrite<- (negate_involutivey).apply(snd(flip_lt_negate__)).assumption.Qed.Lemmachar_plus_left:forall(q:Q) (xy:F),'q<x+y<->hexists(funs:Q=> ('s<x) /\ (' (q-s) <y)).Proof.Abort.Lemmachar_plus_right:forall(r:Q) (xy:F),x+y< 'r<->hexists(funt:Q=> (x< 't) /\ (y< ' (r-t))).Proof.Abort.Definitionhexists4{XYZW} (f:X->Y->Z->W->Type) :HProp:=hexists(funxyzw=>matchxyzwwith| ((x,y) , (z,w)) =>fxyzwend).Lemmachar_times_left:forall(q:Q) (xy:F),'q<x*y<->hexists4(funabcd:Q=>(q<meet(meetab) (meetcd))/\(('a<x< 'b)/\('c<y< 'd))).Proof.Abort.Lemmachar_times_right:forall(r:Q) (xy:F),x*y< 'r<->hexists4(funabcd:Q=>and(join(joinab) (joincd) <r)(and('a<x< 'b)('c<y< 'd))).Proof.Abort.Lemmachar_recip_pos_left:forall(q:Q) (z:F) (nu: 0 <z),'q<recip'z(positive_apart_zeroznu) <-> 'q*z< 1.Proof.Abort.Lemmachar_recip_pos_right:forall(r:Q) (z:F) (nu: 0 <z),recip'z(positive_apart_zeroznu) < 'r<-> 1 < 'r*z.Proof.Abort.Lemmachar_recip_neg_left:forall(q:Q) (w:F) (nu:w< 0),'q<recip'w(negative_apart_zerownu) <-> 'q*w< 1.Proof.Abort.Lemmachar_recip_neg_right:forall(r:Q) (w:F) (nu:w< 0),recip'w(negative_apart_zerownu) < 'r<-> 'r*w< 1.Proof.Abort.Lemmachar_meet_left:forall(q:Q) (xy:F),'q<meetxy<-> 'q<x/\ 'q<y.Proof.Abort.Lemmachar_meet_right:forall(r:Q) (xy:F),meetxy< 'r<->hor(x< 'r) (y< 'r).Proof.Abort.Lemmachar_join_left:forall(q:Q) (xy:F),'q<joinxy<->hor('q<x) ('q<y).Proof.Abort.Lemmachar_join_right:forall(r:Q) (xy:F),joinxy< 'r<->x< 'r/\y< 'r.Proof.Abort.Endstrict_field_order.

--- Miscellaneous\Arithmetic.html ---
ArithmeticLibrary ArithmeticRequireImportBasics.RequireImportSpaces.Nat.Core.LocalSetUniverseMinimizationToSet.Local CloseScopetrunc_scope.Local OpenScopenat_scope.TODO: The results in this file are in the process of being moved over to Core.vTODO: move, renamePropositionnataddsub_comm_ineq_lemma(nm:nat):n.+1 -m<= (n-m).+1.Proof.revertm.simple_inductionnnIHn.-simple_inductionmmIHm;exact_.-introm;simple_inductionmmIHm.+applyleq_refl.+applyIHn.Defined.TODO: move, renamePropositionnataddsub_comm_ineq(nmk:nat): (n+k) -m<= (n-m) +k.Proof.simple_inductionkkIHk.-destruct(nat_add_zero_rn)^, (nat_add_zero_r(n-m))^;constructor.-destruct(nat_add_succ_rnk)^.refine(leq_trans(nataddsub_comm_ineq_lemma(n+k)m)_).destruct(nat_add_succ_r(n-m)k)^.byapplyleq_succ.Defined.TODO: move, renamePropositionnat_sub_add_ineq(nm:nat) :n<=n-m+m.Proof.destruct(@leq_dichotomymn)as[l|gt].-rewrite<-nat_sub_l_add_l;trivial.destruct(nat_add_sub_cancel_rnm)^.applyleq_refl;done.-applyleq_ltingt.destruct(equiv_nat_sub_leq_)^.assumption.Defined.TODO: move, renamePropositioni_lt_n_sum_m(nmi:nat):i<n-m->m<=n.Proof.revertmi;simple_inductionnnIHn.-introsmil.simplinl.contradiction(not_lt_zero_r__).-introsmil.destructm.+applyleq_zero_l.+applyleq_succ.simplinl.apply(IHnmil).Defined.TODO: move, renamePropositionpredeqminus1{n:nat} :n- 1 =nat_predn.Proof.simple_induction'n.-reflexivity.-applynat_sub_zero_r.Defined.TODO: move, renamePropositionpredn_leq_n(n:nat) :nat_predn<=n.Proof.destructn;exact_.Defined.TODO: move, renamePropositionpred_equiv(kn:nat) :k<n->k<S(nat_predn).Proof.introineq;destructn.-contradiction(not_lt_zero_r__).-assumption.Defined.TODO: move, renamePropositionn_leq_pred_Sn(n:nat) :n<=S(nat_predn).Proof.destructn;exact_.Defined.TODO: move, renamePropositionleq_implies_pred_lt(ink:nat): (n>i) ->n<=k->nat_predn<k.Proof.introineq;destructn.-contradiction(not_lt_zero_ri).-intro;assumption.Defined.TODO: move, renamePropositionpred_lt_implies_leq(nk:nat):nat_predn<k->n<=k.Proof.introl;destructn.-applyleq_zero_l.-assumption.Defined.TODO: move, renamePropositionlt_implies_pred_geq(ij:nat) :i<j->i<=nat_predj.Proof.introl;applyleq_predinl;assumption.Defined.TODO: move, renamePropositionj_geq_0_lt_implies_pred_geq(ijk:nat):i<j->k.+1 <=j->k<=nat_predj.Proof.introslineq.destructj.-contradiction(not_lt_zero_ri).-bysimpl;applyleq_pred'.Defined.TODO: move, renamePropositionpred_gt_implies_lt(ij:nat):i<nat_predj->i.+1 <j.Proof.introsineq.assert(H:=leq_succineq).assert(i<j)asX. {apply(@lt_lt_leq_trans_(nat_predj)_);[assumption|applypredn_leq_n].}byrewrite<- (nat_succ_pred'ji).Defined.TODO: move, renamePropositionpred_preserves_lt{in:nat} (p:i<n)m: (n<m) -> (nat_predn<nat_predm).Proof.introl.applyleq_pred'.destruct(symmetric_paths__(nat_succ_pred'ni_)).set(k:=transitive_ltinmpl).destruct(symmetric_paths__(nat_succ_pred'mi_)).assumption.Defined.TODO: move, renamePropositionsub_less{nk:nat} :n-k<=n.Proof.revertk.simple_inductionnnIHn.-intros;applyleq_zero_l.-destructk.+applyleq_refl.+simpl;apply(@leq_trans_n_);[applyIHn|applyleq_succ_r,leq_refl].Defined.TODO: move, renamePropositionsub_less_strict{nk:nat}: 0 <n-> 0 <k->n-k<n.Proof.introsll'.unfold"<".destructk,n;try(contradiction(not_lt_zero_r__)).simpl;applyleq_succ,sub_less.Defined.TODO: move, renamePropositionn_leq_m_n_leq_plus_m_k(nmk:nat):n<=m->n<=m+k.Proof.introl;apply(leq_transl);exact(leq_add_rmk).Defined.This inductive type is defined because it lets you loop fromi=0up toi=nby structural induction on a proof ofincreasing_geqn0. With the existingleqtype and the inductive structure ofn, it is easier and more natural to loop downwards fromi=ntoi=0, but harder to find the least natural number in the interval  satisfying a given property.LocalUnsetEliminationSchemes.Inductiveincreasing_geq(n:nat) :nat->Type0:=|increasing_geq_n:increasing_geqnn|increasing_geq_S(m:nat) :increasing_geqnm.+1 ->increasing_geqnm.Schemeincreasing_geq_ind:=Inductionforincreasing_geqSortType.Schemeincreasing_geq_rec:=Minimalityforincreasing_geqSortType.Definitionincreasing_geq_rect:=increasing_geq_rec.LocalSetEliminationSchemes.Propositionincreasing_geq_S_n(nm:nat):increasing_geqnm->increasing_geqn.+1m.+1.Proof.introa.inductiona.-constructor.-byconstructor.Defined.Propositionincreasing_geq_n_0(n:nat) :increasing_geqn0.Proof.simple_inductionnnIHn.-constructor.-inductionIHn.+constructor;byconstructor.+constructor;byassumption.Defined.Lemmaincreasing_geq_minus(nk:nat):increasing_geqn(n-k).Proof.simple_inductionkkIHk.-destruct(symmetric_paths__(nat_sub_zero_rn));constructor.-destruct(@leq_dichotomynk)as[l|g].+destruct(equiv_nat_sub_leq_)^inIHk.applyleq_succ_rinl.destruct(equiv_nat_sub_leq_)^.exactIHk.+changek.+1with(1 +k).destruct(nat_add_commk1).destruct(symmetric_paths__(nat_sub_r_addnk1)).destruct(symmetric_paths__(@predeqminus1(n-k))).applyincreasing_geq_S.unfold">", "<"in*.applyequiv_lt_lt_subing.by(destruct(symmetric_paths__(nat_succ_pred(n-k)_))).Defined.Lemmaineq_sub'(nk:nat) :k<n->n-k= (n-k.+1).+1.Proof.introineq.destructn.-contradiction(not_lt_zero_rk).-change(n.+1 -k.+1)with(n-k).applyleq_pred'inineq.byapplynat_sub_succ_l.Defined.Lemmaineq_sub(nm:nat) :n<=m->m- (m-n) =n.Proof.revertm;simple_inductionnnIHn.-intros.destruct(symmetric_paths__(nat_sub_zero_rm)),(symmetric_paths__(nat_sub_cancelm));reflexivity.-introsmineq.change(m-n.+1)with(m- (1 +n)).(destruct(nat_add_commn1)).destruct(symmetric_paths__(nat_sub_r_addmn1)).destruct(nat_succ_pred(m-n) (equiv_lt_lt_sub__ineq));simpl;destruct(symmetric_paths__(nat_sub_zero_r(nat_pred(m-n)))).assert(0 <m-n)asdpbyexact(equiv_lt_lt_sub__ineq).assert(nat_pred(m-n) <m)asshby(unfold"<";destruct(symmetric_paths__(nat_succ_pred__));exactsub_less).destruct(symmetric_paths__(ineq_sub'___)).destruct(symmetric_paths__(nat_succ_pred__)).apply(apS),IHn,leq_succ_l,ineq.Defined.Propositionleq_equivalent(nm:nat):n<=m<->increasing_geqmn.Proof.split.-introineq.inductionineq.+constructor.+applyincreasing_geq_S_ninIHineq;constructor;assumption.-introa.inductiona.+constructor.+exact(leq_succ_l_).Defined.TODO: remove  This tautology accepts a (potentially opaqued or QED'ed) proof ofn<=m, and returns a transparent proof which can be computed with (i.e., one can loop from n to m)Definitionleq_wrapper{nm:nat} :n<=m->n<=m.Proof.introineq.destruct(@leq_dichotomynm)as[l|g].-exactl.-contradiction(lt_irreflm(lt_lt_leq_transgineq)).Defined.Propositionsymmetric_rel_total_order(R:nat->nat->Type){p:SymmetricR} {p':ReflexiveR}: (forallnm:nat,n<m->Rnm) -> (forallnm:nat,Rnm).Proof.introsAnm.destruct(@leq_dichotomymn)as[m_leq_n|m_gt_n].-applysymmetry.destructm_leq_n.+applyreflexivity.+applyA.applyleq_succ.assumption.-applyA,m_gt_n.Defined.

--- Miscellaneous\Arrow.html ---
ArrowLibrary ArrowTheorems about Non-dependent function typesRequireImportBasics.OvertureBasics.PathGroupoidsBasics.DecidableBasics.EquivalencesBasics.TruncBasics.TacticsBasics.Iff.RequireImportTypes.Forall.Local OpenScopepath_scope.LocalSetUniverseMinimizationToSet.Generalizable VariablesABCDfgn.Definitionarrow@{uu0} (A:Type@{u}) (B:Type@{u0}) :=A->B.#[export]InstanceIsReflexive_arrow:Reflexivearrow:=fun_=>idmap.#[export]InstanceIsTransitive_arrow:Transitivearrow:=fun___fg=>composegf.SectionAssumeFunext.Context`{Funext}.PathsAs for dependent functions, pathsp:f=gin a function typeA->Bare equivalent to functions taking values in path types,H:forallx:A,fx=gx, or conciselyH:f==g.  These are all given in theOverture, but we can give them separate names for clarity in the non-dependent case.Definitionpath_arrow{AB:Type} (fg:A->B): (f==g) -> (f=g):=path_forallfg.There are a number of combinations of dependent and non-dependent forapD10_path_forall; we list all of the combinations as helpful lemmas for rewriting.Definitionap10_path_arrow{AB:Type} (fg:A->B) (h:f==g):ap10(path_arrowfgh) ==h:=apD10_path_forallfgh.DefinitionapD10_path_arrow{AB:Type} (fg:A->B) (h:f==g):apD10(path_arrowfgh) ==h:=apD10_path_forallfgh.Definitionap10_path_forall{AB:Type} (fg:A->B) (h:f==g):ap10(path_forallfgh) ==h:=apD10_path_forallfgh.Definitioneta_path_arrow{AB:Type} (fg:A->B) (p:f=g):path_arrowfg(ap10p) =p:=eta_path_forallfgp.Definitionpath_arrow_1{AB:Type} (f:A->B): (path_arrowff(funx=> 1)) = 1:=eta_path_arrowff1.Definitionequiv_ap10{AB:Type}fg: (f=g) <~> (f==g):=Build_Equiv__(@ap10ABfg)_.Global Instanceisequiv_path_arrow{AB:Type} (fg:A->B):IsEquiv(path_arrowfg) | 0:=isequiv_path_forallfg.Definitionequiv_path_arrow{AB:Type} (fg:A->B): (f==g) <~> (f=g):=equiv_path_forallfg.Function extensionality for two-variable functionsDefinitionequiv_path_arrow2{XYZ:Type} (fg:X->Y->Z): (forallxy,fxy=gxy) <~>f=g.Proof.refine(equiv_path_arrow__oE_).applyequiv_functor_forall_id;introx.applyequiv_path_arrow.Defined.Definitionap100_path_arrow2{XYZ:Type} {fg:X->Y->Z}(h:forallxy,fxy=gxy) (x:X) (y:Y):ap100(equiv_path_arrow2fgh)xy=hxy.Proof.unfoldap100.refine(ap(funp=>ap10py)_@_).1:applyapD10_path_arrow.cbn.applyapD10_path_arrow.Defined.Path algebraDefinitionpath_arrow_pp{AB:Type} (fgh:A->B)(p:f==g) (q:g==h):path_arrowfh(funx=>px@qx) =path_arrowfgp@path_arrowghq:=path_forall_ppfghpq.TransportTransporting in non-dependent function types is somewhat simpler than in dependent ones.Definitiontransport_arrow{A:Type} {BC:A->Type}{x1x2:A} (p:x1=x2) (f:Bx1->Cx1) (y:Bx2): (transport(funx=>Bx->Cx)pf)y=p# (f(p^ #y)).Proof.destructp;simpl;auto.Defined.This is an improvement totransport_arrow.  That result only shows that the functions are homotopic, but even without funext, we can prove that these functions are equal.Definitiontransport_arrow'{A:Type} {BC:A->Type}{x1x2:A} (p:x1=x2) (f:Bx1->Cx1):transport(funx=>Bx->Cx)pf=transport_pofotransport_p^.Proof.destructp;auto.Defined.Definitiontransport_arrow_toconst{A:Type} {B:A->Type} {C:Type}{x1x2:A} (p:x1=x2) (f:Bx1->C) (y:Bx2): (transport(funx=>Bx->C)pf)y=f(p^ #y).Proof.destructp;simpl;auto.Defined.This is an improvement totransport_arrow_toconst.  That result shows that the functions are homotopic, but even without funext, we can prove that these functions are equal.Definitiontransport_arrow_toconst'{A:Type} {B:A->Type} {C:Type}{x1x2:A} (p:x1=x2) (f:Bx1->C):transport(funx=>Bx->C)pf=fotransportBp^.Proof.destructp;auto.Defined.Definitiontransport_arrow_fromconst{AB:Type} {C:A->Type}{x1x2:A} (p:x1=x2) (f:B->Cx1) (y:B): (transport(funx=>B->Cx)pf)y=p# (fy).Proof.destructp;simpl;auto.Defined.And some naturality and coherence for these laws.Definitionap_transport_arrow_toconst{A:Type} {B:A->Type} {C:Type}{x1x2:A} (p:x1=x2) (f:Bx1->C) {y1y2:Bx2} (q:y1=y2):ap(transport(funx=>Bx->C)pf)q@transport_arrow_toconstpfy2=transport_arrow_toconstpfy1@ap(funy=>f(p^ #y))q.Proof.destructp,q;reflexivity.Defined.Dependent pathsUsually, a dependent path overp:x1=x2inP:A->Typebetweeny1:Px1andy2:Px2is a pathtransportPpy1=y2inPx2.  However, whenPis a function space, these dependent paths have a more convenient description: rather than transporting the argument ofy1forwards and backwards, we transport only forwards but on both sides of the equation, yielding a "naturality square".Definitiondpath_arrow{A:Type} (BC:A->Type) {x1x2:A} (p:x1=x2)(f:Bx1->Cx1) (g:Bx2->Cx2): (forall(y1:Bx1),transportCp(fy1) =g(transportBpy1))<~> (transport(funx=>Bx->Cx)pf=g).Proof.destructp.applyequiv_path_arrow.Defined.Definitionap10_dpath_arrow{A:Type} (BC:A->Type) {x1x2:A} (p:x1=x2)(f:Bx1->Cx1) (g:Bx2->Cx2)(h:forall(y1:Bx1),transportCp(fy1) =g(transportBpy1))(u:Bx1):ap10(dpath_arrowBCpfgh) (p#u)=transport_arrowpf(p#u)@ap(funx=>p# (fx)) (transport_VpBpu)@hu.Proof.destructp;simpl;unfoldap10.exact(apD10_path_forallfghu@ (concat_1p_)^).Defined.Maps on pathsThe action of maps given by application.Definitionap_apply_l{AB:Type} {xy:A->B} (p:x=y) (z:A):ap(funf=>fz)p=ap10pz:= 1.Definitionap_apply_Fl{ABC:Type} {xy:A} (p:x=y) (M:A->B->C) (z:B):ap(funa=> (Ma)z)p=ap10(apMp)z:=matchpwith1 => 1end.Definitionap_apply_Fr{ABC:Type} {xy:A} (p:x=y) (z:B->C) (N:A->B):ap(funa=>z(Na))p=ap01z(apNp):= (ap_composeN__).Definitionap_apply_FlFr{ABC:Type} {xy:A} (p:x=y) (M:A->B->C) (N:A->B):ap(funa=> (Ma) (Na))p=ap11(apMp) (apNp):=matchpwith1 => 1end.The action of maps given by lambda.Definitionap_lambda{ABC:Type} {xy:A} (p:x=y) (M:A->B->C):ap(funab=>Mab)p=path_arrow__(funb=>ap(funa=>Mab)p).Proof.destructp;symmetry;simpl;applypath_arrow_1.Defined.Functorial actionDefinitionfunctor_arrow`(f:B->A) `(g:C->D): (A->C) -> (B->D):= @functor_forallA(fun_=>C)B(fun_=>D)f(fun_=>g).Definitionnot_contrapositive`(f:B->A):notA->notB:=functor_arrowfidmap.Definitioniff_not@{uvk|u<=k,v<=k}(A:Type@{u}) (B:Type@{v}):A<->B->iff@{uvk} (~A) (~B).Proof.introse;split;applynot_contrapositive@{_k},e.Defined.Definitionap_functor_arrow`(f:B->A) `(g:C->D)(hh':A->C) (p:h==h'):ap(functor_arrowfg) (path_arrow__p)=path_arrow__(funb=>apg(p(fb))):= @ap_functor_forall_A(fun_=>C)B(fun_=>D)f(fun_=>g)hh'p.Truncatedness: functions into an n-type is an n-typeGlobal Instancecontr_arrow{AB:Type} `{ContrB}:Contr(A->B) | 100:=contr_forall.Global Instanceistrunc_arrow{AB:Type} `{IsTruncnB}:IsTruncn(A->B) | 100:=istrunc_forall.Functions from a contractible typeThis also follows fromequiv_contr_forall, but this proof has a better inverse map.Definitionequiv_arrow_from_contr(AB:Type) `{ContrA}: (A->B) <~>B.Proof.srapply(equiv_adjointify(funf=>f(centerA))const).-reflexivity.-introf;funexta;unfoldconst;simpl.apply(apf),contr.Defined.EquivalencesGlobal Instanceisequiv_functor_arrow`{IsEquivBAf} `{IsEquivCDg}:IsEquiv(functor_arrowfg) | 1000:= @isequiv_functor_forall_A(fun_=>C)B(fun_=>D)____.Definitionequiv_functor_arrow`{IsEquivBAf} `{IsEquivCDg}: (A->C) <~> (B->D):= @equiv_functor_forall_A(fun_=>C)B(fun_=>D)f_(fun_=>g)_.Definitionequiv_functor_arrow'`(f:B<~>A) `(g:C<~>D): (A->C) <~> (B->D):= @equiv_functor_forall'_A(fun_=>C)B(fun_=>D)f(fun_=>g).(* We could do something like this notation, but it's not clear that it would be that useful, and might be confusing. *)(* Notation "f -> g" := (equiv_functor_arrow' f g) : equiv_scope. *)EndAssumeFunext.DecidabilityThis doesn't require funextGlobal Instancedecidable_arrow{AB:Type}`{DecidableA} `{DecidableB}:Decidable(A->B).Proof.destruct(decB)as[x2|y2].-exact(inl(fun_=>x2)).-destruct(decA)as[x1|y1].+applyinr;introsf.exact(y2(fx1)).+applyinl;introsx1.elim(y1x1).Defined.

--- Miscellaneous\AssociativityLaw.html ---
AssociativityLawLibrary AssociativityLawAssociativity of adjunction compositionRequireImportCategory.CoreFunctor.Core.RequireImportAdjoint.Composition.CoreAdjoint.Core.RequireAdjoint.Composition.LawsTactic.RequireImportTypes.SigmaTypes.Prod.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopeadjunction_scope.Local OpenScopemorphism_scope.Sectioncomposition_lemmas.Local NotationAdjunctionWithFunctorsCD:={fg:FunctorCD*FunctorDC|fstfg-|sndfg}.Context`{H0:Funext}.VariablesBCDE:PreCategory.VariableF:FunctorBC.VariableF':FunctorCB.VariableG:FunctorCD.VariableG':FunctorDC.VariableH:FunctorDE.VariableH':FunctorED.VariableAF:F-|F'.VariableAG:G-|G'.VariableAH:H-|H'.Local OpenScopeadjunction_scope.Lemmaassociativity: ((_,_); (AHoAG)oAF) = ((_,_);AHo(AGoAF)) :>AdjunctionWithFunctorsBE.Proof.applypath_sigma_uncurried;simpl.(exists(path_prod'(Functor.Composition.Laws.associativity___)(symmetry__(Functor.Composition.Laws.associativity___))));Adjoint.Composition.LawsTactic.law_t.Qed.Endcomposition_lemmas.#[export]HintResolveassociativity:category.

--- Miscellaneous\assume_rationals.html ---
assume_rationalsLibrary assume_rationalsFromHoTT.ClassesRequireImportinterfaces.canonical_namesinterfaces.ordersinterfaces.rationalstheory.rationals.Monomorphic UniverseUQ.Parameters(Q:Type@{UQ}) (Qap:Apart@{UQUQ}Q)(Qplus:PlusQ) (Qmult:MultQ)(Qzero:ZeroQ) (Qone:OneQ) (Qneg:NegateQ) (Qrecip:DecRecipQ)(Qle:Le@{UQUQ}Q) (Qlt:Lt@{UQUQ}Q)(QtoField:RationalsToField@{UQUQUQUQ}Q)(Qrats:Rationals@{UQUQUQUQUQUQUQUQUQUQ}Q)(Qtrivialapart:TrivialApartQ) (Qdec:DecidablePathsQ)(Qmeet:MeetQ) (Qjoin:JoinQ) (Qlattice:LatticeOrderQle)(Qle_total:TotalRelation(@leQ_))(Qabs:AbsQ).(* I don't even want to know why this is necessary. *)ParameterQenum:EnumerableQ.Notation"Q+" := (QposQ).Global Existing InstancesQapQplusQmultQzeroQoneQnegQrecipQleQltQtoFieldQratsQtrivialapartQdecQmeetQjoinQlatticeQle_totalQabsQenum.

--- Miscellaneous\Attributes.html ---
AttributesLibrary AttributesAttributes of Functoriality of functor compositionRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportFunctor.Composition.Functorial.Core.RequireImportNaturalTransformation.Composition.Core.RequireImportNaturalTransformation.Isomorphisms.RequireImportFunctor.Attributes.RequireImportFunctorCategory.Core.RequireImportCategory.Morphisms.RequireImportNaturalTransformation.Paths.RequireImportHoTT.Truncations.Core.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Local OpenScopenatural_transformation_scope.Local OpenScopemorphism_scope.Precomposition with an essentially surjective functor is faithfulSectionfaithfull_precomposition_essential_surjective.Quoting the HoTT Book:Lemma. IfA,B,Care precategories andH:A→Bis an
  essentially surjective functor, then(–∘H):(B→C)→(A→C)is faithful.Context`{fs:Funext}.VariablesABC:PreCategory.VariableH:FunctorAB.Context`{H_is_essentially_surjective:IsEssentiallySurjectiveABH}.Lemmaisfaithful_precomposition_essentially_surjective_helper(FG:FunctorBC)(TU:NaturalTransformationFG)(a:A) (b:B)(f:Ha<~=~>b)(H':ToRH=UoRH):Tb=Ub.Proof.apply(apcomponents_of)inH'.applyapD10inH';hnfinH';simplinH'.rewrite<- !(path_components_of_isomorphic'f).rewriteH'.reflexivity.Qed.Global Instanceisfaithful_precomposition_essentially_surjective: @IsFaithful_(B->C) (A->C) (compose_functor___H).Proof.repeatmatchgoalwith|_=>eapplyisfaithful_precomposition_essentially_surjective_helper;eassumption|_=>intro|_=>progresshnfin*|_=>progresssimplin*|_=>applypath_forall|_=>progressstrip_truncations| [H:_|-_] =>applyap10inH|_=>progresspath_natural_transformation| [H:sig_|-_] =>destructH| [H:_,t:_|-_]=>generalizedependent(Ht);clearHend.Qed.Endfaithfull_precomposition_essential_surjective.

--- Miscellaneous\Aut.html ---
AutLibrary AutRequireImportBasics.RequireImportTruncations.RequireImportAlgebra.ooGroup.RequireImportUniverses.BAut.RequireImportPointed.Core.Local OpenScopepointed_scope.Automorphism oo-GroupsWe defineAutXusing the pointed, connected typeBAutX.DefinitionAut(X:Type) :ooGroup:=Build_ooGroup[BAutX,_]_.

--- Miscellaneous\Automorphisms.html ---
AutomorphismsLibrary AutomorphismsRequireImportBasicsTypes.RequireImportHoTT.Truncations.RequireImportUniverses.BAutUniverses.Rigid.RequireImportExcludedMiddle.Local OpenScopetrunc_scope.Local OpenScopepath_scope.The universeAutomorphisms of the universeSee "Parametricity, automorphisms of the universe, and excluded middle" by Booij, Escardo, Lumsdaine, Shulman.If two inequivalent types have equivalent automorphism oo-groups, then assuming LEM we can swap them and leave the rest of the universe untouched.SectionSwapTypes.Amusingly, this does not actually require univalence!  But of course, to verifyBAutA<~>BAutBin any particular example does require univalence.Context`{Funext} `{ExcludedMiddle}.Context(AB:Type) (ne: ~(A<~>B)) (e:BAutA<~>BAutB).Definitionequiv_swap_types:Type<~>Type.Proof.refine(((equiv_decidable_sum(funX:Type=>merely(X=A)))^-1)oE_oE(equiv_decidable_sum(funX:Type=>merely(X=A)))).refine((equiv_functor_sum_l(equiv_decidable_sum(funX=>merely(X.1=B)))^-1)oE_oE(equiv_functor_sum_l(equiv_decidable_sum(funX=>merely(X.1=B))))).refine((equiv_sum_assoc___)oE_oE(equiv_sum_assoc___)^-1).applyequiv_functor_sum_r.assert(q:BAutB<~> {x: {x:Type& ~merely(x=A)} &merely(x.1 =B)}).{refine(equiv_sigma_assoc__oE_).applyequiv_functor_sigma_id;introsX.applyequiv_iff_hprop.-introsp.refine(funq=>_;p).strip_truncations.destructq.exact(ne(equiv_pathXBp)).-exactpr2. }refine(_oEequiv_sum_symm__).applyequiv_functor_sum'.-exact(e^-1oEq^-1).-exact(qoEe).Defined.Definitionequiv_swap_types_swaps:merely(equiv_swap_typesA=B).Proof.assert(ea:= (e(point_)).2).cbninea.strip_truncations;applytr.unfoldequiv_swap_types.applymoveR_equiv_V.rewrite(equiv_decidable_sum_l(funX=>merely(X=A))A(tr1)).assert(ne': ~merely(B=A))by(introsp;strip_truncations;exact(ne(equiv_pathABp^))).rewrite(equiv_decidable_sum_r(funX=>merely(X=A))Bne').cbn.applyap,path_sigma_hprop;cbn.exactea.Defined.Definitionequiv_swap_types_not_id:equiv_swap_types<>equiv_idmap.Proof.introsp.assert(q:=equiv_swap_types_swaps).strip_truncations.applyne.applyequiv_path.rewritepinq;exactq.Qed.EndSwapTypes.In particular, we can swap any two distinct rigid types.Definitionequiv_swap_rigid`{Univalence} `{ExcludedMiddle}(AB:Type) `{IsRigidA} `{IsRigidB} (ne: ~(A<~>B)):Type<~>Type.Proof.refine(equiv_swap_typesABne_).applyequiv_contr_contr.Defined.Such asEmptyandUnit.Definitionequiv_swap_empty_unit`{Univalence} `{ExcludedMiddle}:Type<~>Type:=equiv_swap_rigidEmptyUnit(fune=>e^-1tt).In this case we get an untruncated witness of the swapping.Definitionequiv_swap_rigid_swaps`{Univalence} `{ExcludedMiddle}(AB:Type) `{IsRigidA} `{IsRigidB} (ne: ~(A<~>B)):equiv_swap_rigidABneA=B.Proof.unfoldequiv_swap_rigid,equiv_swap_types.applymoveR_equiv_V.rewrite(equiv_decidable_sum_l(funX=>merely(X=A))A(tr1)).assert(ne': ~merely(B=A))by(introsp;strip_truncations;exact(ne(equiv_pathABp^))).rewrite(equiv_decidable_sum_r(funX=>merely(X=A))Bne').cbn.applyap,path_sigma_hprop;cbn.exact((path_contr(center(BAutB)) (point(BAutB)))..1).Defined.We can also swap the products of two rigid types with another typeX, under a connectedness/truncatedness assumption.Definitionequiv_swap_prod_rigid`{Univalence} `{ExcludedMiddle}(XAB:Type) (n:trunc_index) (ne: ~(X*A<~>X*B))`{IsRigidA} `{IsConnectedn.+1A}`{IsRigidB} `{IsConnectedn.+1B}`{IsTruncn.+1X}:Type<~>Type.Proof.refine(equiv_swap_types(X*A) (X*B)ne_).transitivity(BAutX).-symmetry;exact(baut_prod_rigid_equivXAn).-exact(baut_prod_rigid_equivXBn).Defined.Conversely, from some nontrivial automorphisms of the universe we can deduce nonconstructive consequences.Definitionlem_from_aut_type_unit_empty`{Univalence}(f:Type<~>Type) (eu:fUnit=Empty):ExcludedMiddle_type.Proof.applyDNE_to_LEM,DNE_from_allneg;introsP?.exists(fP);split.-introsp.assert(ContrP)by(applycontr_inhabited_hprop;assumption).assert(q:Unit=P)by(applypath_universe_uncurried,equiv_contr_contr).destructq.rewriteeu.auto.-introsnfp.assert(q:fP=Empty)by(applypath_universe_uncurried,equiv_to_empty,nfp).rewrite<-euinq.apply((apf)^-1)inq.rewriteq;exacttt.Defined.Lemmaequiv_hprop_idprod`{Univalence}(A:Type) (P:Type) (a:merelyA) `{IsHPropP}:P<-> (P*A=A).Proof.split.-introsp;applypath_universewithsnd.applyisequiv_adjointifywith(funa=> (p,a)).+introsx;reflexivity.+intros[p'x].applypath_prod; [applypath_ishprop|reflexivity].-introsq.strip_truncations.applyequiv_pathinq.exact(fst(q^-1a)).Defined.Definitionlem_from_aut_type_inhabited_empty`{Univalence}(f:Type<~>Type)(A:Type) (a:merelyA) (eu:fA=Empty):ExcludedMiddle_type.Proof.applyDNE_to_LEM,DNE_from_allneg;introsP?.exists(f(P*A));split.-introsp.assert(q:=fst(equiv_hprop_idprodAPa)p).apply(apf)inq.rewriteeuinq.rewriteq;auto.-introsq.applyequiv_to_emptyinq.applypath_universe_uncurriedinq.rewrite<-euinq.apply((apf)^-1)inq.exact(snd(equiv_hprop_idprodAPa)q).Defined.If you can derive a constructive taboo from an automorphism of the universe such thatgX<>X, then you getX-many beers; see <https://groups.google.com/d/msg/homotopytypetheory/8CV0S2DuOI8/blCo7x-B7aoJ>.Definitionzero_beers`{Univalence}(g:Type<~>Type) (ge:gEmpty<>Empty): ~~ExcludedMiddle_type.Proof.pose(f:=equiv_inverseg).introsnlem.applyge.applypath_universe_uncurried,equiv_to_empty;introsgz.applynlem.apply(lem_from_aut_type_inhabited_emptyf(gEmpty) (trgz)).unfoldf;applyeissect.Defined.Definitionlem_beers`{Univalence}(g:Type<~>Type) (ge:gExcludedMiddle_type<>ExcludedMiddle_type): ~~ExcludedMiddle_type.Proof.introsnlem.pose(nlem':=equiv_to_emptynlem).applypath_universe_uncurriedinnlem'.rewritenlem'inge.apply(zero_beersg)inge.exact(genlem).Defined.

--- Miscellaneous\BaerSum.html ---
BaerSumLibrary BaerSumRequireImportBasicsTypes.RequireImportWildCatPointed.Core.RequireImportAbGroups.AbelianGroupAbGroups.BiproductAbGroups.AbHom.RequireImportAbSES.CoreAbSES.PullbackAbSES.PushoutAbSES.DirectSum.RequireImportHomotopy.HSpace.Core.Local OpenScopemc_scope.Local OpenScopemc_add_scope.The Baer sum of two short exact sequences, lemmas and consequences.The Baer sum of two short exact sequences is obtained from the pointwise direct sum by pushing forward along the codiagonal and then pulling back along the diagonal. (Swapping the order of pushing forward and pulling back produces an isomorphic short exact sequence.)Definitionabses_baer_sum`{Univalence} {BA:AbGroup@{u}} (EF:AbSESBA):AbSESBA:=abses_pullbackab_diagonal(abses_pushoutab_codiagonal(abses_direct_sumEF)).AbSES'is a bifunctorGiven a morphismfof short exact sequences, the pushout of the domain alongf_1equals the pullback of the codomain alongf_3.Lemmaabses_pushout_is_pullback'`{Univalence} {AA'BB':AbGroup@{u}}{E:AbSESBA} {E':AbSESB'A'} (f:AbSESMorphismEE'):abses_pushout(component1f)E$==abses_pullback(component3f)E'.Proof.(* The morphismf:E->E'factors asE->f_1E->E', where the first map is the map defining the pushoutf_1Eand the second map is denotedabses_pushout_morphism_recfbelow.  This second map is the identity on the first component, so it presents its domain as the pullback ofE'alongf_3. *)exact(abses_pullback_component1_id'(abses_pushout_morphism_recf) (fun_=>idpath)).Defined.Given a morphismfof short exact sequences, the pushout of the domain alongf_1equals the pullback of the codomain alongf_3.Definitionabses_pushout_is_pullback`{Univalence} {AA'BB':AbGroup}{E:AbSESBA} {E':AbSESB'A'} (f:AbSESMorphismEE'):abses_pushout(component1f)E=abses_pullback(component3f)E':=equiv_path_abses_iso(abses_pushout_is_pullback'f).Definitionabses_pushout_pullback_reorder'`{Univalence} {AA'BB':AbGroup}(E:AbSESBA) (f:A$->A') (g:B'$->B):abses_pushoutf(abses_pullbackgE) $==abses_pullbackg(abses_pushoutfE).Proof.(* There are morphismsEg->EandE->fEby definition of the pullback and pushout. We defineF:Eg->fEto be the composite. Its first and third components arefoidandidog. *)pose(F:=absesmorphism_compose(abses_pushout_morphismEf) (abses_pullback_morphismEg)).(* We changeFto a morphism that is the same except that the first and third components arefandg. Thenabses_pushout_is_pullbackshows that the pushout ofEgalongfis equal to the pullback offEalongg. *)refine(abses_pushout_is_pullback'(Build_AbSESMorphismf(component2F)g__));applyF.Defined.This is the statement thatAbSES'is a bifunctor, but we state it separately because Coq is slow to unifyIsBifunctorAbSES'against goals written in this form.Definitionabses_pushout_pullback_reorder`{Univalence} {AA'BB':AbGroup}(E:AbSESBA) (f:A$->A') (g:B'$->B):abses_pushoutf(abses_pullbackgE) =abses_pullbackg(abses_pushoutfE).Proof.applyequiv_path_abses_iso.applyabses_pushout_pullback_reorder'.Defined.Global Instanceis0bifunctor_abses'`{Univalence}:Is0Bifunctor(AbSES':AbGroup^op->AbGroup->Type).Proof.rapplyBuild_Is0Bifunctor''.Defined.Global Instanceis1bifunctor_abses'`{Univalence}:Is1Bifunctor(AbSES':AbGroup^op->AbGroup->Type).Proof.snrapplyBuild_Is1Bifunctor''.1,2:exact_.intros? ?g? ?fE;cbn.exact(abses_pushout_pullback_reorderEfg).Defined.Given a short exact sequenceA->E->Band mapsf:A->A',g:B'->B, we can change the order of pushing out alongfand pulling back alongg.Lemmaabses_reorder_pullback_pushout`{Univalence} {AA'BB':AbGroup}(E:AbSESBA) (f:A$->A') (g:B'$->B):abses_pushoutf(abses_pullbackgE) =abses_pullbackg(abses_pushoutfE).Proof.(* There are morphismsEg->EandE->fEby definition of the pullback and pushout. We defineF:Eg->fEto be the composite. Its first and third components arefoidandidog. *)pose(F:=absesmorphism_compose(abses_pushout_morphismEf) (abses_pullback_morphismEg)).(* We changeFto a morphism that is the same except that the first and third components arefandg. Thenabses_pushout_is_pullbackshows that the pushout ofEgalongfis equal to the pullback offEalongg. *)refine(abses_pushout_is_pullback(Build_AbSESMorphismf(component2F)g__));applyF.Defined.The Baer sum distributes over pullbacks.Lemmabaer_sum_distributive_pullbacks`{Univalence} {ABB':AbGroup}{E:AbSESBA} (fg:ab_homB'B):abses_pullback(f+g)E=abses_baer_sum(abses_pullbackfE) (abses_pullbackgE).Proof.unfoldabses_baer_sum.refine((abses_pullback_compose(B1:=ab_biprodBB)__E)^ @_).refine(ap(abses_pullback_) (abses_pushout_is_pullback(abses_codiagonalE))^ @_).unfoldabses_codiagonal,component1.refine(_^ @_@_).1,3:applyabses_reorder_pullback_pushout.refine(ap(abses_pushout_)_).refine(ap(funh=>abses_pullbackh_) (ab_biprod_corec_diagonal__) @_).refine((abses_pullback_compose__(abses_direct_sumEE))^ @_).exact(ap(abses_pullback_) (abses_directsum_distributive_pullbacksfg)).Defined.The Baer sum is commutative.Lemmabaer_sum_commutative`{Univalence} {AB:AbGroup} (EF:AbSESBA):abses_baer_sumEF=abses_baer_sumFE.Proof.unfoldabses_baer_sum.(* The next line uses thatdirect_sum_swap$oab_diagonalis definitionally equal toab_diagonal: *)refine(_@abses_pullback_composeab_diagonaldirect_sum_swap_).refine(ap(abses_pullbackab_diagonal)_).refine(ap(funf=>abses_pushoutf_)ab_codiagonal_swap^ @_).refine((abses_pushout_compose___) @_).refine(ap_(abses_pushout_is_pullback(abses_swap_morphismEF)) @_).unfoldabses_swap_morphism,component3.applyabses_pushout_pullback_reorder.Defined.The right unit law for the Baer sum says that for allE:AbSESBA,E+E_0=E, whereE_0is the split short exact sequence.Lemmabaer_sum_unit_r`{Univalence} {AB:AbGroup} (E:AbSESBA):abses_baer_sumE(point(AbSESBA)) =E.Proof.refine(ap(abses_baer_sumE)_@_).-exact(abses_pullback_constE).-refine(ap(funF=>abses_baer_sumF(abses_pullbackgrp_homo_constE)) (abses_pullback_idE)^ @_).refine((baer_sum_distributive_pullbacksgrp_homo_idgrp_homo_const)^ @_).refine(ap(funf=>abses_pullbackfE) (grp_unit_r(G:=ab_hom__)_) @_).applyabses_pullback_id.Defined.The left unit law for the Baer sum is analogous.Definitionbaer_sum_unit_l`{Univalence} {AB:AbGroup} (E:AbSESBA):abses_baer_sum(point(AbSESBA))E=E:=baer_sum_commutative__@baer_sum_unit_r_.For anyE:AbSESBA, the pullback ofEalong-id_Bacts as an additive inverse forEwith respect to the Baer sum.Lemmabaer_sum_inverse_l`{Univalence} {AB:AbGroup} (E:AbSESBA):abses_baer_sumE(abses_pullback(-grp_homo_id)E) =point(AbSESBA).Proof.refine(ap(funF=>abses_baer_sumF(abses_pullback_E)) (abses_pullback_idE)^ @_).refine((baer_sum_distributive_pullbacksgrp_homo_id(-grp_homo_id))^ @_).refine(ap(funf=>abses_pullbackf_) (grp_inv_r(G:=ab_hom__)_) @_).symmetry;applyabses_pullback_const.Defined.The right inverse law follows by commutativity.Definitionbaer_sum_inverse_r`{Univalence} {AB:AbGroup} (E:AbSESBA):abses_baer_sum(abses_pullback(-grp_homo_id)E)E=point(AbSESBA):=baer_sum_commutative__@baer_sum_inverse_l_.The Baer sum distributes over pushouts.Lemmabaer_sum_distributive_pushouts`{Univalence}{AA'B:AbGroup} {E:AbSESBA'} (fg:ab_homA'A):abses_pushout(f+g)E=abses_baer_sum(abses_pushoutfE) (abses_pushoutgE).Proof.unfoldabses_baer_sum.refine(abses_pushout_compose(A1:=ab_biprodAA)__E@_).refine(_@abses_pushout_pullback_reorder___).refine(ap(abses_pushoutab_codiagonal)_).refine(ap(funf=>abses_pushoutfE) (ab_biprod_corec_diagonalfg) @_).refine(abses_pushout_compose__E@_).refine(ap(abses_pushout_) (abses_pushout_is_pullback(abses_diagonalE)) @_).refine(abses_pushout_pullback_reorder___@_).exact(ap(abses_pullback_) (abses_directsum_distributive_pushoutsfg)).Defined.Our next goal is to prove that the Baer sum is associative.  Rather than showing this directly, we first provebaer_sum_twist, which says thatabses_baer_sum(abses_baer_sumEF)G=abses_baer_sum(abses_baer_sumGF)E.  The proof of this mimics the proof of commutativity above.  Then we prove associativity by combining this with commutativity.The trinary Baer sum of three short exact sequences.Definitionabses_trinary_baer_sum`{Univalence}{AB:AbGroup@{u}} (EFG:AbSESBA):AbSESBA:=abses_pullbackab_triagonal(abses_pushoutab_cotriagonal(abses_direct_sum(abses_direct_sumEF)G)).ForE,F,G:AbSESBA, the Baer sum ofE,FandG(associated left) is equal to the trinary Baer sum ofE,FandG.Lemmabaer_sum_is_trinary`{Univalence} {AB:AbGroup@{u}} (EFG:AbSESBA):abses_baer_sum(abses_baer_sumEF)G=abses_trinary_baer_sumEFG.Proof.unfoldabses_baer_sum,abses_trinary_baer_sum,ab_triagonal,ab_cotriagonal.refine(ap(abses_pullback_oabses_pushout_)_^ @_).-refine(_@ap(abses_direct_sum_) (abses_pullback_idG)).refine(_@abses_directsum_distributive_pullbacks__).refine(ap(abses_pullback_)_).refine(_@ap(abses_direct_sum_) (abses_pushout_idG)).applyabses_directsum_distributive_pushouts.-refine(ap(abses_pullback_) (abses_pushout_pullback_reorder___) @_).refine(abses_pullback_compose___@_).refine(ap(abses_pullback_)_^).applyabses_pushout_compose.Defined.ForE,F,G:AbSESBA, we can "twist" the order of the trinary Baer sum as follows.Lemmatwist_trinary_baer_sum`{Univalence}{AB:AbGroup@{u}} (EFG:AbSESBA):abses_trinary_baer_sumEFG=abses_trinary_baer_sumGFE.Proof.unfoldabses_trinary_baer_sum.(* The next line uses the fact thatab_triagonalis definitionally equal toab_biprod_twist$oab_triagonal: *)refine(_@abses_pullback_composeab_triagonalab_biprod_twist_).refine(ap(abses_pullback_)_).refine(ap(funf=>abses_pushoutf_)ab_cotriagonal_twist^ @_).refine(abses_pushout_compose___@_).refine(ap_(abses_pushout_is_pullback(abses_twist_directsumEFG)) @_).unfoldabses_twist_directsum,component3.exact(abses_pushout_pullback_reorder___).Defined.It now follows that we can twist the order of the summands in the Baer sum.Lemmabaer_sum_twist`{Univalence} {AB:AbGroup@{u}} (EFG:AbSESBA):abses_baer_sum(abses_baer_sumEF)G=abses_baer_sum(abses_baer_sumGF)E.Proof.refine((baer_sum_is_trinaryEFG) @_@ (baer_sum_is_trinaryGFE)^).applytwist_trinary_baer_sum.Defined.From these results, it finally follows that the Baer sum is associative.Lemmabaer_sum_associative`{Univalence}{AB:AbGroup@{u}} (EFG:AbSESBA):abses_baer_sum(abses_baer_sumEF)G=abses_baer_sumE(abses_baer_sumFG).Proof.refine((baer_sum_twist___)^ @_).refine(baer_sum_commutative__@_).applyap.applybaer_sum_commutative.Defined.The Baer sum makesAbSESBAinto an H-space. (In fact, a coherent H-space, but we leave that for now.)Global Instanceishspace_abses`{Univalence} {BA:AbGroup}:IsHSpace(AbSESBA).Proof.snrapplyBuild_IsHSpace.-exactabses_baer_sum.-intro;applybaer_sum_unit_l.-intro;applybaer_sum_unit_r.Defined.Global Instanceis0bifunctor_abses`{Univalence}:Is0Bifunctor(AbSES:AbGroup^op->AbGroup->pType).Proof.rapplyBuild_Is0Bifunctor''.Defined.Global Instanceis1bifunctor_abses`{Univalence}:Is1Bifunctor(AbSES:AbGroup^op->AbGroup->pType).Proof.snrapplyBuild_Is1Bifunctor''.1,2:exact_.intros? ?f? ?g.rapplyhspace_phomotopy_from_homotopy.1:applyishspace_abses.introE;cbn.applyabses_pushout_pullback_reorder.Defined.Pushouts and pullbacks respect the Baer sumDefinitionbaer_sum_pushout`{Univalence}{AA'B:AbGroup} (f:A$->A') (EF:AbSESBA):abses_pushoutf(abses_baer_sumEF)=abses_baer_sum(abses_pushoutfE) (abses_pushoutfF).Proof.unfoldabses_baer_sum.refine(abses_pushout_pullback_reorder___@ap__).refine((abses_pushout_compose___)^ @_).refine(abses_pushout_homotopic____@_).1:applyab_codiagonal_natural.refine(abses_pushout_compose___@ap__).applyabses_directsum_distributive_pushouts.Defined.Definitionbaer_sum_pullback`{Univalence}{ABB':AbGroup} (f:B'$->B) (EF:AbSESBA):abses_pullbackf(abses_baer_sumEF)=abses_baer_sum(abses_pullbackfE) (abses_pullbackfF).Proof.unfoldabses_baer_sum.refine(abses_pullback_compose___@_).refine((abses_pushout_pullback_reorder___)^@ap__@abses_pushout_pullback_reorder___).refine(abses_pullback_homotopic_(functor_ab_biprodff$oab_diagonal)__@_).1:reflexivity.refine((abses_pullback_compose___)^ @ap__).applyabses_directsum_distributive_pullbacks.Defined.

--- Miscellaneous\BAut.html ---
BAutLibrary BAutRequireImportHoTT.BasicsHoTT.Types.RequireImportConstant.RequireImportHoTT.Truncations.RequireImportObjectClassifierHomotopy.ExactSequencePointed.Local OpenScopetype_scope.Local OpenScopepath_scope.BAut(X)BasicsBAutXis the type of types that are merely equal toX. It is connected, byis0connected_componentand any two points are merely equal bymerely_path_component.DefinitionBAut(X:Type@{u}) := {Z:Type@{u} &merely(Z=X) }.CoercionBAut_pr1X:BAutX->Type:=pr1.Global Instanceispointed_baut{X:Type} :IsPointed(BAutX) := (X;tr1).We also define a pointed versionpBAutX, since the coercionBAut_pr1doesn't work ifBAutXis apType.DefinitionpBAut(X:Type) :pType:= [BAutX,_].Definitionpath_baut`{Univalence} {X} (ZZ':BAutX): (Z<~>Z') <~> (Z=Z':>BAutX):=equiv_path_sigma_hprop__oEequiv_path_universe__.Definitionap_pr1_path_baut`{Univalence} {X}{ZZ':BAutX} (f:Z<~>Z'):ap(BAut_pr1X) (path_bautZZ'f) =path_universef.Proof.unfoldpath_baut,BAut_pr1;simpl.applyap_pr1_path_sigma_hprop.Defined.Definitiontransport_path_baut`{Univalence} {X}{ZZ':BAutX} (f:Z<~>Z') (z:Z):transport(fun(W:BAutX) =>W) (path_bautZZ'f)z=fz.Proof.refine(transport_composeidmap(BAut_pr1X)__@_).refine(_@transport_path_universefz).applyap10,ap,ap_pr1_path_baut.Defined.The following tactic, which applies when trying to prove an hprop, replaces all assumed elements ofBAutXbyXitself. WithUnivalence, this would work for any 0-connected type, but usingmerely_path_componentwe can avoid univalence.Ltacbaut_reduce:=progressrepeatmatchgoalwith| [Z:BAut?X|-_]=>letZispoint:=fresh"Zispoint"inassert(Zispoint:=merely_path_component(point(BAutX))Z);revertZispoint;refine(@Trunc_ind_____);introZispoint;destructZispointend.TruncationIfXis ann.+1-type, thenBAutXis ann.+2-type.Global Instancetrunc_baut`{Univalence} {nX} `{IsTruncn.+1X}:IsTruncn.+2 (BAutX).Proof.applyistrunc_S.introsZW.baut_reduce.exact(@istrunc_equiv_istrunc__(path_baut__)n.+1_).Defined.IfXis truncated, then so is every element ofBAutX.Global Instancetrunc_el_baut{nX} `{Funext} `{IsTruncnX} (Z:BAutX):IsTruncnZ:=ltac:(bybaut_reduce).Operations onBAutMultiplying by a fixed typeDefinitionbaut_prod_r(XA:Type):BAutX->BAut(X*A):=funZ:BAutX=>(Z*A;Trunc_functor(-1) (ap(funW=>W*A)) (pr2Z)):BAut(X*A).Definitionap_baut_prod_r`{Univalence} (XA:Type){ZW:BAutX} (e:Z<~>W):ap(baut_prod_rXA) (path_bautZWe)=path_baut(baut_prod_rXAZ) (baut_prod_rXAW) (equiv_functor_prod_re).Proof.cbn.applymoveL_equiv_M;cbn;unfoldpr1_path.rewrite<- (ap_compose(baut_prod_rXA)pr1(path_sigma_hpropZW_)).rewrite<- ((ap_composepr1(funZ=>Z*A) (path_sigma_hpropZW_))^).rewriteap_pr1_path_sigma_hprop.applymoveL_equiv_M;cbn.applyap_prod_r_path_universe.Qed.CentersThe following lemma says that to define a section of a familyPof hsets overBAutX, it is equivalent to define an element ofPXwhich is fixed by all automorphisms ofX.Lemmabaut_ind_hset`{Univalence}XIt ought to be possible to allow more generallyP:BAutX->Type, but the proof would get more complicated, and this version suffices for present applications.(P:Type->Type) `{forall(Z:BAutX),IsHSet(PZ)}: {e:P(point(BAutX)) &forallg:X<~>X,transportP(path_universeg)e=e}<~> (forall(Z:BAutX),PZ).Proof.refine(equiv_sig_ind_oE_).We use the fact that maps out of a propositional truncation into an hset are equivalent to weakly constant functions.refine((equiv_functor_forall'(P:=funZ=> {f: (Z=X) ->PZ&WeaklyConstantf})1(funZ=>equiv_merely_rec_hset_if_domain__))oE_);simpl.{introsp.change(IsHSet(P(BAut_pr1X(Z;trp)))).exact_. }unfoldWeaklyConstant.Now we peel away a bunch of contractible types.refine(equiv_sig_coind__oE_).srapplyequiv_functor_sigma'.1:apply(equiv_paths_ind_rX(funx_=>Px)).introsp;cbn.refine(equiv_paths_ind_rX_oE_).srapplyequiv_functor_forall'.1:applyequiv_equiv_path.introse;cbn.refine(_oEequiv_moveL_transport_V____).applyequiv_concat_r.rewritepath_universe_transport_idmap,paths_ind_r_transport.reflexivity.Defined.This implies that ifXis a set, then the center ofBAutXis the set of automorphisms ofXthat commute with every other automorphism (i.e. the center, in the usual sense, of the group of automorphisms ofX).Definitioncenter_baut`{Univalence}X`{IsHSetX}: {f:X<~>X&forallg:X<~>X,gof==fog}<~> (forallZ:BAutX,Z=Z).Proof.refine(equiv_functor_forall_id(funZ=>equiv_path_sigma_hpropZZ)oE_).refine(baut_ind_hsetX(funZ=>Z=Z)oE_).simpl.refine(equiv_functor_sigma'(equiv_path_universeXX)_);introsf.applyequiv_functor_forall_id;introsg;simpl.refine(_oEequiv_path_arrow__).refine(_oEequiv_path_equiv(goEf) (foEg)).revertg.equiv_intro(equiv_pathXX)g.revertf.equiv_intro(equiv_pathXX)f.refine(_oEequiv_concat_l(equiv_path_pp__)_).refine(_oEequiv_concat_r(equiv_path_pp__)^_).refine(_oE(equiv_ap(equiv_pathXX)__)^-1).refine(equiv_concat_l(transport_paths_lr__)_oE_).refine(equiv_concat_l(concat_pp_p___)_oE_).refine(equiv_moveR_Vp___oE_).refine(equiv_concat_l__oEequiv_concat_r__).-applyconcat2;applyeissect.-symmetry;applyconcat2;applyeissect.Defined.We show that this equivalence takes the identity equivalence to the identity in the center.  We have to be careful in this proof never tosimplorunfoldtoo many things, or Coq will produce gigantic terms that take it forever to compute with.Definitionid_center_baut`{Univalence}X`{IsHSetX}:center_bautX(exist(fun(f:X<~>X) =>forall(g:X<~>X),gof==fog)(equiv_idmapX)(fun(g:X<~>X) (x:X) =>idpath(gx)))=funZ=>idpathZ.Proof.applypath_forall;introsZ.assert(IsHSet(Z.1 =Z.1))byexact_.baut_reduce.exact(ap(path_sigma_hprop__)path_universe_1@path_sigma_hprop_1_).Defined.Similarly, ifXis a 1-type, we can characterize the 2-center ofBAutX.Coq is too eager about unfolding some things appearing in this proof.SectionCenter2BAut.Local Argumentsequiv_path_equiv:simplnever.Local Argumentsequiv_path2_universe:simplnever.Definitioncenter2_baut`{Univalence}X`{IsTrunc1X}: {f:forallx:X,x=x&forall(g:X<~>X) (x:X),apg(fx) =f(gx) }<~> (forallZ:BAutX, (idpathZ) = (idpathZ)).Proof.refine((equiv_functor_forall_id(funZ=> (equiv_concat_lr__)oE(equiv_ap(equiv_path_sigma_hpropZZ) 1%path1%path)))oE_).{symmetry;applypath_sigma_hprop_1. }{applypath_sigma_hprop_1. }assert(forallZ:BAutX,IsHSet(idpathZ.1 =idpathZ.1))byexact_.refine(baut_ind_hsetX(funZ=>idpathZ=idpathZ)oE_).simplerefine(equiv_functor_sigma'__).{refine(_oEequiv_path2_universe1 1).applyequiv_concat_lr.-symmetry;applypath_universe_1.-applypath_universe_1. }introsf.applyequiv_functor_forall_id;introsg.refine(_oEequiv_path3_universe__).refine(dpath_paths2(path_universeg)__oE_).cbn.change(equiv_idmapX==equiv_idmapX)inf.refine(equiv_concat_lr__).-refine(_@ (path2_universe_postcompose_idmapfg)^).abstract(rewrite!whiskerR_pp, !concat_pp_p;reflexivity).-refine(path2_universe_precompose_idmapfg@_).abstract(rewrite!whiskerL_pp, !concat_pp_p;reflexivity).Defined.Once again we compute it on the identity.  In this case it seems to be unavoidable to do somesimpling (or at leastcbning), making this proof somewhat slower.Definitionid_center2_baut`{Univalence}X`{IsTrunc1X}:center2_bautX(exist(fun(f:forallx:X,x=x) =>forall(g:X<~>X) (x:X),apg(fx) =f(gx))(funx=>idpathx)(fun(g:X<~>X) (x:X) =>idpath(idpath(gx))))=funZ=>idpath(idpathZ).Proof.applypath_forall;introsZ.assert(IsHSet(idpathZ.1 =idpathZ.1))byexact_.baut_reduce.cbn.unfoldfunctor_forall,sig_rect,merely_rec_hset.cbn.rewriteequiv_path2_universe_1.rewrite!concat_p1, !concat_Vp.simpl.rewrite!concat_p1, !concat_Vp.reflexivity.Defined.EndCenter2BAut.SectionClassifyingMaps.Maps intoBAutFclassify bundles with fiberFThe property of being merely equivalent to a given typeFdefines a subuniverse.Definitionsubuniverse_merely_equiv(F:Type) :Subuniverse.Proof.rapply(Build_Subuniverse(funE=>merely(E<~>F))).introsTUmere_eqfiseq_f.strip_truncations.pose(feq:=Build_Equiv__fiseq_f).exact(tr(mere_eqoEfeq^-1)).Defined.The universe of O-local types forsubuniverse_merely_equivFis equivalent toBAutF.Propositionequiv_baut_typeO`{Univalence} {F:Type}:BAutF<~>Type_(subuniverse_merely_equivF).Proof.srapplyequiv_functor_sigma_id;introX;cbn.rapplyTrunc_functor_equiv.exact(equiv_path_universe__)^-1%equiv.Defined.Consequently, maps intoBAutFcorrespond to bundles with fibers merely equivalent toF.Corollaryequiv_map_baut_fibration`{Univalence} {Y:pType} {F:Type}: (Y->BAutF) <~> {p:SliceY&forally:Y,merely(hfiberp.2y<~>F) }.Proof.refine(_oEequiv_postcompose'equiv_baut_typeO).refine(_oEequiv_sigma_fibration_O).snrapplyequiv_functor_sigma_id;introp.rapplyequiv_functor_forall_id;introy.byapplyTrunc_functor_equiv.Defined.The pointed version ofequiv_baut_typeOabove.Propositionpequiv_pbaut_typeOp@{uv+} `{Univalence} {F:Type@{u}}:pBAut@{uv}F<~>* [Type_(subuniverse_merely_equivF), (F;trequiv_idmap)].Proof.snrapplyBuild_pEquiv';cbn.1:exactequiv_baut_typeO.byapplypath_sigma_hprop.Defined.Definitionequiv_pmap_pbaut_pfibration`{Univalence} {YF:pType@{u}}: (Y->*pBAut@{uv}F) <~> {p: {q:pSliceY&forally:Y,merely(hfiberq.2y<~>F) } &pfiberp.1.2 <~>*F}:= (equiv_sigma_pfibration_O(subuniverse_merely_equivF))oEpequiv_pequiv_postcomposepequiv_pbaut_typeOp.WhenYis connected, pointed maps intopBAutFcorrespond to maps into the universe sending the base point toF.Propositionequiv_pmap_pbaut_type_p`{Univalence}{Y:pType@{u}} {F:Type@{u}} `{IsConnected0Y}: (Y->*pBAutF) <~> (Y->* [Type@{u},F]).Proof.refine(_oEpequiv_pequiv_postcomposepequiv_pbaut_typeOp).rapplyequiv_pmap_typeO_type_connected.Defined.WhenYis connected,pBAutFclassifies fiber sequences overYwith fiberF.Definitionequiv_pmap_pbaut_pfibration_connected`{Univalence} {YF:pType} `{IsConnected0Y}: (Y->*pBAutF) <~> {X:pType&FiberSeqFXY}:=classify_fiberseqoEequiv_pmap_pbaut_type_p.EndClassifyingMaps.

--- Miscellaneous\Bifunctor.html ---
BifunctorLibrary BifunctorRequireImportBasics.OvertureBasics.Tactics.RequireImportTypes.ForallTypes.Prod.RequireImportWildCat.CoreWildCat.ProdWildCat.EquivWildCat.NatTransWildCat.SquareWildCat.Opposite.Bifunctors between WildCatsDefinitionWe choose to store redundant information in the class, so that depending on how an instance is constructed, we will get the expected implementations offmap10,fmap01andfmap11.ClassIs0Bifunctor{ABC:Type}`{IsGraphA,IsGraphB,IsGraphC} (F:A->B->C) := {is0functor_bifunctor_uncurried::Is0Functor(uncurryF);is0functor01_bifunctor::foralla,Is0Functor(Fa);is0functor10_bifunctor::forallb,Is0Functor(flipFb);}.ArgumentsIs0Bifunctor{ABC___}F.Argumentsis0functor_bifunctor_uncurried{ABC___}F{_}.Argumentsis0functor01_bifunctor{ABC___}F{_}a:rename.Argumentsis0functor10_bifunctor{ABC___}F{_}b:rename.We provide two alternate constructors, allowing the user to provide just the first field or the last two fields.DefinitionBuild_Is0Bifunctor'{ABC:Type}`{Is01CatA,Is01CatB,IsGraphC} (F:A->B->C)`{!Is0Functor(uncurryF)}:Is0BifunctorF.Proof.snrapplyBuild_Is0Bifunctor.-exact_.-exact(is0functor_functor_uncurried01(uncurryF)).-exact(is0functor_functor_uncurried10(uncurryF)).Defined.DefinitionBuild_Is0Bifunctor''{ABC:Type}`{IsGraphA,IsGraphB,Is01CatC} (F:A->B->C)`{!foralla,Is0Functor(Fa), !forallb,Is0Functor(flipFb)}:Is0BifunctorF.Proof.(* The first condition follows fromis0functor_prod_is0functor. *)nrapplyBuild_Is0Bifunctor;exact_.Defined.1-functorial actionfmapin the first argument.Definitionfmap10{ABC:Type} `{IsGraphA,IsGraphB,IsGraphC}(F:A->B->C) `{!Is0BifunctorF} {a0a1:A} (f:a0$->a1) (b:B): (Fa0b) $-> (Fa1b):=fmap(flipFb)f.fmapin the second argument.Definitionfmap01{ABC:Type} `{IsGraphA,IsGraphB,IsGraphC}(F:A->B->C) `{!Is0BifunctorF} (a:A) {b0b1:B} (g:b0$->b1):Fab0$->Fab1:=fmap(Fa)g.fmapin both arguments.Definitionfmap11{ABC:Type} `{IsGraphA,IsGraphB,IsGraphC}(F:A->B->C) `{!Is0BifunctorF} {a0a1:A} (f:a0$->a1){b0b1:B} (g:b0$->b1):Fa0b0$->Fa1b1:=fmap_pair(uncurryF)fg.As withIs0Bifunctor, we store redundant information.  In addition, we store the proofs that they are consistent with each other.ClassIs1Bifunctor{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC} (F:A->B->C) `{!Is0BifunctorF} := {is1functor_bifunctor_uncurried::Is1Functor(uncurryF);is1functor01_bifunctor::foralla,Is1Functor(Fa);is1functor10_bifunctor::forallb,Is1Functor(flipFb);fmap11_is_fmap01_fmap10{a0a1} (f:a0$->a1) {b0b1} (g:b0$->b1):fmap11Ffg$==fmap01Fa1g$ofmap10Ffb0;fmap11_is_fmap10_fmap01{a0a1} (f:a0$->a1) {b0b1} (g:b0$->b1):fmap11Ffg$==fmap10Ffb1$ofmap01Fa0g;}.ArgumentsIs1Bifunctor{ABC____________}F{Is0Bifunctor} :rename.ArgumentsBuild_Is1Bifunctor{ABC____________}F{_}_____.Argumentsis1functor_bifunctor_uncurried{ABC____________}F{__}.Argumentsis1functor01_bifunctor{ABC____________}F{__}a:rename.Argumentsis1functor10_bifunctor{ABC____________}F{__}b:rename.Argumentsfmap11_is_fmap01_fmap10{ABC____________}F{Is0BifunctorIs1Bifunctor} {a0a1}f{b0b1}g:rename.Argumentsfmap11_is_fmap10_fmap01{ABC____________}F{Is0BifunctorIs1Bifunctor} {a0a1}f{b0b1}g:rename.We again provide two alternate constructors.DefinitionBuild_Is1Bifunctor'{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC} (F:A->B->C)`{!Is0Functor(uncurryF), !Is1Functor(uncurryF)}:Is1Bifunctor(Is0Bifunctor:=Build_Is0Bifunctor'F)F.Proof.snrapplyBuild_Is1Bifunctor.-exact_.-exact(is1functor_functor_uncurried01(uncurryF)).-exact(is1functor_functor_uncurried10(uncurryF)).-introsa0a1fb0b1g.refine(_^$ $@fmap_pair_comp(uncurryF)f(Idb0) (Ida1)g).exact(fmap2_pair(uncurryF) (cat_idl_) (cat_idr_)).-introsa0a1fb0b1g.refine(_^$ $@fmap_pair_comp(uncurryF) (Ida0)gf(Idb1)).exact(fmap2_pair(uncurryF) (cat_idr_) (cat_idl_)).Defined.DefinitionBuild_Is1Bifunctor''{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC} (F:A->B->C)`{!foralla,Is0Functor(Fa), !forallb,Is0Functor(flipFb)}(Is0Bifunctor_F:=Build_Is0Bifunctor''F)`{!foralla,Is1Functor(Fa), !forallb,Is1Functor(flipFb)}(bifunctor_coh:foralla0a1(f:a0$->a1)b0b1(g:b0$->b1),fmap01Fa1g$ofmap10Ffb0$==fmap10Ffb1$ofmap01Fa0g):Is1BifunctorF.Proof.snrapplyBuild_Is1Bifunctor.-exact_.(*is1functor_prod_is1functor. *)-exact_.-exact_.-introsa0a1fb0b1g.exact(bifunctor_coha0a1fb0b1g)^$.-reflexivity.Defined.Bifunctor lemmasCoherenceDefinitionbifunctor_coh{ABC:Type}(F:A->B->C) `{Is1BifunctorABCF}{a0a1:A} (f:a0$->a1) {b0b1:B} (g:b0$->b1):fmap01Fa1g$ofmap10Ffb0$==fmap10Ffb1$ofmap01Fa0g:= (fmap11_is_fmap01_fmap10___)^$ $@fmap11_is_fmap10_fmap01___.2-functorial actionDefinitionfmap02{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}(a:A) {b0b1:B} {gg':b0$->b1} (q:g$==g'):fmap01Fag$==fmap01Fag':=fmap2(Fa)q.Definitionfmap12{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} (f:a0$->a1) {b0b1:B} {gg':b0$->b1} (q:g$==g'):fmap11Ffg$==fmap11Ffg':=fmap2_pair(uncurryF) (Id_)q.Definitionfmap20{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} {ff':a0$->a1} (p:f$==f') (b:B):fmap10Ffb$==fmap10Ff'b:=fmap2(flipFb)p.Definitionfmap21{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} {ff':a0$->a1} (p:f$==f') {b0b1:B} (g:b0$->b1):fmap11Ffg$==fmap11Ff'g:=fmap2_pair(uncurryF)p(Id_).Definitionfmap22{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} {ff':a0$->a1} (p:f$==f'){b0b1:B} {gg':b0$->b1} (q:g$==g'):fmap11Ffg$==fmap11Ff'g':=fmap2_pair(uncurryF)pq.Identity preservationDefinitionfmap01_id{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF} (a:A) (b:B):fmap01Fa(Idb) $==Id(Fab):=fmap_id(Fa)b.Definitionfmap10_id{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF} (a:A) (b:B):fmap10F(Ida)b$==Id(Fab):=fmap_id(flipFb)a.Definitionfmap11_id{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF} (a:A) (b:B):fmap11F(Ida) (Idb) $==Id(Fab):=fmap_id(uncurryF) (a,b).fmap11with left map the identity givesfmap01.Definitionfmap01_is_fmap11{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}(a:A) {b0b1:B} (g:b0$->b1):fmap11F(Ida)g$==fmap01Fag:=fmap11_is_fmap01_fmap10___$@ (_$@Lfmap10_id___) $@cat_idr_.fmap11with right map the identity givesfmap10.Definitionfmap10_is_fmap11{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} (f:a0$->a1) (b:B):fmap11Ff(Idb) $==fmap10Ffb:=fmap11_is_fmap01_fmap10___$@ (fmap01_id___$@R_) $@cat_idl_.Composition preservationDefinitionfmap01_comp{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}(a:A) {b0b1b2:B} (g:b1$->b2) (f:b0$->b1):fmap01Fa(g$of) $==fmap01Fag$ofmap01Faf:=fmap_comp(Fa)fg.Definitionfmap10_comp{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1a2:A} (g:a1$->a2) (f:a0$->a1) (b:B):fmap10F(g$of)b$==fmap10Fgb$ofmap10Ffb:=fmap_comp(flipFb)fg.Definitionfmap11_comp{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1a2:A} (g:a1$->a2) (f:a0$->a1){b0b1b2:B} (k:b1$->b2) (h:b0$->b1):fmap11F(g$of) (k$oh) $==fmap11Fgk$ofmap11Ffh:=fmap_pair_comp(uncurryF)____.Equivalence preservationGlobal Instanceiemap10{ABC:Type} `{HasEquivsA,Is1CatB,HasEquivsC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} (f:a0$<~>a1) (b:B):CatIsEquiv(fmap10Ffb):=iemap(flipFb)f.Global Instanceiemap01{ABC:Type} `{Is1CatA,HasEquivsB,HasEquivsC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}(a:A) {b0b1:B} (g:b0$<~>b1):CatIsEquiv(fmap01Fag):=iemap(Fa)g.Global Instanceiemap11{ABC:Type} `{HasEquivsA,HasEquivsB,HasEquivsC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} (f:a0$<~>a1) {b0b1:B} (g:b0$<~>b1):CatIsEquiv(fmap11Ffg):=iemap(uncurryF) (a:= (a0,b0)) (b:= (_,_)) (f,g).Definitionemap10{ABC:Type} `{HasEquivsA,Is1CatB,HasEquivsC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} (f:a0$<~>a1) (b:B):Fa0b$<~>Fa1b:=Build_CatEquiv(fmap10Ffb).Definitionemap01{ABC:Type} `{Is1CatA,HasEquivsB,HasEquivsC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}(a:A) {b0b1:B} (g:b0$<~>b1):Fab0$<~>Fab1:=Build_CatEquiv(fmap01Fag).Definitionemap11{ABC:Type} `{HasEquivsA,HasEquivsB,HasEquivsC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a0a1:A} (f:a0$<~>a1) {b0b1:B} (g:b0$<~>b1):Fa0b0$<~>Fa1b1:=Build_CatEquiv(fmap11Ffg).Flipping bifunctorsDefinitionis0bifunctor_flip{ABC:Type}(F:A->B->C) `{Is01CatA,Is01CatB,Is01CatC, !Is0BifunctorF}:Is0Bifunctor(flipF).Proof.snrapplyBuild_Is0Bifunctor.-change(Is0Functor(uncurryFoequiv_prod_symm__)).exact_.-exact_.-exact_.Defined.Hint Immediateis0bifunctor_flip:typeclass_instances.Definitionis1bifunctor_flip{ABC:Type}(F:A->B->C) `{H:Is1BifunctorABCF}:Is1Bifunctor(flipF).Proof.snrapplyBuild_Is1Bifunctor.-change(Is1Functor(uncurryFoequiv_prod_symm__)).exact_.-exact_.-exact_.-introsb0b1ga0a1f.exact(fmap11_is_fmap10_fmap01Ffg).-introsb0b1ga0a1f.exact(fmap11_is_fmap01_fmap10Ffg).Defined.Hint Immediateis1bifunctor_flip:typeclass_instances.Composition of bifunctorsThere are 4 different ways to compose a functor with a bifunctor.Restricting a functor along a bifunctor yields a bifunctor.Global Instanceis0bifunctor_postcompose{ABCD:Type}`{IsGraphA,IsGraphB,IsGraphC,IsGraphD}(F:A->B->C) {bf:Is0BifunctorF}(G:C->D) `{!Is0FunctorG}:Is0Bifunctor(funab=>G(Fab)) | 10:= {}.Global Instanceis1bifunctor_postcompose{ABCD:Type}`{Is1CatA,Is1CatB,Is1CatC,Is1CatD}(F:A->B->C) (G:C->D) `{!Is0FunctorG, !Is1FunctorG}`{!Is0BifunctorF} {bf:Is1BifunctorF}:Is1Bifunctor(funab=>G(Fab)) | 10.Proof.snrapplyBuild_Is1Bifunctor.1-3:exact_.-introsa0a1fb0b1g.exact(fmap2G(fmap11_is_fmap01_fmap10Ffg) $@fmap_compG__).-introsa0a1fb0b1g.exact(fmap2G(fmap11_is_fmap10_fmap01Ffg) $@fmap_compG__).Defined.Global Instanceis0bifunctor_precompose{ABCDE:Type}`{IsGraphA,IsGraphB,IsGraphC,IsGraphD,IsGraphE}(G:A->B) (K:E->C) (F:B->C->D)`{!Is0FunctorG, !Is0BifunctorF, !Is0FunctorK}:Is0Bifunctor(funab=>F(Ga) (Kb)) | 10.Proof.snrapplyBuild_Is0Bifunctor.-change(Is0Functor(uncurryFofunctor_prodGK)).exact_.-exact_.-introse.change(Is0Functor(flipF(Ke)oG)).exact_.Defined.Global Instanceis1bifunctor_precompose{ABCDE:Type}`{Is1CatA,Is1CatB,Is1CatC,Is1CatD,Is1CatE}(G:A->B) (K:E->C) (F:B->C->D)`{!Is0FunctorG, !Is1FunctorG, !Is0BifunctorF, !Is1BifunctorF,!Is0FunctorK, !Is1FunctorK}:Is1Bifunctor(funab=>F(Ga) (Kb)) | 10.Proof.snrapplyBuild_Is1Bifunctor.-change(Is1Functor(uncurryFofunctor_prodGK)).exact_.-exact_.-introse.change(Is1Functor(flipF(Ke)oG)).exact_.-introsa0a1fb0b1g.exact(fmap11_is_fmap01_fmap10F(fmapGf) (fmapKg)).-introsa0a1fb0b1g.exact(fmap11_is_fmap10_fmap01F(fmapGf) (fmapKg)).Defined.Global Instanceis0functor_uncurry_uncurry_left{ABCDE}(F:A->B->C) (G:C->D->E)`{IsGraphA,IsGraphB,IsGraphC,IsGraphD,IsGraphE,!Is0BifunctorF, !Is0BifunctorG}:Is0Functor(uncurry(uncurry(funxyz=>G(Fxy)z))).Proof.exact_.Defined.Global Instanceis1functor_uncurry_uncurry_left{ABCDE}(F:A->B->C) (G:C->D->E)`{Is1CatA,Is1CatB,Is1CatC,Is1CatD,Is1CatE,!Is0BifunctorF, !Is1BifunctorF, !Is0BifunctorG, !Is1BifunctorG}:Is1Functor(uncurry(uncurry(funxyz=>G(Fxy)z))).Proof.exact_.Defined.Global Instanceis0functor_uncurry_uncurry_right{ABCDE}(F:A->B->D) (G:C->D->E)`{IsGraphA,IsGraphB,IsGraphC,IsGraphD,IsGraphE,!Is0BifunctorF, !Is0BifunctorG}:Is0Functor(uncurry(uncurry(funxyz=>Gx(Fyz)))).Proof.snrapplyBuild_Is0Functor.introscabcab'[[hf]g].exact(fmap11Gh(fmap11Ffg)).Defined.Global Instanceis1functor_uncurry_uncurry_right{ABCDE}(F:A->B->D) (G:C->D->E)`{Is1CatA,Is1CatB,Is1CatC,Is1CatD,Is1CatE,!Is0BifunctorF, !Is1BifunctorF, !Is0BifunctorG, !Is1BifunctorG}:Is1Functor(uncurry(uncurry(funxyz=>Gx(Fyz)))).Proof.snrapplyBuild_Is1Functor.-introscabcab'[[hf]g] [[h'f']g'] [[qp]r].exact(fmap22Gq(fmap22Fpr)).-introscab.exact(fmap12G_(fmap11_idF__) $@fmap11_idG__).-introscabcab'cab''[[hf]g] [[h'f']g'].exact(fmap12G_(fmap11_compF____) $@fmap11_compG____).Defined.Definitionfmap11_square{ABC:Type} `{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}{a00a20a02a22:A} {f10:a00$->a20} {f12:a02$->a22}{f01:a00$->a02} {f21:a20$->a22}{b00b20b02b22:B} {g10:b00$->b20} {g12:b02$->b22}{g01:b00$->b02} {g21:b20$->b22}(p:Squaref01f21f10f12) (q:Squareg01g21g10g12):Square(fmap11Ff01g01) (fmap11Ff21g21) (fmap11Ff10g10) (fmap11Ff12g12):= (fmap11_compF____)^$ $@fmap22Fpq$@fmap11_compF____.Natural transformations between bifunctorsWe can show that an uncurried natural transformation between uncurried bifunctors by composing the naturality square in each variable.Global Instanceis1natural_uncurry{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC}(F:A->B->C) `{!Is0BifunctorF, !Is1BifunctorF}(G:A->B->C) `{!Is0BifunctorG, !Is1BifunctorG}(alpha:uncurryF$=>uncurryG)(nat_l:forallb,Is1Natural(flipFb) (flipGb) (funx:A=>alpha(x,b)))(nat_r:foralla,Is1Natural(Fa) (Ga) (funy:B=>alpha(a,y))):Is1Natural(uncurryF) (uncurryG)alpha.Proof.snrapplyBuild_Is1Natural.intros[ab] [a'b'] [ff'];cbnin*.change(?w$o?x$== ?y$o?z)with(Squarezwxy).nrapplyvconcatL.1:rapply(fmap11_is_fmap01_fmap10F).nrapplyvconcatR.2:rapply(fmap11_is_fmap01_fmap10G).exact(hconcat(nat_l___f) (nat_r___f')).Defined.Flipping a natural transformation between bifunctors.Definitionnattrans_flip{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC}{F:A->B->C} `{!Is0BifunctorF, !Is1BifunctorF}{G:A->B->C} `{!Is0BifunctorG, !Is1BifunctorG}:NatTrans(uncurryF) (uncurryG)->NatTrans(uncurry(flipF)) (uncurry(flipG)).Proof.introsalpha.snrapplyBuild_NatTrans.-exact(alphaoequiv_prod_symm__).-snrapplyBuild_Is1Natural'.+intros[ba] [b'a'] [gf].exact(isnat(a:=(a,b)) (a':=(a',b'))alpha(f,g)).+intros[ba] [b'a'] [gf].exact(isnat_tr(a:=(a,b)) (a':=(a',b'))alpha(f,g)).Defined.Opposite BifunctorsThere are a few more combinations we can do for this, such as profunctors, but we will leave those for later.Global Instanceis0bifunctor_opABC(F:A->B->C) `{Is0BifunctorABCF}:Is0Bifunctor(F:A^op->B^op->C^op).Proof.snrapplyBuild_Is0Bifunctor.-exact(is0functor_op__(uncurryF)).-introsa.nrapplyis0functor_op.exact(is0functor01_bifunctorFa).-introsb.nrapplyis0functor_op.exact(is0functor10_bifunctorFb).Defined.Global Instanceis1bifunctor_opABC(F:A->B->C) `{Is1BifunctorABCF}:Is1Bifunctor(F:A^op->B^op->C^op).Proof.snrapplyBuild_Is1Bifunctor.-exact(is1functor_op__(uncurryF)).-introsa.nrapplyis1functor_op.exact(is1functor01_bifunctorFa).-introsb.nrapplyis1functor_op.exact(is1functor10_bifunctorFb).-introsa0a1fb0b1g;cbninf,g.exact(fmap11_is_fmap10_fmap01Ffg).-introsa0a1fb0b1g;cbninf,g.exact(fmap11_is_fmap01_fmap10Ffg).Defined.Global Instanceis0bifunctor_op'ABC(F:A^op->B^op->C^op)`{IsGraphA,IsGraphB,IsGraphC,Fop: !Is0Bifunctor(F:A^op->B^op->C^op)}:Is0Bifunctor(F:A->B->C):=is0bifunctor_opA^opB^opC^opF.Global Instanceis1bifunctor_op'ABC(F:A^op->B^op->C^op)`{Is1CatA,Is1CatB,Is1CatC,!Is0Bifunctor(F:A^op->B^op->C^op), !Is1Bifunctor(F:A^op->B^op->C^op)}:Is1Bifunctor(F:A->B->C):=is1bifunctor_opA^opB^opC^opF.

--- Miscellaneous\BiInv.html ---
BiInvLibrary BiInvRequireImportBasicsTypes.ProdTypes.Equiv.Local OpenScopepath_scope.Generalizable VariablesABf.Bi-invertible mapsA map is "bi-invertible" if it has both a section and a retraction, not necessarily the same.  This definition of equivalence was proposed by Andre Joyal.DefinitionBiInv`(f:A->B) :Type:= {g:B->A&gof==idmap} * {h:B->A&foh==idmap}.It seems that the easiest way to show that bi-invertibility is equivalent to being an equivalence is also to show that both are h-props and that they are logically equivalent.Definitionisequiv_biinv`(f:A->B):BiInvf->IsEquivf.Proof.intros[[gs] [hr]].exact(isequiv_adjointifyfg(funx=>apf(apg(rx)^ @s(hx)) @rx)s).Defined.Definitionbiinv_isequiv`(f:A->B):IsEquivf->BiInvf.Proof.intros[gsradj].exact((g;r), (g;s)).Defined.Definitioniff_biinv_isequiv`(f:A->B):BiInvf<->IsEquivf.Proof.split.-applyisequiv_biinv.-applybiinv_isequiv.Defined.Global Instanceishprop_biinv`{Funext} `(f:A->B) :IsHProp(BiInvf) | 0.Proof.applyhprop_inhabited_contr.introsbif;pose(fe:=isequiv_biinvfbif).apply@contr_prod.(* For this, we've done all the work already. *)-byapplycontr_retr_equiv.-byapplycontr_sect_equiv.Defined.Definitionequiv_biinv_isequiv`{Funext} `(f:A->B):BiInvf<~>IsEquivf.Proof.applyequiv_iff_hprop_uncurried,iff_biinv_isequiv.Defined.

--- Miscellaneous\binary_naturals.html ---
binary_naturalsLibrary binary_naturalsRequireImportHoTT.Spaces.Nat.Core.RequireImportHoTT.Tactics.RequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.naturalsHoTT.Classes.interfaces.ordersHoTT.Classes.implementations.peano_naturalsHoTT.Classes.theory.ringsHoTT.Classes.orders.semiringsHoTT.Classes.theory.apartness.Sectionbasics.(* This definition of binary naturals is due to Martín Escardó andCory Knapp *)Inductivebinnat:Type0:=|bzero:binnat(* zero *)|double1:binnat->binnat(* 2n+1 *)|double2:binnat->binnat.(* 2n+2 *)FixpointSucc(n:binnat) :binnat:=matchnwith|bzero=>double1bzero|double1n'=>double2n'|double2n'=>double1(Succn')end.Fixpointdouble(n:binnat) :binnat:=matchnwith|bzero=>bzero|double1n'=>double2(doublen')|double2n'=>double2(Succ(doublen'))end.FixpointDouble(n:nat) :nat:=matchnwith|O=>O|Sn'=>S(S(Doublen'))end.DefinitionDouble1(n:nat) :nat:=S(Doublen).DefinitionDouble2(n:nat) :nat:=S(S(Doublen)).Fixpointbinary(n:nat) :binnat:=matchnwith|O=>bzero|Sn'=>Succ(binaryn')end.Endbasics.Sectionbinary_equiv.Local Fixpointunary'(n:binnat) :nat:=matchnwith|bzero=>O|double1n'=>Double1(unary'n')|double2n'=>Double2(unary'n')end.Local Definitionsuccunary(n:binnat) :unary'(Succn) =S(unary'n).Proof.inductionn.-reflexivity.-reflexivity.-simpl.rewriteIHn.reflexivity.Qed.Local Definitionunarybinary:unary'obinary==idmap.Proof.introsn;inductionnas[|nIHn].-reflexivity.-simpl.rewritesuccunary.applyap.exactIHn.Qed.Definitiondouble1binary(n:nat) :binary(Double1n) =double1(binaryn).Proof.inductionn.-reflexivity.-change(binary(Double1n.+1))with(Succ(Succ(binary(Doublen).+1))).rewriteIHn.reflexivity.Qed.Definitiondouble2binary(n:nat) :binary(Double2n) =double2(binaryn).Proof.inductionn.-reflexivity.-change(binary(Double2n.+1))with(Succ(Succ(binary(Doublen).+2))).rewriteIHn.reflexivity.Qed.Local Definitionbinaryunary:binaryounary'==idmap.Proof.introsn;inductionn.-reflexivity.-rewritedouble1binary.applyap.exactIHn.-rewritedouble2binary.applyap.exactIHn.Qed.Global Instanceisequiv_binary:IsEquivbinary:=isequiv_adjointifybinaryunary'binaryunaryunarybinary.Definitionequiv_binary:nat<~>binnat:=Build_Equiv__binaryisequiv_binary.Endbinary_equiv.Notationequiv_unary:=equiv_binary^-1.Notationunary:=equiv_unary.Sectionsemiring_struct.Global Instancebinnat_0:Zerobinnat:=bzero.Global Instancebinnat_1:Onebinnat:=double1bzero.Local Fixpointbinnat_plus'(mn:binnat) :binnat:=matchm,nwith|bzero,n'=>n'|double1m',bzero=>double1m'(* compute m + n as 2m'+1 + 2n'+1 = 2(m'+n') + 2 *)|double1m',double1n'=>double2(binnat_plus'm'n')(* compute m + n as 2m'+1 + 2n'+2 = 2(m'+n')+2 + 1 = 2(m' + n' + 1) + 1 *)|double1m',double2n'=>double1(Succ(binnat_plus'm'n'))|double2m',bzero=>double2m'(* compute m + n as 2m'+2 + 2n'+1 = 2(m'+n')+2 + 1 = 2(m' + n' + 1) + 1 *)|double2m',double1n'=>double1(Succ(binnat_plus'm'n'))(* compute m + n as 2m'+2 + 2n'+2 = 2(m'+n')+2 + 2 = 2(m' + n' + 1) + 2*)|double2m',double2n'=>double2(Succ(binnat_plus'm'n'))end.Global Instancebinnat_plus:Plusbinnat:=binnat_plus'.Local Fixpointbinnat_mult'(mn:binnat) :binnat:=matchmwith|bzero=>bzero(* compute (2m'+1)*n as 2m'n+n *)|double1m'=> (binnat_mult'm'n) + (binnat_mult'm'n) +n|double2m'=> (binnat_mult'm'n) + (binnat_mult'm'n) +n+nend.Global Instancebinnat_mult:Multbinnat:=binnat_mult'.Endsemiring_struct.Sectionsemiring_laws.Definitionbinarysucc(n:nat) :binaryn.+1 =Succ(binaryn).Proof.reflexivity.Qed.Definitionunarysucc:forallm,unary(Succm) =S(unarym).Proof.equiv_introsbinaryn.rewrite<-binarysucc.rewriteeissect,eissect.reflexivity.Qed.Definitionbinnatplussucc:forall(mn:binnat), (Succm) +n=Succ(m+n).Proof.inductionm;inductionn;tryreflexivity;simpl;rewrite<-IHm;done.Qed.Definitionbinaryplus(mn:nat) :binarym+binaryn=binary(m+n).Proof.inductionm;inductionn;tryreflexivity.-simpl.rewritebinnatplussucc.applyap.done.-simpl.rewrite<-IHm.rewritebinnatplussucc.done.Qed.Definitionunaryplus(mn:binnat) :unarym+unaryn=unary(m+n).Proof.etransitivity(unary(binary(_^-1m+_^-1n))).-apply((eissectbinary(unarym+unaryn)) ^).-rewrite<-binaryplus.rewrite(eisretrbinarym), (eisretrbinaryn).reflexivity.Qed.Local Instancebinnat_add_assoc:Associativebinnat_plus.Proof.hnf;equiv_introsbinaryxyz.changebinnat_pluswithplus.rewritebinaryplus,binaryplus,binaryplus,binaryplus.applyap.applyassociativity.Qed.Local Instancebinnat_add_comm:Commutativebinnat_plus.Proof.hnf;equiv_introsbinaryxy.changebinnat_pluswithplus.rewritebinaryplus,binaryplus.applyap.applyplus_comm.Qed.Definitionbinnatmultsucc:forall(mn:binnat), (Succm) *n=n+ (m*n).Proof.inductionm.-introsn.change(bzero+n=n+bzero).applycommutativity.-introsn.simpl.change(double2m*n)with((m*n) + (m*n) +n+n).applycommutativity.-introsn.simpl.change(double1(Succm) *n)with((Succm) *n+ (Succm) *n+n).rewriteIHm.rewrite(commutativityn(double2m*n)).rewrite(commutativityn(m*n)).rewrite<- (associativity(m*n)n(m*n+n)).rewrite(commutativityn(m*n+n)).rewrite(associativity(m*n)__).rewrite(associativity(m*n) (m*n)n).done.Qed.Definitionbinarymult(mn:nat) :binarym*binaryn=binary(m*n).Proof.inductionm;inductionn;tryreflexivity;rewritebinnatmultsucc,IHm,binaryplus;done.Qed.Definitionunarymult(mn:binnat) :unarym*unaryn=unary(m*n).Proof.etransitivity(unary(binary(_^-1m*_^-1n))).-apply((eissectbinary(unarym*unaryn)) ^).-rewrite<-binarymult.rewrite(eisretrbinarym), (eisretrbinaryn).reflexivity.Qed.Local Instancebinnat_mult_assoc:Associativebinnat_mult.Proof.hnf;equiv_introsbinaryxyz.changebinnat_multwithmult.rewritebinarymult,binarymult,binarymult,binarymult.applyap.applyassociativity.Qed.Local Instancebinnat_mult_comm:Commutativebinnat_mult.Proof.hnf;equiv_introsbinaryxy.changebinnat_multwithmult.rewritebinarymult,binarymult.applyap.applycommutativity.Qed.Local Instancebinnat_distr_l:LeftDistributebinnat_multbinnat_plus.Proof.hnf;equiv_introsbinaryxyz.changebinnat_pluswithplus.changebinnat_multwithmult.rewritebinaryplus,binarymult,binarymult,binarymult,binaryplus.applyap.applyplus_mult_distr_l.Qed.Local Instancebinnat_distr_r:RightDistributebinnat_multbinnat_plus.Proof.hnf;equiv_introsbinaryxyz.changebinnat_pluswithplus.changebinnat_multwithmult.rewritebinaryplus,binarymult,binarymult,binarymult,binaryplus.applyap.applyplus_mult_distr_r.Qed.Global Instancebinnat_set:IsHSetbinnat.Proof.apply(istrunc_isequiv_istruncnatbinary).Qed.Global Instancebinnat_semiring:IsSemiCRingbinnat.Proof.split;trysplit;trysplit;trysplit;hnf;intros.1, 5:applyistrunc_S;introsxy;exact(binnat_setxy).all:apply(equiv_injunary).1, 2, 3, 7:repeatrewrite<-unaryplus.4, 5, 6, 7:rewrite<-unarymult.4, 5, 7:rewrite<-unarymult.4, 5:rewrite<-unarymult.4:rewrite<-unaryplus.5:rewrite<-unarymult.all:applynat_semiring.Qed.Endsemiring_laws.Sectionnaturals.Local Instancebinary_preserving:IsSemiRingPreservingbinary.Proof.split;split.1, 3:hnf;introsxy; [>apply(binaryplusxy) ^ |apply(binarymultxy) ^ ].all:reflexivity.Qed.Global Instancebinnat_le:Lebinnat:=funmn=>unarym<=unaryn.Global Instancebinnat_lt:Ltbinnat:=funmn=>unarym<unaryn.Global Instancebinnat_apart:Apartbinnat:=funmn=>unarym≶unaryn.Local Instancebinnart_apart_symmetric:IsApartbinnat.Proof.split.-apply_.-introsxy.applynat_full.-introsxy.applynat_full.-introsxyzw.applynat_full.assumption.-introsmn.split.+introsE.apply(equiv_injunary).applynat_full.assumption.+introsp.applynat_full.exact(apunaryp).Qed.Local Instancebinnat_full:FullPseudoSemiRingOrderbinnat_lebinnat_lt.Proof.split.-introsmn;applynat_le_hprop.-split;tryintrosmn;tryapplynat_full.+split;tryintrosmn;tryapplynat_full.*split;tryintrosmn;tryapplynat_full.--apply_.--applycotransitive.--split;introsE.++assert(X:unarym=unaryn)bybyapplytight_apart.apply(((equiv_apunarymn) ^-1)X).++rewriteE.applynat_full.reflexivity.*introsEk.applynat_full.exactE.+introsE.assert(H:existsw, (unaryn) = (unarym) +w)bybyapplynat_full.destructHas[wL].exists(binaryw).rewrite<- (eisretrunaryw),unaryplusinL.apply(equiv_injunary).exactL.+introsm.split;introsklE;unfoldlt,binnat_ltin*.*rewrite<-unaryplus, <-unaryplus.applynat_full.exactE.*rewrite<-unaryplus, <-unaryplusinE.apply(strictly_order_reflecting(plus(unarym))).exactE.+introsklE.applynat_full.unfoldapart,binnat_apartinE.rewrite<- (unarymultmn), <- (unarymultkl)inE.exactE.+introsEF.unfoldlt,binnat_lt.rewrite<- (unarymultmn).applynat_full;assumption.-introsmn.applynat_full.Qed.Global Instancebinnat_naturals_to_semiring:NaturalsToSemiRingbinnat:=fun______=>fixf(n:binnat) :=matchnwith|bzero=> 0|double1n'=> 2 * (fn') + 1|double2n'=> 2 * (fn') + 2end.Definitionnat_to_semiring_helper:NaturalsToSemiRingnat:=fun______=>fixf(n:nat) :=matchnwith| 0%nat=> 0|Sn'=> 1 +fn'end.Sectionfor_another_semiring.UniverseU.Context{R:Type} `{IsSemiCRingR}.NotationtoR:= (naturals_to_semiringbinnatR).NotationtoR_fromnat:= (naturals_to_semiringnatR).NotationtoR_vianat:= (toR_fromnat∘unary).Definitionf_suc(m:binnat) :toR(Succm) = (toRm)+1.Proof.inductionm.-change(2 * 0 + 1 = 0 + 1).rewritemult_comm.rewritemult_0_l.done.-change(2 * (toRm) + 2 = 2 * (toRm) + 1 + 1).applyplus_assoc.-inductionmas[|m_|m_].+change(2 * (2 * 0 + 1) + 1 = 2 * 0 + 2 + 1).rewriteplus_mult_distr_l.rewrite(@mult_1_r_AplusAmultAzeroAoneH_).rewritemult_0_r,mult_0_r.reflexivity.+change(2 * (2 * (toRm) + 2) + 1 = 2 * (2 * (toRm) + 1 ) + 2 + 1).apply(ap(funz=>z+ 1)).assert(L: 2 *toRm+ 2 = 2 *toRm+ 1 + 1)bybyrewriteplus_assoc.rewriteL;clearL.rewriteplus_mult_distr_l.rewritemult_1_r.reflexivity.+simplinIHm.change((2 * (toR(double1(Succm))) + 1 = 2 * (toR(double2m)) + 2 + 1)).rewriteIHm;clearIHm.rewriteplus_mult_distr_l.rewritemult_1_r.reflexivity.Qed.Definitionf_nat:forallm:binnat,toRm=toR_vianatm.Proof.equiv_introbinaryn.inductionnas[|nIHn].-reflexivity.-inductionnas[|n_].+change((1 + 1) * 0 + 1 = 1).rewritemult_0_r.applyplus_0_l.+rewritef_suc.rewriteIHn.assert(L: (toR_fromnat∘binary^-1) (binaryn.+1) + 1=toR_fromnat((binary^-1 (binaryn.+1)).+1)%nat).{simplrewrite(plus_comm_1).simplrewriteunarysucc.reflexivity.}rewriteL;clearL.rewrite<-unarysucc.rewrite<-binarysucc.reflexivity.Qed.Local Definitionf_preserves_plus(aa':binnat) :toR(a+a') =toRa+toRa'.Proof.rewritef_nat,f_nat,f_nat.unfoldCompose.rewrite<- (unaryplusaa').applynat_to_sr_morphism.Qed.Local Definitionf_preserves_mult(aa':binnat) :toR(a*a') =toRa*toRa'.Proof.rewritef_nat,f_nat,f_nat.unfoldCompose.rewrite<- (unarymultaa').applynat_to_sr_morphism.Qed.Global Instancebinnat_to_sr_morphism:IsSemiRingPreservingtoR.Proof.split;split.-rapplyf_preserves_plus.-reflexivity.-rapplyf_preserves_mult.-unfoldIsUnitPreserving.applyf_nat.Defined.Lemmabinnat_toR_unique(h:binnat->R) `{!IsSemiRingPreservingh} :forallx,toRx=hx.Proof.equiv_introbinaryn.rewritef_nat;unfoldCompose.rewriteeissect.refine(toR_unique(h∘binary)n).Qed.Endfor_another_semiring.Global Instancebinnat_naturals:Naturalsbinnat.Proof.split.-exactbinnat_semiring.-exactbinnat_full.-intros.applybinnat_to_sr_morphism.-intros.applybinnat_toR_unique.assumption.Qed.Endnaturals.Sectiondecidable.Local Definitionineq_bzero_double1n:bzero<>double1n.Proof.introsp.change((funx=>matchxwith|double1y=>Unit|_=>Emptyend)bzero).rapply(@transportbinnat).-exactp^.-exacttt.Qed.Local Definitionineq_bzero_double2n:bzero<>double2n.Proof.introsp.change((funx=>matchxwith|double2y=>Unit|_=>Emptyend)bzero).rapply(@transportbinnat).-exactp^.-exacttt.Qed.Local Definitionineq_double1_double2mn:double1m<>double2n.Proof.introsp.change((funx=>matchxwith|double2y=>Unit|_=>Emptyend) (double1m)).rapply(@transportbinnat).-exactp^.-exacttt.Qed.Local Definitionundouble(m:binnat) :binnat:=matchmwith|bzero=>bzero|double1k=>k|double2k=>kend.Local Instancedouble1_inj:IsInjectivedouble1:= {injective:=funabE=>apundoubleE}.Local Instancedouble2_inj:IsInjectivedouble2:= {injective:=funabE=>apundoubleE}.Global Instancebinnat_dec:DecidablePathsbinnat.Proof.introsm;inductionmas[|mIHm|mIHm];introsn;inductionnas[|nIHn|nIHn].all:first[left;reflexivity|right; (idtac+applysymmetric_neq);first[applyineq_bzero_double1|applyineq_bzero_double2|applyineq_double1_double2]|destruct(IHmn)as[eq|ineq];[left;applyap;exacteq|right;introsE;first[apply(injectivedouble1)inE|apply(injectivedouble2)inE];auto]].Defined.Enddecidable.Sectionother_laws.Instancebinnat_plus_cancel_l(z:binnat) :LeftCancellationplusz.Proof.introsxyp.apply(equiv_injunary).apply(apunary)inp.rewrite<-unaryplus, <-unaryplusinp.exact(left_cancellation____p).Qed.Instancebinnat_mult_cancel_l(z:binnat):PropHolds(z<> 0) ->LeftCancellation(.*.)z.Proof.introsE.hnfinE.assert(H:unaryz<>unary0).{introsq.apply(equiv_injunary)inq.exact(Eq).}introsxyp.apply(apunary)inp.rewrite<-unarymult, <-unarymultinp.exact(equiv_injunary(nat_mult_cancel_l(unaryz)H__p)).Qed.Local Instancebinnat_le_total:TotalRelation(_:Lebinnat).Proof.introsxy.applynat_le_total.Qed.Local Instancebinnat_lt_irrefl:Irreflexive(_:Ltbinnat).Proof.introsx.applynat_lt_irrefl.Qed.Endother_laws.Sectiontrichotomy.(* TODO this is an inefficient implementation. Instead, write thiswithout going via the unary naturals. *)Instancebinnat_trichotomy:Trichotomy(lt:Ltbinnat).Proof.introsxy.pose(T:=nat_trichotomy(unaryx) (unaryy)).destructTas[l|[c|r]].-left;assumption.-right;left.apply(equiv_injunary);assumption.-right;right;assumption.Defined.Endtrichotomy.Sectionminus.Local DefinitionPred(m:binnat) :binnat:=matchmwith|bzero=>bzero|double1m'=>doublem'|double2m'=>double1m'end.Local Definitionsucc_double(m:binnat) :Succ(doublem) =double1m.Proof.inductionm.-reflexivity.-change(double1(Succ(doublem)) =double1(double1m)).rewriteIHm;reflexivity.-change(double1(Succ(Succ(doublem))) =double1(double2m)).rewriteIHm;reflexivity.Qed.Local Definitiondouble_succ(m:binnat) :double(Succm) =double2m.Proof.inductionm.-reflexivity.-change(double2(Succ(doublem)) =double2(double1m)).rewritesucc_double;reflexivity.-change(double2(double(Succm)) =double2(double2m)).rewriteIHm;reflexivity.Qed.Local Definitionpred_succ(m:binnat) :Pred(Succm) =m.Proof.inductionm;tryreflexivity.-exact(double_succm).Qed.Local Definitiondouble_pred(m:binnat) :double(Predm) =Pred(Pred(doublem)).Proof.inductionm;tryreflexivity.-exact(double_succ(doublem))^.Qed.Local Definitionpred_double2(m:binnat) :Pred(double2m) =double1m.Proof.inductionm;reflexivity.Qed.Local Definitionpred_double1(m:binnat) :Pred(double1m) =doublem.Proof.inductionm;reflexivity.Qed.(*     2*(m-1)+1 = 2*m - 1 *)Local Fixpointbinnat_cut_minus'(mn:binnat) :binnat:=matchm,nwith|bzero,n'=>bzero|m',bzero=>m'(* compute m - n as 2m'+1 - 2n'+1 = 2(m'-n') *)|double1m',double1n'=>double(binnat_cut_minus'm'n')(* compute m - n as 2m'+1 - 2n'+2 = 2(m'-n') - 1 = Pred (double (m' - n')) *)|double1m',double2n'=>Pred(double(binnat_cut_minus'm'n'))(* compute m - n as 2m'+2 - 2n'+1 *)|double2m',double1n'=>Pred(double(binnat_cut_minus'(Succm')n'))(* compute m - n as 2m'+2 - 2n'+2 = 2(m'-n') = double (m' - n') *)|double2m',double2n'=>double(binnat_cut_minus'm'n')end.Global Instancebinnat_cut_minus:CutMinusbinnat:=binnat_cut_minus'.Local Definitionbinnat_minus_zero(m:binnat) :m∸bzero=m.Proof.inductionm;reflexivity.Qed.Local Definitionbinnat_zero_minus(m:binnat) :bzero∸m=bzero.Proof.inductionm;reflexivity.Qed.Local Definitionpred_succ_minus(mn:binnat) :Pred(Succm∸n) =m∸n.Proof.revertn;inductionm;introsn;inductionn;tryreflexivity.-change(Pred(double(bzero∸n)) =bzero).rewritebinnat_zero_minus;reflexivity.-change(Pred(Pred(double(bzero∸n))) =bzero∸double2n).rewritebinnat_zero_minus,binnat_zero_minus;reflexivity.-change(Pred(Pred(double(Succm∸n))) =double(m∸n)).rewrite<-double_pred.applyap.exact(IHmn).-change(double(Succm) =double2m∸bzero).rewritebinnat_minus_zero.exact(double_succm).-change(Pred(Pred(double(Succm∸n))) =double(m∸n)).rewrite<-double_pred.applyap.exact(IHmn).Qed.Local Definitiondouble_cases(m:binnat) : (bzero=doublem) +hfiberdouble2(doublem).Proof.inductionm.-left;reflexivity.-right;exists(doublem);reflexivity.-right;exists(Succ(doublem));reflexivity.Defined.Local Definitionbinnat_minus_succ(mn:binnat) :Succm∸Succn=m∸n.Proof.revertn;inductionm;introsn;inductionn;tryreflexivity.-change(Pred(double(bzero∸n)) =bzero∸double1n).rewritebinnat_zero_minus,binnat_zero_minus.reflexivity.-change(double(bzero∸ (Succn)) =bzero∸double2n).rewritebinnat_zero_minus,binnat_zero_minus.reflexivity.-change(Pred(double(Succm∸bzero)) =double1m∸bzero).rewritebinnat_minus_zero,binnat_minus_zero.rewritedouble_succ,pred_double2.reflexivity.-change(Pred(double(Succm∸Succn)) =Pred(double(m∸n))).rewriteIHm.reflexivity.-change(double(Succm∸bzero) =double2m∸bzero).rewritebinnat_minus_zero,binnat_minus_zero,double_succ.reflexivity.-change(double(Succm∸Succn) =double(m∸n)).rewriteIHm.reflexivity.Qed.Local Definitionbinaryminus(xy:nat) :binaryx∸binaryy=binary(x∸y).Proof.reverty;inductionx;introsy;inductiony;tryreflexivity.-applybinnat_zero_minus.-applybinnat_minus_zero.-simplin*.rewritebinnat_minus_succ.rewriteIHx.reflexivity.Qed.Local Definitionunaryminus(mn:binnat) :unarym∸unaryn=unary(m∸n).Proof.etransitivity(unary(binary(_^-1m∸_^-1n))).-apply((eissectbinary(unarym∸unaryn)) ^).-rewrite<-binaryminus.rewrite(eisretrbinarym), (eisretrbinaryn).reflexivity.Qed.Global Instancebinnat_cut_minus_spec:CutMinusSpecbinnatbinnat_cut_minus.Proof.split.-introsmnE.apply(equiv_injunary).rewrite<-unaryplus, <-unaryminus.applynat_cut_minus_spec.assumption.-introsmnE.apply(equiv_injunary).rewrite<-unaryminus.applynat_cut_minus_spec.assumption.Qed.Endminus.

--- Miscellaneous\BinderApply.html ---
BinderApplyLibrary BinderApplyApply a lemma under bindersRequireImportBasics.OvertureTactics.EvalIn.There are some cases whereapplylemwill fail, butintros;applylemwill succeed.  The tacticbinderapplyis likeintros;applylem, but it cleans up after itself byreverting the things it introduced.  The tacticbinderapplyleminHis tobinderapplylem, asapplyleminHis toapplylem.  Note, however, that the implementation ofbinderapplyleminHis completely different and significantly more complicated.Ltaccan_binder_applyapply_tacfail1_tac:=first[assert_succeedsapply_tac|assert_succeeds(intro;can_binder_applyapply_tacfail1_tac)|fail1_tac].Ltacbinder_applyapply_tacfail1_tac:=can_binder_applyapply_tacfail1_tac;first[apply_tac|letH:=freshinintroH;binder_applyapply_tacfail1_tac;revertH|fail1 "Cannot re-revert some introduced hypothesis" ].The tacticeval_under_binderstacHis equivalent totacHifHis not a product (lambda-abstraction), and roughly equivalent to the constrfunx=>eval_under_binderstac(Hx)ifHis a product.Ltaceval_under_binderstacH:=Bind a convenient name for the recursive callletrec_tac:=eval_under_binderstacinIf the hypothesis is a product (forall), we want to recurse under binders; if not, we're in the base case, and we simply compute the new term.  We usematchrather thanlazymatchso that if the tactic fails to apply under all of the binders, we try again under fewer binders.  We want to try first under as many binders as possible, in case the tactic, e.g., instantiates extra binders with evars.matchtypeofHwithStandard pattern for recursing under binders.  We zeta-expand to work around https://coq.inria.fr/bugs/show_bug.cgi?id=3248 and https://coq.inria.fr/bugs/show_bug.cgi?id=3458; we'd otherwise need globally unique name forx.  We zeta-reduce afterwards so the user doesn't see our zeta-expansion.  We usexin both the pattern and the returned constructor so that we preserve the given name for the binder.|forallx: ?T, @?Px=>letret:=constr:(funx:T=>letHx:=Hxinltac:(letret':=rec_tacHxinexactret'))inletret':= (evalcbvzetainret)inconstr:(ret')Base case - simply returntacH|_=>tacHend.The tacticmake_tac_under_binders_using_intacusing_tacHusestacto transform a termH, solving side-conditions (e.g., iftacusesapply) withusing_tac.  It returns the updated version ofHas a constr; ifHis a hypothesis in the context, it does not modify it.  Conceptually,make_tac_under_binders_using_intacidtacHis the composition of two tactics: atransform_under_binders:(constr->constr)->(constr->constr)that runs a tactic under the binders of the constr it's given, and what would be anevaltacinH, except for the fact that, e.g.,evalrewriteinHdoesn't actually work because it predates tactics in terms (we useeval_in_usingtacusing_tacHinstead).The arguments are:tac- should take the name of a hypothesis, and modify that hypothesis in place.  It could, for example, befunH=>rewriteleminHto do therewriteHunder binders.using_tac- used to solve any side-conditions thattacgenerates.  Not strictly necessary, sincetaccan always solve its own side-conditions, but it's sometimes convenient to instantiatetacwithfunH=>eapplyleminHor something, and solve the side-conditions witheassumption.H- the name of the hypothesis to start from.N.B. We do not requireFunextto use this tactic;Funextwould only required to relate the term returned by this tactic and the original term.  Note also that we only rewrite under top-level binders (e.g., under thexin a hypothesis of typeforallx,Px, but not under thexin a hypothesis of type(funxy=>x+y)=(funxy=>y+x)).Ltacmake_tac_under_binders_using_intacusing_tacH:=eval_under_bindersltac:(funH'=>eval_in_usingtacusing_tacH')H.Ltacdo_tac_under_binders_using_intacusing_tacH:=letH':=make_tac_under_binders_using_intacusing_tacHinletH'':=freshinposeproofH'asH'';clearH;renameH''intoH.Tactic Notation"constrbinder" "apply"constr(lem) "in"constr(H) "using"tactic3(tac):=make_tac_under_binders_using_inltac:(funH'=>applyleminH')tacH.Tactic Notation"constrbinder" "eapply"open_constr(lem) "in"constr(H) "using"tactic3(tac):=constrbinderapplyleminHusingtac.Tactic Notation"binder" "apply"constr(lem) "in"constr(H) "using"tactic3(tac):=do_tac_under_binders_using_inltac:(funH'=>applyleminH')tacH.Tactic Notation"binder" "eapply"open_constr(lem) "in"constr(H) "using"tactic3(tac):=binderapplyleminHusingtac.Tactic Notation"constrbinder" "apply"constr(lem) "in"constr(H) :=constrbinderapplyleminHusingidtac.Tactic Notation"constrbinder" "eapply"open_constr(lem) "in"constr(H) :=constrbindereapplyleminHusingidtac.Tactic Notation"binder" "apply"constr(lem) :=binder_applyltac:(applylem)ltac:(fail1 "Cannot apply"lem).Tactic Notation"binder" "eapply"open_constr(lem) :=binder_applyltac:(eapplylem)ltac:(fail1 "Cannot eapply"lem).Tactic Notation"binder" "apply"constr(lem) "in"constr(H) :=binderapplyleminHusingidtac.Tactic Notation"binder" "eapply"open_constr(lem) "in"constr(H) :=bindereapplyleminHusingidtac.Examplebasic_goal{ABC} (HA:forallx:A,Bx) (HB:forallx:A,Bx->Cx) :forallx:A,Cx.Proof.If we try toapplyHB, wanting to replaceCwithB, we get an error about being unable to unifyB?withA.FailapplyHB.The tacticbinderapplyfixes this shortcoming.binderapplyHB.exactHA.WeAbort, so that we don't get an extra constant floating around.Abort.Examplebasic{ABC} (HA:forallx:A,Bx) (HB:forallx:A,Bx->Cx) :forallx:A,Cx.Proof.If we try toapplyHBinHA, wanting to replaceBwithC, we get an error about being unable to instantiate the argument of typeA: "Error: Unable to find an instance for the variable x."FailapplyHBinHA.The tacticbinderapplyfixes this shortcoming.binderapplyHBinHA.exactHA.WeAbort, so that we don't get an extra constant floating around.Abort.Exampleex_funext`{Funext} {A}fg(H':forallxyzw:A,fxyzw=gxyzw:>A):f=g.Proof.We need to applypath_forallunder binders five times inH'.  We use a different variant each time to demonstrate the various ways of using this tactic.  In a normal proof, you'd probably just dodo4binderapply(@path_forall_)inH'or justrepeatbinderapply(@path_forall_)inH'.  If we dobinderapplypath_forallinH', we are told that Coq can't infer the argumentAtopath_forall.  Instead, we canbindereapplyit, to tell Coq to defer inference and use an evar for now.Failbinderapplypath_forallinH'.bindereapplypath_forallinH'.Alternatively, we can makeAexplicit.  But then we get an error about not being able to resolve the instance ofFunext.  We can either tell Coq to solve the side condition using theassumptiontactic (ortypeclasseseauto, for that matter), or we can have typeclass inference run when we construct the lemma to apply.  Some versions of Proof General are bad about noticingFailwithin a tactic; see http://proofgeneral.inf.ed.ac.uk/trac/ticket/494.  So we comment this one out.Fail binder apply @path_forall in H'.Error: Tactic failure: Cannot use <tactic> to solve side-condition goal
Funext . Extended goal with context:
(Funext ->
 forall (A : Type) (f g : A -> A -> A -> A -> A)
   (H' : forall x' x'0 x'1 : A, f x' x'0 x'1 = g x' x'0 x'1),
 let H0 := H' in Funext).binderapply@path_forallinH'usingassumption.binderapply@path_forallinH'usingtypeclasseseauto.binderapply(@path_forall_)inH'.Now we have removed all arguments tofandginH'.exactH'.WeAbort, so that we don't get an extra constant floating around.Abort.N.B.constrbinderapplyis likebinderapply, except that it constructs a new term and returns it, rather than applying a lemma in-place to a hypothesis.  It's primarily useful as plumbing for higher-level tactics.

--- Miscellaneous\BinInt.html ---
BinIntLibrary BinIntRequireExportHoTT.Spaces.BinInt.Core.RequireExportHoTT.Spaces.BinInt.Spec.RequireExportHoTT.Spaces.BinInt.Equiv.RequireExportHoTT.Spaces.BinInt.LoopExp.

--- Miscellaneous\Binomial.html ---
BinomialLibrary BinomialRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoidsBasics.DecidableSpaces.Nat.CoreSpaces.Nat.DivisionSpaces.Nat.FactorialTactics.EvalIn.LocalSetUniverseMinimizationToSet.LocalUnsetEliminationSchemes.Local OpenScopenat_scope.Binomial coefficientsDefinitionThe binomial coefficientnat_choosenmis the number of ways to choosemelements from a set ofnelements. We define it recursively using Pascal's identity. We use nestedFixpoints in order to get a function that computes definitionally on the edge cases as well as the inductive case.We separate out this helper result to prevent Coq from unfolding things into a larger term. This computesnchoosem.+1given a functionfthat computesnchoosem.Fixpointnat_choose_stepnf:=matchnwith| 0 => 0|Sn'=>fn'+nat_choose_stepn'fend.Fixpointnat_choose(nm:nat) {structm} :nat:=matchmwith| 0 => 1|Sm'=>nat_choose_stepn(funn=>nat_choosenm')end.We make sure we never unfold binomial coefficients withsimplorcbnsince the terms do not look good. Instead, we should use lemmas we prove about it to make proofs clearer to read.Argumentsnat_choosenm:simplnever.PropertiesThe three defining properties ofnat_choosehold definitionally.By definition, we have Pascal's identity.Definitionnat_choose_succ@{}nm:nat_choosen.+1m.+1 =nat_choosenm+nat_choosenm.+1:=idpath.There is only one way to choose0elements from any number of elements.Definitionnat_choose_zero_r@{}n:nat_choosen0 = 1:=idpath.There are no ways to choose a non-zero number of elements from0elements.Definitionnat_choose_zero_l@{}m:nat_choose0m.+1 = 0:=idpath.The binomial coefficient is zero ifmis greater thann.Definitionnat_choose_lt@{}nm:n<m->nat_choosenm= 0.Proof.revertm;inductionn;hnf;introsmH;destructH.1, 2:reflexivity.1, 2:rewrite_reflnat_choose_succ;exact(ap011nat_add(IHn__) (IHn__)).Defined.There is only one way to choosenelements fromnelements.Definitionnat_choose_diag@{}n:nat_choosenn= 1.Proof.inductionnas[|nIHn];only1:reflexivity.rewrite_reflnat_choose_succ.rhs_Vnrapplynat_add_zero_r.nrapplyap011.-exactIHn.-rapplynat_choose_lt.Defined.There arenways to choose1element fromnelements.Definitionnat_choose_one_r@{}n:nat_choosen1 =n.Proof.inductionnas[|nIHn];only1:reflexivity.rewrite_reflnat_choose_succ.exact(apnat_succIHn).Defined.There aren.+1ways to choosenelements fromn.+1elements.Definitionnat_choose_succ_l_diag@{}n:nat_choosen.+1n=n.+1.Proof.inductionnas[|nIHn];only1:reflexivity.rewrite_reflnat_choose_succ.rhs_Vnrapply(nat_add_comm_1).nrapplyap011.-exactIHn.-applynat_choose_diag.Defined.The binomial coefficients can be written as a quotient of factorials. This is typically used as a definition of the binomial coefficients.Definitionnat_choose_factorial@{}nm:m<=n->nat_choosenm=factorialn/ (factorialm*factorial(n-m)).Proof.revertnm;applynat_double_ind_leq;intron.(* The case whenm=0. *){rewritenat_mul_one_l.rewritenat_sub_zero_r.symmetry;rapplynat_div_cancel. }(* The case whenm=n. *){rewritenat_sub_cancel.rewritenat_mul_one_r.rewritenat_div_cancel.1:nrapplynat_choose_diag.exact_. }(* The case withn.+1andm.+1withm<nand an induction hypothesis. *)introsmHIHn.rewrite_reflnat_choose_succ.rewrite2IHn.2,3:exact_.rewrite<- (nat_div_cancel_mul_l__m.+1).2:exact_.rewritenat_mul_assoc.rewrite<-nat_factorial_succ.rewrite<- (nat_div_cancel_mul_l(factorialn)_(n-m)).2:rapplyequiv_lt_lt_sub.rewritenat_mul_assoc.rewrite(nat_mul_comm(n-m) (factorialm.+1)).rewrite<-nat_mul_assoc.rewritenat_sub_succ_r.rewrite<-nat_factorial_pred.2:rapplyequiv_lt_lt_sub.lhs_Vnrapplynat_div_dist.-rewritenat_factorial_succ.rewrite<-nat_mul_assoc.exact_.-rewrite<-nat_dist_r.rewritenat_add_succ_l.rewritenat_add_sub_r_cancel.2:exact_.rewrite<-nat_factorial_succ.reflexivity.Defined.Another recursive property of the binomial coefficients.  To choosem+1elements from a set of sizen+1, one hasn+1choices for the first element and then can make the remainingmchoices from the remainingnelements.  This overcounts by a factor ofm+1, since there arem+1elements that could have been called the "first" element.Definitionnat_choose_succ_mul@{}nm:nat_choosen.+1m.+1 = (n.+1 *nat_choosenm) /m.+1.Proof.destruct(leq_dichotomymn)as[H|H].2: {rewrite2nat_choose_lt;only2, 3:exact_.rewritenat_mul_zero_r.symmetry;applynat_div_zero_l. }rewrite2nat_choose_factorial.2,3:exact_.rewritenat_div_mul_l.2:exact_.rewritenat_div_div_l.byrewrite(nat_mul_comm_m.+1),nat_mul_assoc.Defined.The binomial coefficients are symmetric about the middle of the range0<=n.Definitionnat_choose_sub@{}nm:m<=n->nat_choosenm=nat_choosen(n-m).Proof.introsH.rewrite2nat_choose_factorial.2,3:exact_.rewritenat_sub_sub_cancel_r.2:exact_.byrewritenat_mul_comm.Defined.

--- Miscellaneous\Biproduct.html ---
BiproductLibrary BiproductRequireImportBasicsTypesTruncations.Core.RequireImportWildCat.RequireImportHSet.RequireImportAbelianGroup.RequireImportModalities.ReflectiveSubuniverse.Local OpenScopemc_add_scope.Biproducts of abelian groupsDefinitionab_biprod@{u} (AB:AbGroup@{u}) :AbGroup@{u}.Proof.rapply(Build_AbGroup(grp_prodAB)).intros[ab] [a'b'].applypath_prod;simpl;applycommutativity.Defined.These inheritIsEmbeddinginstances from theirgrp_prodversions.Definitionab_biprod_inl{AB:AbGroup} :A$->ab_biprodAB:=grp_prod_inl.Definitionab_biprod_inr{AB:AbGroup} :B$->ab_biprodAB:=grp_prod_inr.These inheritIsSurjectioninstances from theirgrp_prodversions.Definitionab_biprod_pr1{AB:AbGroup} :ab_biprodAB$->A:=grp_prod_pr1.Definitionab_biprod_pr2{AB:AbGroup} :ab_biprodAB$->B:=grp_prod_pr2.Definitionab_biprod_ind{AB:AbGroup}(P:ab_biprodAB->Type)(Hinl:foralla,P(ab_biprod_inla))(Hinr:forallb,P(ab_biprod_inrb))(Hop:forallxy,Px->Py->P(x+y)):forallx,Px.Proof.intros[ab].snrapply((grp_prod_decomposeab)^ #_).applyHop.-exact(Hinla).-exact(Hinrb).Defined.Definitionab_biprod_ind_homotopy{ABC:AbGroup}{fg:ab_biprodAB$->C}(Hinl:f$oab_biprod_inl$==g$oab_biprod_inl)(Hinr:f$oab_biprod_inr$==g$oab_biprod_inr):f$==g.Proof.rapplyab_biprod_ind.-exactHinl.-exactHinr.-introsxypq.lhsnrapplygrp_homo_op.rhsnrapplygrp_homo_op.f_ap.Defined.(* Maps out of biproducts are determined on the two inclusions. *)Definitionequiv_ab_biprod_ind_homotopy`{Funext} {ABX:AbGroup} (phipsi:ab_biprodAB$->X): (phi$oab_biprod_inl==psi$oab_biprod_inl)* (phi$oab_biprod_inr==psi$oab_biprod_inr)<~>phi==psi.Proof.applyequiv_iff_hprop.-exact(uncurryab_biprod_ind_homotopy).-exact(funh=> (funa=>h_,funb=>h_)).Defined.Recursion principlePropositionab_biprod_rec{ABY:AbGroup}(f:A$->Y) (g:B$->Y): (ab_biprodAB) $->Y.Proof.snrapplyBuild_GroupHomomorphism.-intros[ab];exact(fa+gb).-intros[ab] [a'b'];simpl.rewrite(grp_homo_opf).rewrite(grp_homo_opg).rewrite(associativity_(gb)_).rewrite<- (associativity_(fa')_).rewrite(commutativity(fa')_).rewrite(associativity_(gb)_).exact(associativity_(fa')_)^.Defined.Corollaryab_biprod_rec_uncurried{ABY:AbGroup}: (A$->Y) * (B$->Y)-> (ab_biprodAB) $->Y.Proof.intros[fg].exact(ab_biprod_recfg).Defined.Propositionab_biprod_rec_eta{ABY:AbGroup}(u:ab_biprodAB$->Y):ab_biprod_rec(u$oab_biprod_inl) (u$oab_biprod_inr) ==u.Proof.intros[ab];simpl.refine((grp_homo_opu__)^ @apu_).applypath_prod.-exact(right_identitya).-exact(left_identityb).Defined.Propositionab_biprod_rec_beta_inl{ABY:AbGroup}(a:A$->Y) (b:B$->Y): (ab_biprod_recab) $oab_biprod_inl==a.Proof.introx;simpl.rewrite(grp_homo_unitb).exact(right_identity(ax)).Defined.Propositionab_biprod_rec_beta_inr{ABY:AbGroup}(a:A$->Y) (b:B$->Y): (ab_biprod_recab) $oab_biprod_inr==b.Proof.introy;simpl.rewrite(grp_homo_unita).exact(left_identity(by)).Defined.Theoremisequiv_ab_biprod_rec`{Funext} {ABY:AbGroup}:IsEquiv(@ab_biprod_rec_uncurriedABY).Proof.srapplyisequiv_adjointify.-introphi.exact(phi$oab_biprod_inl,phi$oab_biprod_inr).-introphi.applyequiv_path_grouphomomorphism.exact(ab_biprod_rec_etaphi).-intros[ab].applypath_prod.+applyequiv_path_grouphomomorphism.applyab_biprod_rec_beta_inl.+applyequiv_path_grouphomomorphism.applyab_biprod_rec_beta_inr.Defined.Corecursion principle, inherited from Groups/Group.v.Definitionab_biprod_corec{ABX:AbGroup} (f:X$->A) (g:X$->B):X$->ab_biprodAB:=grp_prod_corecfg.Functoriality ofab_biprodDefinitionfunctor_ab_biprod{AA'BB':AbGroup} (f:A$->A') (g:B$->B'):ab_biprodAB$->ab_biprodA'B':= (ab_biprod_corec(f$oab_biprod_pr1) (g$oab_biprod_pr2)).Definitionab_biprod_functor_beta{ZXYAB:AbGroup} (f0:Z$->X) (f1:Z$->Y)(g0:X$->A) (g1:Y$->B):functor_ab_biprodg0g1$oab_biprod_corecf0f1$==ab_biprod_corec(g0$of0) (g1$of1):=fun_=>idpath.Global Instanceis0bifunctor_ab_biprod:Is0Bifunctorab_biprod.Proof.srapplyBuild_Is0Bifunctor'.snrapplyBuild_Is0Functor.intros[AB] [A'B'] [fg].exact(functor_ab_biprodfg).Defined.Global Instanceis1bifunctor_ab_biprod:Is1Bifunctorab_biprod.Proof.snrapplyBuild_Is1Bifunctor'.snrapplyBuild_Is1Functor.-intros[AB] [A'B'] [fg] [f'g'] [pq] [ab].snrapplyequiv_path_prod.exact(pa,qb).-reflexivity.-cbn;reflexivity.Defined.Definitionisequiv_functor_ab_biprod{AA'BB':AbGroup}(f:A$->A') (g:B$->B') `{IsEquiv__f} `{IsEquiv__g}:IsEquiv(functor_ab_biprodfg).Proof.srapplyisequiv_adjointify.1: {rapplyfunctor_ab_biprod;applygrp_iso_inverse.+exact(Build_GroupIsomorphism__f_).+exact(Build_GroupIsomorphism__g_). }all:intros[ab];simpl.all:applypath_prod'.1,2:applyeisretr.all:applyeissect.Defined.Definitionequiv_functor_ab_biprod{AA'BB':AbGroup}(f:A$->A') (g:B$->B') `{IsEquiv__f} `{IsEquiv__g}:GroupIsomorphism(ab_biprodAB) (ab_biprodA'B'):=Build_GroupIsomorphism___(isequiv_functor_ab_biprodfg).Biproducts preserve embeddings.Definitionfunctor_ab_biprod_embedding{AA'BB':AbGroup}(i:A$->B) (i':A'$->B')`{IsEmbeddingi} `{IsEmbeddingi'}:IsEmbedding(functor_ab_biprodii').Proof.intros[bb'].applyhprop_allpath.intros[[a0a0']p] [[a1a1']p'];cbninp,p'.rapplypath_sigma_hprop;cbn.pose(q:= (equiv_path_prod__)^-1p);cbninq.pose(q':= (equiv_path_prod__)^-1p');cbninq'.destructqas[q0q1],q'as[q0'q1'].applypath_prod;rapplyisinj_embedding;cbn.-exact(q0@q0'^).-exact(q1@q1'^).Defined.Products preserve surjections.Definitionfunctor_ab_biprod_surjection`{Funext} {AA'BB':AbGroup}(p:A$->B) (p':A'$->B')`{S:IsSurjectionp} `{S':IsSurjectionp'}:IsSurjection(functor_ab_biprodpp').Proof.intros[bb'].poseproof(a:=Sb);poseproof(a':=S'b').applycenterina,a'.strip_truncations.rapplycontr_inhabited_hprop.applytr.exists(ab_biprod_inla.1 +ab_biprod_inra'.1);cbn.applypath_prod;refine(grp_homo_op___@_);rewrite(grp_homo_unit_);cbn.-exact(right_identity_@a.2).-exact(left_identity_@a'.2).Defined.Lemmas for working with biproductsThe swap isomorphism of the biproduct of two groups.Definitiondirect_sum_swap{AB:AbGroup}:ab_biprodAB$<~>ab_biprodBA.Proof.snrapplyBuild_GroupIsomorphism'.-applyequiv_prod_symm.-intro;reflexivity.Defined.Addition+is a group homomorphismA+A->A.Definitionab_codiagonal{A:AbGroup} :ab_biprodAA$->A:=ab_biprod_recgrp_homo_idgrp_homo_id.Definitionab_codiagonal_natural{AB:AbGroup} (f:A$->B):f$oab_codiagonal$==ab_codiagonal$ofunctor_ab_biprodff:=funa=>grp_homo_opf__.Definitionab_diagonal{A:AbGroup} :A$->ab_biprodAA:=ab_biprod_corecgrp_homo_idgrp_homo_id.Given two abelian group homomorphismsfandg, their pairing(f,g):B->A+Acan be written as a composite. Note thatab_biprod_corecis an alias forgrp_prod_corec.Lemmaab_biprod_corec_diagonal`{Funext} {AB:AbGroup} (fg:B$->A):ab_biprod_corecfg= (functor_ab_biprodfg) $oab_diagonal.Proof.applyequiv_path_grouphomomorphism;reflexivity.Defined.Precomposing the codiagonal with the swap map has no effect.Lemmaab_codiagonal_swap`{Funext} {A:AbGroup}: (@ab_codiagonalA) $odirect_sum_swap=ab_codiagonal.Proof.applyequiv_path_grouphomomorphism.introa;cbn.exact(abgroup_commutative___).Defined.The corresponding result for the diagonal is true definitionally, so it isn't strictly necessary to state it, but we record it anyways.Definitionab_diagonal_swap{A:AbGroup}:direct_sum_swap$o(@ab_diagonalA) =ab_diagonal:=idpath.The biproduct is associative.Lemmaab_biprod_assoc{ABC:AbGroup}:ab_biprodA(ab_biprodBC) $<~>ab_biprod(ab_biprodAB)C.Proof.snrapplyBuild_GroupIsomorphism'.-applyequiv_prod_assoc.-unfoldIsSemiGroupPreserving;reflexivity.Defined.The iterated diagonals(ab_diagonal+id)oab_diagonaland(id+ab_diagonal)oab_diagonalagree, after reassociating the direct sum.Definitionab_commute_id_diagonal{A:AbGroup}: (functor_ab_biprod(@ab_diagonalA)grp_homo_id) $oab_diagonal=ab_biprod_assoc$o(functor_ab_biprodgrp_homo_idab_diagonal) $oab_diagonal:=idpath.A similar result for the codiagonal.Lemmaab_commute_id_codiagonal`{Funext} {A:AbGroup}: (@ab_codiagonalA) $o(functor_ab_biprodab_codiagonalgrp_homo_id) $oab_biprod_assoc=ab_codiagonal$o(functor_ab_biprodgrp_homo_idab_codiagonal).Proof.applyequiv_path_grouphomomorphism.introa;cbn.exact(grp_assoc___)^.Defined.The next few results are used to prove associativity of the Baer sum.A "twist" isomorphism(A+B)+C<~>(C+B)+A.Lemmaab_biprod_twist{ABC:AbGroup@{u}}:ab_biprod(ab_biprodAB)C$<~>ab_biprod(ab_biprodCB)A.Proof.snrapplyBuild_GroupIsomorphism.-snrapplyBuild_GroupHomomorphism.+intros[[ab]c].exact((c,b),a).+unfoldIsSemiGroupPreserving.reflexivity.-snrapplyisequiv_adjointify.+intros[[cb]a].exact((a,b),c).+reflexivity.+reflexivity.Defined.The triagonal and cotriagonal homomorphisms.Definitionab_triagonal{A:AbGroup} :A$->ab_biprod(ab_biprodAA)A:= (functor_ab_biprodab_diagonalgrp_homo_id) $oab_diagonal.Definitionab_cotriagonal{A:AbGroup} :ab_biprod(ab_biprodAA)A$->A:=ab_codiagonal$o(functor_ab_biprodab_codiagonalgrp_homo_id).For an abelian groupA, precomposing the triagonal onAwith the twist map onAhas no effect.Definitionab_triagonal_twist{A:AbGroup}:ab_biprod_twist$o@ab_triagonalA=ab_triagonal:=idpath.A similar result for the cotriagonal.Definitionab_cotriagonal_twist`{Funext} {A:AbGroup}: @ab_cotriagonalA$oab_biprod_twist=ab_cotriagonal.Proof.applyequiv_path_grouphomomorphism.introx.cbn.refine((grp_assoc___)^ @_).refine(abgroup_commutative___@_).exact(ap(funa=>a+sndx) (abgroup_commutative___)).Defined.

--- Miscellaneous\BlakersMassey.html ---
BlakersMasseyLibrary BlakersMasseyRequireImportHoTT.BasicsHoTT.Types.RequireImportColimits.Pushout.RequireImportColimits.SpanPushout.RequireImportHomotopy.Join.Core.RequireImportTruncations.The Generalized Blakers-Massey TheoremPath algebra helper lemmaHere is a strange-looking path algebra helper lemma that is easier to prove by lifting to a general case and doing a path-induction blast.  It says something about what happens when we transport from the center of a based path-space to some other point, assuming we know a particular way to "compute" the action of the type family in question.Definitiontransport_singleton`{Univalence}{A:Type} {x:A} (B:forall(y:A), (x=y) ->Type){y:A} (p:x=y) (u:Bxidpath)(f:forall(q:x=x),Bxq<~>By(q@p))(ev:ap10(apDBp)p=transport_arrow_toconstp(Bx)p@path_universe_uncurried(@equiv_transport_(By) ((p@p^) @p)p(concat_pV_ppp)oE(f(p@p^))oE@equiv_transport_(Bx)(transport(funy=>x=y)p^p)(p@p^) (transport_paths_rp^p))):transport(funyp:{y:A&x=y} =>Byp.1yp.2)(path_contr(A:= {y:A&x=y}) (x;idpath) (y;p))u=transport(By) (concat_1p_) (fidpathu).Proof.destructp;cbnin*.apply(fune=>e@concat_1p_)inev.applymoveR_equiv_Vinev.apply(apequiv_fun)inev.applyap10inev.specialize(evu).cbninev.exactev.Defined.SetupSectionGBM.Context{XY:Type} (Q:X->Y->Type).Here's the hypothesis of ABFJ generalized Blakers-Massey.  It works for any reflective subuniverse, not only modalities!Context(O:ReflectiveSubuniverse).Context(isconnected_cogap:forall(x1x3:X) (y2y4:Y)(q12:Qx1y2) (q32:Qx3y2) (q34:Qx3y4),IsConnectedO(Join((x1;q12) = (x3;q32) :> {x:X&Qxy2})((y2;q32) = (y4;q34) :> {y:Y&Qx3y}))).LetP:=SPushoutQ.Local Notationleft:= (spushlQ).Local Notationright:= (spushrQ).Local Notationglue:= (spglueQ).Here's a lemma that's a sort of "singleton contractibility" equivalence, but expressed in a particularly strange way.  As we'll see, this form of the lemma comes up naturally *twice* in the proof, and proving it once here to use in both places is crucial so that the two uses can be identified later on.Local Definitionfrobnicate{x0x1:X} (r:leftx0=leftx1)(s:x0=x1) (y:Y) (q1:Qx1y): {q0:Qx0y&{w:transport(funx=>Qxy)sq0=q1&glueq0@ (glueq1)^ =r} }<~>aplefts=r.Proof.refine(_oEequiv_sigma_assoc'__).refine(_oEequiv_functor_sigma'(Q:=funqt=>glueqt.1 @ (glueq1)^ =r)(equiv_functor_sigma_id(funq0:Qx0y=>equiv_moveL_transport_V(funx=>Qxy)sq0q1))(funqt=>equiv_idmap)).refine(_oEequiv_contr_sigma_);cbn.rewrite(ap_transports^ (funxq=>glueq)q1).rewrite(transport_paths_FlFrs^ (glueq1)).rewriteap_V,inv_V,ap_const,concat_p1.exact(equiv_concat_l(concat_pp_V__)^_).Although we proved this lemma withrewrite, we make it transparent, not so that *we* can reason about it, but so that Coq can evaluate it.Defined.(* But except in one place, we don't want it to try (otherwise things get really slow). *)Opaquefrobnicate.CodesRight-hand codesThe right-hand codes family is easy.Definitioncoderight{x0:X} {y:Y} (r:leftx0=righty) :Type:=O(hfibergluer).Left-hand codesWe enhance the HFLL and ABFJ theorems by defining a version of code-left that doesn't depend on one map being surjective.SectionCodeLeft.Context{x0x1:X} (r:leftx0=leftx1).The left codes are themselves a pushout, of what is morally also a dependent span, but we formulate it as an ordinary pushout of projections between iterated Sigma-types, most of which we express as records for performance reasons.  The span iscodeleft1<-codeleft0->codeleft2.Definitioncodeleft1:Type:= {s:x0=x1&(* v : *)aplefts=r}.Recordcodeleft2:= {codeleft2_y0:Y;codeleft2_q00:Qx0codeleft2_y0;codeleft2_q10:Qx1codeleft2_y0;codeleft2_u:gluecodeleft2_q00@ (gluecodeleft2_q10)^ =r}.Recordcodeleft0:= {codeleft0_s:x0=x1;codeleft0_y0:Y;codeleft0_v:apleftcodeleft0_s=r;codeleft0_q00:Qx0codeleft0_y0;codeleft0_q10:Qx1codeleft0_y0;codeleft0_w:transport(funx=>Qxcodeleft0_y0)codeleft0_scodeleft0_q00=codeleft0_q10;codeleft0_u:gluecodeleft0_q00@ (gluecodeleft0_q10)^ =r;Note the first use of frobnicate here.codeleft0_d:frobnicatercodeleft0_scodeleft0_y0codeleft0_q10(codeleft0_q00;codeleft0_w;codeleft0_u) =codeleft0_v}.Definitioncodeleft01:codeleft0->codeleft1.Proof.intros[sy0vq00q10wud].exact(s;v).Defined.Definitioncodeleft02:codeleft0->codeleft2.Proof.intros[sy0vq00q10wud].exact(Build_codeleft2y0q00q10u).Defined.Definitioncodeleft:Type:=O(Pushoutcodeleft01codeleft02).Codes for glueSectionCodeGlue.Context{y1:Y} (q11:Qx1y1).We prove that codes respect glue as a chain of equivalences between types built from pushouts and double-pushouts.  The first step is to add the data of our hypothesized-to-be-connected type insidecodeleft2.Definitioncodeleft2plus:={yqqu:codeleft2&Join((x0;codeleft2_q00yqqu) = (x1;codeleft2_q10yqqu):> {x:X&Qx(codeleft2_y0yqqu)})((codeleft2_y0yqqu;codeleft2_q10yqqu) = (y1;q11):> {y:Y&Qx1y})}.Since this connected type is itself a join, hence a pushout, the second step is to distribute this and reexpress the whole thing as another pushout of iterated Sigma-types (again mostly expressed as records for performance reasons).RecordOcodeleft2b:= {Ocodeleft2b_s:x0=x1;Ocodeleft2b_y0:Y;Ocodeleft2b_q00:Qx0Ocodeleft2b_y0;Ocodeleft2b_q10:Qx1Ocodeleft2b_y0;Ocodeleft2b_w:transport(funx=>QxOcodeleft2b_y0)Ocodeleft2b_sOcodeleft2b_q00=Ocodeleft2b_q10;Ocodeleft2b_u:glueOcodeleft2b_q00@ (glueOcodeleft2b_q10)^ =r}.DefinitionOcodeleft2c:= {q01:Qx0y1&(* u: *)glueq01@ (glueq11)^ =r}.RecordOcodeleft2a:= {Ocodeleft2a_s:x0=x1;Ocodeleft2a_q01:Qx0y1;Ocodeleft2a_w:transport(funx=>Qxy1)Ocodeleft2a_sOcodeleft2a_q01=q11;Ocodeleft2a_u:glueOcodeleft2a_q01@ (glueq11)^ =r}.DefinitionOcodeleft2ab:Ocodeleft2a->Ocodeleft2b.Proof.intros[sq01wu].exact(Build_Ocodeleft2bsy1q01q11wu).Defined.DefinitionOcodeleft2ac:Ocodeleft2a->Ocodeleft2c.Proof.intros[sq01wu].exact(q01;u).Defined.This proof is basically just rearranging Sigma-types/records and paths in Sigma-types and contracting based path spaces.Definitionequiv_Ocodeleft2plus:PushoutOcodeleft2abOcodeleft2ac<~>codeleft2plus.Proof.refine((equiv_sigma_pushout_____)^-1oE_).srefine(equiv_pushout_____).-srefine(equiv_functor_sigma_id_oE_).2:intro;refine(equiv_functor_prod'__);applyequiv_path_sigma.make_equiv_contr_basedpaths.-srefine(equiv_functor_sigma_id_oE_).2:intro;applyequiv_path_sigma.make_equiv.-srefine(equiv_functor_sigma_id_oE_).2:intro;applyequiv_path_sigma.make_equiv_contr_basedpaths.-intros;reflexivity.-intros;reflexivity.Defined.Now we combine this equivalence with the insertion of our connected type.Definitionequiv_Ocodeleft2:O(PushoutOcodeleft2abOcodeleft2ac) <~>Ocodeleft2.Proof.refine((equiv_O_functorO(equiv_sigma_contr(funyqqu:codeleft2=>O(Join((x0;codeleft2_q00yqqu) = (x1;codeleft2_q10yqqu))((codeleft2_y0yqqu;codeleft2_q10yqqu) = (y1;q11))))))oE_).refine((equiv_O_sigma_OO_)^-1oE_).applyequiv_O_functor.applyequiv_Ocodeleft2plus.Defined.The next step is to reassociate the resulting double-pushout and "contract" both of them, one after the other, because they are pushouts along equivalences.  In order to do this, we need first of all to know that the resulting map fromcodeleft0to the above pushout factors throughOcodeleft2bvia an equivalence.  Here's the equivalence:DefinitionOcodeleft02b:codeleft0<~>Ocodeleft2b.Proof.make_equiv_contr_basedpaths.Defined.DefinitionOcodeleft02(c:codeleft0):PushoutOcodeleft2abOcodeleft2ac:=pushl'Ocodeleft2abOcodeleft2ac(Ocodeleft02bc).DefinitionOcodeleft02plus_02b(c:codeleft0): (equiv_Ocodeleft2plus(Ocodeleft02c)).1 =codeleft02c.Proof.destructc;reflexivity.Qed.And here we show that this equivalence is indeed a factor of the relevant map in the original pushout.DefinitionOcodeleft02_02b(c:codeleft0):equiv_Ocodeleft2(toO_(Ocodeleft02c)) =toO_(codeleft02c).Proof.destructc.unfoldequiv_Ocodeleft2.Opaqueequiv_Ocodeleft2plus.cbn.refine(ap_(ap_(to_O_natural___)) @_).refine(ap_(to_O_natural___) @_).refine(to_O_natural___@_).applyap.rapplyOcodeleft02plus_02b.Qed.Thus, our pushout in which one vertex is itself a pushout can be written as a "double pushout"codeleft1<-codeleft0->codeleft2b<-codeleft2a->codeleft2c.Since the mapcodeleft0->codeleft2bis an equivalence, the pushout of the left-hand span is equivalent tocodeleft1, and thus the whole thing is equivalent to a pushoutcodeleft1<-codeleft2a->codeleft2cNow we claim that the left-hand map of this span is also an equivalence.  Rather than showing this directly, it seems to be much easier to first construct *an* equivalence fromcodeleft2atocodeleft1and then show that it is equal (as a function) to the induced one.  Here's the equivalence:DefinitionOcodeleft2a1:Ocodeleft2a<~>codeleft1.Proof.etransitivity.2:{rapplyequiv_functor_sigma_id;intross.Here's frobnicate showing up again!applyfrobnicate. }make_equiv.Defined.And now we check that the two are equal.  Because we used the same proof offrobnicatein two places, this equality becomes definitional after simply decomposing up a Sigma-type!DefinitionOcodeleft2a1_through_2b0:Ocodeleft2a1==codeleft01oOcodeleft02b^-1oOcodeleft2ab.Proof.intros;reflexivity.Defined.Now we're finally ready to prove the glue equivalence.  Since later on we'll have to compute its action on inputs fromcodeleft1, we decompose it into seven steps, each of which with a corresponding computation lemma.  (These lemmas seem to be much easier to prove step-by-step than all at once if we proved the whole equivalence in a big shebang.)Definitioncodeglue1:codeleft<~>O(Pushout(O_functorOcodeleft01)(O_functorOcodeleft02)):=equiv_O_pushoutO__.Definitioncodeglue1_pushl(s:x0=x1) (v:aplefts=r):codeglue1(toO_(pushl(s;v))) =toO_(pushl(toO_(s;v))):=equiv_O_pushout_to_O_pushl____.Definitioncodeglue2:O(Pushout(O_functorOcodeleft01) (O_functorOcodeleft02))<~>O(Pushout(O_functorOcodeleft01) (O_functorOOcodeleft02)).Proof.srefine(equiv_O_functorO(equiv_inverse(equiv_pushout(f:=O_functorOcodeleft01)(g:=O_functorOOcodeleft02)1%equiv1%equivequiv_Ocodeleft2__))).-introsx;reflexivity.-applyO_indpaths;introsx.abstract(rewrite!to_O_natural;applyOcodeleft02_02b).Defined.Definitioncodeglue2_pushl(s:x0=x1) (v:aplefts=r):codeglue2(toO_(pushl(toO_(s;v))))=toO_(pushl(toO_(s;v))):=to_O_equiv_natural___.Definitioncodeglue3:O(Pushout(O_functorOcodeleft01) (O_functorOOcodeleft02))<~>O(Pushoutcodeleft01Ocodeleft02):=equiv_inverse(equiv_O_pushoutO__).Definitioncodeglue3_pushl(s:x0=x1) (v:aplefts=r):codeglue3(toO_(pushl(toO_(s;v))))=toO_(pushl(s;v)):=inverse_equiv_O_pushout_to_O_pushl____.Definitioncodeglue4:O(Pushoutcodeleft01Ocodeleft02)<~>O(Pushout(funx:Ocodeleft2a=>pushr'codeleft01Ocodeleft02b(Ocodeleft2abx))Ocodeleft2ac):=equiv_O_functorO(equiv_inverse(equiv_pushout_assoc____)).Definitioncodeglue4_pushl(s:x0=x1) (v:aplefts=r):codeglue4(toO_(pushl(s;v)))=toO_(pushl(pushl(s;v))):=to_O_equiv_natural___.Definitioncodeglue5:O(Pushout(funx:Ocodeleft2a=>pushr'codeleft01Ocodeleft02b(Ocodeleft2abx))Ocodeleft2ac)<~>O(PushoutOcodeleft2a1Ocodeleft2ac).Proof.srefine(equiv_O_functorO(equiv_inverse(equiv_pushout(f:=Ocodeleft2a1) (g:=Ocodeleft2ac)1%equiv_1%equiv__))).-exact(Build_Equiv__(pushl'codeleft01Ocodeleft02b)_).-introsx.refine(ap_(Ocodeleft2a1_through_2b0x) @_).refine(pglue'codeleft01Ocodeleft02b_@_).applyap,eisretr.-introsx;reflexivity.Defined.Definitioncodeglue5_pushl(s:x0=x1) (v:aplefts=r):codeglue5(toO_(pushl(pushl(s;v))))=toO_(pushl(s;v)):=to_O_equiv_natural___.Definitioncodeglue6:O(PushoutOcodeleft2a1Ocodeleft2ac) <~>OOcodeleft2c:=equiv_O_functorO(equiv_inverse(Build_Equiv__(pushr'Ocodeleft2a1Ocodeleft2ac)_)).Definitioncodeglue6_pushl(s:x0=x1) (v:aplefts=r):codeglue6(toO_(pushl(s;v)))=letz:= (frobnicatersy1q11)^-1vintoOOcodeleft2c(Ocodeleft2ac(Build_Ocodeleft2asz.1z.2.1z.2.2)):=to_O_equiv_natural___.Definitioncodeglue7:OOcodeleft2c<~>coderight(r@glueq11).Proof.unfoldcoderight,Ocodeleft2c.applyequiv_O_functor.applyequiv_functor_sigma_id;introsq01.applyequiv_moveL_pM.Defined.Definitioncodeglue7_to_O(q01:Qx0y1) (u:glueq01@ (glueq11)^ =r):codeglue7(toO_(q01;u))=toO(hfiberglue(r@glueq11))(q01;moveL_pM(glueq11) (glueq01)ru):=to_O_equiv_natural___.Definitioncodeglue:codeleft<~>coderight(r@glueq11):=codeglue7oEcodeglue6oEcodeglue5oEcodeglue4oEcodeglue3oEcodeglue2oEcodeglue1.EndCodeGlue.EndCodeLeft.Completion of codesContext`{Univalence}.Context(x0:X).The equivalencecodegluerequires a bit of massaging to put it into the form needed by the actual definition ofcodefrom pushout-induction and univalence.Definitionap_code_glue(x1:X) (y1:Y) (q11:Qx1y1):transport(funp:SPushoutQ=>leftx0=p->Type)(glueq11)codeleft=coderight.Proof.applypath_arrow;introsz.refine((transport_arrow_toconst___) @_).applypath_universe_uncurried.refine(_oEequiv_transportcodeleft(transport_paths_r__)).refine(_oEcodeglue_q11).refine(equiv_transportcoderight_).refine(concat_pV_pz(glueq11)).Defined.Here's the final definition ofcode.Definitioncode(p:P) (r:leftx0=p) :Type:=SPushout_indQ(funp=>leftx0=p->Type)(@codeleftx0) (@coderightx0)ap_code_gluepr.When we compute withcode, we'll need to extract from it the actual behavior of the functioncodeglue.  Here's the mess of path algebra that we "naturally" get out when we try to do that; later we'll see how to deal with it.Definitioncode_beta_glue(x1:X) (y1:Y) (q11:Qx1y1)(r:leftx0=righty1):ap10(apDcode(glueq11))r=transport_arrow_toconst(glueq11)codeleftr@path_universe_uncurried(@equiv_transport_coderight((r@ (glueq11)^) @glueq11)r(concat_pV_pr(glueq11))oE(codeglue(r@ (glueq11)^)q11)oE@equiv_transport_codeleft(transport(funy:SPushoutQ=>leftx0=y) (glueq11)^r)(r@ (glueq11)^) (transport_paths_r(glueq11)^r)).Proof.refine(ap(funh=>ap10hr)(spushout_ind_beta_sglueQ(funp=>leftx0=p->Type)(@codeleftx0) (@coderightx0)ap_code_gluex1y1q11) @_).refine(ap10_path_arrow____).Defined.Contractibility of codesTo construct a center for every type of codes, we construct one in an easy case and transport it around.Definitioncenter_code1:code(leftx0) 1.Proof.change(codeleft(idpath(leftx0))).unfoldcodeleft.applyto,pushl.unfoldcodeleft1.exact(idpath;idpath).Defined.Definitioncenter_code(p:P) (r:leftx0=p) :codepr:=transport(fun(pr: {p:P&leftx0=p}) =>codepr.1pr.2)(path_contr(A:= {p:P&leftx0=p})(leftx0;idpath) (p;r))center_code1.As in HFLL, we first construct a contraction in the "partially general" case of an arbitrary path from left to right.Definitioncontraction_code_right(y1:Y) (r:leftx0=righty1)(c:code(righty1)r):center_code(righty1)r=c.Proof.change(coderightr)inc.unfoldcoderightinc.revertc;refine(O_indpaths___);intros[q01t].unfoldcenter_code,center_code1.Here's how we use the apparently-unmanageablecode_beta_glue.  First we destruct the pathtto make things simpler.destructt.Then we notice that if we tried rewriting withcode_beta_gluehere, the unmanageable-looking result is actually fully general over the pathglueq01, so we can prove by path induction that it equals the nicer expression we'd like to see.  This is the purpose of the lemmatransport_singleton.rewrite(transport_singletoncode(glueq01)_(funr=> @codegluex0x0ry1q01)(code_beta_gluex0y1q01(glueq01))).unfoldcodeglue.Now we evaluatecodegluestep by step using our lemmas.do6change_apply_equiv_compose.rewritecodeglue1_pushl,codeglue2_pushl,codeglue3_pushl,codeglue4_pushl,codeglue5_pushl,codeglue6_pushl,codeglue7_to_O.rewrite<- (ap_transport(concat_1p(glueq01))(funr=>toO(hfibergluer))_).applyap;unfoldhfiber;rewritetransport_sigma'.applyap;rewritetransport_paths_r.Finally, we have another terrible-looking thing involvingfrobnicate.  However, there are enough identity paths thatfrobnicateevaluates to... something that's almost fully path-general!  So with just a little bit of further work, we can reduce it also to something we can prove with path-induction.Transparentfrobnicate.cbn.Opaquefrobnicate.rewrite(transport_compose(funq=>glueq@ (glueq01)^ = 1%path)pr1).unfoldpath_sigma';rewriteap_V,ap_pr1_path_sigma,transport_1.destruct(glueq01);reflexivity.Qed.It should be possible to prove an analogouscontraction_code_leftdirectly, but for now we follow HFLL and ABFJ by introducing a surjectivity assumption.Definitioncontraction_code{y0:Y} (q00:Qx0y0)(pr: {p:P&leftx0=p}) (c:codepr.1pr.2):center_codepr.1pr.2 =c.Proof.revertc.srefine(transport(funpr'=>forallc,center_codepr'.1pr'.2 =c)(path_contr(righty0;glueq00)pr)_).clearpr;cbn;introsc.applycontraction_code_right.Defined.Definitioncontr_code_inhab(inh:merely{y0:Y&Qx0y0})(p:P) (r:leftx0=p):Contr(codepr).Proof.strip_truncations.destructinhas[y0q00].exact(Build_Contr_(center_codepr) (contraction_codeq00(p;r))).Defined.This version is sufficient for the classical Blakers-Massey theorem, as we'll see below, since its leg-wise connectivity hypothesis implies the above surjectivity assumption.  ABFJ have a different method for eliminating the surjectivity assumption using a lemma about pushouts of monos also being pullbacks, though it seems to only work for coderight.EndGBM.The classical Blakers-Massey TheoremGlobal Instanceblakers_massey`{Univalence} (mn:trunc_index){XY:Type} (Q:X->Y->Type)`{forally,IsConnectedm.+1 {x:X&Qxy} }`{forallx,IsConnectedn.+1 {y:Y&Qxy} }(x:X) (y:Y):IsConnMap(m+2+n) (@spglueXYQxy).Proof.introsr.snrefine(contr_code_inhabQ(m+2+n)_x(merely_isconnectedn_) (spushrQy)r).1:intros;applyisconnected_join.all:exact_.Defined.

--- Miscellaneous\bool.html ---
BoolLibrary BoolTheorems about the booleansRequireImportHoTT.Basics.RequireImportTypes.Equiv.Local OpenScopepath_scope.(* coq calls it "bool", we call it "Bool" *)LocalUnsetEliminationSchemes.InductiveBool:Type0:=|true:Bool|false:Bool.SchemeBool_ind:=InductionforBoolSortType.SchemeBool_rec:=MinimalityforBoolSortType.(* For compatibility with Coq'sinduction*)DefinitionBool_rect:=Bool_ind.AddPrintingIfBool.Declare Scopebool_scope.DelimitScopebool_scopewithBool.Bind Scopebool_scopewithBool.Definitionandb(b1b2:Bool) :Bool:=ifb1thenb2elsefalse.Definitionorb(b1b2:Bool) :Bool:=ifb1thentrueelseb2.Definitionnegb(b:Bool) :=ifbthenfalseelsetrue.Definitionimplb(b1b2:Bool) :Bool:=ifb1thenb2elsetrue.Infix"||" :=orb:bool_scope.Infix"&&" :=andb:bool_scope.Infix"->" :=implb:bool_scope.Definitionimplb_true{b} :implbbtrue=true:=ifbasbreturnimplbbtrue=truethenidpathelseidpath.Definitionimplb_impl{ab} : (a->b)%Bool=true<-> (a=true->b=true).Proof.destructa;simpl;split;trivialusingidpathwithnocore;destructb;simpl;autousingidpathwithnocore.Defined.Global Instancetrunc_ifnAB`{IsTruncnA,IsTruncnB} (b:Bool):IsTruncn(ifbthenAelseB) | 100:=ifbasbreturn(IsTruncn(ifbthenAelseB))then_else_.DecidabilitySectionBoolDecidable.Definitionfalse_ne_true: ~ (false=true):=funH=>matchHin(_=y)return(ifyreturnSetthenEmptyelseBool)with| 1%path=>trueend.Definitiontrue_ne_false: ~ (true=false):=funH=>false_ne_true(symmetry__H).Global Instancedecidable_paths_bool:DecidablePathsBool:=funxy=>matchxasx,yasyreturn((x=y) + ~(x=y))with|true,true=>inlidpath|false,false=>inlidpath|true,false=>inrtrue_ne_false|false,true=>inrfalse_ne_trueend.Definitionhset_bool:IsHSetBool:=_.EndBoolDecidable.In particular,negbhas no fixed pointsDefinitionnot_fixed_negb(b:Bool) :negbb<>b:=matchbreturnnegbb<>bwith|true=>false_ne_true|false=>true_ne_falseend.And conversely, if two elements ofBoolare unequal, they must be related bynegb.Definitionnegb_ne{b1b2:Bool}: (b1<>b2) -> (b1=negbb2).Proof.destructb1,b2.-introsoops;case(oopsidpath).-reflexivity.-reflexivity.-introsoops;case(oopsidpath).Defined.This version ofnegb_neis more convenient todestructagainst.Definitionnegb_ne'{b1b2:Bool}: (b1<>b2) -> (negbb1=b2).Proof.introsoops.symmetry.applynegb_ne.exact(symmetric_neqoops).Defined.Products asforalloverBoolSectionBoolForall.VariableP:Bool->Type.Letf(s:forallb,Pb) := (sfalse,strue).Letg(u:Pfalse*Ptrue) (b:Bool) :Pb:=matchbwith|false=>fstu|true=>snduend.Definitionequiv_bool_forall_prod`{Funext} :(forallb,Pb) <~>Pfalse*Ptrue.Proof.apply(equiv_adjointifyfg);repeat(reflexivity||intros[]||intro||applypath_forall).Defined.EndBoolForall.Definitionequiv_bool_rec_uncurried`{Funext} (P:Type) :P*P<~> (Bool->P):= (equiv_bool_forall_prod(fun_=>P))^-1%equiv.The typeBool<~>Boolis equivalent toBool.The nonidentity equivalence is negation (the flip).Global Instanceisequiv_negb:IsEquivnegb.Proof.refine(@Build_IsEquiv__negbnegb(funb=>ifbasbreturnnegb(negbb) =bthenidpathelseidpath)(funb=>ifbasbreturnnegb(negbb) =bthenidpathelseidpath)_).intros[];simpl;exactidpath.Defined.Definitionequiv_negb:Bool<~>Bool:=Build_EquivBoolBoolnegb_.Any equivalenceBool<~>Boolsendstrueandfalseto different things.Lemmaeval_bool_isequiv(f:Bool->Bool) `{IsEquivBoolBoolf}:ffalse=negb(ftrue).Proof.poseproof(eissectftrue).poseproof(eissectffalse).simplin*.destruct(ftrue), (ffalse).-etransitivity;try(eassumption|| (symmetry;eassumption)).-simpl.reflexivity.-simpl.reflexivity.-etransitivity;try(eassumption|| (symmetry;eassumption)).Defined.SectionEquivBoolEquiv.We will identify the constant equivalence withtrueand the flip equivalence withfalse, and do this by evaluating the equivalence function ontrue.Letf: (Bool<~>Bool) ->Bool:=fune=>etrue.Letg:Bool-> (Bool<~>Bool) :=funb=>ifbthen(equiv_idmapBool)elseequiv_negb.Definitionaut_bool_canonical(e:Bool<~>Bool):e==g(fe).Proof.unfoldf,g;clearfg;intros[];simpl.-destruct(etrue);reflexivity.-refine(eval_bool_isequive@_).destruct(etrue);reflexivity.Defined.Lemmaequiv_bool_aut_bool`{Funext} :Bool<~> (Bool<~>Bool).Proof.refine(equiv_adjointifygf__).-introe.applypath_equiv,path_forall.introsb;symmetry;applyaut_bool_canonical.-intros[];reflexivity.Defined.It follows that every automorphism ofBoolis eitheridmapornegb.Definitionaut_bool_idmap_or_negb`{Funext} (e:Bool<~>Bool): (e=equiv_idmapBool) + (e=equiv_negb).Proof.reverte.equiv_introequiv_bool_aut_boole.destructe;simpl.-exact(inlidpath).-exact(inridpath).Defined.But, obviously, not both.Definitionidmap_bool_ne_negb:equiv_idmapBool<>equiv_negb.Proof.introsoops.exact(true_ne_false(ap10_equivoopstrue)).Defined.In particular, every pair of automorphisms ofBoolcommute with each other.Definitionabelian_aut_bool(e1e2:Bool<~>Bool):e1oe2==e2oe1.Proof.introb.refine(ape1(aut_bool_canonicale2b) @_).refine(aut_bool_canonicale1_@_).refine(_@ape2(aut_bool_canonicale1b)^).refine(_@ (aut_bool_canonicale2_)^).unfoldf,g.destruct(e1true), (e2true),b;reflexivity.Defined.EndEquivBoolEquiv.

--- Miscellaneous\BoundedSearch.html ---
BoundedSearchLibrary BoundedSearchRequireImportHoTT.BasicsHoTT.Types.RequireImportHoTT.Truncations.Core.RequireImportHoTT.Spaces.Nat.Core.Sectionbounded_search.Context(P:nat->Type)(P_dec:foralln,Decidable(Pn))(P_inhab:hexists(funn=>Pn)).We open type_scope again after nat_scope in order to use the product type notation.Local OpenScopenat_scope.Local OpenScopetype_scope.Local Definitionminimal(n:nat) :Type:=forallm:nat,Pm->n<=m.If we assumeFunext, thenminimalnis a proposition.  But to avoid needingFunext, we propositionally truncate it.Local Definitionmin_n_Type:Type:= {n:nat&merely(Pn) *merely(minimaln) }.Local Instanceishpropmin_n:IsHPropmin_n_Type.Proof.applyishprop_sigma_disjoint.introsnn'[pm] [p'm'].strip_truncations.applyleq_antisym.-exact(mn'p').-exact(m'np).Defined.Local Definitionsmaller(n:nat) := {l:nat&Pl*minimall* (l<=n) }.Local Definitionsmaller_S(n:nat) (k:smallern) :smaller(Sn).Proof.destructkas[l[[pm]z]].existsl.repeatsplit.1,2:assumption.exact_.Defined.Local Definitionbounded_search(n:nat) :smallern+foralll:nat, (l<=n) ->not(Pl).Proof.inductionnas[|nIHn].-assert(P0 +not(P0))asX; [applyP_dec|].destructXas[h|].+left.refine(0;(h,_,_)).*intros? ?.exact_.+right.introsllleq0.assert(l0:l= 0)byrapplyleq_antisym.rewritel0;assumption.-destructIHnas[|n0].+left.applysmaller_S.assumption.+assert(P(n.+1) +not(P(n.+1)))asXbyapplyP_dec.destructXas[h|].*left.refine(n.+1;(h,_,_)).--introsmpm.assert((n.+1 <=m)+(n.+1>m))asXbyapplyleq_dichotomy.destructXas[leqSnm|ltmSn].++assumption.++unfoldgt,ltinltmSn.assert(m<=n)asXbyrapplyleq_pred'.destruct(n0mXpm).*right.introslq.assert((l<=n) + (l>n))asXbyapplyleq_dichotomy.destructXas[h|h].--exact(n0lh).--unfoldltinh.assert(eqlSn:l=n.+1)by(applyleq_antisym;assumption).rewriteeqlSn;assumption.Defined.Local Definitionn_to_min_n(n:nat) (Pn:Pn) :min_n_Type.Proof.assert(smallern+foralll, (l<=n) ->not(Pl))asXbyapplybounded_search.destructXas[[l[[Plml]leqln]]|none].-exact(l;(trPl,trml)).-destruct(nonen(leq_refln)Pn).Defined.Local Definitionprop_n_to_min_n:min_n_Type.Proof.refine(Trunc_rec_P_inhab).intros[nPn].exact(n_to_min_nnPn).Defined.Definitionminimal_n: {n:nat&Pn}.Proof.destructprop_n_to_min_nas[npl].destructplas[p_].exact(n;fstmerely_inhabited_iff_inhabited_stablep).Defined.Endbounded_search.Sectionbounded_search_alt_type.Context(X:Type)(e:nat<~>X)(P:X->Type)(P_dec:forallx,Decidable(Px))(P_inhab:hexists(funx=>Px)).Bounded search works for types equivalent to the naturals even without full univalence.Definitionminimal_n_alt_type: {x:X&Px}.Proof.set(P'n:=P(en)).assert(P'_dec:foralln,Decidable(P'n))byapply_.assert(P'_inhab:hexists(funn=>P'n)).{strip_truncations.applytr.destructP_inhabas[xp].exists(e^-1x).unfoldP'.rewrite(eisretre).exactp.}destruct(minimal_nP'P'_decP'_inhab)as[np'].exists(en).exactp'.Defined.Endbounded_search_alt_type.

--- Miscellaneous\Bouquet.html ---
BouquetLibrary BouquetRequireImportBasicsTypes.RequireImportPointedWildCat.RequireImportAlgebra.Groups.RequireImportModalities.ReflectiveSubuniverseTruncations.Core.RequireImportHomotopy.Suspension.RequireImportHomotopy.ClassifyingSpace.RequireImportHomotopy.HomotopyGroup.Local OpenScopetrunc_scope.Local OpenScopepointed_scope.ImportClassifyingSpaceNotation.In this file we show that the fundamental group of a bouquet of circles indexed by a type S is the free group on that type S. We begin by defining S-indexed wedges of circles as the suspension of the pointification of S.SectionAssumeUnivalence.Context`{Univalence}.An S-indexed wedge of circles a.k.a a bouquet can be defined as the suspension of the pointification of S.DefinitionBouquet(S:Type) :pType:=psusp(pointifyS).Global Instanceisconnected_bouquet(S:Type):IsConnected0 (BouquetS).Proof.rapplyisconnected_susp.Defined.We can directly prove that it satisfies the desired equivalence together with naturality in the second argument.Lemmanatequiv_pi1bouquet_rec(S:Type):NatEquiv(opyon(Pi1 (BouquetS)))(opyonSogroup_type).Proof.Pointifynrefine(natequiv_compose__).1:refine(natequiv_prewhisker(natequiv_pointify_rS)ptype_group).Post-compose withpequiv_loops_bg_gnrefine(natequiv_compose__).1:rapply(natequiv_postwhisker_(natequiv_inversenatequiv_g_loops_bg)).Loop-susp adjointnrefine(natequiv_compose__).1:refine(natequiv_prewhisker(natequiv_loop_susp_adjoint_r(pointifyS))B).Pi1-BG adjunctionrapplynatequiv_bg_pi1_adjoint.Defined.For the rest of this file, we don't need to unfold this.Local Opaquenatequiv_pi1bouquet_rec.Theoremequiv_pi1bouquet_rec(S:Type) (G:Group): (Pi1 (BouquetS) $->G) <~> (S->G).Proof.applynatequiv_pi1bouquet_rec.Defined.Global Instanceis1natural_equiv_pi1bouquet_rec(S:Type):Is1Natural(opyon(Pi1 (BouquetS)))(opyonSogroup_type)(funG=>equiv_pi1bouquet_recSG).Proof.rapply(is1natural_natequiv(natequiv_pi1bouquet_rec_)).Defined.We can define the inclusion map by using the previous equivalence on the identity group homomorphism.Definitionpi1bouquet_incl(S:Type):S->Pi1 (BouquetS).Proof.rapplyequiv_pi1bouquet_rec.applygrp_homo_id.Defined.The fundemental group of an S-bouquet is the free group on S.Global Instanceisfreegroupon_pi1bouquet(S:Type):IsFreeGroupOnS(Pi1 (BouquetS)) (pi1bouquet_inclS).Proof.applyequiv_isfreegroupon_isequiv_precomp.introG.snrapplyisequiv_homotopic'.1:applyequiv_pi1bouquet_rec.introsf.refine(_@ @is1natural_equiv_pi1bouquet_recS__fgrp_homo_id).simpl;f_ap;symmetry.rapply(cat_idr_strongf).Defined.EndAssumeUnivalence.

--- Miscellaneous\canonical_names.html ---
canonical_namesLibrary canonical_namesRequireExportHoTT.BasicsHoTT.TypesHoTT.Truncations.Core.Declare Scopemc_scope.DelimitScopemc_scopewithmc.Global OpenScopemc_scope.Generalizable VariablesABfgxy.Monomorphic UniverseUlargeUhuge.Monomorphic ConstraintUlarge<Uhuge.Lemmamerely_destruct{A} {P:Type} {sP:IsHPropP}(x:merelyA) : (A->P) ->P.Proof.introsE;revertx.applyTrunc_ind.-apply_.-exactE.Qed.Notation" g ∘ f " := (Composegf)%mc.Notation"(∘)" :=Compose(onlyparsing) :mc_scope.Definitionid{A:Type} (a:A) :=a.Notation"(=)" :=paths(onlyparsing) :mc_scope.Notation"( x =)" := (pathsx) (onlyparsing) :mc_scope.Notation"(= x )" := (funy=>pathsyx) (onlyparsing) :mc_scope.Notation"(<>)" := (funxy=> ~x=y) (onlyparsing) :mc_scope.Notation"( x <>)" := (funy=>x<>y) (onlyparsing) :mc_scope.Notation"(<> x )" := (funy=>y<>x) (onlyparsing) :mc_scope.ClassApartA:=apart:RelationA.Infix"≶" :=apart:mc_scope.Notation"(≶)" :=apart(onlyparsing) :mc_scope.Notation"( x ≶)" := (apartx) (onlyparsing) :mc_scope.Notation"(≶ x )" := (funy=>apartyx) (onlyparsing) :mc_scope.(* Even for setoids with decidable equality x <> y does not imply x ≶ y.Therefore we introduce the following class. *)ClassTrivialApartA{Aap:ApartA} :={trivial_apart_prop:is_mere_relationAapart;trivial_apart:forallxy,x≶y<->x<>y}.#[export]ExistingInstancetrivial_apart_prop.Definitionsig_apart`{ApartA} (P:A->Type) :Apart(sigP) :=funxy=>x.1 ≶y.1.#[export]HintExtern10 (Apart(sig_)) =>apply@sig_apart:typeclass_instances.ClassCastAB:=cast:A->B.Argumentscast__{Cast}_.Notation"' x" := (cast__x) :mc_scope.#[global]TypeclassesTransparentCast.(* Other canonically named relations/operations/constants: *)ClassSgOpA:=sg_op:A->A->A.ClassMonUnitA:=mon_unit:A.ClassPlusA:=plus:A->A->A.ClassMultA:=mult:A->A->A.ClassOneA:=one:A.ClassZeroA:=zero:A.ClassNegateA:=negate:A->A.ClassDecRecipA:=dec_recip:A->A.DefinitionApartZeroR`{ZeroR} `{ApartR} :=sig(≶zero).ClassRecipA`{ApartA} `{ZeroA} :=recip:ApartZeroA->A.#[global]TypeclassesTransparentSgOpMonUnitPlusMultZeroOneNegate.ClassMeetA:=meet:A->A->A.ClassJoinA:=join:A->A->A.ClassTopA:=top:A.ClassBottomA:=bottom:A.#[global]TypeclassesTransparentMeetJoinTopBottom.ClassLeA:=le:RelationA.ClassLtA:=lt:RelationA.#[global]TypeclassesTransparentLeLt.DefinitionNonNegR`{ZeroR} `{LeR} :=sig(lezero).DefinitionPosR`{ZeroR} `{LtR} :=sig(ltzero).DefinitionNonPosR`{ZeroR} `{LeR} :=sig(funy=>leyzero).Global Instanceplus_is_sg_op`{f:PlusA} :SgOpA:=f.Global Instancemult_is_sg_op`{f:MultA} :SgOpA:=f.Global Instanceone_is_mon_unit`{c:OneA} :MonUnitA:=c.Global Instancezero_is_mon_unit`{c:ZeroA} :MonUnitA:=c.Global Instancemeet_is_sg_op`{f:MeetA} :SgOpA:=f.Global Instancejoin_is_sg_op`{f:JoinA} :SgOpA:=f.Global Instancetop_is_mon_unit`{s:TopA} :MonUnitA:=s.Global Instancebottom_is_mon_unit`{s:BottomA} :MonUnitA:=s.#[export]HintExtern4 (Apart(ApartZero_)) =>apply@sig_apart:typeclass_instances.#[export]HintExtern4 (Apart(NonNeg_)) =>apply@sig_apart:typeclass_instances.#[export]HintExtern4 (Apart(Pos_)) =>apply@sig_apart:typeclass_instances.We group these notations into a module, so that just this subset can be exported in some cases.ModuleExportBinOpNotations.(* Notations: *)Declare Scopemc_add_scope.Infix"+" :=sg_op:mc_add_scope.Notation"(+)" :=sg_op(onlyparsing) :mc_add_scope.Notation"( x +)" := (sg_opx) (onlyparsing) :mc_add_scope.Notation"(+ x )" := (funy=>sg_opyx) (onlyparsing) :mc_add_scope.Declare Scopemc_mult_scope.Infix"*" :=sg_op:mc_mult_scope.Notation"( x *.)" := (sg_opx) (onlyparsing) :mc_mult_scope.Notation"(.*.)" :=sg_op(onlyparsing) :mc_mult_scope.Notation"(.* x )" := (funy=>sg_opyx) (onlyparsing) :mc_mult_scope.Infix"+" :=plus:mc_scope.Notation"(+)" :=plus(onlyparsing) :mc_scope.Notation"( x +)" := (plusx) (onlyparsing) :mc_scope.Notation"(+ x )" := (funy=>y+x) (onlyparsing) :mc_scope.Infix"*" :=mult:mc_scope.(* We don't add "( * )", "( * x )" and "( x * )" notationsbecause they conflict with comments. *)Notation"( x *.)" := (multx) (onlyparsing) :mc_scope.Notation"(.*.)" :=mult(onlyparsing) :mc_scope.Notation"(.* x )" := (funy=>y*x) (onlyparsing) :mc_scope.Notation"- x" := (negatex) :mc_scope.Notation"(-)" :=negate(onlyparsing) :mc_scope.Notation"x - y" := (x+ -y) :mc_scope.Notation"0" :=zero:mc_scope.Notation"1" :=one:mc_scope.Notation"2" := (1 + 1) :mc_scope.Notation"3" := (1 + (1 + 1)) :mc_scope.Notation"4" := (1 + (1 + (1 + 1))) :mc_scope.Notation"5" := (1 + (1 + (1 + (1 + 1)))) :mc_scope.Notation"6" := (1 + (1 + (1 + (1 + (1 + 1))))) :mc_scope.Notation"- 1" := (-(1)) :mc_scope.Notation"- 2" := (-(2)) :mc_scope.Notation"- 3" := (-(3)) :mc_scope.Notation"- 4" := (-(4)) :mc_scope.EndBinOpNotations.Notation"/ x" := (dec_recipx) :mc_scope.Notation"(/)" :=dec_recip(onlyparsing) :mc_scope.Notation"x / y" := (x* /y) :mc_scope.Notation"// x" := (recipx) :mc_scope.Notation"(//)" :=recip(onlyparsing) :mc_scope.Notation"x // y" := (x* //y) :mc_scope.Notation"⊤" :=top:mc_scope.Notation"⊥" :=bottom:mc_scope.Infix"⊓" :=meet:mc_scope.Notation"(⊓)" :=meet(onlyparsing) :mc_scope.Notation"( X ⊓)" := (meetX) (onlyparsing) :mc_scope.Notation"(⊓ X )" := (funY=>Y⊓X) (onlyparsing) :mc_scope.Infix"⊔" :=join:mc_scope.Notation"(⊔)" :=join(onlyparsing) :mc_scope.Notation"( X ⊔)" := (joinX) (onlyparsing) :mc_scope.Notation"(⊔ X )" := (funY=>Y⊔X) (onlyparsing) :mc_scope.Infix"≤" :=le:mc_scope.Notation"(≤)" :=le(onlyparsing) :mc_scope.Notation"( x ≤)" := (lex) (onlyparsing) :mc_scope.Notation"(≤ x )" := (funy=>y≤x) (onlyparsing) :mc_scope.Infix"<=" :=le(onlyparsing) :mc_scope.Notation"(<=)" :=le(onlyparsing) :mc_scope.Notation"( x <=)" := (lex) (onlyparsing) :mc_scope.Notation"(<= x )" := (funy=>y≤x) (onlyparsing) :mc_scope.Infix"<" :=lt:mc_scope.Notation"(<)" :=lt(onlyparsing) :mc_scope.Notation"( x <)" := (ltx) (onlyparsing) :mc_scope.Notation"(< x )" := (funy=>y<x) (onlyparsing) :mc_scope.Notation"x ≤ y ≤ z" := (x≤y/\y≤z) :mc_scope.Notation"x ≤ y < z" := (x≤y/\y<z) :mc_scope.Notation"x < y < z" := (x<y/\y<z) :mc_scope.Notation"x < y ≤ z" := (x<y/\y≤z) :mc_scope.It is likely that ≤ and < are transitive (and ≤ reflexive) so informautoof this.Ltacauto_trans:=matchgoalwith[H: ?R?x?y,I: ?R?y?z|- ?R?x?z] =>apply(transitivityHI)end.#[export]HintExtern2 (?x≤ ?y) =>reflexivity:core.#[export]HintExtern4 (?x≤ ?z) =>auto_trans:core.#[export]HintExtern4 (?x< ?z) =>auto_trans:core.ClassAbsA`{LeA} `{ZeroA} `{NegateA}:=abs_sig:forall(x:A), {y:A| (0 ≤x->y=x) /\ (x≤ 0 ->y= -x)}.Definitionabs`{AbsA} :=funx:A=> (abs_sigx).1.(* Common properties: *)(* Class Inverse `(A -> B) : Type := inverse: B -> A.Arguments inverse {A B} _ {Inverse} _.Typeclasses Transparent Inverse.Notation "f ⁻¹" := (inverse f) : mc_scope. *)ClassIdempotent`(f:A->A->A) (x:A) :Type:=idempotency:fxx=x.Argumentsidempotency{A}__{Idempotent}.ClassUnaryIdempotent{A} (f:A->A) :Type:=unary_idempotent:IdempotentComposef.#[export]ExistingInstancesunary_idempotent.Lemmaunary_idempotency`{UnaryIdempotentAf}x:f(fx) =fx.Proof.change(f(fx))with(Composeffx).apply(ap(fung=>gx)).change(Composeff=f).applyidempotency.apply_.Qed.ClassBinaryIdempotent`(op:A->A->A) :Type:=binary_idempotent:forallx,Idempotentopx.#[export]ExistingInstancesbinary_idempotent.ClassLeftIdentity{AB} (op:A->B->B) (x:A):Type:=left_identity:forally,opxy=y.ClassRightIdentity{AB} (op:A->B->A) (y:B):Type:=right_identity:forallx,opxy=x.ClassAbsorption{ABC} (op1:A->C->A) (op2:A->B->C) :Type:=absorption:forallxy,op1x(op2xy) =x.ClassLeftAbsorb{AB} (op:A->B->A) (x:A):Type:=left_absorb:forally,opxy=x.ClassRightAbsorb{AB} (op:A->B->B) (y:B):Type:=right_absorb:forallx,opxy=y.ClassLeftInverse{A} {B} {C} (op:A->B->C) (inv:B->A) (unit:C):=left_inverse:forallx,op(invx)x=unit.ClassRightInverse{A} {B} {C} (op:A->B->C) (inv:A->B) (unit:C):=right_inverse:forallx,opx(invx) =unit.ClassCommutative{BA} (f:A->A->B) :Type:=commutativity:forallxy,fxy=fyx.#[global]TypeclassesTransparentCommutative.ClassHeteroAssociative{ABCABBCABC}(fA_BC:A->BC->ABC) (fBC:B->C->BC)(fAB_C:AB->C->ABC) (fAB:A->B->AB):Type:=associativity:forallxyz,fA_BCx(fBCyz) =fAB_C(fABxy)z.ClassAssociative{A} (f:A->A->A):=simple_associativity:HeteroAssociativeffff.#[export]ExistingInstancessimple_associativity.ClassInvolutive{A} (f:A->A) :=involutive:forallx,f(fx) =x.ClassTotalRelation`(R:RelationA) :Type:=total:forallxy:A,Rxy|_|Ryx.Argumentstotal{A}_{TotalRelation}__.ClassTrichotomy`(R:RelationA):=trichotomy:forallxy:A,Rxy|_|x=y|_|Ryx.Argumentstrichotomy{A}R{Trichotomy}__.Argumentsirreflexivity{A}_{Irreflexive}__.ClassCoTransitive`(R:RelationA) :Type:=cotransitive:forallxy,Rxy->forallz,hor(Rxz) (Rzy).Argumentscotransitive{ARCoTransitivexy}__.ClassEquivRel`(R:RelationA) :Type:=Build_EquivRel{EquivRel_Reflexive:ReflexiveR;EquivRel_Symmetric:SymmetricR;EquivRel_Transitive:TransitiveR}.#[export]ExistingInstancesEquivRel_ReflexiveEquivRel_SymmetricEquivRel_Transitive.DefinitionSigEquivRel{A:Type} (R:RelationA) :Type:={_:ReflexiveR| {_:SymmetricR|TransitiveR}}.Global Instancetrunc_sig_equiv_rel`{Funext} {A:Type}(R:RelationA) {n} `{!forall(xy:A),IsTruncn(Rxy)}:IsTruncn(SigEquivRelR).Proof.apply@istrunc_sigma.-applyistrunc_forall.-intros.apply@istrunc_sigma;intros;applyistrunc_forall.Defined.Lemmaissig_equiv_rel{A:Type} (R:RelationA):SigEquivRelR<~>EquivRelR.Proof.issig.Defined.Global Instanceistrunc_equiv_rel`{Funext} {A:Type}(R:RelationA) {n} `{!forall(xy:A),IsTruncn(Rxy)}:IsTruncn(EquivRelR).Proof.exact(istrunc_equiv_istrunc(SigEquivRelR) (issig_equiv_relR)).Qed.ClassConjugateA:=conj:A->A.ClassDistrOpp{A} `(SgOpA) `(ConjugateA):=distropp:forallxy:A,conj(sg_opxy) =sg_op(conjy) (conjx).ClassSwapOp{A} `(NegateA) `(ConjugateA):=swapop:forallx,conj(-x) = - (conjx).ClassFactorNegLeft{A} `(NegateA) `(SgOpA):=factorneg_l:forallxy,sg_op(-x)y= - (sg_opxy).ClassFactorNegRight{A} `(NegateA) `(SgOpA):=factorneg_r:forallxy,sg_opx(-y) = - (sg_opxy).ClassLeftHeteroDistribute{ABC}(f:A->B->C) (g_r:B->B->B) (g:C->C->C) :Type:=distribute_l:forallabc,fa(g_rbc) =g(fab) (fac).ClassRightHeteroDistribute{ABC}(f:A->B->C) (g_l:A->A->A) (g:C->C->C) :Type:=distribute_r:forallabc,f(g_lab)c=g(fac) (fbc).ClassLeftDistribute{A} (fg:A->A->A):=simple_distribute_l:LeftHeteroDistributefgg.#[export]ExistingInstancessimple_distribute_l.ClassRightDistribute{A} (fg:A->A->A):=simple_distribute_r:RightHeteroDistributefgg.#[export]ExistingInstancessimple_distribute_r.ClassHeteroSymmetric{A} {T:A->A->Type}(R:forall{xy},Txy->Tyx->Type) :Type:=hetero_symmetric`(a:Txy) (b:Tyx) :Rab->Rba.(* Although cancellation is the same as being injective, we want a propername to refer to this commonly used property. *)Sectioncancellation.Context`(op:A->A->A) (z:A).ClassLeftCancellation:=left_cancellation:forallxy,opzx=opzy->x=y.ClassRightCancellation:=right_cancellation:forallxy,opxz=opyz->x=y.Context{Aap:ApartA}.ClassStrongLeftCancellation:=strong_left_cancellation:forallxy,x≶y->opzx≶opzy.ClassStrongRightCancellation:=strong_right_cancellation:forallxy,x≶y->opxz≶opyz.Endcancellation.(* Common names for properties that hold in N, Z, Q, ... *)ClassZeroProductA`{!MultA} `{!ZeroA} :Type:=zero_product:forallxy,x*y= 0 ->x= 0 |_|y= 0.ClassZeroDivisor{R} `{ZeroR} `{MultR} (x:R) :Type:=zero_divisor:x<> 0 /\existsy,y<> 0 /\x*y= 0.ClassNoZeroDivisorsR`{ZeroR} `{MultR} :Type:=no_zero_divisorsx: ~ZeroDivisorx.Global Instancezero_product_no_zero_divisors`{ZeroProductA}:NoZeroDivisorsA.Proof.introsx[? [? [?E]]].destruct(zero_product__E);auto.Qed.(* A common induction principle for both the naturals and integers *)ClassBiinductionR`{ZeroR} `{OneR} `{PlusR} :Type:=biinduction(P:R->Type):P0 -> (foralln,Pn<->P(1 +n)) ->foralln,Pn.Additional operationsClassCutMinusA:=cut_minus:A->A->A.Infix"∸" :=cut_minus:mc_scope.Notation"(∸)" :=cut_minus(onlyparsing) :mc_scope.Notation"( x ∸)" := (cut_minusx) (onlyparsing) :mc_scope.Notation"(∸ y )" := (funx=>x∸y) (onlyparsing) :mc_scope.Inductivecomparison:Set:=LT|EQ|GT.ClassCompareA:=compare:A->A->comparison.Infix"?=" :=compare:mc_scope.Notation"(?=)" :=compare(onlyparsing) :mc_scope.Notation"( x ?=)" := (comparex) (onlyparsing) :mc_scope.Notation"(?= y )" := (funx=>x?=y) (onlyparsing) :mc_scope.ClassEqbA:=eqb:A->A->Bool.Infix"=?" :=eqb:mc_scope.Notation"(=?)" :=eqb(onlyparsing) :mc_scope.Notation"( x =?)" := (eqbx) (onlyparsing) :mc_scope.Notation"(=? y )" := (funx=>x=?y) (onlyparsing) :mc_scope.ClassLtbA:=ltb:A->A->Bool.Infix"<?" :=ltb:mc_scope.Notation"(<?)" :=ltb(onlyparsing) :mc_scope.Notation"( x <?)" := (ltbx) (onlyparsing) :mc_scope.Notation"(<? y )" := (funx=>x<?y) (onlyparsing) :mc_scope.ClassLebA:=leb:A->A->Bool.Infix"<=?" :=leb:mc_scope.Notation"(<=?)" :=leb(onlyparsing) :mc_scope.Notation"( x <=?)" := (lebx) (onlyparsing) :mc_scope.Notation"(<=? y )" := (funx=>x<=?y) (onlyparsing) :mc_scope.ClassReturn(M:Type->Type) :=ret:forall{A},A->MA.ClassBind(M:Type->Type) :=bind:forall{AB},MA-> (A->MB) ->MB.ClassEnumerable@{i} (A:Type@{i}) :={enumerator:nat->A;enumerator_issurj:IsSurjectionenumerator}.#[export]ExistingInstanceenumerator_issurj.ArgumentsenumeratorA{_}_.Argumentsenumerator_issurjA{_}_.(*The following class is nice to parametrize instances by additional properties, for example:forallz,PropHolds(z<>0)->LeftCancellationopzThis tool is very powerful as we can combine it with instances as:forallxy,PropHolds(x<>0)->PropHolds(y<>0)->PropHolds(x*y<>0)Of course, one should be very careful not to make too many instances as that couldeasily lead to a blow-up of the search space (or worse, cycles).*)ClassPropHolds(P:Type) :=prop_holds:P.#[export]HintExtern0 (PropHolds_) =>assumption:typeclass_instances.Ltacsolve_propholds:=matchgoalwith| [ |-PropHolds(?P) ] =>apply_| [ |- ?P] =>change(PropHoldsP);apply_end.

--- Miscellaneous\Cantor.html ---
CantorLibrary CantorRequireImportHoTT.BasicsHoTT.Types.RequireImportIdempotents.RequireImportHoTT.Truncations.CoreUniverses.BAutSpaces.Cantor.Local OpenScopeequiv_scope.Local OpenScopepath_scope.BAut(Cantor)A pre-idempotent onBAutCantorthat does not splitWe go into a non-exported module so that we can use short names for definitions without polluting the global namespace.ModuleBAut_Cantor_Idempotent.SectionAssumptions.Context`{Univalence}.Definitionf:BAutCantor->BAutCantor.Proof.introsZ.Here is the important part of this definition.exists(Z+Cantor).The rest is just a proof thatZ+Cantoris again equivalent toCantor, usingcantor_foldand the assumption thatZis equivalent toCantor.pose(e:=Z.2);simpline;clearbodye.strip_truncations.applytr.applypath_universe_uncurried.refine(equiv_cantor_foldoE_).refine(equiv_path__e+E1).Defined.For the pre-idempotence off, the main point is again the existence of the equivalencefold_cantor.Definitionpreidem_f:IsPreIdempotentf.Proof.introsZ.applypath_baut.unfoldf;simpl.refine(_oEequiv_sum_assocZCantorCantor).apply(1 +Eequiv_cantor_fold).Defined.We record how the action offandfofon paths corresponds to an action on equivalences.Definitionap_f{ZZ':BAutCantor} (p:Z=Z'):equiv_path__(apfp)..1=equiv_pathZZ'p..1 +E1.Proof.destructp.applypath_equiv,path_arrow.intros[z|a];reflexivity.Defined.Definitionap_ff{ZZ':BAutCantor} (p:Z=Z'):equiv_path__(ap(fof)p)..1=equiv_pathZZ'p..1 +E1 +E1.Proof.destructp.applypath_equiv,path_arrow.intros[[z|a]|a];reflexivity.Defined.Now let's assumefis quasi-idempotent, but not necessarily using the same witness of pre-idempotency.Context(Ip:IsPreIdempotentf) (Jp: @IsQuasiIdempotent_fIp).DefinitionI(Z:BAutCantor): (Z+Cantor) +Cantor<~>Z+Cantor:=equiv_path__(IpZ)..1.DefinitionI0:Cantor+Cantor+Cantor+Cantor<~>Cantor+Cantor+Cantor:=I(f(point(BAutCantor))).We don't know much aboutI0, but we can show that it maps the rightmost two summands to the rightmost one, using the naturality ofI.  Here is the naturality.DefinitionInat(ZZ':BAutCantor) (e:Z<~>Z'):IZ'oE(e+E1 +E1)= (e+E1)oEIZ.Proof.reverte;equiv_intro(equiv_pathZZ')q.revertq;equiv_intro((equiv_path_sigma_hpropZZ')^-1)p.simpl.rewrite<-ap_ff, <-ap_f.unfoldI.refine((equiv_path_pp__)^ @_@ (equiv_path_pp__)).applyap.refine((pr1_path_pp(ap(fof)p) (IpZ'))^ @_@pr1_path_pp__).applyap.apply(concat_ApIp).Qed.To show our claim about the action ofI0, we will apply this naturality to the flip automorphism ofCantor+Cantor.  Here are the images of that automorphism underfandfof.Definitionf_flip:=equiv_sum_symmCantorCantor+Eequiv_idmapCantor.Definitionff_flip:=(equiv_sum_symmCantorCantor+Eequiv_idmapCantor) +E(equiv_idmapCantor).The naturality ofIimplies thatI0commutes with these images of the flip.DefinitionI0nat_flip(x: ((Cantor+Cantor) +Cantor) +Cantor):I0(ff_flipx) =f_flip(I0x):=ap10_equiv(Inat(f(point(BAutCantor))) (f(point(BAutCantor)))(equiv_sum_symmCantorCantor))x.The value of this is that we can detect which summand an element is in depending on whether or not it is fixed byf_fliporff_flip.Definitionf_flip_fixed_iff_inr(x:Cantor+Cantor+Cantor): (f_flipx=x) <->is_inrx.Proof.split;introsp;destructxas[[c|c]|c];simplinp.-applypath_sum_inlinp.elim(inl_ne_inr__p^).-applypath_sum_inlinp.elim(inl_ne_inr__p).-exacttt.-elimp.-elimp.-reflexivity.Defined.Definitionff_flip_fixed_iff_inr(x:Cantor+Cantor+Cantor+Cantor): (ff_flipx=x) <-> (is_inrx+is_inl_andis_inrx).Proof.split;introsp;destructxas[[[c|c]|c]|c];simplinp.-do2applypath_sum_inlinp.elim(inl_ne_inr__p^).-do2applypath_sum_inlinp.elim(inl_ne_inr__p).-exact(inrtt).-exact(inltt).-destructpas[e|e];elime.-destructpas[e|e];elime.-destructpas[e|_]; [elime|reflexivity].-destructpas[_|e]; [reflexivity|elime].Defined.And the naturality guarantees thatI0preserves fixed points.DefinitionI0_fixed_iff_fixed(x:Cantor+Cantor+Cantor+Cantor): (ff_flipx=x) <-> (f_flip(I0x) =I0x).Proof.split;introsp.-refine((I0nat_flipx)^ @apI0p).-apply(equiv_injI0).refine(I0nat_flipx@p).Defined.Putting it all together, here is the proof of our claim aboutI0.DefinitionI0_preserves_inr(x:Cantor+Cantor+Cantor+Cantor): (is_inrx+is_inl_andis_inrx) <->is_inr(I0x).Proof.refine(iff_compose_(f_flip_fixed_iff_inr(I0x))).refine(iff_compose_(I0_fixed_iff_fixedx)).applyiff_inverse,ff_flip_fixed_iff_inr.Defined.Now we bring quasi-idempotence into play.DefinitionJ(Z:BAutCantor):IZ+E1=I(fZ).Proof.unfoldI;simpl.refine((ap_f(IpZ))^ @_).do2applyap.applyJp.Defined.We reach a contradiction by showing that the two maps whichJclaims are equal send elements of the third summand of the domain into different summands of the codomain.Definitionimpossible:Empty.Proof.pose(x:=inl(inr(funn=>true)): ((f(point(BAutCantor))) +Cantor) +Cantor).apply(not_is_inl_and_inr'(I(f(point(BAutCantor)))x)).-exact(transportis_inl(ap10_equiv(J(point(BAutCantor)))x)tt).-exact(fst(I0_preserves_inrx) (inrtt)).Defined.EndAssumptions.EndBAut_Cantor_Idempotent.Let's make the important conclusions available globally.Definitionbaut_cantor_idem`{Univalence}:BAutCantor->BAutCantor:=BAut_Cantor_Idempotent.f.Definitionpreidem_baut_cantor_idem`{Univalence}:IsPreIdempotentbaut_cantor_idem:=BAut_Cantor_Idempotent.preidem_f.Definitionnot_qidem_baut_cantor_idem`{Univalence}: ~ {I:IsPreIdempotentbaut_cantor_idem&IsQuasiIdempotentbaut_cantor_idem}:=funIJ=>BAut_Cantor_Idempotent.impossibleIJ.1IJ.2.

--- Miscellaneous\Card.html ---
CardLibrary CardRepresentation of cardinals, see Chapter 10 of the HoTT book.RequireImportHoTT.Universes.TruncType.RequireImportHoTT.Classes.interfaces.abstract_algebra.This speeds things up considerablyLocal Opaqueequiv_isequivistrunc_isequiv_istrunc.Definitions and operationsDefinitionCard:=Trunc0HSet.DefinitioncardA`{IsHSetA} :Card:=tr(Build_HSetA).Definitionsum_card(ab:Card) :Card.Proof.strip_truncations.refine(tr(Build_HSet(a+b))).Defined.Definitionprod_card(ab:Card) :Card.Proof.strip_truncations.refine(tr(Build_HSet(a*b))).Defined.Definitionexp_card`{Funext} (ba:Card) :Card.Proof.strip_truncations.refine(tr(Build_HSet(b->a))).Defined.Definitionleq_card`{Univalence} :Card->Card->HProp.Proof.refine(Trunc_rec(funa=>_)).refine(Trunc_rec(funb=>_)).exact(hexists(fun(i:a->b) =>IsInjectivei)).Defined.PropertiesSectioncontents.Context`{Univalence}.Global Instanceplus_card:PlusCard:=sum_card.Global Instancemult_card:MultCard:=prod_card.Global Instancezero_card:ZeroCard:=tr(Build_HSetEmpty).Global Instanceone_card:OneCard:=tr(Build_HSetUnit).Global Instancele_card:LeCard:=leq_card.(* Reduce an algebraic equation to an equivalence *)Local Ltacreduce:=repeat(intros?);strip_truncations;cbn;f_ap;applypath_hset.(* Simplify an equation by unfolding all the definitions apart fromthe actual operations. *)(* Note that this is an expensive thing to do, and will be very slow unless we tell it not to unfold the following. *)Local Ltacsimpl_ops:=cbv-[plus_cardmult_cardzero_cardone_cardexp_card].We only make the instances of upper classes global, since the
  other instances will be project anyway.Cardis a semi-ringInstanceassociative_sum:Associativeplus_card.Proof.reduce.symmetry.applyequiv_sum_assoc.Defined.Instancerightid_sum:RightIdentityplus_cardzero_card.Proof.reduce.applysum_empty_r.Defined.Instancecommutative_sum:Commutativeplus_card.Proof.reduce.applyequiv_sum_symm.Defined.Instanceassociative_prod:Associativemult_card.Proof.reduce.applyequiv_prod_assoc.Defined.Instancerightid_prod:RightIdentitymult_cardone_card.Proof.reduce.applyprod_unit_r.Defined.Instancecommutative_prod:Commutativemult_card.Proof.reduce.applyequiv_prod_symm.Defined.Instanceleftdistributive_card:LeftDistributemult_cardplus_card.Proof.reduce.applysum_distrib_l.Defined.Instanceleftabsorb_card:LeftAbsorbmult_cardzero_card.Proof.reduce.applyprod_empty_l.Defined.Global Instanceissemiring_card:IsSemiCRingCard.Proof.repeatsplit;tryapply_.-repeatintro.simpl_ops.rewrite(commutativityzero_card_).applyrightid_sum.-repeatintro.simpl_ops.rewrite(commutativityone_card_).applyrightid_prod.Defined.Properties of exponentiationLemmaexp_zero_card(a:Card) :exp_card0a= 1.Proof.simpl_ops.reduce.symmetry.applyequiv_empty_rec.Defined.Lemmaexp_card_one(a:Card) :exp_carda1 = 1.Proof.simpl_ops.reduce.symmetry.applyequiv_unit_coind.Defined.Lemmaexp_one_card(a:Card) :exp_card1a=a.Proof.reduce.symmetry.applyequiv_unit_rec.Defined.Lemmaexp_card_sum_mult(abc:Card) :exp_card(b+c)a= (exp_cardba) * (exp_cardca).Proof.reduce.symmetry.applyequiv_sum_distributive.Defined.Lemmaexp_mult_card_exp(abc:Card) :exp_card(b*c)a=exp_cardc(exp_cardba).Proof.rewrite(@commutativity__(.*.)_bc).reduce.symmetry.applyequiv_uncurry.Defined.Lemmaexp_card_mult_mult(abc:Card) :exp_cardc(a*b) = (exp_cardca) * (exp_cardcb).Proof.reduce.symmetry.applyequiv_prod_coind.Defined.Properties of ≤Instancereflexive_card:Reflexiveleq_card.Proof.introx.strip_truncations.applytr.existsidmap.refine(fun__=>idmap).Defined.Instancetransitive_card:Transitiveleq_card.Proof.introsabc.strip_truncations.introsHabHbc.strip_truncations.destructHabas[iabHab].destructHbcas[ibcHbc].applytr.exists(ibc∘iab).introsxyHxy.applyHab.applyHbc.applyHxy.Defined.Global Instancepreorder_card:PreOrderle_card.Proof.split;apply_.Defined.Endcontents.Cardinality comparisons(* We also work with cardinality comparisons directly to avoid unnecessary type truncations via cardinals. *)DefinitionInjectionXY:={f:X->Y|IsInjectivef}.Global InstanceInjection_refl:ReflexiveInjection.Proof.introsX.exists(funx=>x).introsxx'.done.Qed.LemmaInjection_transXYZ:InjectionXY->InjectionYZ->InjectionXZ.Proof.intros[fHf] [gHg].exists(funx=>g(fx)).introsxx'H.byapplyHf,Hg.Qed.DefinitionInjectsIntoXY:=merely(InjectionXY).Global InstanceInjectsInto_refl:ReflexiveInjectsInto.Proof.introsX.applytr.reflexivity.Qed.LemmaInjectsInto_transXYZ:InjectsIntoXY->InjectsIntoYZ->InjectsIntoXZ.Proof.introsH1H2.eapplymerely_destruct;tryapplyH1.intros[fHf].eapplymerely_destruct;tryapplyH2.intros[gHg].applytr.exists(funx=>g(fx)).introsxx'H.byapplyHf,Hg.Qed.Infinity(* We call a set infinite if nat embeds into it. *)DefinitioninfiniteX:=InjectionnatX.

--- Miscellaneous\Cat.html ---
CatLibrary CatCat, precategories of precategoriesDefinitionsRequireCat.Core.Morphisms in catRequireCat.Morphisms.IncludeCat.Core.IncludeCat.Morphisms.

--- Miscellaneous\Categories.html ---
CategoriesLibrary CategoriesCategory TheoryTo get all of the category theory library in scope with the proper qualified names, you shouldRequireImportCategories.orRequireImportHoTT.Categories.First we give modules to all of the kinds of category theory constructions (corresponding to directories), so that we can refer to them asCategory.fooorFunctor.fooafterRequireImportCategories.CategoriesRequireHoTT.Categories.Category.FunctorsRequireHoTT.Categories.Functor.Natural TransformationsRequireHoTT.Categories.NaturalTransformation.Functor CategoriesRequireHoTT.Categories.FunctorCategory.GroupoidsRequireHoTT.Categories.GroupoidCategory.Precategory of GroupoidsRequireHoTT.Categories.CategoryOfGroupoids.Discrete CategoriesRequireHoTT.Categories.DiscreteCategory.Indiscrete CategoriesRequireHoTT.Categories.IndiscreteCategory.Finite Discrete Categories (natural numbers as categories)RequireHoTT.Categories.NatCategory.Chain Categories[n]RequireHoTT.Categories.ChainCategory.Initial and Terminal CategoriesRequireHoTT.Categories.InitialTerminalCategory.The Category of SetsRequireHoTT.Categories.SetCategory.The Category of Simplicial SetsRequireHoTT.Categories.SimplicialSets.The Category of Semi-Simplicial SetsRequireHoTT.Categories.SemiSimplicialSets.The Hom FunctorRequireHoTT.Categories.HomFunctor.ProfunctorsRequireHoTT.Categories.Profunctor.The Category of CategoriesRequireHoTT.Categories.Cat.Laws about Functor CategoriesRequireHoTT.Categories.ExponentialLaws.Laws about Product CategoriesRequireHoTT.Categories.ProductLaws.Comma CategoriesRequireHoTT.Categories.Comma.Universal Properties and Universal MorphismsRequireHoTT.Categories.UniversalProperties.Kan ExtensionsRequireHoTT.Categories.KanExtensions.AdjunctionsRequireHoTT.Categories.Adjoint.LimitsRequireHoTT.Categories.Limits.PseudofunctorsRequireHoTT.Categories.Pseudofunctor.Pseudonatural TransformationsRequireHoTT.Categories.PseudonaturalTransformation.Lax Comma CategoriesRequireHoTT.Categories.LaxComma.Duality as a FunctorRequireHoTT.Categories.DualFunctor.The Grothendieck ConstructionRequireHoTT.Categories.Grothendieck.The Category of Sections of a FunctorRequireHoTT.Categories.CategoryOfSections.The Dependent ProductRequireHoTT.Categories.DependentProduct.The Yoneda LemmaRequireHoTT.Categories.Yoneda.The Structure Identity PrincipleRequireHoTT.Categories.Structure.Fundamental PregroupoidsRequireHoTT.Categories.FundamentalPreGroupoidCategory.Homotopy PreCategoryRequireHoTT.Categories.HomotopyPreCategory.(* We bind the record structures forPreCategory,IsCategory,IsStrictCategory,Functor, and eventuallyNaturalTransformationat top level. *)LocalSetWarningsAppend"-notation-overridden".IncludeHoTT.Categories.Category.Core.IncludeHoTT.Categories.Category.Strict.IncludeHoTT.Categories.Category.Univalent.IncludeHoTT.Categories.Functor.Core.IncludeHoTT.Categories.NaturalTransformation.Core.IncludeHoTT.Categories.FunctorCategory.Core.IncludeHoTT.Categories.GroupoidCategory.Core.IncludeHoTT.Categories.CategoryOfGroupoids.IncludeHoTT.Categories.DiscreteCategory.Core.IncludeHoTT.Categories.IndiscreteCategory.Core.IncludeHoTT.Categories.NatCategory.Core.IncludeHoTT.Categories.ChainCategory.Core.IncludeHoTT.Categories.InitialTerminalCategory.Core.IncludeHoTT.Categories.SetCategory.Core.IncludeHoTT.Categories.SimplicialSets.Core.IncludeHoTT.Categories.SemiSimplicialSets.Core.IncludeHoTT.Categories.HomFunctor.IncludeHoTT.Categories.Profunctor.Core.IncludeHoTT.Categories.Cat.Core.IncludeHoTT.Categories.Comma.Core.IncludeHoTT.Categories.UniversalProperties.IncludeHoTT.Categories.KanExtensions.Core.IncludeHoTT.Categories.Adjoint.Core.IncludeHoTT.Categories.Limits.Core.IncludeHoTT.Categories.Pseudofunctor.Core.IncludeHoTT.Categories.PseudonaturalTransformation.Core.IncludeHoTT.Categories.LaxComma.Core.IncludeHoTT.Categories.DualFunctor.IncludeHoTT.Categories.CategoryOfSections.Core.IncludeHoTT.Categories.DependentProduct.IncludeHoTT.Categories.Yoneda.IncludeHoTT.Categories.Structure.Core.IncludeHoTT.Categories.FundamentalPreGroupoidCategory.IncludeHoTT.Categories.HomotopyPreCategory.RequireExportHoTT.Categories.Notations.Some checks that should pass, if all of the importing went correctly.(*Check PreCategory.Check IsStrictCategory _.Check Category.compose.Check Category.sum.Check Category.Sum.sum_compose.Check Functor.sum.Check Functor.Prod.Core.unique.Check (_ o _)functor.*)

--- Miscellaneous\CategoryOfGroupoids.html ---
CategoryOfGroupoidsLibrary CategoryOfGroupoidsGroupoid, the precategory of strict groupoid categoriesRequireImportFunctor.CoreCategory.Strict.RequireImportCat.Core.RequireImportGroupoidCategory.Core.RequireImportFunctor.Paths.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.Sectiongroupoid_cat.Context`{Funext}.LetP:PreCategory->Type:=funC=>IsGroupoidC/\IsStrictCategoryC.LetHF:forallCD,PC->PD->IsHSet(FunctorCD):=funCDHCHD=> @trunc_functor_CD_(sndHD)_.There is a full precategory ofcatwhich is the strict groupoid precategoriesDefinitiongroupoid_cat:PreCategory:= @sub_pre_cat_PHF.Endgroupoid_cat.

--- Miscellaneous\CategoryOfSections.html ---
CategoryOfSectionsLibrary CategoryOfSectionsCategory of sections of a functorRequireCategoryOfSections.Core.IncludeCategoryOfSections.Core.

--- Miscellaneous\cauchy.html ---
cauchyLibrary cauchyFromHoTT.ClassesRequireImportinterfaces.abstract_algebrainterfaces.rationalsinterfaces.ordersimplementations.peano_naturalsorders.fieldstheory.dec_fieldstheory.fieldstheory.rationals.Sectioncauchy.Context(Q:Type).Context`{RationalsQ}.Context{Q_dec_paths:DecidablePathsQ}.Context{Qtriv:TrivialApartQ}.Context(F:Type).Context`{Forderedfield:OrderedFieldF}.Letqinc:CastQF:=rationals_to_fieldQF.Existing Instanceqinc.(* TODO The following two instances should probably come from the`Rationals` instance. *)Context(qinc_strong_presving:IsSemiRingStrongPreservingqinc).Existing Instanceqinc_strong_presving.Sectionsequence.Context(x:nat->F).ClassCauchyModulus(M:QposQ->nat) :=cauchy_convergence:forallepsilon:QposQ,forallmn,Mepsilon<=m->Mepsilon<=n->- ' ('epsilon) < (xm) - (xn) < ' ('epsilon).ClassIsLimit(l:F) :=is_limit:forallepsilon:QposQ,hexists(funN:nat=>foralln:nat,N<=n->- ' ('epsilon) <l-xn< ' ('epsilon)).Endsequence.ClassIsComplete:=is_complete:forallx:nat->F,forallM,CauchyModulusxM->existsl,IsLimitxl.Sectiontheory.Context(x:nat->F) {M} `{CauchyModulusxM}.Lemmamodulus_close_limit{l}(islim:IsLimitxl)(epsilon:QposQ):x(M(epsilon/ 2)) - ' ('epsilon)<l<x(M(epsilon/ 2)) + ' ('epsilon).Proof.assert(lim_close:=is_limitx(epsilon/ 2));strip_truncations.destructlim_closeas[Nisclose'].set(n:=Nat.Core.nat_max(M(epsilon/ 2))N).assert(leNn:=le_nat_max_r(M(epsilon/ 2))N:N≤n).assert(isclose:=isclose'nleNn).clearisclose'.assert(leMn:=le_nat_max_l(M(epsilon/ 2))N:M(epsilon/ 2) ≤n).assert(leMM:M(epsilon/ 2) ≤M(epsilon/ 2) )byapply(Nat.Core.leq_refl).assert(x_close:=cauchy_convergencex(epsilon/2)n(M(epsilon/ 2))leMnleMM).cbninisclose,x_close.rewrite(@preserves_multQF____________)inisclose,x_close.assert(eq22: ' 2 = 2).{rewrite(@preserves_plusQF____________).rewrite(@preserves_1QF__________).reflexivity.}set(ap20:=positive_apart_zero2lt_0_2: 2 ≶ 0).assert(ap20': ' 2 ≶ 0).{rewriteeq22;exactap20.}rewrite(dec_recip_to_recip2ap20')inisclose,x_close.assert(eq_recip_22:recip'(' 2)ap20'=recip'2ap20).{applyrecip_proper_alt.exacteq22.}unfoldrecip'ineq_recip_22.rewriteeq_recip_22inisclose,x_close.cleareq22ap20'eq_recip_22.rewrite<- (field_split2(' ('epsilon))).set(eps_recip_2:= (' ('epsilon) *recip'2ap20)).foldap20.change(' ('epsilon) *recip'2ap20)witheps_recip_2.unfoldrecip'ineps_recip_2.set(xMeps2:=x(M(epsilon/ 2))).foldxMeps2inx_close.rewritenegate_plus_distr.split.-apply(strictly_order_reflecting(+ (-xn))).refine(transitivity_(fstisclose)).clearisclose.foldeps_recip_2.foldeps_recip_2inx_close.applyfst,flip_lt_minus_rinx_close.rewriteplus_comminx_close.applyflip_lt_minus_linx_close.rewriteplus_comminx_close.applyflip_lt_minus_linx_close.rewrite<-(plus_assocxMeps2_(-xn)).rewrite(plus_comm_(-xn)).rewrite(plus_assocxMeps2(-xn)_).apply(strictly_order_reflecting(+eps_recip_2)).apply(strictly_order_reflecting(+eps_recip_2)).rewriteplus_negate_l,plus_0_l.rewrite<- (plus_assoc(xMeps2-xn)__).rewrite<- (plus_assoc(-eps_recip_2)__).rewriteplus_negate_l,plus_0_r.rewrite<- (plus_assoc(xMeps2-xn)__).rewriteplus_negate_l,plus_0_r.assumption.-apply(strictly_order_reflecting(+ (-xn))).refine(transitivity(sndisclose)_).clearisclose.foldeps_recip_2.foldeps_recip_2inx_close.applysndinx_close.applyflip_lt_minus_linx_close.rewriteplus_comminx_close.apply(strictly_order_reflecting(+xn)).rewrite<- (plus_assoc_(-xn) (xn)).rewriteplus_negate_l,plus_0_r.rewrite(plus_commeps_recip_2(xn)).rewrite(plus_assocxMeps2__).apply(strictly_order_preserving(+eps_recip_2)).assumption.Qed.Endtheory.Endcauchy.

--- Miscellaneous\CayleyDickson.html ---
CayleyDicksonLibrary CayleyDicksonRequireImportClasses.interfaces.abstract_algebra.RequireImportCubical.DPathCubical.PathSquare.RequireImportPointed.CorePointed.pSusp.RequireImportHomotopy.HSpace.Core.RequireImportHomotopy.Suspension.RequireImportHomotopy.Join.Core.Local OpenScopepointed_scope.Local OpenScopemc_mult_scope.A Cayley-Dickson Spheroid is a pointed type X which is an H-space, with two operations called negation and conjugation, satisfying the seven following laws.
x=x   x**=x   1*=1    (-x)*=-x*   x(-y)=-(xy)   (xy)* = y* x*    x* x=1ClassCayleyDicksonSpheroid(X:pType) := {cds_hspace:IsHSpaceX;cds_negate:NegateX;cds_conjug:ConjugateX;cds_negate_inv:Involutivecds_negate;cds_conjug_inv:Involutivecds_conjug;cds_conjug_unit_pres:IsUnitPreservingcds_conjug;cds_conjug_left_inv:LeftInverse(.*.)cds_conjugmon_unit;cds_conjug_distr:DistrOpp(.*.)cds_conjug;cds_swapop:SwapOp(-)cds_conjug;cds_factorneg_r:FactorNegRight(-) (.*.);}.#[export]ExistingInstancescds_hspacecds_negatecds_conjugcds_negate_invcds_conjug_invcds_conjug_unit_prescds_conjug_left_invcds_conjug_distrcds_swapopcds_factorneg_r.SectionCayleyDicksonSpheroid_Properties.Context{X:pType} `(CayleyDicksonSpheroidX).Global Instancecds_factorneg_l:FactorNegLeft(-) (.*.).Proof.introsxy.transitivity(conj(conj(-x*y))).1:symmetry;applyinvolutive.rewritedistropp.rewriteswapop.rewritefactorneg_r.rewriteswapop.rewrite<-distropp.rewriteinvolutive.reflexivity.Defined.Global Instancecds_conjug_right_inv:RightInverse(.*.)cds_conjugmon_unit.Proof.introx.set(p:=cds_conjugx).rewrite<- (involutivex).applyleft_inverse.Defined.EndCayleyDicksonSpheroid_Properties.Global Instanceconjugate_susp(A:Type) `(NegateA):Conjugate(SuspA).Proof.srapplySusp_rec.+exactNorth.+exactSouth.+introa.exact(merida).Defined.Global Instancenegate_susp(A:Type) `(NegateA):Negate(SuspA).Proof.srapplySusp_rec.+exactSouth.+exactNorth.+introa.exact(merid(-a))^.Defined.ClassCayleyDicksonImaginaroid(A:Type) := {cdi_negate:NegateA;cdi_negate_involutive:Involutivecdi_negate;cdi_susp_hspace:IsHSpace(psuspA);cdi_susp_factorneg_r:FactorNegRight(negate_suspAcdi_negate)hspace_op;cdi_susp_conjug_left_inv:LeftInversehspace_op(conjugate_suspAcdi_negate)mon_unit;cdi_susp_conjug_distr:DistrOpphspace_op(conjugate_suspAcdi_negate);}.#[export]ExistingInstancescdi_negatecdi_negate_involutivecdi_susp_hspacecdi_susp_factorneg_rcdi_susp_conjug_left_invcdi_susp_conjug_distr.Global Instanceinvolutive_negate_susp{A} `(CayleyDicksonImaginaroidA):Involutive(negate_suspAcdi_negate).Proof.srapplySusp_ind;tryreflexivity.introx.applydp_paths_FFlr.rewriteconcat_p1.rewriteSusp_rec_beta_merid.rewriteap_V.rewriteSusp_rec_beta_merid.rewriteinv_V.rewrite(involutivex).applyconcat_Vp.Defined.Global Instanceinvolutive_conjugate_susp{A} `(CayleyDicksonImaginaroidA):Involutive(conjugate_suspAcdi_negate).Proof.srapplySusp_ind;tryreflexivity.introx.applydp_paths_FFlr.rewriteconcat_p1.rewrite2Susp_rec_beta_merid.applyconcat_Vp.Defined.Global Instanceisunitpreserving_conjugate_susp{A} `(CayleyDicksonImaginaroidA): @IsUnitPreserving__ptpt(conjugate_suspAcdi_negate).Proof.reflexivity.Defined.Global Instanceswapop_conjugate_susp{A} `(CayleyDicksonImaginaroidA):SwapOpnegate(conjugate_suspAcdi_negate).Proof.srapplySusp_ind;tryreflexivity.introx.applydp_paths_FlFr.rewriteconcat_p1.rewriteap_compose.rewrite(ap_composenegate).rewriteSusp_rec_beta_merid.rewriteap_V.rewriteinv_V.rewrite3Susp_rec_beta_merid.applyconcat_pV.Defined.Every suspension of a Cayley-Dickson imaginaroid gives a Cayley-Dickson spheroid.Global Instancecds_susp_cdi{A} `(CayleyDicksonImaginaroidA):CayleyDicksonSpheroid(psuspA) := {}.Global Instancecdi_conjugate_susp_left_inverse{A} `(CayleyDicksonImaginaroidA):LeftInversehspace_op(conjugate_suspAcdi_negate)mon_unit.Proof.srapplycds_conjug_left_inv.Defined.Global Instancecdi_conjugate_susp_right_inverse{A} `(CayleyDicksonImaginaroidA):RightInversehspace_op(conjugate_suspAcdi_negate)mon_unit.Proof.srapplycds_conjug_right_inv.Defined.Global Instancecdi_susp_left_identity{A} `(CayleyDicksonImaginaroidA):LeftIdentityhspace_opmon_unit.Proof.exact_.Defined.Global Instancecdi_susp_right_identity{A} `(CayleyDicksonImaginaroidA):RightIdentityhspace_opmon_unit.Proof.exact_.Defined.Global Instancecdi_negate_susp_factornegleft{A} `(CayleyDicksonImaginaroidA):FactorNegLeft(negate_suspAcdi_negate)hspace_op.Proof.srapplycds_factorneg_l.Defined.A Cayley-Dickson imaginaroid A whose multiplciation on the suspension is associative gives rise to a H-space structure on the join of the suspension of A with itself.SectionImaginaroidHSpace.(* Let A be a Cayley-Dickson imaginaroid with associative H-space multiplication on Susp A *)Context{A} `(CayleyDicksonImaginaroidA)`(!Associativehspace_op).Declaring these as local instances so that they can be foundLocal Instancehspace_op':SgOp(SuspA) :=hspace_op.Local Instancehspace_unit':MonUnit(SuspA) :=hspace_mon_unit.First we make some observations with the context we have.SectionLemmata.Context(abcd:SuspA).Local Definitionf:= (funx=>a* (c* -x)).Local Definitiong:= (funy=>c* (y*b)).Lemmalemma1:f(-mon_unit) =a*c.Proof.unfoldf;applyap.exact(hspace_right_identityc).Defined.Lemmalemma2:f(conjc*conja*d*conjb) = (-d) *conjb.Proof.unfoldf.rewrite2factorneg_r.rewrite3simple_associativity.rewrite<-distropp.rewrite(right_inverse(a*c)).rewrite(left_identityd).symmetry.applyfactorneg_l.Defined.Lemmalemma3:gmon_unit=c*b.Proof.unfoldg;applyap.applyleft_identity.Defined.Lemmalemma4:g(conjc*conja*d*conjb) =conja*d.Proof.unfoldg.rewrite2simple_associativity.rewrite<-simple_associativity.rewriteleft_inverse.rewriteright_identity.rewrite2simple_associativity.rewriteright_inverse.rewrite<-simple_associativity.applyleft_identity.Defined.EndLemmata.Argumentsf{__}.Argumentsg{__}.Here is the multiplication map in algebraic form:
      (a,b) * (c,d) = (a * c - d * b*, a* * d + c * b)
      the following is the spherical form.Global Instancecd_op:SgOp(pjoin(psuspA) (psuspA)).Proof.unfoldpsusp,pjoin;cbn.introsxy;revertx.srapplyJoin_rec;hnf.{introa.reverty.srapplyJoin_rec;hnf.-introc.exact(joinl(a*c)).-introd.exact(joinr(conja*d)).-introsxy.applyjglue. }{introb.reverty.srapplyJoin_rec;hnf.-introc.exact(joinr(c*b)).-introd.exact(joinl((-d) *conjb)).-introsxy.symmetry.applyjglue. }introsab.reverty.srapplyJoin_ind.1:intro;applyjglue.1:intro;cbn;symmetry;applyjglue.introscd.applysq_dp^-1.refine(sq_ccGG_^_^_).1,2:applyJoin_rec_beta_jglue.change(PathSquare(jglue(a*c) (c*b)) (jglue((-d) *conjb) (conja*d))^(jglue(a*c) (conja*d)) (jglue((-d) *conjb) (c*b))^).rewrite<- (lemma1ac), <- (lemma2abcd),<- (lemma3bc), <- (lemma4abcd).refine(sq_GGGG_____).2,4:applyap.1,2,3,4:srapply(Join_rec_beta_jglue__(funab=>jglue(fa) (gb))).refine(sq_cGcG___).1,2:exact(ap_V_(jglue__)).refine(@sq_ap_______(jglue__) (jglue__)^(jglue__) (jglue__)^_).generalize(conjc*conja*d*conjb).clearabcd.change(foralls:SuspA,Diamond(-mon_unit)s(mon_unit)s).srapplySusp_ind;hnf.1:byapplydiamond_v_sq.1:byapplydiamond_h_sq.introa.applydiamond_twist.Defined.Global Instancecd_op_left_identity:LeftIdentitycd_oppt.Proof.snrapplyJoin_ind_FFlr.1,2:exact(fun_=>ap_(hspace_left_identity_)).introsab.lhsnrapplywhiskerR.{lhsrefine(ap_(ap_idmap_)).exact(Join_rec_beta_jglue(func=>joinl(pt*c))(fund=>joinr(conjpt*d))(funxy=>jglue(pt*x) (conjpt*y))ab). }symmetry.applyjoin_natsq.Defined.Global Instancecd_op_right_identity:RightIdentitycd_oppt.Proof.snrapplyJoin_ind_FFlr.1:exact(fun_=>apjoinl(hspace_right_identity_)).1:exact(fun_=>apjoinr(hspace_left_identity_)).introsab.refine(whiskerR__@_).{refine(ap_(ap_idmap_) @_).simpl;rapplyJoin_rec_beta_jglue. }symmetry.applyjoin_natsq.Defined.Global Instancehspace_cdi_susp_assoc:IsHSpace(pjoin(psuspA) (psuspA)):= {}.EndImaginaroidHSpace.

--- Miscellaneous\Centralizer.html ---
CentralizerLibrary CentralizerRequireImportBasicsTypesTruncations.Core.RequireImportHFiberAbelianGroup.(* Given a groupG, we define the centralizer of an elementg:Gas a subgroup and use this to show that the cyclic subgroup generated bygis abelian. *)Local OpenScopemc_scope.Local OpenScopemc_mult_scope.(* First we show that the collection of elements that commute with a fixed elementgis a subgroup. *)Definitioncentralizer{G:Group} (g:G):=funh=>g*h=h*g.Definitioncentralizer_unit{G:Group} (g:G) :centralizergmon_unit.Proof.exact(grp_unit_r_@ (grp_unit_l_)^).Defined.Definitioncentralizer_sgop{G:Group} (ghk:G)(p:centralizergh) (q:centralizergk):centralizerg(h*k).Proof.refine(grp_assoc___@_).refine(ap(funx=>x*k)p@_).refine((grp_assoc___)^ @_).refine(ap(funx=>h*x)q@_).applygrp_assoc.Defined.Definitioncentralizer_inverse{G:Group} (gh:G)(p:centralizergh):centralizerg(-h).Proof.unfoldcentralizerin*.symmetry.refine((grp_unit_r_)^ @_@grp_unit_l_).refine(ap(funx=> (-h*g*x)) (grp_inv_rh)^ @_@ap(funx=>x* (g* -h)) (grp_inv_lh)).refine(grp_assoc___@_@ (grp_assoc___)^).refine(ap(funx=>x* (-h))_).refine((grp_assoc___)^ @_@grp_assoc___).exact(ap(funx=> (-h) *x)p).Defined.Global Instanceissubgroup_centralizer{G:Group} (g:G):IsSubgroup(centralizerg).Proof.srapplyBuild_IsSubgroup.-applycentralizer_unit.-applycentralizer_sgop.-applycentralizer_inverse.Defined.Definitioncentralizer_subgroup{G:Group} (g:G):=Build_SubgroupG(centralizerg)_.(* Now we define cyclic subgroups.  We allow any mapUnit->Gin this definition, because in applications (such asZ_commutative) we have no control over the map. *)Definitioncyclic_subgroup_from_unit{G:Group} (gen:Unit->G) :=subgroup_generated(hfibergen).(* When we have a particular elementgofG, we could choose the predicate to befunh=>h=g, but to fit into the above definition, we useunit_nameg, which gives the predicatefunh=>hfiber(unit_nameg)h. *)Definitioncyclic_subgroup{G:Group} (g:G) :=cyclic_subgroup_from_unit(unit_nameg).(* Any cyclic subgroup is commutative. *)Global Instancecommutative_cyclic_subgroup{G:Group} (gen:Unit->G):Commutative(@group_sgop(cyclic_subgroup_from_unitgen)).Proof.introshk.destructhas[hH];cbninH.destructkas[kK];cbninK.strip_truncations.(* It's enough to check equality after including into G: *)apply(equiv_ap_isembedding(subgroup_incl_)__)^-1.cbn.inductionHas[h[[]p]| |h1h2H1H2IHH1IHH2].-(* The case when h = g: *)inductionp.inductionKas[k[[]q]| |k1k2K1K2IHK1IHK2].+(* The case when k = g: *)inductionq.reflexivity.+(* The case when k = mon_unit: *)applycentralizer_unit.+(* The case when k = k1 (-k2): *)srapply(issubgroup_in_op_inv(H:=centralizer(gentt)));assumption.-(* The case when h = mon_unit: *)symmetry;applycentralizer_unit.-(* The case when h = h1 (-h2): *)symmetry.srapply(issubgroup_in_op_inv(H:=centralizerk));unfoldcentralizer;symmetry;assumption.Defined.Definitionabgroup_cyclic_subgroup{G:Group} (g:G) :AbGroup:=Build_AbGroup(cyclic_subgroupg)_.

--- Miscellaneous\ChainCategory.html ---
ChainCategoryLibrary ChainCategoryThe category ω of (ℕ, ≤), and the chain categories[n]RequireImportCategory.Subcategory.Full.RequireImportCategory.Sigma.Univalent.RequireImportCategory.MorphismsCategory.UnivalentCategory.Strict.RequireImportHoTT.BasicsHoTT.TypesHoTT.Spaces.Nat.Core.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopenat_scope.DefinitionsQuoting Wikipedia (http://en.wikipedia.org/wiki/Total_order#Chains):While chain is sometimes merely a synonym for totally ordered set,
    it can also refer to a totally ordered subset of some partially
    ordered set. The latter definition has a crucial role in Zorn's
    lemma.  We take the convention that a "chain" is a totally ordered or
    linearly ordered set; the corresponding category on that set has,
    as morphisms, the order relation.(* N.B. The notation here (including that[n]have as objects theset{0,1,...,n}) was originally suggested by David Spivak.It's possible that we should pick a different or more commonterminology. *)ModuleExportCore.[ω], the linear order on ℕDefinitionomega:PreCategory:= @Build_PreCategorynatleqleq_refl(funxyzpq=>leq_transqp)(fun_______=>path_ishprop__)(fun___=>path_ishprop__)(fun___=>path_ishprop__)_.[n], a linear order on a finite set withn+1elementsUsingn+1elements allows us to agree with the common
      definition of ann-simplex, where a 0-simplex is a point, and
      a 1-simplex has two end-points, etc.Definitionchain(n:nat) :PreCategory:= {m:omega|m<=n}%category.TODO: Possibly generalize this to arbitrary sets with arbitrary
      (total?) orders on them?ModuleExportChainCategoryCoreNotations.Notation"[ n ]" := (chainn) :category_scope.EndChainCategoryCoreNotations.EndCore.ModuleExportNotations.IncludeChainCategoryCoreNotations.EndNotations.ModuleUtf8.ExportNotations.Notation"[ ∞ ]" :=omega:category_scope.Notation"[ 'ω' ]" :=omega:category_scope.EndUtf8.ModuleExportStrict.Definitionisstrict_omega:IsStrictCategoryomega.Proof.exact_.Defined.Definitionisstrict_chain{n} :IsStrictCategory[n].Proof.exact_.Defined.EndStrict.ModuleExportUnivalent.Global Instanceiscategory_omega:IsCategoryomega.Proof.introssd.refine(isequiv_iff_hprop__).{refine(istrunc_equiv_istrunc_(issig_isomorphic___));simpl;refine_. }{introm;applyleq_antisym;applym. }Defined.Definitioniscategory_chain{n} :IsCategory[n].Proof.exact_.Defined.EndUnivalent.

--- Miscellaneous\ChineseRemainder.html ---
ChineseRemainderLibrary ChineseRemainderRequireImportClasses.interfaces.canonical_names.RequireImportWildCat.RequireImportModalities.ReflectiveSubuniverse.RequireImportAlgebra.AbGroups.RequireImportAlgebra.Rings.Ring.RequireImportAlgebra.Rings.Ideal.RequireImportAlgebra.Rings.QuotientRing.RequireImportAlgebra.Rings.CRing.Chinese remainder theoremImportIdeal.Notation.Local OpenScopering_scope.Local OpenScopewc_iso_scope.SectionChineseRemainderTheorem.We assumeUnivalencein order to work with quotients. We also need it forFunextin a few places.Context`{Univalence}We need two coprime idealsIandJto state the theorem. We don't introduce the coprimeness assumption as of yet in order to show something slightly stronger.{R:Ring} (IJ:IdealR).We begin with the homomorphism which will show to be a surjection. Using the first isomorphism theorem for rings we can improve this to be the isomorphism we want.  This is the corecursion of the two quotient mapsDefinitionrng_homo_crt:R$-> (R/I) × (R/J).Proof.applyring_product_corec.1,2:applyrng_quotient_map.Defined.Since we are working with quotients, we make the following notation to make working with the proof somewhat easier.Local Notation"[ x ]" := (rng_quotient_map_x).We then need to prove the following lemma. The hypotheses here can be derived by coprimality ofIandJ. But we don't need that here.Lemmaissurjection_rng_homo_crt'(xy:R)(q1:rng_homo_crtx= (0, 1)) (q2:rng_homo_crty= (1, 0)):IsSurjectionrng_homo_crt.Proof.In order to show thatrng_homo_crtis a surjection, we need to show that its propositional truncation of the fiber at any point is contractible.intros[ab].reverta;srapplyQuotientRing_ind_hprop;introa.revertb;srapplyQuotientRing_ind_hprop;introb.We can think ofaandbas the pair(amodI,bmodJ). We need to show that there merely exists some element inRthat gets mapped byrng_homo_crtto the pair.snrapplyBuild_Contr; [|introsz;strip_truncations;applypath_ishprop].We make this choice and show it maps as desired.applytr;exists(b*x+a*y).Finally using some simple ring laws we can show it maps to our pair.rewriterng_homo_plus.rewrite2rng_homo_mult.rewriteq1,q2.applypath_prod.+change([b] * 0 + [a] * 1 = [a] :>R/I).byrewriterng_mult_one_r,rng_mult_zero_r,rng_plus_zero_l.+change([b] * 1 + [a] * 0 = [b] :>R/J).byrewriterng_mult_one_r,rng_mult_zero_r,rng_plus_zero_r.Defined.Now we show that ifx+y=1forIxandJythen we can satisfy the hypotheses of the previous lemma.Sectionrng_homo_crt_beta.Context(xy:R) (ix:Ix) (iy:Jy) (p:x+y= 1).Lemmarng_homo_crt_beta_left:rng_homo_crtx= (0, 1).Proof.applyrng_moveR_Mrinp.rewriterng_plus_comminp.applypath_prod;applyqglue.-change(I(-x+ 0)).applyideal_in_negate_plus.1:assumption.applyideal_in_zero.-change(J(-x+ 1)).rewriterng_plus_comm.byrewrite<-p.Defined.Lemmarng_homo_crt_beta_right:rng_homo_crty= (1, 0).Proof.applyrng_moveR_rMinp.rewriterng_plus_comminp.applypath_prod;applyqglue.-change(I(-y+ 1)).byrewrite<-p.-change(J(-y+ 0)).applyideal_in_negate_plus.1:assumption.applyideal_in_zero.Defined.Endrng_homo_crt_beta.We can now show the map is surjective from coprimality ofIandJ.Global Instanceissurjection_rng_homo_crt:CoprimeIJ->IsSurjectionrng_homo_crt.Proof.introsc.First we turn the coprimality assumption into an equivalent assumption about the mere existence of two elements of each ideal which sum to one.applyequiv_coprime_suminc.Since the goal is a hprop we may strip the truncations.strip_truncations.Now we can break apart the data of this witness.destructcas[[[xix] [yjy]]p];change(x+y= 1)inp.Now we apply all our previous lemmasapply(issurjection_rng_homo_crt'xy).1:exact(rng_homo_crt_beta_leftxyixjyp).exact(rng_homo_crt_beta_rightxyixjyp).Defined.Now supposeIandJare coprime.Context(c:CoprimeIJ).The Chinese Remainder TheoremTheoremchinese_remainder:R/ (I∩J)%ideal≅ (R/I) × (R/J).Proof.We use the first isomorphism theorem. Coq can already infer which map we wish to use, so for clarity we tell it not to do so.snrapplyrng_first_iso'.1:rapplyrng_homo_crt.1:exact_.Finally we must show the ideal of this map is the intersection.applyideal_subset_antisymm.-introsr[ij].applypath_prod;applyqglue.1:change(I(-r+ 0)).2:change(J(-r+ 0)).1,2:rewriterng_plus_comm.1,2:applyideal_in_plus_negate.1,3:applyideal_in_zero.1,2:assumption.-introsip.applyequiv_path_prodinp.destructpas[pq].applyideal_in_negate'.rewrite<-rng_plus_zero_r.Here we need to derive the relation from paths in the quotient. This is what requires univalence.split.1:exact(related_quotient_paths___p).1:exact(related_quotient_paths___q).Defined.EndChineseRemainderTheorem.We also have the same for products of ideals when in a commuatative ring.Theoremchinese_remainder_prod`{Univalence}{R:CRing} (IJ:IdealR) (c:CoprimeIJ):R/ (I⋅J)%ideal≅ (R/I) × (R/J).Proof.etransitivity.{rapplyrng_quotient_invar.symmetry.rapplyideal_intersection_is_product. }rapplychinese_remainder.Defined.

--- Miscellaneous\Choice.html ---
ChoiceLibrary ChoiceRequireImportHoTT.BasicsHoTT.TypesHoTT.Universes.HSetHoTT.Truncations.CoreHoTT.Colimits.QuotientHoTT.Projective.The following is an alternative (0,-1)-projectivity predicate onA. Given a family of quotient equivalence classesf:forallx:A,Bx/Rx, forR:forallx:A,Relation(Bx), we merely have a choice functiong:forallx,Bx, factoringfasfx=class_of(gx).DefinitionHasQuotientChoice(A:Type) :=forall(B:A->Type), (forallx,IsHSet(Bx)) ->forall(R:forallx,Relation(Bx))(pR:forallx,is_mere_relation(Bx) (Rx)),(forallx,Reflexive(Rx)) ->(forallx,Symmetric(Rx)) ->(forallx,Transitive(Rx)) ->forall(f:forallx:A,Bx/Rx),hexists(fung: (forallx:A,Bx) =>forallx,class_of(Rx) (gx) =fx).Sectionchoose_has_quotient_choice.Context`{Univalence}{A:Type} {B:A->Type} `{!forallx,IsHSet(Bx)}(P:forallx,Bx->Type) `{!forallx(a:Bx),IsHProp(Pxa)}.Local DefinitionRelClassEquiv(x:A) (a:Bx) (b:Bx) :Type:=Pxa<~>Pxb.Local Instancereflexive_relclass:forallx,Reflexive(RelClassEquivx).Proof.introsab.applyequiv_idmap.Qed.Local Instancesymmetric_relclass:forallx,Symmetric(RelClassEquivx).Proof.introsab1b2p.apply(equiv_inversep).Qed.Local Instancetransitive_relclass:forallx,Transitive(RelClassEquivx).Proof.introsab1b2b3pq.apply(equiv_composeqp).Qed.Local Instancehprop_choose_cod(a:A):IsHProp{c:Ba/RelClassEquiva|forallb,in_class(RelClassEquiva)cb<~>Pab}.Proof.applyishprop_sigma_disjoint.refine(Quotient_ind_hprop___).introb1.refine(Quotient_ind_hprop___).introsb2fg.applyqglue.apply(fb2)^-1.applyg.applyreflexive_relclass.Qed.Local Definitionprechoose(i:forallx,hexists(Px)) (a:A): {c:Ba/RelClassEquiva|forallb:Ba,in_class(RelClassEquiva)cb<~>Pab}.Proof.specialize(ia).strip_truncations.destructias[b1h].exists(class_of_b1).introb2.applyequiv_iff_hprop.-introf.exact(fh).-introp.byapplyequiv_iff_hprop.Defined.Local Definitionchoose(i:forallx,hexists(Px)) (a:A):Ba/RelClassEquiva:= (prechooseia).1.Endchoose_has_quotient_choice.The following section derivesHasTrChoice0AfromHasQuotientChoiceA.Sectionhas_tr0_choice_quotientchoice.Context`{Funext} (A:Type) (qch:HasQuotientChoiceA).Local DefinitionRelUnit(B:A->Type) (a:A) (b1b2:Ba) :HProp:=Build_HPropUnit.Local Instancereflexive_relunit(B:A->Type) (a:A):Reflexive(RelUnitBa).Proof.done.Qed.Local Instancesymmetric_relunit(B:A->Type) (a:A):Symmetric(RelUnitBa).Proof.done.Qed.Local Instancetransitive_relunit(B:A->Type) (a:A):Transitive(RelUnitBa).Proof.done.Qed.Local Instanceishprop_quotient_relunit(B:A->Type) (a:A):IsHProp(Ba/RelUnitBa).Proof.applyhprop_allpath.refine(Quotient_ind_hprop___).intror.refine(Quotient_ind_hprop___).intros.byapplyqglue.Qed.Lemmahas_tr0_choice_quotientchoice:HasTrChoice0A.Proof.introsBsBf.transparentassert(g: (foralla,Ba/RelUnitBa)).-introa.specialize(fa).strip_truncations.exact(class_of_f).-specialize(qchB_(RelUnitB)____g).strip_truncations.applytr.applyqch.Qed.Endhas_tr0_choice_quotientchoice.Lemmahas_quotient_choice_tr0choice(A:Type):HasTrChoice0A->HasQuotientChoiceA.Proof.introschBsBRpRrRsRtRf.set(P:=funab=>class_of(Ra)b=fa).assert(foralla,merely((funx=> {b|Pxb})a))asg.-introa.refine(Quotient_ind_hprop_(func=>merely{b|class_of(Ra)b=c})_(fa)).introb.applytr.byexistsb.-poseproof(ch(funa=> {b|Pab})_g)ash.strip_truncations.applytr.exists(funx=> (hx).1).introa.applyh.Qed.Global Instanceisequiv_has_tr0_choice_to_has_quotient_choice`{Funext} (A:Type):IsEquiv(has_quotient_choice_tr0choiceA).Proof.srapplyisequiv_iff_hprop.-applyistrunc_forall.-applyhas_tr0_choice_quotientchoice.Qed.Definitionequiv_has_tr0_choice_has_quotient_choice`{Funext} (A:Type):HasTrChoice0A<~>HasQuotientChoiceA:=Build_Equiv__(has_quotient_choice_tr0choiceA)_.The next section useshas_quotient_choice_tr0choiceto generalizequotient_rec2, seechoose_quotient_indbelow.Sectionchoose_quotient_ind.Context`{Univalence}{I:Type} `{!HasTrChoice0I}{A:I->Type} `{!foralli,IsHSet(Ai)}(R:foralli,Relation(Ai))`{!foralli,is_mere_relation(Ai) (Ri)}{rR:foralli,Reflexive(Ri)}{sR:foralli,Symmetric(Ri)}{tR:foralli,Transitive(Ri)}.First generalize theqglueconstructor.Lemmaqglue_forall(fg:foralli,Ai) (r:foralli,Ri(fi) (gi)): (funi=>class_of(Ri) (fi)) = (funi=>class_of(Ri) (gi)).Proof.funexts.byapplyqglue.Defined.Given suitable preconditions, we will show thatChoosePropPagis inhabited, rather than directly giving an inhabitant ofPg. This turns out to be beneficial becauseChoosePropPagis a proposition.Local DefinitionChooseProp(P: (foralli,Ai/Ri) ->Type) `{!forallg,IsHSet(Pg)}(a:forall(f:foralli,Ai),P(funi=>class_of(Ri) (fi)))(g:foralli,Ai/Ri):Type:= {b:Pg|merely(exists(f:foralli,Ai)(q:g=funi=>class_of(Ri) (fi)),forall(f':foralli,Ai)(r:foralli,Ri(fi) (f'i)),qglue_forallff'r#q#b=af')}.Local Instanceishprop_choose_quotient_ind_chooseprop(P: (foralli,Ai/Ri) ->Type) `{!forallg,IsHSet(Pg)}(a:forall(f:foralli,Ai),P(funi=>class_of(Ri) (fi)))(g:foralli,Ai/Ri):IsHProp(ChoosePropPag).Proof.applyishprop_sigma_disjoint.introsxyh1h2.strip_truncations.destructh1as[f1[q1p1]].destructh2as[f2[q2p2]].specialize(p1f1(funi=>rRi(f1i))).set(pR:=funi=>related_quotient_paths(Ri)__(ap(funh=>hi)q2^@ap(funh=>hi)q1)).specialize(p2f1pR).do2applymoveL_transport_Vinp1.do2applymoveL_transport_Vinp2.refine(p1@_@p2^).applymoveR_transport_p.rewriteinv_V.rewrite<-transport_pp.applymoveR_transport_p.rewriteinv_V.do2rewrite<-transport_pp.set(pa:= (qglue_forallf2f1pR)^@ (q2^ @q1@qglue_forallf1f1_)).byinduction(hset_path2idpathpa).Qed.(* SinceChoosePropPagis a proposition, we can applyhas_quotient_choice_tr0choiceand strip its truncation in order to deriveChoosePropPag. *)Lemmachooseprop_quotient_ind(P: (foralli,Ai/Ri) ->Type) `{!forallg,IsHSet(Pg)}(a:forall(f:foralli,Ai),P(funi=>class_of(Ri) (fi)))(E:forall(ff':foralli,Ai) (r:foralli,Ri(fi) (f'i)),qglue_forallff'r#af=af')(g:foralli,Ai/Ri):ChoosePropPag.Proof.poseproof(has_quotient_choice_tr0choiceI_A_R____g)ash.strip_truncations.destructhas[hp].applypath_forallinp.refine(transport_p_).exists(ah).applytr.existsh.exists1.applyE.Defined.By projecting out ofchooseprop_quotient_indwe obtain a generalization ofquotient_rec2.Lemmachoose_quotient_ind(P: (foralli,Ai/Ri) ->Type) `{!forallg,IsHSet(Pg)}(a:forall(f:foralli,Ai),P(funi=>class_of(Ri) (fi)))(E:forall(ff':foralli,Ai) (r:foralli,Ri(fi) (f'i)),qglue_forallff'r#af=af')(g:foralli,Ai/Ri):Pg.Proof.exact(chooseprop_quotient_indPaEg).1.Defined.A specialization ofchoose_quotient_indto the case wherePgis a proposition.Lemmachoose_quotient_ind_prop(P: (foralli,Ai/Ri) ->Type) `{!forallg,IsHProp(Pg)}(a:forall(f:foralli,Ai),P(funi=>class_of(Ri) (fi)))(g:foralli,Ai/Ri):Pg.Proof.refine(choose_quotient_indPa_g).intros.applypath_ishprop.Defined.The recursion principle derived fromchoose_quotient_ind.Definitionchoose_quotient_rec{B:Type} `{!IsHSetB} (a: (foralli,Ai) ->B)(E:forall(ff':foralli,Ai),(foralli,Ri(fi) (f'i)) ->af=af')(g:foralli,Ai/Ri):B:=choose_quotient_ind(fun_=>B)a(funff'r=>transport_const__@Eff'r)g.The "beta-rule" ofchoose_quotient_ind.Lemmachoose_quotient_ind_compute(P: (foralli,Ai/Ri) ->Type) `{!forallg,IsHSet(Pg)}(a:forall(f:foralli,Ai),P(funi=>class_of(Ri) (fi)))(E:forall(ff':foralli,Ai) (r:foralli,Ri(fi) (f'i)),qglue_forallff'r#af=af')(f:foralli,Ai):choose_quotient_indPaE(funi=>class_of(Ri) (fi)) =af.Proof.refine(Trunc_ind(funa=> (_a).1 =_)__).cbn.intros[f'p].rewritetransport_sigma.set(p':=funx=>related_quotient_paths(Rx)__(px)).assert(p= (funi=>qglue(p'i)))aspE.-funextx.applyhset_path2.-rewritepE.applyE.Qed.The "beta-rule" ofchoose_quotient_rec.Lemmachoose_quotient_rec_compute{B:Type} `{!IsHSetB} (a: (foralli,Ai) ->B)(E:forall(ff':foralli,Ai),(foralli,Ri(fi) (f'i)) ->af=af')(f:foralli,Ai):choose_quotient_recaE(funi=>class_of(Ri) (fi)) =af.Proof.apply(choose_quotient_ind_compute(fun_=>B)).Qed.Endchoose_quotient_ind.

--- Miscellaneous\Circle.html ---
CircleLibrary CircleRequireImportBasicsTypes.RequireImportPointed.CorePointed.LoopsPointed.pEquiv.RequireImportHSet.RequireImportSpaces.Int.RequireImportColimits.Coeq.RequireImportTruncations.CoreTruncations.Connectedness.Theorems about theCircle.Local OpenScopepointed_scope.Local OpenScopepath_scope.Generalizable VariablesXABfgn.(* ** Definition of theCircle. *)We define the circle as the coequalizer of two copies of the identity map ofUnit.  This is easily equivalent to the naive definitionPrivate Inductive Circle : Type0 :=
| base : Circle
| loop : base = base.but it allows us to apply the flattening lemma directly rather than having to pass across that equivalence.The circle is defined to be the coequalizer of two copies of the identity map onUnit.DefinitionCircle:= @CoeqUnitUnitidmapidmap.It has a basepoint.Definitionbase:Circle:=coeqtt.And a non-trivial path.Definitionloop:base=base:=cgluett.Here is a notation for the circle that can be imported.ModuleCircleNotation.NotationS1:=Circle(onlyparsing).EndCircleNotation.Circle inductionDefinitionCircle_ind(P:Circle->Type)(b:Pbase) (l:loop#b=b):forall(x:Circle),Px.Proof.refine(Coeq_indP(funu=>transportP(apcoeq(path_unitttu))b)_).intros[];exactl.Defined.Computation rule for circle induction.DefinitionCircle_ind_beta_loop(P:Circle->Type)(b:Pbase) (l:loop#b=b):apD(Circle_indPbl)loop=l:=Coeq_ind_beta_cglueP__tt.We markCircle,baseandloopto never be simplified bysimplorcbnin order to hide how we defined it from the user.ArgumentsCircle:simplnever.Argumentsbase:simplnever.Argumentsloop:simplnever.ArgumentsCircle_ind_beta_loop:simplnever.The recursion princple or non-dependent eliminator.DefinitionCircle_rec(P:Type) (b:P) (l:b=b):Circle->P:=Circle_ind(fun_=>P)b(transport_const__@l).Computation rule for non-dependent eliminator.DefinitionCircle_rec_beta_loop(P:Type) (b:P) (l:b=b):ap(Circle_recPbl)loop=l.Proof.unfoldCircle_rec.refine(cancelL(transport_constloopb)___).refine((apD_const(Circle_ind(fun_=>P)b_)loop)^ @_).refine(Circle_ind_beta_loop(fun_=>P)__).Defined.TheCircleis pointed bybase.Global Instanceispointed_Circle:IsPointedCircle:=base.DefinitionpCircle:pType:= [Circle,base].The loop space of theCircleis the IntegersIntThis is the encode-decode style proof a la Licata-Shulman.SectionEncodeDecode.We assume univalence throughout this section.Context`{Univalence}.First we define the type of codes, this is a type family over the circle. This can be thought of as the covering space by the homotopical real numbers. It is defined by mapping loop to the path given by univalence applied to the automorphism of the integers. We will show that the section of this family atbaseis equivalent to the loop space of the circle. Giving us an equivalencebase=base<~>Int.DefinitionCircle_code:Circle->Type:=Circle_recTypeInt(path_universeint_succ).Transporting alongloopgives us the successor automorphism onInt.Definitiontransport_Circle_code_loop(z:Int):transportCircle_codeloopz=int_succz.Proof.refine(transport_composeidmapCircle_codeloopz@_).unfoldCircle_code;rewriteCircle_rec_beta_loop.applytransport_path_universe.Defined.Transporting alongloop^gives us the predecessor onInt.Definitiontransport_Circle_code_loopV(z:Int):transportCircle_codeloop^z=int_predz.Proof.refine(transport_composeidmapCircle_codeloop^z@_).rewriteap_V.unfoldCircle_code;rewriteCircle_rec_beta_loop.rewrite<- (path_universe_Vint_succ).applytransport_path_universe.Defined.To turn a path inCirclebased atbaseinto a code we transport along it. We call this encoding.DefinitionCircle_encode(x:Circle) : (base=x) ->Circle_codex:=funp=>p#zero.TODO: explain this proof in more detail.  Turning a code into a path based atbase. We call this decoding.DefinitionCircle_decode(x:Circle) :Circle_codex-> (base=x).Proof.revertx;refine(Circle_ind(funx=>Circle_codex->base=x) (loopexploop)_).applypath_forall;introsz;simplinz.refine(transport_arrow___@_).refine(transport_paths_rloop_@_).rewritetransport_Circle_code_loopV.rewriteloopexp_pred_r.applyconcat_pV_p.Defined.The non-trivial part of the proof that decode and encode are equivalences is showing that decoding followed by encoding is the identity on the fibers overbase.DefinitionCircle_encode_loopexp(z:Int):Circle_encodebase(loopexploopz) =z.Proof.inductionzas[|n|n].-reflexivity.-rewriteloopexp_succ_r.unfoldCircle_encodeinIHz|- *.rewritetransport_pp.rewriteIHz.applytransport_Circle_code_loop.-rewriteloopexp_pred_r.unfoldCircle_encodeinIHz|- *.rewritetransport_pp.rewriteIHz.applytransport_Circle_code_loopV.Defined.Now we put it together.DefinitionCircle_encode_isequiv(x:Circle) :IsEquiv(Circle_encodex).Proof.refine(isequiv_adjointify(Circle_encodex) (Circle_decodex)__).(* Here we induct onx:Circle.  We just did the case whenxisbase. *)-refine(Circle_ind(funx=> (Circle_encodex)o(Circle_decodex) ==idmap)Circle_encode_loopexp__).(* What remains is easy sinceIntis known to be a set. *)byapplypath_forall;introsz;applyhset_path2.(* The other side is trivial by path induction. *)-intros[];reflexivity.Defined.Finally giving us an equivalence between the loop space of theCircleandInt.Definitionequiv_loopCircle_int: (base=base) <~>Int:=Build_Equiv__(Circle_encodebase) (Circle_encode_isequivbase).EndEncodeDecode.Connectedness and truncatedness of theCircleThe circle is 0-connected.Global Instanceisconnected_Circle`{Univalence} :IsConnected0Circle.Proof.applyis0connected_merely_allpath.1:exact(trbase).srefine(Circle_ind___).-simplerefine(Circle_ind___).+exact(tr1).+applypath_ishprop.-applypath_ishprop.Defined.It follows that the circle is a 1-type.Global Instanceistrunc_Circle`{Univalence} :IsTrunc1Circle.Proof.applyistrunc_S.introsxy.assert(p:=merely_path_is0connectedCirclebasex).assert(q:=merely_path_is0connectedCirclebasey).strip_truncations.destructp,q.refine(istrunc_equiv_istrunc(n:= 0)Intequiv_loopCircle_int^-1).Defined.Iteration of equivalencesIfP:Circle->Typeis defined by a typeXand an autoequivalencef, then the image ofn:Intregarded as inbase=baseisiter_intfn.DefinitionCircle_action_is_iter`{Univalence}X(f:X<~>X) (n:Int) (x:X):transport(Circle_recTypeX(path_universef)) (equiv_loopCircle_int^-1n)x=int_iterfnx.Proof.refine(_@loopexp_path_universe___).refine(transport_composeidmap___@_).refine(ap(funp=>transportidmappx)_).unfoldequiv_loopCircle_int;cbn.unfoldCircle_decode;simpl.rewriteap_loopexp.refine(ap(funp=>loopexppn)_).applyCircle_rec_beta_loop.Defined.The universal property of the circle (Lemma 6.2.9 in the Book).  We could deduce this fromisequiv_Coeq_rec, but it's nice to see a direct proof too.DefinitionCircle_rec_uncurried(P:Type): {b:P&b=b} -> (Circle->P):=funx=>Circle_recP(pr1x) (pr2x).Global Instanceisequiv_Circle_rec_uncurried`{Funext} (P:Type) :IsEquiv(Circle_rec_uncurriedP).Proof.srapplyisequiv_adjointify.-exact(fung=> (gbase;apgloop)).-introsg.applypath_arrow.srapplyCircle_ind.+reflexivity.+unfoldCircle_rec_uncurried;cbn.applytransport_paths_FlFr'.applyequiv_p1_1q.applyCircle_rec_beta_loop.-intros[bp];applyap.applyCircle_rec_beta_loop.Defined.Definitionequiv_Circle_rec`{Funext} (P:Type): {b:P&b=b} <~> (Circle->P):=Build_Equiv___(isequiv_Circle_rec_uncurriedP).A pointed version of the universal property of the circle.Definitionpmap_from_circle_loops`{Funext} (X:pType): (pCircle->**X) <~>*loopsX.Proof.snrapplyBuild_pEquiv'.-refine(_oE(issig_pmap__)^-1%equiv).equiv_via{xp: {x:X&x=x} &xp.1 =pt}.2:make_equiv_contr_basedpaths.exact((equiv_functor_sigma_pb(equiv_Circle_recX)^-1%equiv)).-simpl.applyap_const.Defined.

--- Miscellaneous\Classes.html ---
ClassesLibrary ClassesRequireImportBasics.OvertureBasics.Tactics.ClassesInjective FunctionsClassIsInjective{AB:Type} (f:A->B):=injective:forallxy,fx=fy->x=y.Argumentsinjective{AB}f{_}__.Definitionneq_isinj{AB:Type} (f:A->B) `{!IsInjectivef}:forallxy,x<>y->fx<>fy.Proof.introsxynpq.applynp, (injectivef).exactq.Defined.Global Instanceisinj_idmapA: @IsInjectiveAAidmap:=funxy=>idmap.#[export]HintUnfoldIsInjective:typeclass_instances.Definitionisinj_compose{ABCfg} `{IsInjectiveBCg} `{IsInjectiveABf}:IsInjective(gof).Proof.introsxyp.byapply(injectivef), (injectiveg).Defined.#[export]HintImmediateisinj_compose:typeclass_instances.Definitionisinj_cancelL{ABC:Type} (f:A->B) (g:B->C)`{!IsInjective(gof)}:IsInjectivef.Proof.introsxyp.apply(injective(gof)).exact(apgp).Defined.Antisymmetric RelationsClassAntiSymmetric{A:Type} (R:A->A->Type) :Type:=antisymmetry:forallxy,Rxy->Ryx->x=y.Argumentsantisymmetry{A}R{AntiSymmetric}xy__.

--- Miscellaneous\ClassifyingSpace.html ---
ClassifyingSpaceLibrary ClassifyingSpaceRequireImportBasicsTypes.RequireImportPointedWildCat.RequireImportCubical.DPathCubical.PathSquareCubical.DPathSquare.RequireImportAlgebra.AbGroups.RequireImportHomotopy.HSpace.Core.RequireImportTruncType.RequireImportTruncations.CoreTruncations.Connectedness.RequireImportHomotopy.HomotopyGroup.RequireImportHomotopy.WhiteheadsPrinciple.Local OpenScopepointed_scope.Local OpenScopemc_scope.Local OpenScopetrunc_scope.Local OpenScopemc_mult_scope.We define the Classifying space of a group to be the following HIT:HIT ClassifyingSpace (G : Group) : 1-Type
   | bbase : ClassifyingSpace
   | bloop : X -> bbase = bbase
   | bloop_pp : forall x y, bloop (x * y) = bloop x @ bloop y.We implement this is a private inductive type.ModuleExportClassifyingSpace.SectionClassifyingSpace.Private InductiveClassifyingSpace(G:Group) :=|bbase:ClassifyingSpaceG.Context{G:Group}.Axiombloop:G->bbaseG=bbaseG.Global Argumentsbbase{_}.Axiombloop_pp:forallxy,bloop(x*y) =bloopx@bloopy.Global Instanceistrunc_ClassifyingSpace:IsTrunc1 (ClassifyingSpaceG).Proof.Admitted.EndClassifyingSpace.Now we can state the expected dependent elimination principle, and derive other versions of the elimination principle from it.SectionClassifyingSpace_ind.Local OpenScopedpath_scope.Context{G:Group}.Note that since our classifying space is 1-truncated, we can only eliminate into 1-truncated type families.DefinitionClassifyingSpace_ind(P:ClassifyingSpaceG->Type)`{forallb,IsTrunc1 (Pb)}(bbase':Pbbase)(bloop':forallx,DPathP(bloopx)bbase'bbase')(bloop_pp':forallxy,DPathSquareP(sq_G1(bloop_ppxy))(bloop'(x*y)) ((bloop'x) @Dp(bloop'y)) 1 1)(b:ClassifyingSpaceG):Pb:=matchbwithbbase=> (fun__=>bbase')endbloop'bloop_pp'.Here we state the computation rule forClassifyingSpace_indoverbloopas an axiom. We don't need one forbloop_ppsince we have a 1-type. We leave this as admitted since the computation rule is an axiom.DefinitionClassifyingSpace_ind_beta_bloop(P:ClassifyingSpaceG->Type)`{forallb,IsTrunc1 (Pb)}(bbase':Pbbase) (bloop':forallx,DPathP(bloopx)bbase'bbase')(bloop_pp':forallxy,DPathSquareP(sq_G1(bloop_ppxy))(bloop'(x*y)) ((bloop'x) @Dp(bloop'y)) 1 1)(x:G):apD(ClassifyingSpace_indPbbase'bloop'bloop_pp') (bloopx) =bloop'x.Proof.Admitted.EndClassifyingSpace_ind.EndClassifyingSpace.Other eliminatorsSectionEliminators.Context{G:Group}.The non-dependent eliminatorDefinitionClassifyingSpace_rec(P:Type) `{IsTrunc1P} (bbase':P) (bloop':G->bbase'=bbase')(bloop_pp':forallxy:G,bloop'(x*y) =bloop'x@bloop'y):ClassifyingSpaceG->P.Proof.srefine(ClassifyingSpace_ind(fun_=>P)bbase'__).1:introx;applydp_const,bloop',x.introsxy.applyds_const'.rapplysq_GGcc.2:refine(_@ap_(dp_const_pp__)).1,2:symmetry;applyeissect.byapplysq_G1.Defined.Computation rule for non-dependent eliminatorDefinitionClassifyingSpace_rec_beta_bloop(P:Type) `{IsTrunc1P} (bbase':P) (bloop':G->bbase'=bbase')(bloop_pp':forallxy:G,bloop'(x*y) =bloop'x@bloop'y) (x:G):ap(ClassifyingSpace_recPbbase'bloop'bloop_pp') (bloopx) =bloop'x.Proof.rewrite<-dp_apD_const'.unfoldClassifyingSpace_rec.rewriteClassifyingSpace_ind_beta_bloop.applyeissect.Qed.Sometimes we want to induct into a set which means we can ignore the bloop_pp arguments. Since this is a routine argument, we turn it into a special case of our induction principle.DefinitionClassifyingSpace_ind_hset(P:ClassifyingSpaceG->Type)`{forallb,IsTrunc0 (Pb)}(bbase':Pbbase) (bloop':forallx,DPathP(bloopx)bbase'bbase'):forallb,Pb.Proof.refine(ClassifyingSpace_indPbbase'bloop'_).intros.applyds_G1.applypath_ishprop.Defined.DefinitionClassifyingSpace_rec_hset(P:Type) `{IsTrunc0P} (bbase':P) (bloop':G->bbase'=bbase'):ClassifyingSpaceG->P.Proof.srapply(ClassifyingSpace_recPbbase'bloop'_).intros;applypath_ishprop.Defined.Similarly, when eliminating into an hprop, we only have to handle the basepoint.DefinitionClassifyingSpace_ind_hprop(P:ClassifyingSpaceG->Type)`{forallb,IsTrunc(-1) (Pb)} (bbase':Pbbase):forallb,Pb.Proof.refine(ClassifyingSpace_ind_hsetPbbase'_).intros;rapplydp_ishprop.Defined.EndEliminators.The classifying space is 0-connected.Global Instanceisconnected_classifyingspace{G:Group}:IsConnected0 (ClassifyingSpaceG).Proof.apply(Build_Contr_(trbbase)).srapplyTrunc_ind.srapplyClassifyingSpace_ind_hprop;reflexivity.Defined.The classifying space of a group is pointed.Global Instanceispointed_classifyingspace(G:Group):IsPointed(ClassifyingSpaceG):=bbase.DefinitionpClassifyingSpace(G:Group) := [ClassifyingSpaceG,bbase].To use theBGnotation forpClassifyingSpaceimport this module.ModuleImportClassifyingSpaceNotation.DefinitionBG:=pClassifyingSpaceG.EndClassifyingSpaceNotation.blooptakes the unit of the group to reflexivity.Definitionbloop_id{G:Group} :bloop(mon_unit:G) =idpath.Proof.symmetry.apply(cancelL(bloopmon_unit)).refine(_@bloop_pp__).refine(_@ap_(left_identity_)^).applyconcat_p1.Defined.bloop"preserves inverses" by taking inverses inGto inverses of paths inBG.Definitionbloop_inv{G:Group} :forallx:G,bloop(-x) = (bloopx)^.Proof.introx.refine(_@concat_p1_).applymoveL_Vp.refine(_@bloop_id).refine((bloop_pp__)^ @_).applyap,right_inverse.Defined.The underlying pointed map ofpequiv_g_loops_bg.Definitionpbloop{G:Group} :G->*loops(BG).Proof.srapplyBuild_pMap.1:exactbloop.applybloop_id.Defined.(* This says thatBis left adjoint to the loop space functor from pointed 1-types to groups. *)DefinitionpClassifyingSpace_rec{G:Group} (P:pType) `{IsTrunc1P}(bloop':G->loopsP)(bloop_pp':forallxy:G,bloop'(x*y) =bloop'x@bloop'y):BG->*P:=Build_pMap(BG)P(ClassifyingSpace_recP(pointP)bloop'bloop_pp')idpath.(* And this is one of the standard facts about adjoint functors: (R h') o eta = h, where h : G -> R P, h' : L G -> P is the adjunct, and eta (bloop) is the unit. *)DefinitionpClassifyingSpace_rec_beta_bloop{G:Group} (P:pType) `{IsTrunc1P}(bloop':G->loopsP)(bloop_pp':forallxy:G,bloop'(x*y) =bloop'x@bloop'y):fmaploops(pClassifyingSpace_recPbloop'bloop_pp')obloop==bloop'.Proof.introx;simpl.refine(concat_1p_@concat_p1_@_).applyClassifyingSpace_rec_beta_bloop.Defined.Here we prove thatBGis a delooping ofG, i.e. thatloopsBG<~>G.SectionEncodeDecode.Context`{Univalence} {G:Group}.Local Definitioncodes:BG->HSet.Proof.srapplyClassifyingSpace_rec.+srapply(Build_HSetG).+introx.applypath_trunctype.exact(Build_Equiv__(funt=>t*x)_).+introsxy;cbnbeta.refine(_@path_trunctype_pp__).applyap,path_equiv,path_forall.intro;cbn.applyassociativity.Defined.Local Definitionencode:forallb,bbase=b->codesb.Proof.introsbp.exact(transportcodespmon_unit).Defined.Local Definitioncodes_transport:forallxy:G,transportcodes(bloopx)y=y*x.Proof.introsxy.rewritetransport_idmap_ap.rewriteap_compose.rewriteClassifyingSpace_rec_beta_bloop.rewriteap_trunctype.byrewritetransport_path_universe_uncurried.Qed.Local Definitiondecode:forall(b:BG),codesb->bbase=b.Proof.srapplyClassifyingSpace_ind_hset.+exactbloop.+introx.applydp_arrow.introy;cbnin*.applydp_paths_r.refine((bloop_pp__)^ @_).symmetry.applyap,codes_transport.Defined.Local Lemmadecode_encode:forallbp,decodeb(encodebp) =p.Proof.introsbp.destructp.applybloop_id.Defined.Global Instanceisequiv_bloop:IsEquiv(@bloopG).Proof.srapplyisequiv_adjointify.+exact(encode_).+rapplydecode_encode.+introx.refine(codes_transport__@_).applyleft_identity.Defined.The defining property of BG.Definitionequiv_g_loops_bg:G<~>loops(BG):=Build_Equiv__bloop_.Pointed version of the defining property.Definitionpequiv_g_loops_bg:G<~>*loops(BG):=Build_pEquiv__pbloop_.Definitionpequiv_loops_bg_g:=pequiv_g_loops_bg^-1*%equiv.We also have that the equivalence is a group isomorphism.First we show that the loop space of a pointed 1-type is a group.DefinitionLoopGroup(X:pType) `{IsTrunc1X} :Group:=Build_Group(loopsX)concatidpathinverse(Build_IsGroup____(Build_IsMonoid___(Build_IsSemiGroup___concat_p_pp)concat_1pconcat_p1)concat_Vpconcat_pV).Definitiongrp_iso_g_loopgroup_bg:GroupIsomorphismG(LoopGroup(BG)).Proof.snrapplyBuild_GroupIsomorphism'.1:exactequiv_g_loops_bg.introsxy.applybloop_pp.Defined.Definitiongrp_iso_g_pi1_bg:GroupIsomorphismG(Pi1(BG)).Proof.snrapply(transitive_groupisomorphism___grp_iso_g_loopgroup_bg).snrapplyBuild_GroupIsomorphism'.-rapplyequiv_tr.-introsxy;reflexivity.Defined.(* We also record this fact. *)Definitiongrp_homo_loops{XY:pType} `{IsTrunc1X} `{IsTrunc1Y}: (X->**Y) ->* [LoopGroupX$->LoopGroupY,grp_homo_const].Proof.snrapplyBuild_pMap.-introf.snrapplyBuild_GroupHomomorphism.+exact(fmaploopsf).+nrapplyfmap_loops_pp.-cbnbeta.applyequiv_path_grouphomomorphism.exact(pointed_htpyfmap_loops_pconst).Defined.EndEncodeDecode.WhenGis an abelian group,BGis an H-space.SectionHSpace_bg.Context{G:AbGroup}.Definitionbg_mul:BG->BG->BG.Proof.introb.snrapplyClassifyingSpace_rec.1:exact_.1:exactb.{introx.revertb.snrapplyClassifyingSpace_ind_hset.1:exact_.1:exact(bloopx).cbn;introy.applydp_paths_lr.refine(concat_pp_p___@_).applymoveR_Vp.refine((bloop_pp__)^ @_@bloop_pp__).applyap,commutativity. }introsxy.revertb.srapplyClassifyingSpace_ind_hprop.exact(bloop_ppxy).Defined.Definitionbg_mul_symm:forallxy,bg_mulxy=bg_mulyx.Proof.introsx.srapplyClassifyingSpace_ind_hset.{simpl.revertx.srapplyClassifyingSpace_ind_hset.1:reflexivity.introsx.applysq_dp^-1,sq_1G.refine(ap_idmap_@_^).nrapplyClassifyingSpace_rec_beta_bloop. }introsy;revertx.simpl.snrapplyClassifyingSpace_ind_hprop.1:exact_.simpl.nrapply(transport_paths_FFlr'(g:=idmap)).applyequiv_p1_1q.lhsnrapplyap_idmap.nrapplyClassifyingSpace_rec_beta_bloop.Defined.Definitionbg_mul_left_id:forallb:BG,bg_mulbbaseb=b.Proof.applybg_mul_symm.Defined.Definitionbg_mul_right_id:forallb:BG,bg_mulbbbase=b.Proof.reflexivity.Defined.Global Instanceishspace_bg:IsHSpace(BG):=Build_IsHSpace_bg_mulbg_mul_left_idbg_mul_right_id.EndHSpace_bg.Functoriality of B(-)Global Instanceis0functor_pclassifyingspace:Is0FunctorB.Proof.applyBuild_Is0Functor.introsGHf.snrapplypClassifyingSpace_rec.-exact_.-exact(bloopof).-introsxy.refine(apbloop(grp_homo_opfxy) @_).applybloop_pp.Defined.Definitionbloop_natural(GH:Group) (f:G$->H):fmaploops(fmapBf)obloop==bloopof.Proof.nrapplypClassifyingSpace_rec_beta_bloop.Defined.Lemmapbloop_natural(GK:Group) (f:G$->K):fmaploops(fmapBf)o*pbloop==*pbloopo*f.Proof.srapplyphomotopy_homotopy_hset.applybloop_natural.Defined.Definitionnatequiv_g_loops_bg`{Univalence}:NatEquivptype_group(loopsoB).Proof.snrapplyBuild_NatEquiv.1:introsG;rapplypequiv_g_loops_bg.snrapplyBuild_Is1Natural.introsXYf.symmetry.applypbloop_natural.Defined.Global Instanceis1functor_pclassifyingspace:Is1FunctorB.Proof.applyBuild_Is1Functor.Action on 2-cells-introsGHfgp.snrapplyBuild_pHomotopy.{snrapplyClassifyingSpace_ind_hset.1:exact_.1:reflexivity.introx.rapplyequiv_sq_dp^-1.simpl.rewrite2ClassifyingSpace_rec_beta_bloop.applysq_1G.applyap.exact(px). }reflexivity.Preservation of identity-introsG.snrapplyBuild_pHomotopy.{snrapplyClassifyingSpace_ind_hset.1:exact_.1:reflexivity.introx.rapplyequiv_sq_dp^-1.simpl.rewriteClassifyingSpace_rec_beta_bloop.applysq_1G.symmetry.applyap_idmap. }reflexivity.Preservation of composition-introsGHKgf.snrapplyBuild_pHomotopy.{snrapplyClassifyingSpace_ind_hset.1:exact_.1:reflexivity.introx.rapplyequiv_sq_dp^-1.simpl.rapplysq_ccGG.1,2:symmetry.2:refine(ap_compose(ClassifyingSpace_rec___(funxy=>apbloop(grp_homo_opgxy) @bloop_pp(gx) (gy)))_(bloopx)@ap__@_).1-3:nrapplyClassifyingSpace_rec_beta_bloop.applysq_1G.reflexivity. }reflexivity.Defined.Interestingly,fmapBis an equivalenceGlobal Instanceisequiv_fmap_pclassifyingspace`{U:Univalence} (GH:Group):IsEquiv(fmapB(a:=G) (b:=H)).Proof.snrapplyisequiv_adjointify.{introsf.refine(grp_homo_compose(grp_iso_inverse_) (grp_homo_compose__)).1,3:rapplygrp_iso_g_loopgroup_bg.exact(grp_homo_loopsf). }{introsf.rapplyequiv_path_pforall.snrapplyBuild_pHomotopy.{snrapplyClassifyingSpace_ind_hset.1:exact_.{cbn;symmetry.rapply(point_eqf). }{introg.rapplyequiv_sq_dp^-1.rewriteClassifyingSpace_rec_beta_bloop.simpl.rapplysq_ccGc.1:symmetry;rapplydecode_encode.applyequiv_sq_path.rewriteconcat_pp_p.rewriteconcat_pp_V.reflexivity. } }symmetry;applyconcat_1p. }introsf.rapplyequiv_path_grouphomomorphism.introx.rapply(moveR_equiv_V'equiv_g_loops_bg).nrapplypClassifyingSpace_rec_beta_bloop.Defined.Hence we have that group homomorphisms are equivalent to pointed maps between their deloopings.Theoremequiv_grp_homo_pmap_bg`{U:Univalence} (GH:Group): (G$->H) <~> (BG$->BH).Proof.snrapplyBuild_Equiv.2:applyisequiv_fmap_pclassifyingspace.Defined.Global Instanceis1natural_grp_homo_pmap_bg_r{U:Univalence} (G:Group):Is1Natural(opyonG) (opyon(BG)oB) (equiv_grp_homo_pmap_bgG).Proof.snrapplyBuild_Is1Natural.introsKHfh.applypath_hom.rapply(fmap_compBhf).Defined.Theoremnatequiv_grp_homo_pmap_bg`{U:Univalence} (G:Group):NatEquiv(opyonG) (opyon(BG)oB).Proof.rapplyBuild_NatEquiv.Defined.B(Pi1X)<~>*Xfor a 0-connected 1-truncatedX.Theorempequiv_pclassifyingspace_pi1`{Univalence}(X:pType) `{IsConnected0X} `{IsTrunc1X}:B(Pi1X) <~>*X.Proof.The pointed mapfis the adjunct to the inverse of the natural maploopsX->Pi1X. We define it first, to make the later goals easier to read.transparentassert(f: (B(Pi1X) ->*X)).{snrapplypClassifyingSpace_rec.1:exact_.1:exact(equiv_tr0_)^-1%equiv.introsxy.strip_truncations.reflexivity. }snrapply(Build_pEquiv__f).fis an equivalence sinceloops_functorfobloop==tr^-1, and the other two maps are equivalences.applyisequiv_is0connected_isequiv_loops.snrapply(cancelR_isequivbloop).1:exact_.rapplyisequiv_homotopic';symmetry.nrapplypClassifyingSpace_rec_beta_bloop.Defined.Lemmanatequiv_bg_pi1_adjoint`{Univalence} (X:pType) `{IsConnected0X}:NatEquiv(opyon(Pi1X)) (opyonXoB).Proof.nrefine(natequiv_compose(G:=opyon(Pi1(pTr1X)))__).2:exact(natequiv_opyon_equiv(A:=Group) (grp_iso_inverse(grp_iso_pi_Tr0X))).refine(natequiv_compose_(natequiv_grp_homo_pmap_bg_)).refine(natequiv_compose(G:=opyon(pTr1X)oB)__);revgoals.{refine(natequiv_prewhisker__).refine(natequiv_opyon_equiv_^-1$).rapplypequiv_pclassifyingspace_pi1. }snrapplyBuild_NatEquiv.1:intro;exactpequiv_ptr_rec.rapplyis1natural_prewhisker.Defined.The classifying space functor and the fundamental group functor form an adjunction (pType needs to be restricted to the subcategory of 0-connected pTypes). Note that the full adjunction should also be natural in X, but this was not needed yet.Theoremequiv_bg_pi1_adjoint`{Univalence} (X:pType)`{IsConnected0X} (G:Group): (Pi1X$->G) <~> (X$->BG).Proof.rapplynatequiv_bg_pi1_adjoint.Defined.Lemmais1natural_equiv_bg_pi1_adjoint_r`{Univalence}(X:pType) `{IsConnected0X}:Is1Natural(opyon(Pi1X)) (opyonXoB)(equiv_bg_pi1_adjointX).Proof.rapply(is1natural_natequiv(natequiv_bg_pi1_adjointX)).Why so slow? Fixed by making this opaque.Opaqueequiv_bg_pi1_adjoint.Defined.Transparentequiv_bg_pi1_adjoint.

--- Miscellaneous\Closed.html ---
ClosedLibrary ClosedRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensions.RequireImportModalityAccessibleNullificationLexTopological.RequireImportColimits.PushoutHomotopy.Join.Core.Local OpenScopenat_scope.Local OpenScopepath_scope.Closed modalitiesWe begin by characterizing the modal types.SectionClosedModalTypes.Context(U:HProp).Definitionequiv_inO_closed(A:Type): (U->ContrA) <->IsEquiv(funa:A=>push(inra) :JoinUA).Proof.split.-introsuac.simplerefine(isequiv_adjointify____).*simplerefine(Pushout_recA___).+introsu;pose(uacu);exact(centerA).+introsa;assumption.+intros[ua].simpl.pose(uacu).applycontr.*introsz.patternz.simplerefine(Pushout_ind____z).+introsu.pose(contr_inhabited_hpropUu).applypath_contr.+introsa;reflexivity.+intros[ua];pose(contr_inhabited_hpropUu).applypath_contr.*introsa.reflexivity.-intros?u.refine(contr_equiv(JoinUA) (funa:A=>push(inra))^-1).pose(contr_inhabited_hpropUu).exact_.Defined.EndClosedModalTypes.Exercise 7.13(ii): Closed modalitiesDefinitionCl(U:HProp) :Modality.Proof.snrapplyBuild_Modality.-introsX;exact(U->ContrX).-exact_.-introsTBT_inOffeq.cbn;introsu;pose(T_inOu).refine(contr_equiv_f);exact_.-intros;exact(JoinUX).-introsTu.pose(contr_inhabited_hprop_u).exact_.-introsTx.exact(push(inrx)).-introsABB_inOfz.srefine(Pushout_indB___z).+introsu;applycenter,B_inO,u.+introsa;applyf.+intros[ua].pose(B_inO(push(inra))u).applypath_contr.-intros;reflexivity.-introsAA_inOzz'u.pose(A_inOu).applycontr_paths_contr.Defined.The closed modality is accessible.Global Instanceaccmodality_closed(U:HProp):IsAccModality(ClU).Proof.unshelveeconstructor.-econstructor.exact(fun_:U=>Empty).-introsX;split.+introsX_inOu.pose(X_inOu).applyooextendable_contr;exact_.+introsextu.apply(Build_Contr_((fst(extu1%nat)Empty_rec).1tt));introsx.unfoldconstinext.exact((fst(snd(extu2) (fst(extu1%nat)Empty_rec).1(fun_=>x)) (Empty_ind_)).1tt).Defined.In fact, it is topological, and therefore (assuming univalence) lex.  As for topological modalities generally, we don't need to declare these as global instances, but we prove them here as local instances for exposition.Local Instancetopological_closed(U:HProp):Topological(ClU):=_.Global Instancelex_closed`{Univalence} (U:HProp):Lex(ClU).Proof.rapplylex_topological.Defined.Thus, it also has the following alternative version.DefinitionCl'(U:HProp) :Modality:=Nul(Build_NullGeneratorsU(fun_=>Empty)).

--- Miscellaneous\Cocone.html ---
CoconeLibrary CoconeRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Graph.RequireImportDiagrams.Diagram.Local OpenScopepath_scope.Generalizable All Variables.CoconesA Cocone over a diagramDto a typeXis a family of maps from the types ofDtoXmaking the triangles formed with the arrows ofDcommuting.ClassCocone{G:Graph} (D:DiagramG) (X:Type) := {legs:foralli,Di->X;legs_comm:forallij(g:Gij),legsjo(D_fg) ==legsi;}.ArgumentsBuild_Cocone{GDX}legslegs_comm.Argumentslegs{GDX}Cix:rename.Argumentslegs_comm{GDX}Cijgx:rename.Coercionlegs:Cocone>->Funclass.Definitionissig_Cocone{G:Graph} (D:DiagramG) (X:Type):_<~>CoconeDX:=ltac:(issig).SectionCocone.Context`{Funext} {G:Graph} {D:DiagramG} {X:Type}.path_coconesays when two cocones are equal (up to funext).Definitionpath_cocone_naive{C1C2:CoconeDX}(P:=funq'=>forall(ij:G) (g:Gij) (x:Di),q'j(D_fgx) =q'ix)(path_legs:legsC1=legsC2)(path_legs_comm:transportPpath_legs(legs_commC1) =legs_commC2):C1=C2:=matchpath_legs_commin(_=v1)returnC1= {|legs:=legsC2;legs_comm:=v1|}with|idpath=>matchpath_legsin(_=v0)returnC1= {|legs:=v0;legs_comm:=path_legs# (legs_commC1) |}with|idpath=> 1endend.Definitionpath_cocone{C1C2:CoconeDX}(path_legs:foralli,C1i==C2i)(path_legs_comm:forallijgx,legs_commC1ijgx@path_legsix=path_legsj(D_fgx) @legs_commC2ijgx):C1=C2.Proof.destructC1as[legspp_q],C2as[rpp_r].refine(path_cocone_naive(path_forall__(funi=>path_forall__(path_legsi)))_).cbn;funextijfx.rewrite4transport_forall_constant,transport_paths_FlFr.rewriteconcat_pp_p;applymoveR_Vp.rewrite2 (ap_apply_lD2(path_forall__(funi=>path_forall__(path_legsi)))).rewrite3eisretr.applypath_legs_comm.Defined.Given a coconeCtoXand a map fromXtoY, one can postcompose each map ofCto get a cocone toY.Definitioncocone_postcompose(C:CoconeDX) {Y:Type}: (X->Y) ->CoconeDY.Proof.introsf.srapplyBuild_Cocone;introi.1:exact(foCi).introsjgx.exact(apf(legs_comm_ijgx)).Defined.Universality of a cocone.A colimit will be the extremity of a universal cocone.A coconeCoverDtoXis said universal when for allYthe mapcocone_postcomposeis an equivalence. In particular, given another coconeC'overDtoX'the inverse of the map allows to recover a maph:X->X'such thatC'isCpostcomposed withh. The fact thatcocone_postcomposeis an equivalence is an elegant way of stating the usual "unique existence" of category theory.ClassUniversalCocone(C:CoconeDX) := {is_universal:forallY,IsEquiv(@cocone_postcomposeCY);}.(* Use :> and remove the two following lines,once Coq 8.16 is the minimum required version. *)#[export]ExistingInstanceis_universal.Coercionis_universal:UniversalCocone>->Funclass.EndCocone.We now prove several functoriality results, first on cocone and then on colimits.SectionFunctorialityCocone.Context`{Funext} {G:Graph}.Postcomposition for coconesIdentity and associativity for the postcomposition of a cocone with a map.Definitioncocone_postcompose_identity{D:DiagramG} `(C:Cocone_DX):cocone_postcomposeCidmap=C.Proof.srapplypath_cocone;introi.1:reflexivity.introsjgx;simpl.applyequiv_p1_1q,ap_idmap.Defined.Definitioncocone_postcompose_comp{D:DiagramG}`(f:X->Y) `(g:Y->Z) (C:CoconeDX):cocone_postcomposeC(gof)=cocone_postcompose(cocone_postcomposeCf)g.Proof.srapplypath_cocone;introi.1:reflexivity.introsjhx;simpl.applyequiv_p1_1q,ap_compose.Defined.Precomposition for coconesGiven a cocone overD2and a Diagram mapm:D1=>D2, one can precompose each map of the cocone by the corresponding one ofmto get a cocone overD1.Definitioncocone_precompose{D1D2:DiagramG} (m:DiagramMapD1D2) {X}: (CoconeD2X) -> (CoconeD1X).Proof.introC.srapplyBuild_Cocone;introi.1:exact(Ciomi).introsjgx;simpl.etransitivity.+applyap.symmetry.applyDiagramMap_comm.+applylegs_comm.Defined.Identity and associativity for the precomposition of a cocone with a diagram map.Definitioncocone_precompose_identity(D:DiagramG) (X:Type):cocone_precompose(X:=X) (diagram_idmapD) ==idmap.Proof.introC;srapplypath_cocone;simpl.1:reflexivity.intros;simpl.applyconcat_p1.Defined.Definitioncocone_precompose_comp{D1D2D3:DiagramG}(m2:DiagramMapD2D3) (m1:DiagramMapD1D2) (X:Type): (cocone_precompose(X:=X)m1)o(cocone_precomposem2)==cocone_precompose(diagram_compm2m1).Proof.introC;simpl.srapplypath_cocone.1:reflexivity.introsijgx;simpl.applyequiv_p1_1q.unfoldCommutativeSquares.comm_square_comp.refine(concat_p_pp___@_).applyap10,ap.rewrite3ap_V.refine((inv_pp__)^ @_).applyinverse2.rewriteap_pp.applyap.byrewriteap_compose.Defined.Associativity of a precomposition and a postcomposition.Definitioncocone_precompose_postcompose{D1D2:DiagramG}(m:DiagramMapD1D2) `(f:X->Y) (C:CoconeD2X):cocone_postcompose(cocone_precomposemC)f=cocone_precomposem(cocone_postcomposeCf).Proof.srapplypath_cocone;introi.1:reflexivity.introsjgx;simpl.applyequiv_p1_1q.etransitivity.+applyap_pp.+applyap10,ap.symmetry.applyap_compose.Defined.The precomposition with a diagram equivalence is an equivalence.Global Instancecocone_precompose_equiv{D1D2:DiagramG}(m:D1~d~D2) (X:Type) :IsEquiv(cocone_precompose(X:=X)m).Proof.srapplyisequiv_adjointify.1:apply(cocone_precompose(diagram_equiv_invm)).+introsC.etransitivity.-applycocone_precompose_comp.-rewritediagram_inv_is_retraction.applycocone_precompose_identity.+introsC.etransitivity.-applycocone_precompose_comp.-rewritediagram_inv_is_section.applycocone_precompose_identity.Defined.The postcomposition with an equivalence is an equivalence.Global Instancecocone_postcompose_equiv{D:DiagramG} `(f:X<~>Y):IsEquiv(funC:CoconeDX=>cocone_postcomposeCf).Proof.srapplyisequiv_adjointify.1:exact(funC=>cocone_postcomposeCf^-1).+introsC.etransitivity.-symmetry.applycocone_postcompose_comp.-etransitivity.2:applycocone_postcompose_identity.applyap.funextx;applyeisretr.+introsC.etransitivity.-symmetry.applycocone_postcompose_comp.-etransitivity.2:applycocone_postcompose_identity.applyap.funextx;applyeissect.Defined.Universality preservationUniversality of a cocone is preserved by composition with a (diagram) equivalence.Global Instancecocone_precompose_equiv_universality{D1D2:DiagramG}(m:D1~d~D2) {X} (C:CoconeD2X) (_:UniversalCoconeC):UniversalCocone(cocone_precompose(X:=X)mC).Proof.srapplyBuild_UniversalCocone;intro.rewrite(path_forall__(funf=>cocone_precompose_postcomposemfC)).srapplyisequiv_compose.Defined.Global Instancecocone_postcompose_equiv_universality{D:DiagramG} `(f:X<~>Y)(C:CoconeDX) (_:UniversalCoconeC):UniversalCocone(cocone_postcomposeCf).Proof.snrapplyBuild_UniversalCocone;intro.rewrite<- (path_forall__(fung=>cocone_postcompose_compfgC)).srapplyisequiv_compose.Defined.EndFunctorialityCocone.

--- Miscellaneous\Coeq.html ---
CoeqLibrary CoeqRequireImportBasics.RequireImportTypes.PathsTypes.ArrowTypes.SigmaTypes.ForallTypes.UniverseTypes.Prod.RequireImportColimits.GraphQuotient.Local OpenScopepath_scope.Homotopy coequalizersDefinitionDefinitionCoeq@{iju} {B:Type@{i}} {A:Type@{j}} (fg:B->A) :Type@{u}:=GraphQuotient@{iju} (funab=> {x:B& (fx=a) * (gx=b)}).Definitioncoeq{BAfg} (a:A) : @CoeqBAfg:=gqa.Definitioncglue{BAfg}b: @coeqBAfg(fb) =coeq(gb):=gqglue(b; (idpath,idpath)).ArgumentsCoeq:simplnever.Argumentscoeq:simplnever.Argumentscglue:simplnever.DefinitionCoeq_ind{BAfg} (P: @CoeqBAfg->Type)(coeq':foralla,P(coeqa))(cglue':forallb, (cglueb) # (coeq'(fb)) =coeq'(gb)):forallw,Pw.Proof.rapplyGraphQuotient_ind.introsab[x[[] []]].exact(cglue'x).Defined.LemmaCoeq_ind_beta_cglue{BAfg} (P: @CoeqBAfg->Type)(coeq':foralla,P(coeqa))(cglue':forallb, (cglueb) # (coeq'(fb)) =coeq'(gb)) (b:B):apD(Coeq_indPcoeq'cglue') (cglueb) =cglue'b.Proof.rapplyGraphQuotient_ind_beta_gqglue.Defined.DefinitionCoeq_rec{BAfg} (P:Type) (coeq':A->P)(cglue':forallb,coeq'(fb) =coeq'(gb)): @CoeqBAfg->P.Proof.rapplyGraphQuotient_rec.introsab[x[[] []]].exact(cglue'x).Defined.DefinitionCoeq_rec_beta_cglue{BAfg} (P:Type) (coeq':A->P)(cglue':forallb:B,coeq'(fb) =coeq'(gb)) (b:B):ap(Coeq_recPcoeq'cglue') (cglueb) =cglue'b.Proof.rapplyGraphQuotient_rec_beta_gqglue.Defined.DefinitionCoeq_ind_hprop{BAfg} (P: @CoeqBAfg->Type)`{forallx,IsHProp(Px)}(i:foralla,P(coeqa)):forallx,Px.Proof.snrapplyCoeq_ind.1:exacti.introsb.rapplypath_ishprop.Defined.DefinitionCoeq_ind_eta_homotopic{BAfg} {P: @CoeqBAfg->Type}(h:forallw:Coeqfg,Pw):h==Coeq_indP(hocoeq) (funb=>apDh(cglueb)).Proof.unfoldpointwise_paths.nrapply(Coeq_ind_(fun_=> 1)).introsb.lhsnrapplytransport_paths_FlFr_D.lhsnrapply(whiskerL_(Coeq_ind_beta_cglue____)).lhsnrapply(whiskerR(concat_p1_)).nrapplyconcat_Vp.Defined.DefinitionCoeq_rec_eta_homotopic{BAfg} {P:Type} (h: @CoeqBAfg->P):h==Coeq_recP(hocoeq) (funb=>aph(cglueb)).Proof.unfoldpointwise_paths.nrapply(Coeq_ind_(fun_=> 1)).introsb.applytransport_paths_FlFr',equiv_p1_1q.symmetry;nrapplyCoeq_rec_beta_cglue.Defined.DefinitionCoeq_ind_eta`{Funext}{BAfg} {P: @CoeqBAfg->Type} (h:forallw:Coeqfg,Pw):h=Coeq_indP(hocoeq) (funb=>apDh(cglueb)):=path_forall__(Coeq_ind_eta_homotopich).DefinitionCoeq_rec_eta`{Funext}{BAfg} {P:Type} (h: @CoeqBAfg->P):h=Coeq_recP(hocoeq) (funb=>aph(cglueb)):=path_forall__(Coeq_rec_eta_homotopich).DefinitionCoeq_ind_homotopy{BAfg} (P: @CoeqBAfg->Type){mn:foralla,P(coeqa)} (u:m==n){r:forallb, (cglueb) # (m(fb)) =m(gb)}{s:forallb, (cglueb) # (n(fb)) =n(gb)}(p:forallb,ap(transportP(cglueb)) (u(fb)) @ (sb) =rb@u(gb)):Coeq_indPmr==Coeq_indPns.Proof.unfoldpointwise_paths.nrapplyCoeq_ind;introsb.lhsnrapply(transport_paths_FlFr_D(f:=Coeq_indPmr) (g:=Coeq_indPns)).lhsnrapply(whiskerL_(Coeq_ind_beta_cgluePnsb)).lhsnrapply(whiskerR(whiskerR(apinverse(Coeq_ind_beta_cgluePmrb))_)).lhsnrapplyconcat_pp_p;nrapplymoveR_Mp.rhsnrapply(whiskerR(inv_V_)).exact(pb).Defined.Universal propertySee Colimits/CoeqUnivProp.v for a similar universal property withoutFunext.DefinitionCoeq_unrec{BA} (fg:B->A) {P}(h:Coeqfg->P): {k:A->P&kof==kog}.Proof.exists(hocoeq).introsb.exact(aph(cglueb)).Defined.Definitionisequiv_Coeq_rec`{Funext} {BA} (fg:B->A)P:IsEquiv(funp: {h:A->P&hof==hog} =>Coeq_recPp.1p.2).Proof.srapply(isequiv_adjointify_(Coeq_unrecfg)).-introsh.applypath_arrow.srapplyCoeq_ind;introsb.1:cbn;reflexivity.cbn.nrapplytransport_paths_FlFr'.applyequiv_p1_1q.nrapplyCoeq_rec_beta_cglue.-intros[hq];srapplypath_sigma'.+reflexivity.+cbn.rapplypath_forall;introsb.applyCoeq_rec_beta_cglue.Defined.Definitionequiv_Coeq_rec`{Funext} {BA} (fg:B->A)P: {h:A->P&hof==hog} <~> (Coeqfg->P):=Build_Equiv___(isequiv_Coeq_recfgP).FunctorialityDefinitionfunctor_coeq{BAfgB'A'f'g'}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh): @CoeqBAfg-> @CoeqB'A'f'g'.Proof.refine(Coeq_rec_(coeqok)_);introsb.refine(apcoeq(pb) @_@apcoeq(qb)^).applycglue.Defined.Definitionfunctor_coeq_beta_cglue{BAfgB'A'f'g'}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)(b:B):ap(functor_coeqhkpq) (cglueb)=apcoeq(pb) @cglue(hb) @apcoeq(qb)^:= (Coeq_rec_beta_cglue___b).Definitionfunctor_coeq_compose{BAfgB'A'f'g'B''A''f''g''}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)(h':B'->B'') (k':A'->A'')(p':k'of'==f''oh') (q':k'og'==g''oh'):functor_coeq(h'oh) (k'ok)(funb=>apk'(pb) @p'(hb))(funb=>apk'(qb) @q'(hb))==functor_coeqh'k'p'q'ofunctor_coeqhkpq.Proof.refine(Coeq_ind_(funa=> 1)_);cbn;introsb.nrapplytransport_paths_FlFr'.applyequiv_p1_1q;symmetry.rewriteap_compose.rewrite!functor_coeq_beta_cglue, !ap_pp,functor_coeq_beta_cglue.rewrite<- !ap_compose.cbn.rewrite!ap_V,ap_pp,inv_pp, <-ap_compose, !concat_p_pp.reflexivity.Qed.Definitionfunctor_coeq_homotopy{BAfgB'A'f'g'}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)(h':B->B') (k':A->A')(p':k'of==f'oh') (q':k'og==g'oh')(r:h==h') (s:k==k')(u:forallb,s(fb) @p'b=pb@apf'(rb))(v:forallb,s(gb) @q'b=qb@apg'(rb)):functor_coeqhkpq==functor_coeqh'k'p'q'.Proof.refine(Coeq_ind_(funa=>apcoeq(sa))_);cbn;introsb.refine(transport_paths_FlFr(cglueb)_@_).rewriteconcat_pp_p;applymoveR_Vp.rewrite!functor_coeq_beta_cglue.OpenScopelong_path_scope.rewrite!concat_p_pp.rewrite<- (ap_pp(@coeq__f'g') (s(fb)) (p'b)).rewriteu,ap_pp, !concat_pp_p;applywhiskerL;rewrite!concat_p_pp.rewriteap_V;applymoveR_pV.rewrite!concat_pp_p, <- (ap_pp(@coeq__f'g') (s(gb)) (q'b)).rewritev,ap_pp,ap_V,concat_V_pp.rewrite<- !ap_compose.exact(concat_Ap(@cglue__f'g') (rb)).CloseScopelong_path_scope.Qed.Definitionfunctor_coeq_sect{BAfgB'A'f'g'}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)(h':B'->B) (k':A'->A)(p':k'of'==foh') (q':k'og'==goh')(r:h'oh==idmap) (s:k'ok==idmap)(u:forallb,apk'(pb) @p'(hb) @apf(rb) =s(fb))(v:forallb,apk'(qb) @q'(hb) @apg(rb) =s(gb)): (functor_coeqh'k'p'q')o(functor_coeqhkpq) ==idmap.Proof.refine(Coeq_ind_(funa=>apcoeq(sa))_);cbn;introsb.refine(transport_paths_FFlr(cglueb)_@_).rewriteconcat_pp_p;applymoveR_Vp.rewritefunctor_coeq_beta_cglue, !ap_pp.rewrite<- !ap_compose;cbn.rewritefunctor_coeq_beta_cglue.OpenScopelong_path_scope.rewrite!concat_p_pp.rewrite<-u, !ap_pp, !(ap_composek'coeq).rewrite!concat_pp_p;do2applywhiskerL.rewrite!concat_p_pp.rewrite<-v.rewrite!ap_pp, !ap_V, !concat_p_pp, !concat_pV_p.rewrite<- !ap_compose.exact(concat_Apcglue(rb)).CloseScopelong_path_scope.Qed.SectionIsEquivFunctorCoeq.Context{BAfgB'A'f'g'}(h:B->B') (k:A->A')`{IsEquiv__h} `{IsEquiv__k}(p:kof==f'oh) (q:kog==g'oh).Definitionfunctor_coeq_inverse: @CoeqB'A'f'g'-> @CoeqBAfg.Proof.refine(functor_coeqh^-1k^-1__).-introsb.refine(ap(k^-1of') (eisretrhb)^ @_@eissectk(f(h^-1b))).applyap,inverse,p.-introsb.refine(ap(k^-1og') (eisretrhb)^ @_@eissectk(g(h^-1b))).applyap,inverse,q.Defined.Definitionfunctor_coeq_eissect: (functor_coeqhkpq)ofunctor_coeq_inverse==idmap.Proof.OpenScopelong_path_scope.refine(functor_coeq_sect________(eisretrh) (eisretrk)__);introsb.The two proofs are identical modulo replacingfbyg,f'byg', andpbyq.all:rewrite!ap_pp, <-eisadj.all:rewrite<- !ap_compose.all:rewrite(concat_pA1_p(eisretrk)__).all:rewriteconcat_pV_p.all:rewrite<- (ap_compose(k^-1o_)k).all:rewrite(ap_compose_(kok^-1)).all:rewrite(concat_A1p(eisretrk) (ap_(eisretrhb)^)).all:rewriteap_V,concat_pV_p;reflexivity.CloseScopelong_path_scope.Qed.Definitionfunctor_coeq_eisretr:functor_coeq_inverseo(functor_coeqhkpq) ==idmap.Proof.OpenScopelong_path_scope.refine(functor_coeq_sect________(eissecth) (eissectk)__);introsb.all:rewrite!concat_p_pp,eisadj, <-ap_V, <- !ap_compose.all:rewrite(ap_compose(_oh)k^-1).all:rewrite<- !(ap_ppk^-1), !concat_pp_p.1:rewrite(concat_Ap(funb=> (pb)^) (eissecthb)^).2:rewrite(concat_Ap(funb=> (qb)^) (eissecthb)^).all:rewriteconcat_p_Vp,concat_p_pp.all:rewrite<- (ap_compose(ko_)k^-1), (ap_compose_(k^-1ok)).all:rewrite(concat_A1p(eissectk)_).all:rewriteap_V,concat_pV_p;reflexivity.CloseScopelong_path_scope.Qed.Global Instanceisequiv_functor_coeq:IsEquiv(functor_coeqhkpq):=isequiv_adjointify_functor_coeq_inversefunctor_coeq_eissectfunctor_coeq_eisretr.Definitionequiv_functor_coeq: @CoeqBAfg<~> @CoeqB'A'f'g':=Build_Equiv__(functor_coeqhkpq)_.EndIsEquivFunctorCoeq.Definitionequiv_functor_coeq'{BAfgB'A'f'g'}(h:B<~>B') (k:A<~>A')(p:kof==f'oh) (q:kog==g'oh): @CoeqBAfg<~> @CoeqB'A'f'g':=equiv_functor_coeqhkpq.A double recursion principleSectionCoeqRec2.Context{BA:Type} {fg:B->A} {B'A':Type} {f'g':B'->A'}(P:Type) (coeq':A->A'->P)(cgluel:forallba',coeq'(fb)a'=coeq'(gb)a')(cgluer:forallab',coeq'a(f'b') =coeq'a(g'b'))(cgluelr:forallbb',cgluelb(f'b') @cgluer(gb)b'=cgluer(fb)b'@cgluelb(g'b')).DefinitionCoeq_rec2:Coeqfg->Coeqf'g'->P.Proof.introsxy;revertx.snrapplyCoeq_rec.-introsa.reverty.snrapplyCoeq_rec.+introsa'.exact(coeq'aa').+introsb';cbn.applycgluer.-introsb.reverty.snrapplyCoeq_ind.+introsa'.cbn.applycgluel.+introsb'.nrapply(transport_paths_FlFr'(cglueb')).lhsnrapply(_@@ 1).1:applyCoeq_rec_beta_cglue.rhsnrapply(1 @@_).2:applyCoeq_rec_beta_cglue.symmetry.applycgluelr.Defined.DefinitionCoeq_rec2_beta(a:A) (a':A'):Coeq_rec2(coeqa) (coeqa') =coeq'aa':= 1.DefinitionCoeq_rec2_beta_cgluel(a:A) (b':B'):ap(Coeq_rec2(coeqa)) (cglueb') =cgluerab'.Proof.nrapplyCoeq_rec_beta_cglue.Defined.DefinitionCoeq_rec2_beta_cgluer(b:B) (a':A'):ap(funx=>Coeq_rec2x(coeqa')) (cglueb) =cgluelba'.Proof.nrapplyCoeq_rec_beta_cglue.Defined.TODO:Coeq_rec2_beta_cgluelrEndCoeqRec2.A double induction principleSectionCoeqInd2.Context`{Funext}{BA:Type} {fg:B->A} {B'A':Type} {f'g':B'->A'}(P:Coeqfg->Coeqf'g'->Type)(coeq':forallaa',P(coeqa) (coeqa'))(cgluel:forallba',transport(funx=>Px(coeqa')) (cglueb)(coeq'(fb)a') =coeq'(gb)a')(cgluer:forallab',transport(funy=>P(coeqa)y) (cglueb')(coeq'a(f'b')) =coeq'a(g'b'))Perhaps this should really be written usingconcatD.(cgluelr:forallbb',ap(transport(P(coeq(gb))) (cglueb')) (cgluelb(f'b'))@cgluer(gb)b'=transport_transportP(cglueb) (cglueb') (coeq'(fb) (f'b'))@ap(transport(funx=>Px(coeq(g'b'))) (cglueb))(cgluer(fb)b')@cgluelb(g'b')).DefinitionCoeq_ind2:forallxy,Pxy.Proof.simplerefine(Coeq_ind___).-introsa.simplerefine(Coeq_ind___).+introsa'.exact(coeq'aa').+introsb';cbn.applycgluer.-introsb.applypath_forall;introsa.reverta;simplerefine(Coeq_ind___).+introsa'.cbn.refine(transport_forall_constant___@_).applycgluel.+introsb';cbn.refine(transport_paths_FlFr_D(cglueb')_@_).rewriteCoeq_ind_beta_cglue.Now begins the long haul.OpenScopelong_path_scope.rewriteap_pp.repeatrewriteconcat_p_pp.Our first order of business is to get rid of theCoeq_inds, which only occur in the following incarnation.set(G:= (Coeq_ind(P(coeq(fb)))(funa':A'=>coeq'(fb)a')(funb'0:B'=>cgluer(fb)b'0))).Let's reduce theapD(loop#G)first.rewrite(apD_transport_forall_constantP(cglueb)G(cglueb'));simpl.rewrite!inv_pp, !inv_V.Now we can cancel atransport_forall_constant.rewrite!concat_pp_p;applywhiskerL.And a path-inverse pair.  This removes all thetransport_forall_constants.rewrite!concat_p_pp,concat_pV_p.Now we can beta-reduce the last remainingG.substG;rewriteCoeq_ind_beta_cglue;simpl.Now we just have to rearrange it a bit.rewrite!concat_pp_p;do2applymoveR_Vp;rewrite!concat_p_pp.applycgluelr.CloseScopelong_path_scope.Qed.EndCoeqInd2.SymmetryDefinitionCoeq_sym_map{BA} (fg:B->A) :Coeqfg->Coeqgf:=Coeq_rec(Coeqgf)coeq(funb:B=> (cglueb)^).Lemmasect_Coeq_sym_map{BA} {fg:B->A}: (Coeq_sym_mapfg)o(Coeq_sym_mapgf) ==idmap.Proof.srapply@Coeq_ind.-reflexivity.-introb.simpl.abstract(rewritetransport_paths_FFlr,Coeq_rec_beta_cglue,ap_V,Coeq_rec_beta_cglue;hott_simpl).Defined.LemmaCoeq_sym{BA} {fg:B->A} : @CoeqBAfg<~>Coeqgf.Proof.exact(equiv_adjointify(Coeq_sym_mapfg) (Coeq_sym_mapgf)sect_Coeq_sym_mapsect_Coeq_sym_map).Defined.FlatteningThe flattening lemma for coequalizers follows from the flattening lemma for graph quotients.SectionFlattening.Context`{Univalence} {BA:Type} {fg:B->A}(F:A->Type) (e:forallb,F(fb) <~>F(gb)).Definitioncoeq_flatten_fam:Coeqfg->Type:=Coeq_recTypeF(funx=>path_universe(ex)).Local DefinitionR(ab:A) := {x:B& (fx=a) * (gx=b)}.Local Definitione'(ab:A) :Rab-> (Fa<~>Fb).Proof.intros[x[[] []]];exact(ex).Defined.Definitionequiv_coeq_flatten:sigcoeq_flatten_fam<~>Coeq(functor_sigmaf(fun_=>idmap)) (functor_sigmage).Proof.snrefine(_oEequiv_gq_flattenFe'oE_).-snrapplyequiv_functor_gq.1:reflexivity.intros[ax] [by];simpl.unfoldfunctor_sigma.(* We useequiv_path_sigmatwice on the RHS: *)equiv_via{x0: {H0:B&F(fH0)} &{p:fx0.1 =a&p#x0.2 =x} * {q:gx0.1 =b&q#ex0.1x0.2 =y}}.2: {nrapplyequiv_functor_sigma_id;intros[cz];cbn.nrapplyequiv_functor_prod'.all:apply(equiv_path_sigma_(_;_) (_;_)). }(*make_equiv_contr_basedpaths.handles the rest, but is slow, so we do some steps manually. *)(* The RHS can be shuffled to this form: *)equiv_via{r:Rab& {x02:F(fr.1) & (transportF(fstr.2)x02=x) *(transportF(sndr.2) (er.1x02) =y)}}.2:make_equiv.(* Three path contractions handle the rest. *)nrapplyequiv_functor_sigma_id;intros[c[pq]].destructp,q;unfolde';simpl.make_equiv_contr_basedpaths.-applyequiv_functor_sigma_id;introsx.applyequiv_path.revertx;snrapplyCoeq_ind.1:reflexivity.simpl.introsb.snrapply(dpath_path_FlFr(cglueb)).applyequiv_1p_q1.rhsnrapplyCoeq_rec_beta_cglue.exact(GraphQuotient_rec_beta_gqglue_(funabs=>path_universe(e'abs))___).Defined.EndFlattening.

--- Miscellaneous\CoeqUnivProp.html ---
CoeqUnivPropLibrary CoeqUnivPropRequireImportBasics.Overture.RequireImportBasics.Tactics.RequireImportBasics.PathGroupoids.RequireImportTypes.Paths.RequireImportColimits.Coeq.RequireImportCubical.DPath.RequireImportCubical.DPathSquare.RequireImportWildCat.Core.RequireImportWildCat.Displayed.RequireImportWildCat.Equiv.RequireImportWildCat.EquivGpd.RequireImportWildCat.Forall.RequireImportWildCat.NatTrans.RequireImportWildCat.Paths.RequireImportWildCat.ZeroGroupoid.Using wild 0-groupoids, the universal property can be proven without funext. A simple equivalence of 0-groupoids betweenCoeqfg->Pand{h:A->P&hof==hog}would not carry all the higher-dimensional information, but if we generalize it to dependent functions, then it does suffice.SectionUnivProp.Context{BA:Type} (fg:B->A) (P:Coeqfg->Type).This allows Coq to infer 0-groupoid structures of the form@isgraph_forallCP(func=>isgraph_paths(Pc))on any type of the formforallc,Pc.isgraph_pathsis not a global instance.isgraph_totalis, but we need to adjust the priority.  The other needed ingredients are all global instances.Local Existing Instancesisgraph_total| 1.Local Existing Instancesisgraph_paths| 2.The domain of the equivalence: sections ofPoverCoeqfg. Coq correctly infers the 0-groupoid structure@isgraph_forall(Coeqfg)P(funz:Coeqfg=>isgraph_paths(Pz)).DefinitionCoeq_ind_type:=forallz:Coeqfg,Pz.The codomain of the equivalence is a sigma-groupoid of this family:DefinitionCoeq_ind_data(h:foralla:A,P(coeqa)):=forallb:B,DPathP(cglueb) (h(fb)) (h(gb)).We considerCoeq_ind_datato be a displayed 0-groupoid, where objects overh:foralla:A,P(coeqa)are dependent paths as defined above and morphisms overp:h==kare witnesses thatpcommutes with the homotopies overhandk.Local Instanceisdgraph_Coeq_ind_data:IsDGraphCoeq_ind_data.Proof.introshkprs.exact(forallb,ap(transportP(cglueb)) (p(fb)) @sb=rb@p(gb)).Defined.Local Instanceisd01cat_Coeq_ind_data:IsD01CatCoeq_ind_data.Proof.nrapplyBuild_IsD01Cat.-introshh'b;exact(concat_1p_p1_).-introshkjpqh'k'j'p'q'b.lhsnrapplyap_pp_p.lhsnrapply(whiskerL_(p'b)).lhsnrapplyconcat_p_pp.lhsnrapply(whiskerR(q'b)).nrapplyconcat_pp_p.Defined.Local Instanceisd0gpd_Coeq_ind_data:IsD0GpdCoeq_ind_data.Proof.introshkprsp'b.lhsnrapply(whiskerR(ap_V__)).nrapplymoveL_pV.lhsnrapplyconcat_pp_p.lhsnrapply(whiskerL_(p'b)^).lhsnrapplyconcat_p_pp.lhsnrapply(whiskerR(concat_Vp_)).nrapplyconcat_1p.Defined.Here is the functor. The domain is the fully-applied type ofCoeq_ind: sections ofPoverCoeqfg. The codomain consists of input data forCoeq_indgiven a 0-groupoid structure viais0gpd_total.DefinitionCoeq_ind_inv:Coeq_ind_type->sigCoeq_ind_data.Proof.introsh.exists(hocoeq).introsb.exact(apDh(cglueb)).Defined.UseSetPrintingImplicitto see the 0-groupoid structures described above.Local Instanceis0functor_Coeq_ind_inv:Is0FunctorCoeq_ind_inv.Proof.nrapplyBuild_Is0Functor.introshkp.exists(pocoeq).introsb.nrapplymoveL_pM.exact((apD_homotopicp(cglueb))^).Defined.Local Instanceissurjinj_Coeq_ind_inv:IsSurjInjCoeq_ind_inv.Proof.nrapplyBuild_IsSurjInj.-intros[hr].exists(Coeq_indPhr).exists(funa=>idpath).introsb.applyequiv_1p_q1.symmetry.nrapplyCoeq_ind_beta_cglue.-introshk[pp'].snrapplyCoeq_ind.1:exactp.introsb;specialize(p'b).lhsnrapplytransport_paths_FlFr_D.lhsnrapplyconcat_pp_p.lhsnrapply(whiskerL_p').lhsnrapplyconcat_p_pp.lhsnrapply(whiskerR(concat_Vp_)).nrapplyconcat_1p.Defined.Definitionequiv_0gpd_Coeq_ind:Build_ZeroGpdCoeq_ind_type___$<~>Build_ZeroGpd(sigCoeq_ind_data)___.Proof.snrapplyBuild_CatEquiv.1:rapplyBuild_Morphism_0Gpd.rapplyisequiv_0gpd_issurjinj.Defined.EndUnivProp.Here we prove that the 0-groupoid universal property established in the previous section is natural with respect tofunctor_coeq. More precisely, we show thatCoeq_ind_invcommutes with precomposition withkandfunctor_coeqhkpq.SectionUnivPropNat.Context{BA:Type} (fg:B->A) {B'A':Type} (f'g':B'->A')(h:B->B') (k:A->A') (p:kof==f'oh) (q:kog==g'oh)(P:Coeqf'g'->Type).Local OpenScopedpath_scope.We recall these instances to allow Coq to infer the same 0-groupoid structures as in the previous section.Local Existing Instancesisgraph_total| 1.Local Existing Instancesisgraph_paths| 2.Local Existing Instancesisdgraph_Coeq_ind_data.Help Coq find the same graph structure for the sigma-groupoid ofCoeq_ind_datawhen precomposing withfunctor_coeq.Local Instanceisgraph_Coeq_ind_data_total:IsGraph(sig(Coeq_ind_datafg(Pofunctor_coeqhkpq))).Proof.rapplyisgraph_total.Defined.Given a map out ofA'that coequalizes the parallel pairf'andg', we construct a map out ofAthat coequalizesfandg. Precomposing withkyields a dependent mapforalla:A,P(coeq(ka)), andfunctor_coeq_beta_cgluegives us a way to relate the paths.Definitionfunctor_Coeq_ind_data:sig(Coeq_ind_dataf'g'P)->sig(Coeq_ind_datafg(Pofunctor_coeqhkpq)).Proof.intros[mr].exists(mok).introsb.unfoldCoeq_ind_datainr.apply(dp_compose'__(functor_coeq_beta_cgluehkpqb)).nrefine(_@Dpr(hb) @Dp_).1:exact(dp_composecoeqP(pb) (apDm(pb))).exact(dp_composecoeqP(qb)^ (apDm(qb)^)).Defined.A helper lemma for proving functoriality offunctor_Coeq_ind_data. This is the action ofCoeq_ind___ofunctor_coeqhkpqon the pathcglueb.Local LemmaCoeq_ind_functor_coeq_beta_cglue{b:B}{m:foralla':A',P(coeqa')}{r:forallb':B',DPathP(cglueb') (m(f'b')) (m(g'b'))}:apD(funx=>Coeq_indPmr(functor_coeqhkpqx)) (cglueb)= (dp_compose'(functor_coeqhkpq)P(functor_coeq_beta_cgluehkpqb))^-1((dp_composecoeqP(pb) (apDm(pb)) @Dpr(hb)) @Dpdp_composecoeqP(qb)^ (apDm(qb)^)).Proof.nrefine(ap__@ (dp_apD_compose'___(Coeq_indPmr))^)^.lhsnrapply(dp_whiskerL_(dp_apD_compose_invcoeqP(Coeq_indPmr))^).lhsnrapply(dp_whiskerR_(dp_whiskerR_(dp_apD_compose_invcoeqP_)^)).lhsnrapply(dp_whiskerR_(dp_whiskerL_(Coeq_ind_beta_cglue____)^)).lhsnrapply(dp_whiskerR_(dp_apD_pp_____)^).exact(dp_apD_pp_____)^.Defined.Local Instanceis0functor_functor_Coeq_ind_data:Is0Functorfunctor_Coeq_ind_data.Proof.nrapplyBuild_Is0Functor.intros[mr] [ns] [uv].exists(uok).introsb.lhsnrapply(whiskerL_Coeq_ind_functor_coeq_beta_cglue^).rhsnrapply(whiskerRCoeq_ind_functor_coeq_beta_cglue^_).nrapplymoveL_Mp.lhsnrapplyconcat_p_pp.lhsnrefine(transport_paths_FlFr_D(cglueb) (Coeq_ind_homotopyPuv_))^.apply(ds_dp(Coeq_indPmro_) (Coeq_indPnso_)___).exact(dp_apD_nat(Coeq_ind_homotopyPuvo_) (cglueb)).Defined.Recall the domain of this functor is the type of dependent mapsforallz:Coeqf'g',Pz. By precomposing withfunctor_coeqhkpq:Coeqfg->Coeqf'g'we get a dependent mapforallz:Coeqfg,(P(functor_coeqhkpqz)).Definitionfunctor_Coeq_ind_type:Coeq_ind_typef'g'P->Coeq_ind_typefg(Pofunctor_coeqhkpq):=funx=>xofunctor_coeqhkpq.Local Instanceis0functor_functor_Coeq_ind_type:Is0Functorfunctor_Coeq_ind_type.Proof.nrapplyBuild_Is0Functor.introsmnr.exact(rofunctor_coeqhkpq).Defined.We now have two different ways of mappping fromCoeq_ind_typef'g'Ptosig(Coeq_ind_datafg(Pofunctor_coeqhkpq)). Here we construct a transformation between these two maps.Coeq_ind_type f' g' P ---------functor_Coeq_ind_type---> Coeq_ind_type f g (P o functor_coeq h k p q)
        |                                                                   |
        |                                                                   |
  Coeq_ind_inv f' g' P                                      Coeq_ind_inv f g (P o functor_coeq h k p q)
        |                                                                   |
        |                                                                   |
        V                                                                   V
  sig (Coeq_ind_data f' g' P) ---functor_Coeq_ind_data---> sig (Coeq_ind_data f g (P o functor_coeq h k p q))DefinitionCoeq_ind_inv_nat:Coeq_ind_invfg(Pofunctor_coeqhkpq)ofunctor_Coeq_ind_type$=>functor_Coeq_ind_datao(Coeq_ind_invf'g'P).Proof.introsm.exists(fun_=>idpath).introsb;simpl.lhsnrapplyconcat_1p;rhsnrapplyconcat_p1.rhsnrapply(dp_apD_compose'__(functor_coeq_beta_cgluehkpqb)_).nrapplyap.nrefine(_@ (dp_apD_pp_____)^).rhsnrapply(dp_whiskerR_(dp_apD_pp_____)).lhsnrapply(dp_whiskerL_(dp_apD_compose_inv___)^).exact(dp_whiskerR_(dp_whiskerR_(dp_apD_compose_inv___)^)).Defined.EndUnivPropNat.

--- Miscellaneous\Coherent.html ---
CoherentLibrary CoherentRequireImportBasicsHSpace.CorePointed.CorePointed.Loops.Local OpenScopemc_mult_scope.Local OpenScopepointed_scope.Coherent H-space structuresAn H-space is coherent when the left and right identities agree at the base point.ClassIsCoherent(X:pType) `{IsHSpaceX} :=iscoherent:left_identitypt=right_identitypt.RecordIsCohHSpace(A:pType) := {ishspace_cohhspace:IsHSpaceA;iscoherent_cohhspace:IsCoherentA;}.#[export]ExistingInstancesishspace_cohhspaceiscoherent_cohhspace.Definitionissig_iscohhspace(A:pType): {hspace_op:SgOpA& {hspace_left_identity:LeftIdentityhspace_oppt& {hspace_right_identity:RightIdentityhspace_oppt&hspace_left_identitypt=hspace_right_identitypt} } }<~>IsCohHSpaceA:=ltac:(make_equiv).A type equivalent to a coherent H-space is a coherent H-space.Definitioniscohhspace_equiv_cohhspace{XY:pType} `{IsCohHSpaceY} (f:X<~>*Y):IsCohHSpaceX.Proof.snrapplyBuild_IsCohHSpace.-rapply(ishspace_equiv_hspacef).applyishspace_cohhspace;assumption.-unfoldIsCoherent;cbn.refine(_@@ 1).refine(ap(apf^-1)_).pelimf.refine(1 @@_).applyiscoherent.Defined.Every loop space is a coherent H-space.Definitioniscohhspace_loops{X:pType} :IsCohHSpace(loopsX).Proof.snrapplyBuild_IsCohHSpace.-applyishspace_loops.-reflexivity.Defined.

--- Miscellaneous\Colimit.html ---
ColimitLibrary ColimitRequireImportBasicsTypes.RequireImportDiagrams.Diagram.RequireImportDiagrams.Graph.RequireImportDiagrams.Cocone.RequireImportDiagrams.ConstantDiagram.RequireImportColimits.Coeq.Local OpenScopepath_scope.Generalizable All Variables.This file contains the definition of colimits, and functoriality results on colimits.ColimitsA colimit is the extremity of a cocone.ClassIsColimit`(D:DiagramG) (Q:Type) := {iscolimit_cocone:CoconeDQ;iscolimit_unicocone:UniversalCoconeiscolimit_cocone;}.(* Use :> and remove the two following lines,once Coq 8.16 is the minimum required version. *)#[export]ExistingInstanceiscolimit_cocone.Coercioniscolimit_cocone:IsColimit>->Cocone.ArgumentsBuild_IsColimit{GDQ}CH:rename.Argumentsiscolimit_cocone{GDQ}C:rename.Argumentsiscolimit_unicocone{GDQ}H:rename.cocone_postcompose_invis defined for convenience: it is only the inverse ofcocone_postcompose. It allows to recover the maphfrom a coconeC'.Definitioncocone_postcompose_inv`{D:DiagramG} {QX}(H:IsColimitDQ) (C':CoconeDX) :Q->X:= @equiv_inv___(iscolimit_unicoconeHX)C'.Existence of colimitsWhatever the diagram considered, there exists a colimit of it. The existence is given by the HITcolimit.Definition of the HITHIT Colimit {G : Graph} (D : Diagram G) : Type :=
  | colim : forall i, D i -> Colimit D
  | colimp : forall i j (f : G i j) (x : D i) : colim j (D _f f x) = colim i x
  .A colimit is just the coequalizer of the source and target maps of the diagram.  The source type in the coequalizer ought to be:{x : sig D & {y : sig D & {f : G x.1 y.1 & D _f f x.2 = y.2}}}However we notice that the path type forms a contractible component, so we can use the more efficient:{x : sig D & {j : G & G x.1 j}}DefinitionColimit{G:Graph} (D:DiagramG) :Type:=@Coeq{x:sigD& {j:G&Gx.1j}}(sigD)(funt=>t.1)(funt=> (t.2.1;D_ft.2.2t.1.2)).Definitioncolim{G:Graph} {D:DiagramG} (i:G) (x:Di) :ColimitD:=coeq(i;x).Definitioncolimp{G:Graph} {D:DiagramG} (ij:G) (f:Gij) (x:Di):colimj(D_ffx) =colimix:= (cglue((i;x);j;f))^.DefinitionColimit_ind{G:Graph} {D:DiagramG} (P:ColimitD->Type)(q:forallix,P(colimix))(pp_q:forall(ij:G) (g:Gij) (x:Di),(@colimpGDijgx) # (qj(D_fgx)) =qix):forallw,Pw.Proof.srapplyCoeq_ind.-intros[xi].exact(qxi).-intros[[ix] [jf]].cbninf;cbn.applymoveR_transport_p.symmetry.exact(pp_q____).Defined.DefinitionColimit_ind_beta_colimp{G:Graph} {D:DiagramG}(P:ColimitD->Type) (q:forallix,P(colimix))(pp_q:forall(ij:G) (g:Gij) (x:Di),@colimpGDijgx#q_(D_fgx) =q_x)(ij:G) (g:Gij) (x:Di):apD(Colimit_indPqpp_q) (colimpijgx) =pp_qijgx.Proof.refine(apD_V__@_).applymoveR_equiv_M.applymoveR_equiv_M.refine(Coeq_ind_beta_cglue____@_).symmetry.applymoveL_transport_p_V.Defined.DefinitionColimit_rec{G:Graph} {D:DiagramG} (P:Type) (C:CoconeDP):ColimitD->P.Proof.srapply(Colimit_ind_C).introsijgx.refine(transport_const__@_).applylegs_comm.Defined.DefinitionColimit_rec_beta_colimp{G:Graph} {D:DiagramG}(P:Type) (C:CoconeDP) (ij:G) (g:Gij) (x:Di):ap(Colimit_recPC) (colimpijgx) =legs_commCijgx.Proof.rapply(cancelL(transport_const(colimpijgx)_)).srapply((apD_const(Colimit_ind(fun_=>P)C_) (colimpijgx))^ @_).srapply(Colimit_ind_beta_colimp(fun_=>P)C_ijgx).Defined.Argumentscolim:simplnever.Argumentscolimp:simplnever.Colimit_rec is an equivalenceGlobal Instanceisequiv_colimit_rec`{Funext} {G:Graph}{D:DiagramG} (P:Type) :IsEquiv(Colimit_rec(D:=D)P).Proof.srapplyisequiv_adjointify.{introf.srapplyBuild_Cocone.1:introsig;applyf, (colimig).introsijgx.applyap,colimp. }{intro.applypath_forall.srapplyColimit_ind.1:reflexivity.intros????;cbn.nrapplytransport_paths_FlFr'.applyequiv_p1_1q.applyColimit_rec_beta_colimp. }{intros[].srapplypath_cocone.1:reflexivity.intros????;cbn.rewriteColimit_rec_beta_colimp.hott_simpl. }Defined.Definitionequiv_colimit_rec`{Funext} {G:Graph} {D:DiagramG} (P:Type):CoconeDP<~> (ColimitD->P) :=Build_Equiv___(isequiv_colimit_recP).And we can now show that the HIT is actually a colimit.Definitioncocone_colimit{G:Graph} (D:DiagramG) :CoconeD(ColimitD):=Build_Coconecolimcolimp.Global Instanceunicocone_colimit`{Funext} {G:Graph} (D:DiagramG):UniversalCocone(cocone_colimitD).Proof.srapplyBuild_UniversalCocone;introY.srapply(isequiv_adjointify_(Colimit_recY)__).-introsC.srapplypath_cocone.1:reflexivity.introsijfx;simpl.applyequiv_p1_1q.applyColimit_rec_beta_colimp.-introf.applypath_forall.srapplyColimit_ind.1:reflexivity.introsijgx;simpl.nrapply(transport_paths_FlFr'(g:=f)).applyequiv_p1_1q.applyColimit_rec_beta_colimp.Defined.Global Instanceiscolimit_colimit`{Funext} {G:Graph} (D:DiagramG):IsColimitD(ColimitD) :=Build_IsColimit_(unicocone_colimitD).Functoriality of colimitsSectionFunctorialityColimit.Context`{Funext} {G:Graph}.Colimits are preserved by composition with a (diagram) equivalence.Definitioniscolimit_precompose_equiv{D1D2:DiagramG}(m:D1~d~D2) {Q:Type}:IsColimitD2Q->IsColimitD1Q.Proof.introsHQ.srapply(Build_IsColimit(cocone_precomposemHQ)_).applycocone_precompose_equiv_universality,HQ.Defined.Definitioniscolimit_postcompose_equiv{D:DiagramG} `(f:Q<~>Q'):IsColimitDQ->IsColimitDQ'.Proof.introsHQ.srapply(Build_IsColimit(cocone_postcomposeHQf)_).applycocone_postcompose_equiv_universality,HQ.Defined.A diagram mapm:D1=>D2induces a map between any two colimits ofD1andD2.Definitionfunctor_colimit{D1D2:DiagramG} (m:DiagramMapD1D2){Q1Q2} (HQ1:IsColimitD1Q1) (HQ2:IsColimitD2Q2):Q1->Q2:=cocone_postcompose_invHQ1(cocone_precomposemHQ2).And this map commutes with diagram map.Definitionfunctor_colimit_commute{D1D2:DiagramG}(m:DiagramMapD1D2) {Q1Q2}(HQ1:IsColimitD1Q1) (HQ2:IsColimitD2Q2):cocone_precomposemHQ2=cocone_postcomposeHQ1(functor_colimitmHQ1HQ2):= (eisretr(cocone_postcomposeHQ1)_)^.Colimits of equivalent diagramsNow we have than two equivalent diagrams have equivalent colimits.Context{D1D2:DiagramG} (m:D1~d~D2) {Q1Q2}(HQ1:IsColimitD1Q1) (HQ2:IsColimitD2Q2).Definitionfunctor_colimit_eissect:functor_colimitmHQ1HQ2ofunctor_colimit(diagram_equiv_invm)HQ2HQ1==idmap.Proof.applyap10.srapply(equiv_inj(cocone_postcomposeHQ2)_).1:applyHQ2.etransitivity.2:symmetry;applycocone_postcompose_identity.etransitivity.1:applycocone_postcompose_comp.rewriteeisretr,cocone_precompose_postcompose,eisretr.rewritecocone_precompose_comp,diagram_inv_is_section.applycocone_precompose_identity.Defined.Definitionfunctor_colimit_eisretr:functor_colimit(diagram_equiv_invm)HQ2HQ1ofunctor_colimitmHQ1HQ2==idmap.Proof.applyap10.srapply(equiv_inj(cocone_postcomposeHQ1)_).1:applyHQ1.etransitivity.2:symmetry;applycocone_postcompose_identity.etransitivity.1:applycocone_postcompose_comp.rewriteeisretr,cocone_precompose_postcompose,eisretr.rewritecocone_precompose_comp,diagram_inv_is_retraction.applycocone_precompose_identity.Defined.Global Instanceisequiv_functor_colimit:IsEquiv(functor_colimitmHQ1HQ2):=isequiv_adjointify__functor_colimit_eissectfunctor_colimit_eisretr.Definitionequiv_functor_colimit:Q1<~>Q2:=Build_Equiv___isequiv_functor_colimit.EndFunctorialityColimit.Unicity of colimitsA particuliar case of the functoriality result is that all colimits of a diagram are equivalent (and hence equal in presence of univalence).Theoremcolimit_unicity`{Funext} {G:Graph} {D:DiagramG} {Q1Q2:Type}(HQ1:IsColimitDQ1) (HQ2:IsColimitDQ2):Q1<~>Q2.Proof.srapplyequiv_functor_colimit.srapply(Build_diagram_equiv(diagram_idmapD)).Defined.Colimits are left adjoint to constant diagramTheoremcolimit_adjoint`{Funext} {G:Graph} {D:DiagramG} {C:Type}: (ColimitD->C) <~>DiagramMapD(diagram_constC).Proof.symmetry.refine(equiv_colimit_recCoE_).applyequiv_diagram_const_cocone.Defined.

--- Miscellaneous\Colimit_Coequalizer.html ---
Colimit_CoequalizerLibrary Colimit_CoequalizerRequireImportBasics.RequireImportTypes.RequireImportDiagrams.ParallelPair.RequireImportDiagrams.Cocone.RequireImportColimits.Colimit.RequireImportColimits.Coeq.Generalizable All Variables.Coequalizer as a colimitIn this file, we defineCoequalizerthe coequalizer of two maps as the colimit of a particuliar diagram, and then show that it is equivalent toCoeqthe primitive coequalizer defined as an HIT.CoequalizerSectionCoequalizer.Context{AB:Type}.DefinitionIsCoequalizer(fg:B->A):=IsColimit(parallel_pairfg).DefinitionCoequalizer(fg:B->A):=Colimit(parallel_pairfg).Equivalence withCoeqContext{fg:B->A}.Definitioncocone_Coeq:Cocone(parallel_pairfg) (Coeqfg).Proof.srapplyBuild_Cocone.+intros[]; [exact(coeqog)|exactcoeq].+introsijphix;destructi,j,phi;simpl;[exact(cgluex) |reflexivity].Defined.Lemmaiscoequalizer_Coeq`{Funext}:IsColimit(parallel_pairfg) (Coeqfg).Proof.srapply(Build_IsColimitcocone_Coeq).srapplyBuild_UniversalCocone.introsX.srapplyisequiv_adjointify.-introsC.srapplyCoeq_rec.+exact(legsCfalse).+introsb.etransitivity.*exact(legs_commCtruefalsetrueb).*exact(legs_commCtruefalsefalseb)^.-introsC.srapplypath_cocone.+introsix;destructi;simpl.*exact(legs_commCtruefalsefalsex).*reflexivity.+introsijphix;destructi,j,phi;simpl.*hott_simpl.matchgoalwith| [|-ap(Coeq_rec?a?b?c)_@_=_]=>rewrite(Coeq_rec_beta_cglueabc)end.hott_simpl.*reflexivity.-introsF.applypath_forall.matchgoalwith| [|- ?G==_] =>simplerefine(Coeq_ind(funw=>Gw=Fw)__)end.+reflexivity.+introsb;simpl.nrapply(transport_paths_FlFr'(g:=F)).applyequiv_p1_1q.refine(Coeq_rec_beta_cglue____@_).applyconcat_p1.Defined.Definitionequiv_Coeq_Coequalizer`{Funext}:Coeqfg<~>Coequalizerfg.Proof.srapplycolimit_unicity.3:eapplyiscoequalizer_Coeq.eapplyiscolimit_colimit.Defined.EndCoequalizer.

--- Miscellaneous\Colimit_Flattening.html ---
Colimit_FlatteningLibrary Colimit_FlatteningRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Diagram.RequireImportDiagrams.Graph.RequireImportDiagrams.Cocone.RequireImportDiagrams.DDiagram.RequireImportColimits.Colimit.Local OpenScopepath_scope.Flattening lemmaThis file provides a proof of the flattening lemma for colimits. This lemma describes the typesigE'whenE':colimitD->Typeis a type family defined by recursion on a colimit. The flattening lemma in the case of coequalizers is presented in section 6.12 of the HoTT book and is in Colimits/Coeq.v.  TODO: See whether there's a straightforward way to deduce the flattening lemma for general colimits from the version for coequalizers.SectionFlattening.Equifibered diagramsContext`{Univalence} {G:Graph} (D:DiagramG)(E:DDiagramD) `(Equifibered__E).LetE_f{ij:G} (g:Gij) (x:Di) :E(i;x) ->E(j; (D_fg)x):= @arr_E(i;x) (j;D_fgx) (g; 1).Now, given an equifibered diagram and using univalence, one can define a type familyE':colimitD->Typeby recursion on the colimit.DefinitionE':ColimitD->Type.Proof.applyColimit_rec.simplerefine(Build_Cocone__).-exact(funix=>E(i;x)).-introsijgx;cbn.symmetry.srapply(path_universe(E_f__)).Defined.Helper lemmasDefinitiontransport_E'{ij:G} (g:Gij)  (x:Di) (y:E(i;x)):transportE'(colimpijgx) (E_fgxy) =y.Proof.refine(transport_idmap_ap___@_).srefine(transport2idmap__@_).2:applyColimit_rec_beta_colimp;cbn.apply(moveR_transport_Vidmap).symmetry;applytransport_path_universe.Defined.Definitiontransport_E'_V{ij:G} (g:Gij)  (x:Di) (y:E(i;x)):transportE'(colimpijgx)^y=E_fgxy.Proof.applymoveR_transport_V.symmetry.applytransport_E'.Defined.Definitiontransport_E'_V_E'{ij:G} (g:Gij)  (x:Di) (y:E(i;x)):transport_E'gxy=ap(transportE'(colimpijgx)) (transport_E'_Vgxy)^@transport_pVE'(colimpijgx)y.Proof.rewritemoveR_transport_V_V,inv_V.symmetry;applyap_transport_transport_pV.Defined.Main resultWe define the cocone over the sigma diagram tosigE'.Definitioncocone_E':Cocone(diagram_sigmaE) (sigE').Proof.srapplyBuild_Cocone;cbn.-introsiw.exists(colimiw.1);cbn.exactw.2.-introsijgx;cbn.srapplypath_sigma'.+applycolimp.+applytransport_E'.Defined.And we directly prove that it is universal.  We break the proof into parts to slightly speed it up.Local Opaquepath_sigmaap11.Local Definitioncocone_extendsZ:Cocone(diagram_sigmaE)Z-> ((sigE') ->Z).Proof.intros[qqq];cbnin*.intros[xy];revertxy.srapplyColimit_ind;cbn.+introsixy;exact(qi(x;y)).+introsijgx;cbn.funexty.refine(transport_arrow_toconst___@_).refine(_@qqijg(x;y)).cbn;f_ap.refine(path_sigma'_1_);cbn.applytransport_E'_V.Defined.Local Definitioncocone_isretrZ:cocone_postcomposecocone_E'ococone_extendsZ==idmap.Proof.intros[qqq].srapplypath_cocone.+introsix;reflexivity.+introsijg[xy].rewriteconcat_1p,concat_p1.cbn;rewriteap_path_sigma.simpl.rewriteColimit_ind_beta_colimp.rewriteap10_path_forall.rewriteconcat_pp_p,concat_V_pp.refine(_@concat_1p_).refine(concat_p_pp___@_).refine(_@@ 1).matchgoalwith|-ap_?X@_=_=>set(p:=X)end.assert(r:transport_E'_Vgxy=p^).{substp.exact(moveL_transport_V_VE'____)^. }rewriter;clearr.destructp.reflexivity.Defined.(* 0.1s *)Local Definitioncocone_issectZ:cocone_extendsZococone_postcomposecocone_E'==idmap.Proof.introf.funext[xy].revertxy.srapplyColimit_ind.+cbn;reflexivity.+introsijgx;cbn.funexty.refine(transport_forall___@_).rewritetransport_paths_FlFr.refine((1 @@_@@ 1) @ (concat_p1_@@ 1) @concat_Vp_).matchgoalwith|-transportDE'?C___=_=>rewrite(transportD_is_transport_(funw=>Cw.1w.2))end.rewritetransport_paths_FlFr.lhsrapplyconcat_pp_p.applymoveR_Vp.applyequiv_1p_q1.rewriteap_path_sigma.rewriteColimit_ind_beta_colimp.rewriteap10_path_forall.simpl.rewriteconcat_pp_p,concat_V_pp.rewriteap11_is_ap10_ap01.cbn.rewriteconcat_1p.rewrite(ap_compose(funy=> (colimj((D_fg)x);y))f).rewrite(ap_compose(funx0:existsx0:Dj,E(j;x0)=> (colimj(pr1x0);pr2x0))f).rewrite<- ! (ap_ppf).apply(ap(apf)).refine(_@concat_pp_p___).matchgoalwith|-_= (ap?ff?pp1@ ?pp2) @ ?pp3=>set(p1:=pp1)end.assert(p1eq:p1=ap(transportE'(colimpijgx)^)(transport_pVE'(colimpijgx)y)^).{substp1;clear.etransitivity.1:srapplymoveL_transport_V_1.etransitivity.1:nrapplyinverse2;snrapplytransport_VpV.symmetry;applyap_V. }rewritep1eq;clearp1eqp1.rewrite<-ap_compose;cbn.rewrite(ap_path_sigma(funx=>E(j;x))(funxy=> (colimjx;y))).cbn;rewrite!concat_p1,concat_pp_p,ap_V.applymoveL_Vp.matchgoalwith|- ?pp1@_= ?pp2@_=>set(p1:=pp1);changepp2with(path_sigma'E'1(transport_E'_Vgx(transportE'(colimpijgx) (transportE'(colimpijgx)^y))))end.assert(p1eq:p1=path_sigma'E'1 (transport_Vp___)).{substp1.rewrite<-ap_exist.rewrite(ap_compose(transportE'(colimpijgx)^)(funv=> (colimj((D_fg)x);v))).f_ap;set(p:=colimpijgx).clear;symmetry.applytransport_VpV. }rewritep1eq;clearp1eqp1.rewrite<- !path_sigma_pp_pp';f_ap.rewriteconcat_p1,concat_pp_p.refine(1 @@_).applymoveL_Mp.rewrite<-ap_V, <-ap_pp.srefine(_@_).-refine(ap(transportE'(colimpijgx))_).refine((transport_E'_V___)^ @_).refine(ap_(transport_pV___)).-f_ap.refine(1 @@_).applytransport_VpV.-set(e:=transportE'(colimpijgx)(transportE'(colimpijgx)^y)).rewriteap_pp, <-ap_compose.refine(_@ (transport_E'_V_E'___)^).refine(1 @@_).subste.refine(_@ (transport_pVp___)^).rewriteap_compose.f_ap;symmetry.applytransport_VpV.Defined.(* TODO: a little slow, 0.40s *)Global Instanceunicocone_cocone_E':UniversalCoconecocone_E'.Proof.srapplyBuild_UniversalCocone.introZ;srapplyisequiv_adjointify.-exact(cocone_extendsZ).-exact(cocone_isretrZ).-exact(cocone_issectZ).Defined.The flattening lemma follows by colimit unicity.Definitionflattening_lemma:Colimit(diagram_sigmaE) <~>sigE'.Proof.srapplycolimit_unicity.3:applyiscolimit_colimit.rapplyBuild_IsColimit.applyunicocone_cocone_E'.Defined.EndFlattening.(* TODO: ending the section is a bit slow (0.2s).  But simply removing the Section (and changing "Let" to "Local Definition") causes the whole file to be much slower.  It should be possible to remove the section without making the whole file slower. *)

--- Miscellaneous\Colimit_Prod.html ---
Colimit_ProdLibrary Colimit_ProdRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Diagram.RequireImportColimits.Colimit.RequireImportColimits.Colimit_Sigma.RequireImportDiagrams.Graph.Colimit of product by a constant typeGiven a diagramD, one of his colimitsQand a typeA, one can consider the diagram of the products of the types ofDandA. Then, a colimit of such a diagram isA*Q.This is the constant case of the fileColimit_Sigmaand we reuse its results.SectionColimitProd.Context`{Funext} {G:Graph} (D:DiagramG) (A:Type).Definitionprod_diagram:DiagramG.Proof.srapplyBuild_Diagram.-exact(funi=>A* (Di)).-simpl;introsijfx.exact(fstx,D_ff(sndx)).Defined.Definitiondiagram_equiv_prod_sigma:sigma_diagram(fun_:A=>D) ~d~prod_diagram.Proof.unshelveeconstructor.-srapplyBuild_DiagramMap;cbn.+introi;applyequiv_sigma_prod0.+reflexivity.-introi;cbn.applyequiv_sigma_prod0.Defined.Lemmaiscolimit_prod{Q:Type} (HQ:IsColimitDQ):IsColimitprod_diagram(A*Q).Proof.eapplyiscolimit_postcompose_equiv.-applyequiv_sigma_prod0.-eapplyiscolimit_precompose_equiv.+symmetry;applydiagram_equiv_prod_sigma.+byapplyiscolimit_sigma.Defined.EndColimitProd.

--- Miscellaneous\Colimit_Pushout.html ---
Colimit_PushoutLibrary Colimit_PushoutRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Graph.RequireImportDiagrams.Diagram.RequireImportDiagrams.Span.RequireImportDiagrams.Cocone.RequireImportColimits.Colimit.(* We require this now, but will import later. *)RequireColimits.Pushout.Local OpenScopepath_scope.Pushout as a colimitIn this file, we definePOthe pushout of two maps as the colimit of a particular diagram, and then show that it is equivalent topushoutthe primitive pushout defined as an HIT.POSectionPO.Context{ABC:Type}.DefinitionBuild_span_cocone{f:A->B} {g:A->C} {Z:Type}(inl':B->Z) (inr':C->Z)(pp':inl'of==inr'og):Cocone(spanfg)Z.Proof.srapplyBuild_Cocone.-intros[|[]]; [exact(inr'og) |exactinl'|exactinr'].-intros[u|b] [u'|b'] [];cbn.destructb'.+exactpp'.+reflexivity.Defined.Definitionpol'{f:A->B} {g:A->C} {Z} (Co:Cocone(spanfg)Z):B->Z:=legsCo(inrtrue).Definitionpor'{f:A->B} {g:A->C} {Z} (Co:Cocone(spanfg)Z):C->Z:=legsCo(inrfalse).Definitionpopp'{f:A->B} {g:A->C} {Z} (Co:Cocone(spanfg)Z):pol'Coof==por'Coog:=funx=>legs_commCo(inltt) (inrtrue)ttx@ (legs_commCo(inltt) (inrfalse)ttx)^.Definitionis_PO(f:A->B) (g:A->C) :=IsColimit(spanfg).DefinitionPO(f:A->B) (g:A->C) :=Colimit(spanfg).Context{f:A->B} {g:A->C}.Definitionpol:B->POfg:=colim(D:=spanfg) (inrtrue).Definitionpor:C->POfg:=colim(D:=spanfg) (inrfalse).Definitionpopp(a:A) :pol(fa) =por(ga):=colimp(D:=spanfg) (inltt) (inrtrue)tta@ (colimp(D:=spanfg) (inltt) (inrfalse)tta)^.We next define the eliminatorsPO_indandPO_rec. To make later proof terms smaller, we define two things we'll need.DefinitionPO_ind_obj(P:POfg->Type) (l':forallb,P(polb))(r':forallc,P(porc)):forall(i:span_graph) (x:obj(spanfg)i),P(colimix).Proof.intros[u|[]]x;cbn.-exact(@colimp_(spanfg) (inlu) (inrtrue)ttx#l'(fx)).-exact(l'x).-exact(r'x).Defined.DefinitionPO_ind_arr(P:POfg->Type) (l':forallb,P(polb))(r':forallc,P(porc)) (pp':foralla,poppa#l'(fa) =r'(ga)):forall(ij:span_graph) (e:span_graphij) (ar:spanfgi),transportP(colimpijear) (PO_ind_objPl'r'j(((spanfg)_fe)ar)) =PO_ind_objPl'r'iar.Proof.intros[u|b] [u'|b'] [];cbn.destructb';cbn.1:reflexivity.unfoldpoppinpp'.introa.applymoveR_transport_p.rhs_Vnrapplytransport_pp.destructu.symmetry;applypp'.Defined.DefinitionPO_ind(P:POfg->Type) (l':forallb,P(polb))(r':forallc,P(porc)) (pp':foralla,poppa#l'(fa) =r'(ga)):forallw,Pw:=Colimit_indP(PO_ind_objPl'r') (PO_ind_arrPl'r'pp').DefinitionPO_ind_beta_pp(P:POfg->Type) (l':forallb,P(polb))(r':forallc,P(porc)) (pp':foralla,poppa#l'(fa) =r'(ga)):forallx,apD(PO_indPl'r'pp') (poppx) =pp'x.Proof.introx.lhsnrapplyapD_pp.rewrite(Colimit_ind_beta_colimpP__(inltt) (inrtrue)ttx).rewriteconcat_p1,apD_V.rewrite(Colimit_ind_beta_colimpP__(inltt) (inrfalse)ttx).rewritemoveR_transport_p_V,moveR_moveL_transport_p.rewriteinv_pp,inv_V.applyconcat_p_Vp.Defined.DefinitionPO_rec(P:Type) (l':B->P) (r':C->P)(pp':l'of==r'og) :POfg->P:=Colimit_recP(Build_span_coconel'r'pp').DefinitionPO_rec_beta_pp(P:Type) (l':B->P)(r':C->P) (pp':l'of==r'og):forallx,ap(PO_recPl'r'pp') (poppx) =pp'x.Proof.introx.unfoldpopp.refine(ap_pp___@_@concat_p1_).refine(_@@_).1:exact(Colimit_rec_beta_colimpP(Build_span_coconel'r'pp')(inltt) (inrtrue)ttx).lhsnrapplyap_V.apply(inverse2(q:=1)).exact(Colimit_rec_beta_colimpP(Build_span_coconel'r'pp')(inltt) (inrfalse)ttx).Defined.A nice property: the pushout of an equivalence is an equivalence.Global InstancePO_of_equiv(Hf:IsEquivf):IsEquivpor.Proof.srapplyisequiv_adjointify.-srapplyPO_rec.+exact(gof^-1).+exactidmap.+introx.applyap,eissect.-srapplyPO_ind;cbn.+intro.refine((popp_)^ @_).applyap,eisretr.+reflexivity.+introa;cbn.nrapplytransport_paths_FFlr'.refine(concat_p1_@_).rewritePO_rec_beta_pp.rewriteeisadj.destruct(eissectfa);cbn.rewriteconcat_p1.symmetry;applyconcat_Vp.-cbn;reflexivity.Defined.EndPO.Equivalence withpushoutSectionis_PO_pushout.ImportColimits.Pushout.Context`{Funext} {ABC:Type} {f:A->B} {g:A->C}.Definitionis_PO_pushout:is_POfg(Pushoutfg).Proof.srapplyBuild_IsColimit.-srapplyBuild_span_cocone.+exact(pushoinl).+exact(pushoinr).+exactpglue.-srapplyBuild_UniversalCocone.introY;srapplyisequiv_adjointify.+introCo.srapplyPushout_rec.*exact(pol'Co).*exact(por'Co).*exact(popp'Co).+intros[CoCo'].srapplypath_cocone.*intros[[]|[]]x;simpl.1:apply(Co'(inltt) (inrfalse)tt).all:reflexivity.*cbnbeta.intros[u|b] [u'|b'] []x.destructu,b';cbn.2:reflexivity.rhsnrapplyconcat_1p.lhsrefine(_@@ 1).1:nrapplyPushout_rec_beta_pglue.unfoldpopp',legs_comm.applyconcat_pV_p.+introh.applypath_forall.srapplyPushout_ind;cbn.1,2:reflexivity.introa;cbnbeta.nrapplytransport_paths_FlFr';applyequiv_p1_1q.unfoldpopp';cbn.rhs_Vnrapplyconcat_p1.nrapplyPushout_rec_beta_pglue.Defined.Definitionequiv_pushout_PO:Pushoutfg<~>POfg.Proof.srapplycolimit_unicity.3:eapplyis_PO_pushout.eapplyiscolimit_colimit.Defined.Definitionequiv_pushout_PO_beta_pglue(a:A):apequiv_pushout_PO(pgluea) =poppa.Proof.cbn.refine(_@_).1:nrapplyPushout_rec_beta_pglue.unfoldpopp';cbn.rewrite2concat_1p.reflexivity.Defined.DefinitionPushout_rec_PO_rec(P:Type) (pushb:B->P) (pushc:C->P)(pusha:foralla:A,pushb(fa) =pushc(ga)):Pushout_recPpushbpushcpusha==PO_recPpushbpushcpushaoequiv_pushout_PO.Proof.snrapplyPushout_ind.1, 2:reflexivity.introa;cbnbeta.nrapplytransport_paths_FlFr';applyequiv_p1_1q.lhsexact(Pushout_rec_beta_pgluePpushbpushcpushaa).symmetry.lhsnrapply(ap_composeequiv_pushout_PO_(pgluea)).lhsnrapply(ap_(equiv_pushout_PO_beta_pgluea)).nrapplyPO_rec_beta_pp.Defined.Endis_PO_pushout.

--- Miscellaneous\Colimit_Pushout_Flattening.html ---
Colimit_Pushout_FlatteningLibrary Colimit_Pushout_FlatteningRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Diagram.RequireImportDiagrams.DDiagram.RequireImportDiagrams.Span.RequireImportDiagrams.Cocone.RequireImportColimits.Colimit.RequireImportColimits.Colimit_Pushout.RequireImportColimits.Colimit_Flattening.Pushout caseWe deduce the flattening lemma for pushouts from the flattening lemma for general colimits. This pushout is defined as the colimit of a span and is not the pushout that appears elsewhere in the library. The flattening lemma for the pushout that appears elsewhere in the library is in Colimits/Pushout.v.SectionPOCase.Context`{Univalence} {ABC} {f:A->B} {g:A->C}.Context(A0:A->Type) (B0:B->Type) (C0:C->Type)(f0:forallx,A0x<~>B0(fx)) (g0:forallx,A0x<~>C0(gx)).DefinitionPOCase_P:POfg->Type.Proof.simplerefine(PO_recTypeB0C0_).cbn;introx.eapplypath_universe_uncurried.etransitivity.-symmetry.applyf0.-applyg0.Defined.DefinitionPOCase_E:DDiagram(spanfg).Proof.simplerefine(Build_Diagram___);cbn.-intros[[]x];revertx.+exactA0.+destructb;assumption.-intros[[[]|[]]x] [[[]|[]]y];cbn;intros[[]p].+exact(funy=>p# (f0xy)).+exact(funy=>p# (g0xy)).Defined.Global InstancePOCase_HE:EquifiberedPOCase_E.Proof.applyBuild_Equifibered.intros[[]|[]] [[]|[]] []x;compute.-exact(equiv_isequiv(f0x)).-exact(equiv_isequiv(g0x)).Defined.DefinitionPO_flattening:PO(functor_sigmaff0) (functor_sigmagg0) <~>existsx,POCase_Px.Proof.transitivity(Colimit(diagram_sigmaPOCase_E)).{applyequiv_path.unfoldPO;applyap.srapplypath_diagram;cbn.-intros[|[]];cbn.all:reflexivity.-intros[[]|[]] [[]|[]] []x;cbnin*.all:reflexivity. }transitivity(existsx,E'(spanfg)POCase_EPOCase_HEx).-applyflattening_lemma.-applyequiv_functor_sigma_id.introx.applyequiv_path.unfoldE',POCase_P,PO_rec.f_ap.srapplypath_cocone.+intros[[]|[]]y;cbn.1:applypath_universe_uncurried;applyg0.all:reflexivity.+intros[[]|[]] [[]|[]] [];cbn.*introy.simpl.rhsnrapplyconcat_1p.unfoldpath_universe.lhsnrapply(ap(funx=>x@_)_^).1:nrapplypath_universe_V_uncurried.exact(path_universe_compose(f0y)^-1 (g0y))^.*intros;applyconcat_Vp.Defined.EndPOCase.

--- Miscellaneous\Colimit_Sigma.html ---
Colimit_SigmaLibrary Colimit_SigmaRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Diagram.RequireImportDiagrams.Graph.RequireImportDiagrams.Cocone.RequireImportColimits.Colimit.Colimit of the dependent sum of a family of diagramsGiven a family of diagramsDy, and a colimitQyof each diagram, one can consider the diagram of the sigmas of the types of theDys. Then, a colimit of such a diagram is the sigma of theQys.SectionColimitSigma.Context`{Funext} {G:Graph} {Y:Type} (D:Y->DiagramG).The diagram of the sigmas.Definitionsigma_diagram:DiagramG.Proof.srapplyBuild_Diagram.-exact(funi=> {y:Y&Dyi}).-simpl;introsijgx.exact(x.1;Dx.1_fgx.2).Defined.The embedding, for a particulary, ofD(y)in the sigma diagram.Definitionsigma_diagram_map(y:Y) :DiagramMap(Dy)sigma_diagram.Proof.srapplyBuild_DiagramMap.1:exact(funix=> (y;x)).reflexivity.Defined.Context{Q:Y->Type}.The sigma of a family of cocones.Definitionsigma_cocone(C:forally,Cocone(Dy) (Qy)):Coconesigma_diagram(sigQ).Proof.srapplyBuild_Cocone;simpl;introsix.1:exact(x.1;legs(Cx.1)ix.2).simpl;introsgx'.srapplypath_sigma'.1:reflexivity.applylegs_comm.Defined.The main result:sigQis a colimit of the diagram of sigma types.Lemmaiscolimit_sigma(HQ:forally,IsColimit(Dy) (Qy)):IsColimitsigma_diagram(sigQ).Proof.pose(SigmaC:=sigma_cocone(funy=>HQy)).srapply(Build_IsColimitSigmaC).srapplyBuild_UniversalCocone.introsX;srapplyisequiv_adjointify.-introsCXx.srapply(cocone_postcompose_inv(HQx.1)_x.2).srapply(cocone_precompose_CX).applysigma_diagram_map.-introCX.pose(CXy:=funy=>cocone_precompose(sigma_diagram_mapy)CX).change(cocone_postcomposeSigmaC(funx=>cocone_postcompose_inv(HQx.1) (CXyx.1)x.2) =CX).srapplypath_cocone;simpl.+introsix.change(legs(cocone_postcompose(HQx.1)(cocone_postcompose_inv(HQx.1) (CXyx.1)))ix.2 =CXix).exact(ap10(apD10(aplegs(eisretr(cocone_postcompose(HQx.1)) (CXy_)))i)x.2).+introsijg[yx];simpl.set(py:= (eisretr(cocone_postcompose(HQy)) (CXyy))).set(py1:=aplegspy).specialize(apDlegs_commpy);intropy2.simplin*.rewrite(path_forall__(transport_forall_constant__))inpy2.applyapD10inpy2;specialize(py2i);simplinpy2.rewrite(path_forall__(transport_forall_constant__))inpy2.applyapD10inpy2;specialize(py2j);simplinpy2.rewrite(path_forall__(transport_forall_constant__))inpy2.applyapD10inpy2;specialize(py2g);simplinpy2.rewrite(path_forall__(transport_forall_constant__))inpy2.applyapD10inpy2;specialize(py2x);simplinpy2.rewritetransport_paths_FlFrinpy2.rewriteconcat_1p,concat_pp_pinpy2.applymoveL_Mpinpy2.rewrite(ap_path_sigma_1p(funx01x02=>cocone_postcompose_inv(HQx01) (CXyx01)x02)).(* Set Printing Coercions.(* to understand what happens *)*)substpy1.etransitivity.*etransitivity.2:exactpy2.applyap.rewrite(ap_composelegs(funx0=>x0ix)).rewrite(ap_apply_lD2_ix).reflexivity.*applyap10,ap.rewrite(ap_composelegs(funx0=>x0j_)).rewrite(ap_apply_lD2_j_).reflexivity.-introsf.applypath_forall;intros[yx];simpl.rewrite<-cocone_precompose_postcompose.srapply(apD10(g:=funx=>f(y;x))_x).snrapplyequiv_moveR_equiv_V.srapplypath_cocone.1:reflexivity.introsijgx';simpl.hott_simpl.exact(ap_compose___)^.Defined.EndColimitSigma.Sigma diagrams and diagram maps / equivalencesSectionSigmaDiagram.Context{G:Graph} {Y:Type} (D1D2:Y->DiagramG).Definitionsigma_diagram_functor(m:forally,DiagramMap(D1y) (D2y)):DiagramMap(sigma_diagramD1) (sigma_diagramD2).Proof.srapplyBuild_DiagramMap.-introsi.srapply(functor_sigmaidmap_).introsy;applym.-introsijgx;simplin*.srapplypath_sigma'.1:reflexivity.simpl.apply(DiagramMap_comm(mx.1)).Defined.Definitionsigma_diag_functor_equiv(m:forally, (D1y) ~d~ (D2y)): (sigma_diagramD1) ~d~ (sigma_diagramD2).Proof.srapply(Build_diagram_equiv(sigma_diagram_functorm)).introsi.srapplyisequiv_functor_sigma.introsy;applym.Defined.EndSigmaDiagram.

--- Miscellaneous\Comma.html ---
CommaLibrary CommaComma CategoriesSince there are only notations inComma.Notations, we can just export those.LocalSetWarningsAppend"-notation-overridden".RequireImportBasics.Notations.RequireExportComma.Notations.DefinitionsRequireComma.Core.DualsRequireComma.Dual.Projection functorsRequireComma.Projection.RequireComma.InducedFunctors.FunctorialityRequireComma.ProjectionFunctors.RequireComma.Functorial.IncludeComma.Core.IncludeComma.Dual.IncludeComma.Projection.IncludeComma.InducedFunctors.IncludeComma.ProjectionFunctors.IncludeComma.Functorial.We don't want to make utf-8 notations the default, so we don't export them.

--- Miscellaneous\CommutativeSquares.html ---
CommutativeSquaresLibrary CommutativeSquaresRequireImportBasics.OvertureBasics.PathGroupoidsBasics.Tactics.Comutative squaresCommutative squares compose vertically.A --f--> B
      |    //  |
      h  comm  g
      |  //    |
      V //     V
      C --f'-> D
      |    //  |
      h' comm' g'
      |  //    |
      V //     V
      E --f''> FLemmacomm_square_comp{ABCDEF}{f:A->B} {f':C->D} {h:A->C} {g:B->D} (comm:f'oh==gof){f'':E->F} {h':C->E} {g':D->F} (comm':f''oh'==g'of'):f''o(h'oh) == (g'og)of.Proof.introsx.path_via(g'(f'(hx))).applyap,comm.Defined.Commutative squares compose horizontally.A --k--> B --l--> C
      |    //  |    //  |
      f  comm  g  comm  h
      |  //    |  //    |
      V //     V //     V
      X --i--> Y --j--> ZLemmacomm_square_comp'{ABCXYZ:Type}{k:A->B} {l:B->C}{f:A->X} {g:B->Y} {h:C->Z}{i:X->Y} {j:Y->Z}(H:iof==gok) (K:jog==hol): (joi)of==ho(lok).Proof.introsx.path_via(j(g(kx))).applyap,H.Defined.Given any commutative square fromftof'whose verticalswA,wBare equivalences, the equiv_inv square fromf'tofwith verticalswA^-1,wB^-1also commutes.Lemmacomm_square_inverse{AB:Type} {f:A->B}{A'B':Type} {f':A'->B'}{wA:A<~>A'} {wB:B<~>B'}(wf:f'owA==wBof):fo(wA^-1) == (wB^-1)of'.Proof.introsa'.path_via(wB^-1 (wB(f(wA^-1a')))).-applyinverse,eissect.-applyap, (concat(wf_)^).applyap,eisretr.Defined.Up to naturality, the result ofcomm_square_inversereally is a
retraction (aka left inverse);Lemmacomm_square_inverse_is_sect{AB:Type} {f:A->B}{A'B':Type} {f':A'->B'}(wA:A<~>A') (wB:B<~>B')(wf:f'owA==wBof) (a:A):comm_square_compwf(comm_square_inversewf)a@eissectwB(fa)=apf(eissectwAa).Proof.unfoldcomm_square_inverse,comm_square_comp;simpl.repeatapply(concat(concat_pp_p___)).applymoveR_Vp.transitivity(ap(wB^-1owB) (apf(eissectwAa)) @eissectwB(fa)).2:apply(concat(concat_Ap(eissectwB)_)). 2:applyap,ap_idmap.apply(concat(concat_p_pp___)),whiskerR.apply(concat(ap_pp(wB^-1)__)^), (concatR(ap_composewB__)^).applyap, (concat(concat_pp_p___)),moveR_Vp.path_via(ap(f'owA) (eissectwAa) @wfa).-applywhiskerR.apply(concatR(ap_composewAf'_)^).applyap,eisadj.-apply(concat(concat_Apwf_)).applywhiskerL, (ap_composefwB).Defined.and similarly,comm_square_inverseis a section (aka right equiv_inv).Lemmacomm_square_inverse_is_retr{AB:Type} {f:A->B}{A'B':Type} {f':A'->B'}(wA:A<~>A') (wB:B<~>B')(wf:f'owA==wBof) (a:A'):comm_square_comp(comm_square_inversewf)wfa@eisretrwB(f'a)=apf'(eisretrwAa).Proof.unfoldcomm_square_inverse,comm_square_comp;simpl.rewrite!ap_pp.rewrite<- !concat_pp_p.rewriteconcat_pp_p.set(p:= (apwB(ap(wB^-1) (apf'(eisretrwAa)))@eisretrwB(f'a))).path_via((eisretrwB_)^ @p).-applywhiskerR.applymoveR_pM.path_via((eisretrwB(f'(wA(wA^-1a))))^ @ap(wBowB^-1) (wf((wA^-1)a))).+rewriteap_V, <-eisadj.transitivity(apidmap(wf((wA^-1)a))@ (eisretrwB(wB(f((wA^-1)a))))^).*applywhiskerR,inverse,ap_idmap.*apply(concat_Ap(funb'=> (eisretrwBb')^)_).+applyap.rewriteap_compose, !ap_V.applyinverse,inv_V.-applymoveR_Vp.substp.rewrite<-ap_compose.path_via(eisretrwB_@apidmap(apf'(eisretrwAa))).+apply(concat_Ap(eisretrwB)_).+applyap,ap_idmap.Defined.

--- Miscellaneous\Composition.html ---
CompositionLibrary CompositionComposition of natural transformationsCompositionRequireNaturalTransformation.Composition.Core.FunctorialityRequireNaturalTransformation.Composition.Functorial.Laws about compositionRequireNaturalTransformation.Composition.Laws.IncludeNaturalTransformation.Composition.Core.IncludeNaturalTransformation.Composition.Functorial.IncludeNaturalTransformation.Composition.Laws.ModuleExportNaturalTransformationCompositionNotations.IncludeNaturalTransformation.Composition.Core.NaturalTransformationCompositionCoreNotations.EndNaturalTransformationCompositionNotations.

--- Miscellaneous\Cone.html ---
ConeLibrary ConeRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Graph.RequireImportDiagrams.Diagram.Local OpenScopepath_scope.Generalizable All Variables.ConesA Cone over a diagramDto a typeXis a family of maps fromXto the types ofDmaking the triangles formed with the arrows ofDcommuting.ClassCone(X:Type) {G:Graph} (D:DiagramG) := {legs:foralli,X->Di;legs_comm:forallij(g:Gij), (D_fg)olegsi==legsj;}.ArgumentsBuild_Cone{XGD}legslegs_comm.Argumentslegs{XGD}Cix:rename.Argumentslegs_comm{XGD}Cijgx:rename.Coercionlegs:Cone>->Funclass.SectionCone.Context`{Funext} {X:Type} {G:Graph} {D:DiagramG}.path_conesays when two cones are equals (up to funext).Definitionpath_cocone_naive{C1C2:ConeXD}(P:=funq'=>forall(ij:G) (g:Gij) (x:X),D_fg(q'ix) =q'jx)(path_legs:legsC1=legsC2)(path_legs_comm:transportPpath_legs(legs_commC1) =legs_commC2):C1=C2:=matchpath_legs_commin(_=v1)returnC1= {|legs:=legsC2;legs_comm:=v1|}with|idpath=>matchpath_legsin(_=v0)returnC1= {|legs:=v0;legs_comm:=path_legs# (legs_commC1) |}with|idpath=> 1endend.Definitionpath_cone{C1C2:ConeXD}(path_legs:foralli,C1i==C2i)(path_legs_comm:forallijgx,legs_commC1ijgx@path_legsjx=ap(D_fg) (path_legsix) @legs_commC2ijgx):C1=C2.Proof.destructC1as[legspp_q],C2as[rpp_r].refine(path_cocone_naive(path_forall__(funi=>path_forall__(path_legsi)))_).cbn;funextijfx.rewrite4transport_forall_constant,transport_paths_FlFr.rewriteconcat_pp_p;applymoveR_Vp.rewriteap_compose.rewrite2 (ap_apply_lD2(path_foralllegsr(funi=>path_forall(legsi) (ri) (path_legsi)))).rewrite3eisretr.applypath_legs_comm.Defined.Precomposition for conesGiven a coneCfromXand a map fromYtoX, one can precompose each map ofCto get a cone fromY.Definitioncone_precompose(C:ConeXD) {Y:Type} (f:Y->X) :ConeYD.Proof.srapplyBuild_Cone;introi.1:exact(Ciof).introsjgx.applylegs_comm.Defined.Universality of a cone.A limit will be the extremity of an universal cone.A coneCoverDfromXis said universal when for allYthe mapcone_precomposeis an equivalence. In particular, given another coneC'overDfromX'the inverse of the map allows us to recover a maph:X->X'such thatC'isCprecomposed withh. The fact thatcone_precomposeis an equivalence is an elegant way of stating the usual "unique existence" of category theory.ClassUniversalCone(C:ConeXD) := {is_universal:forallY,IsEquiv(@cone_precomposeCY);}.(* Use :> and remove the two following lines,once Coq 8.16 is the minimum required version. *)#[export]ExistingInstanceis_universal.Coercionis_universal:UniversalCone>->Funclass.EndCone.We now prove several functoriality results, first on cone and then on limits.SectionFunctorialityCone.Context`{Funext} {G:Graph}.Precomposition for conesIdentity and associativity for the precomposition of a cone with a map.Definitioncone_precompose_identity{D:DiagramG} `(C:ConeX_D):cone_precomposeCidmap=C.Proof.srapplypath_cone;introi.1:reflexivity.introsjgx;simpl.applyconcat_p1_1p.Defined.Definitioncone_precompose_comp{D:DiagramG}`(f:Z->Y) `(g:Y->X) (C:ConeXD):cone_precomposeC(gof)=cone_precompose(cone_precomposeCg)f.Proof.srapplypath_cone;introi.1:reflexivity.introsjhx;simpl.applyconcat_p1_1p.Defined.Postcomposition for conesGiven a cocone overD2and a Diagram mapm:D1=>D2, one can postcompose each map of the cone by the corresponding one ofmto get a cone overD1.Definitioncone_postcompose{D1D2:DiagramG} (m:DiagramMapD1D2) {X}: (ConeXD1) -> (ConeXD2).Proof.introC.srapplyBuild_Cone;introi.1:exact(mioCi).introsjgx;simpl.etransitivity.1:applyDiagramMap_comm.applyap,legs_comm.Defined.Identity and associativity for the postcomposition of a cone with a diagram map.Definitioncone_postcompose_identity(D:DiagramG) (X:Type):cone_postcompose(X:=X) (diagram_idmapD) ==idmap.Proof.introC;srapplypath_cone;simpl.1:reflexivity.intros;simpl.refine(_@ (concat_1p_)^).refine(concat_p1_@concat_1p_@ap_idmap_).Defined.Definitioncone_postcompose_comp{D1D2D3:DiagramG}(m2:DiagramMapD2D3) (m1:DiagramMapD1D2) (X:Type): (cone_postcompose(X:=X)m2)o(cone_postcomposem1)==cone_postcompose(diagram_compm2m1).Proof.introC;simpl.srapplypath_cone.1:reflexivity.introsijgx;simpl.applyequiv_p1_1q.unfoldCommutativeSquares.comm_square_comp.refine(_@concat_p_pp___).applyap.rewriteap_pp.applyap.symmetry.byapplyap_compose.Defined.Associativity of a postcomposition and a precomposition.Definitioncone_postcompose_precompose{D1D2:DiagramG}(m:DiagramMapD1D2) `(f:Y->X) (C:ConeXD1):cone_precompose(cone_postcomposemC)f=cone_postcomposem(cone_precomposeCf).Proof.srapplypath_cone;introi.1:reflexivity.introsjgx;simpl.applyconcat_p1_1p.Defined.The postcomposition with a diagram equivalence is an equivalence.Global Instancecone_precompose_equiv{D1D2:DiagramG}(m:D1~d~D2) (X:Type) :IsEquiv(cone_postcompose(X:=X)m).Proof.srapplyisequiv_adjointify.1:apply(cone_postcompose(diagram_equiv_invm)).+introsC.etransitivity.-applycone_postcompose_comp.-rewritediagram_inv_is_section.applycone_postcompose_identity.+introsC.etransitivity.-applycone_postcompose_comp.-rewritediagram_inv_is_retraction.applycone_postcompose_identity.Defined.The precomposition with an equivalence is an equivalence.Global Instancecone_postcompose_equiv{D:DiagramG} `(f:Y<~>X):IsEquiv(funC:ConeXD=>cone_precomposeCf).Proof.srapplyisequiv_adjointify.1:exact(funC=>cone_precomposeCf^-1).+introsC.etransitivity.-symmetry.applycone_precompose_comp.-etransitivity.2:applycone_precompose_identity.applyap.funextx;applyeissect.+introsC.etransitivity.-symmetry.applycone_precompose_comp.-etransitivity.2:applycone_precompose_identity.applyap.funextx;applyeisretr.Defined.Universality preservationUniversality of a cone is preserved by composition with a (diagram) equivalence.Global Instancecone_postcompose_equiv_universality{D1D2:DiagramG}(m:D1~d~D2) {X} (C:ConeXD1) (_:UniversalConeC):UniversalCone(cone_postcompose(X:=X)mC).Proof.srapplyBuild_UniversalCone;intro.rewrite(path_forall__(funf=>cone_postcompose_precomposemfC)).srapplyisequiv_compose.Defined.Global Instancecone_precompose_equiv_universality{D:DiagramG} `(f:Y<~>X)(C:ConeXD) (_:UniversalConeC):UniversalCone(cone_precomposeCf).Proof.srapplyBuild_UniversalCone;intro.rewrite<- (path_forall__(fung=>cone_precompose_compgfC)).srapplyisequiv_compose.Defined.EndFunctorialityCone.

--- Miscellaneous\Congruence.html ---
CongruenceLibrary CongruenceThis file implements algebra congruence relation. It serves as a
    universal algebra generalization of normal subgroup, ring ideal, etc.Congruence is used to construct quotients, in similarity with how
    normal subgroup and ring ideal are used to construct quotients.RequireExportHoTT.Algebra.Universal.Algebra.RequireImportHoTT.Universes.HPropHoTT.Classes.interfaces.canonical_namesHoTT.Algebra.Universal.Homomorphism.UnsetEliminationSchemes.Local OpenScopeAlgebra_scope.Sectioncongruence.Context{σ :Signature} (A:Algebraσ) (Φ:foralls,Relation(As)).A finitary operationf:As1*As2*...*Asn->AtsatisfiesOpCompatiblefiffΦ s1 x1 y1 * Φ s2 x2 y2 * ... * Φ sn xn ynimpliesΦ t (f (x1, x2, ..., xn)) (f (y1, y2, ..., yn)).The below definition generalizes this to infinitary operations.DefinitionOpCompatible{w:SymbolTypeσ} (f:OperationAw) :Type:=forall(ab:DomOperationAw),(foralli:Arityw,Φ(sorts_domwi) (ai) (bi)) ->Φ(sort_codw) (fa) (fb).ClassOpsCompatible:Type:=ops_compatible:forall(u:Symbolσ),OpCompatibleu.#A.Global Instancetrunc_ops_compatible`{Funext} {n:trunc_index}`{!forallsxy,IsTruncn(Φsxy)}:IsTruncnOpsCompatible.Proof.applyistrunc_forall.Defined.A family of relationsΦis a congruence iff it is a family of
      mere equivalence relations andOpsCompatibleAΦholds.ClassIsCongruence:Type:=Build_IsCongruence{is_mere_relation_cong:forall(s:Sortσ),is_mere_relation(As) (Φs);equiv_rel_cong:forall(s:Sortσ),EquivRel(Φs);ops_compatible_cong:OpsCompatible}.Global ArgumentsBuild_IsCongruence{is_mere_relation_cong}{equiv_rel_cong}{ops_compatible_cong}.Global Existing Instanceis_mere_relation_cong.Global Existing Instanceequiv_rel_cong.Global Existing Instanceops_compatible_cong.Global Instancehprop_is_congruence`{Funext} :IsHPropIsCongruence.Proof.apply(equiv_hprop_allpath_)^-1.intros[C1C2C3] [D1D2D3].bydestruct(path_ishpropC1D1),(path_ishpropC2D2),(path_ishpropC3D3).Defined.Endcongruence.A homomorphismf:foralls,As->Bsis compatible
    with a congruenceΦiffΦsxyimpliesfsx=fsy.DefinitionHomCompatible{σ :Signature} {AB:Algebraσ}(Φ:foralls,Relation(As)) `{!IsCongruenceAΦ}(f:foralls,As->Bs) `{!IsHomomorphismf}:Type:=foralls(xy:As),Φsxy->fsx=fsy.

--- Miscellaneous\Connectedness.html ---
ConnectednessLibrary ConnectednessConnectednessRequireImportBasics.RequireImportTypes.RequireImportExtensions.RequireImportFactorization.RequireExportModalities.Modality.(*Exportsince the actual definitions of connectedness appear there, in the generality of a modality. *)RequireImportModalities.Descent.RequireImportTruncations.CoreTruncations.SeparatedTrunc.This reduces universe variables inconn_pointed_typeandconn_point_elim, which refer toUnit.LocalSetUniverseMinimizationToSet.Local OpenScopepath_scope.Local OpenScopetrunc_scope.There is a slight controversy of indexing for connectedness — in particular, how the indexing for maps shoud relate to the indexing for types.  One may reasonably take the connectedness of a map to correspond either to that of its *fibers*, or of its *cofiber*; these differ by 1.  The traditional topological indexing uses the cofiber.  We use the fiber, as does Lurie inHTT; but we choose to agree with the traditional indexing on types, while Lurie agrees with it on maps.Currently, the translation is therefore as follows:HoTT              Traditional       LurieMap    (n-1)-connected   n-connected       n-connective
Type   n-connected       n-connected       (n+1)-connectiveA handy benchmark: under our indexing, the mapS1->1is 0-connected but not 1-connected, while the map1->S1is (–1)–connected but not 0-connected.One reason for our choice is that this way, the n-truncated and n-connected maps are the modal and modally-connected maps for the n-truncation modality.  Many of the basic lemmas about connected maps are in fact true for any modality, and can be found inModality.v.  Thus, here we consider mainly properties that involve the interaction of connectedness at different truncation levels.Truncatedness of the type of extensionsA key lemma on the interaction between connectedness and truncatedness: suppose one is trying to extend along an n-connected map, into a k-truncated family of types (k ≥ n).  Then the space of possible extensions is (k–n–2)-truncated.(Mnemonic for the indexing: think of the base case, where k=n; then we know we can eliminate, so the space of extensions is contractible.)This lemma is most useful via corollaries like the wedge-inclusion, the wiggly wedge, and their n-ary generalizations.Lemmaistrunc_extension_along_conn`{Funext} {mn:trunc_index}{AB:Type} (f:A->B) `{IsConnMapn__f}(P:B->Type) {HP:forallb:B,IsTrunc(m+2+n) (Pb)}(d:foralla:A,P(fa)):IsTruncm(ExtensionAlongfPd).Proof.revertPHPd.simple_inductionmm'IH;introsPHPd;simplin*.(* m = –2 *)-apply(Build_Contr_(extension_conn_map_elimnfPd)).introsy.apply(allpath_extension_conn_mapn);assumption.(* m = S m' *)-applyistrunc_S.introsee'.refine(istrunc_isequiv_istrunc_(path_extensionee')).(* magically infers: paths in extensions = extensions into paths, which by induction is m'-truncated. *)Defined.Connectedness of path spacesGlobal Instanceisconnected_paths`{Univalence} {nA}`{IsConnectedn.+1A} (xy:A):IsConnectedn(x=y).Proof.refine(contr_equiv'_(equiv_path_Trxy)^-1).Defined.Connectivity of pointed typesThe connectivity of a pointed type and (the inclusion of) its point are intimately connected.We can't make both of theseInstances, as that would result in infinite loops.Global Instanceconn_pointed_type@{u} {n:trunc_index} {A:Type@{u}} (a0:A)`{IsConnMapn__(unit_namea0)}:IsConnectedn.+1A| 1000.Proof.applyisconnected_conn_map_to_unit.apply(OO_cancelR_conn_map(Trn.+1) (Trn) (unit_namea0) (const_ttA)).Defined.Definitionconn_point_incl`{Univalence} {n:trunc_index} {A:Type} (a0:A)`{IsConnectedn.+1A}:IsConnMapn(unit_namea0).Proof.rapply(OO_cancelL_conn_map(Trn.+1) (Trn) (unit_namea0) (const_ttA)).applyO_lex_leq_Tr.Defined.#[export]HintImmediateconn_point_incl:typeclass_instances.Note thatOO_cancelR_conn_mapandOO_cancelL_conn_map(Proposition 2.31 of CORS) generalize the above statements to 2/3 of a 2-out-of-3 property for connected maps, for any reflective subuniverse and its subuniverse of separated types.  If useful, we could specialize that more general form explicitly to truncations.To prove ann-truncated predicate on an (n+1)-connected, pointed type, it's enough to prove it for the basepoint.Definitionconn_point_elim`{Univalence} (n:trunc_index) {A:pType@{u}} `{IsConnectedn.+1A}(P:A->Type@{u}) `{foralla,IsTruncn(Pa)} (p0:P(pointA)):foralla,Pa.Proof.This follows fromconn_point_inclandconn_map_elim, but we give a direct proof.introa.SinceAisn+1-connected,a0=aisn-connected, which means thatTrn(a0=a)has an element.poseproof(p:=center(Trn((pointA) =a))).strip_truncations.exact(p#p0).Defined.Decreasing connectednessAnn.+1-connected type is alson-connected.  This obviously can't be anInstance!Definitionisconnected_prednA`{IsConnectedn.+1A}:IsConnectednA.Proof.applyisconnected_from_elim;introsC?f.refine(isconnected_elimn.+1Cf).Defined.Ak-connected type isn-connected, whenk>=n.  We constrainkby making it of the formn+2+m, which makes the induction go through smoothly.Definitionisconnected_pred_addnmA`{H:IsConnected(n+2+m)A}:IsConnectedmA.Proof.inductionn.1:assumption.applyIHn.applyisconnected_pred.assumption.Defined.A version with the order of summands swapped, which is sometimes handy, e.g. in the next two results.Definitionisconnected_pred_add'nmA`{H:IsConnected(m+2+n)A}:IsConnectedmA.Proof.apply(isconnected_pred_addnm).destruct(trunc_index_add_commmn);assumption.Defined.It follows that ann.+1-connected type is also-1-connected.Definitionmerely_isconnectednA`{IsConnectedn.+1A}:merelyA:= @center_(isconnected_pred_add'n(-1)A).And that ann.+2-connected type is0-connected.Definitionis0connected_isconnected(n:trunc_index)A`{IsConnectedn.+2A}:IsConnected0A:=isconnected_pred_add'n0A.Definitionisconnmap_pred_addnmAB(f:A->B) `{IsConnMap(n+2+m)__f}:IsConnMapmf.Proof.introb.exact(isconnected_pred_addnm_).Defined.0-connectednessTo be 0-connected is the same as to be (-1)-connected and that any two points are merely equal.  TODO: This should also be generalized to separated subuniverses (CORS Remark 2.35).Definitionmerely_path_is0connected`{Univalence}(A:Type) `{IsConnected0A} (xy:A):merely(x=y).Proof.This follows immediately fromisconnected_pathsabove.rapplycenter.Defined.Definitionis0connected_merely_allpath`{Univalence}(A:Type) `{merelyA}(p:forall(xy:A),merely(x=y)):IsConnected0A.Proof.strip_truncations.applycontr_inhabited_hprop.-applyhprop_allpath;introszw.strip_truncations.exact(equiv_path_Trzw(pzw)).-applytr;assumption.Defined.The path component of a pointx:Xis connected.Global Instanceis0connected_component{X:Type} (x:X):IsConnected0 {z:X&merely(z=x) }.Proof.apply(Build_Contr_(tr(x;tridpath))).rapplyTrunc_ind;intros[Zp].strip_truncations.apply(aptr).rapplypath_sigma_hprop.exactp^.Defined.Any two points in a path component are merely equal.  This follows frommerely_path_is0connected, but this proof doesn't need univalence.Definitionmerely_path_component{X:Type} {x:X}(z1z2: {z:X&merely(z=x) }):merely(z1=z2).Proof.destructz1as[z1p1],z2as[z2p2].strip_truncations.applytr.applypath_sigma_hprop;cbn.exact(p1@p2^).Defined.The path component of a pointx:Xis equivalent to the image of the constant mapUnit->Xatx.Definitionequiv_component_image_unit{X:Type} (x:X): {z:X&merely(z=x) } <~>image(Tr(-1)) (unit_namex).Proof.unfoldimage;simpl.applyequiv_functor_sigma_id;introsz;simpl.applyTrunc_functor_equiv;unfoldhfiber.refine((equiv_contr_sigma_)^-1oE_).applyequiv_path_inverse.Defined.0-connected types are indecomposableGlobal Instanceindecomposable_0connected`{Univalence}(X:Type) `{IsConnected0X}:IndecomposableX.Proof.assert(IsConnected(-1)X)byrefine(isconnected_pred(-1)X).constructor.-introsABf.assert(z:=center(merelyX) :merelyX);generalizez.refine(Trunc_rec_).+applyishprop_sum;tryexact_.introslr.strip_truncations.exact(not_is_inl_and_inr'(fz) (lz) (rz)).+introsx.remember(fx)asyeqn:p.destructyas[a|b]; [left|right];introsx'.all:assert(q:=merely_path_is0connectedXxx');strip_truncations.all:refine(transport_(apfq)_).all:exact(transport_p^tt).-introsnx.apply(Trunc_rec(n:= -1)nx).exact(center(merelyX)).Defined.(* Truncation preserves connectedness. Note that this is for different levels. *)Global Instanceisconnected_trunc{X:Type} (nm:trunc_index) `{IsConnectednX}:IsConnectedn(TrmX).Proof.unfoldIsConnected.srapply(contr_equiv'_(Trunc_swapnmX)^-1).Defined.SectionWedge_Incl_Conn.Connectivity of the wedge into the product.A very useful form of the key lemmaistrunc_extension_along_connis the connectivity of the wedge into the product, for a pair of pointed spaces.  In fact this can be formulated without mentioning the wedge per se (so, without requiring HIT’s), since the statement only needs to talk about maps out of the wedge.Once again, we believe that the type of the conclusion is an hprop (though we do not prove it) — essentially because it is wrapping up an elimination principle and its corresponding computation rule — and so we make the proof of this result opaque.Context`{Univalence}{mn:trunc_index}{A:Type} (a0:A) `{IsConnectedm.+1A}{B:Type} (b0:B) `{IsConnectedn.+1B}(P:A->B->Type) {HP:forallab,IsTrunc(m+2+n) (Pab)}(f_a0:forallb:B,Pa0b)(f_b0:foralla:A,Pab0)(f_a0b0:f_a0b0=f_b0a0).Corollaryisconn_wedge_incl: {f:forallab,Pab& {e_a0:forallb,fa0b=f_a0b& {e_b0:foralla,fab0=f_b0a&e_b0a0= (e_a0b0) @f_a0b0}}}.Proof.assert(goal_as_extension:ExtensionAlong(unit_namea0)(funa=>ExtensionAlong(unit_nameb0) (Pa) (unit_name(f_b0a)))(unit_name(f_a0; (unit_namef_a0b0)))).-apply(extension_conn_map_elimm).+apply(conn_point_incla0).+introsa.apply(istrunc_extension_along_conn(n:=n)).*apply(conn_point_inclb0).*applyHP.-destructgoal_as_extensionas[f_ebname_ea_eab].assert(ea_eab:=name_ea_eabtt);clearname_ea_eab.exists(funa=>pr1(f_eba)).exists(funb=>apD10(ea_eab..1)b).exists(funa=>pr2(f_eba)tt).(* The last component is essentially (g' ..2), wrapped in a bit of path-algebra. *)applymoveL_Mp.apply(concatR(apD10(ea_eab..2)tt)).set(ea:=ea_eab..1).generalizeea;simpl.clearea_eabea.intros.rewritetransport_arrow.rewritetransport_const.rewritetransport_paths_Fl.exact1%path.Qed.It is easier to apply the above result with its components separated.Definitionwedge_incl_elim:forallab,Pab:=isconn_wedge_incl.1.Definitionwedge_incl_comp1:forallb,wedge_incl_elima0b=f_a0b:=isconn_wedge_incl.2.1.Definitionwedge_incl_comp2:foralla,wedge_incl_elimab0=f_b0a:=isconn_wedge_incl.2.2.1.Definitionwedge_incl_comp3:wedge_incl_comp2a0= (wedge_incl_comp1b0) @f_a0b0:=isconn_wedge_incl.2.2.2.EndWedge_Incl_Conn.Definitionwedge_incl_elim_uncurried`{Univalence}{mn:trunc_index}{A:Type} (a0:A) `{IsConnectedm.+1A}{B:Type} (b0:B) `{IsConnectedn.+1B}(P:A->B->Type) {HP:forallab,IsTrunc(m+2+n) (Pab)}(fs: {f_a0:forallb:B,Pa0b& {f_b0:foralla:A,Pab0&f_a0b0=f_b0a0}}):forall(a:A) (b:B),Pab.Proof.destructfsas[f_a0[f_b0f_a0b0]].refine(wedge_incl_elim_____f_a0b0).Defined.

--- Miscellaneous\Constant.html ---
ConstantLibrary ConstantRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensionsFactorization.RequireImportTruncations.CoreModalities.Modality.Local OpenScopepath_scope.Local OpenScopetrunc_scope.Varieties of constant functionRecall that a functionf:X->Yis *weakly constant*,WeaklyConstantf, ifforallxy,fx=fy.  We show, following Kraus, Escardo, Coquand, and Altenkirch, that the type of fixed points of a weakly constant endofunction is an hprop.  However, to avoid potential confusion withCoq.Init.Wf.Fix, instead of their notationFix, we denote this type byFixedBy.DefinitionFixedBy{X:Type} (f:X->X) := {x:X&fx=x}.Global Instanceishprop_fix_wconst{X:Type} (f:X->X){wc:WeaklyConstantf}:IsHProp(FixedByf).Proof.applyhprop_inhabited_contr;intros[x0p0].refine(contr_equiv'{x:X&fx0=x}_);unfoldFixedBy.applyequiv_functor_sigma_id.introsx.applyequiv_concat_l.applywconst.Defined.It follows that if a typeXadmits a weakly constant endofunctionf, thenFixedByfis equivalent tomerelyX.Definitionequiv_fix_merely{X:Type} (f:X->X){wc:WeaklyConstantf}:FixedByf<~>merelyX.Proof.applyequiv_iff_hprop.-intros[xp];exact(trx).-applyTrunc_rec;introsx.exists(fx).applywconst.Defined.Therefore, a type is collapsible (admits a weakly constant endomap) if and only ifmerelyX->X(it has "split support").Definitionsplitsupp_collapsible{X} `{CollapsibleX}:merelyX->X.Proof.refine(_o(equiv_fix_merelycollapse)^-1).applypr1.Defined.Definitioncollapsible_splitsupp{X} (s:merelyX->X):CollapsibleX.Proof.refine(Build_Collapsible_(sotr)_);introsxy.apply(aps),path_ishprop.Defined.We say thatfis *conditionally constant* if it factors through the propositional truncationmerelyX, and *constant* if it factors throughUnit.DefinitionConditionallyConstant{XY:Type} (f:X->Y):=ExtensionAlong(@tr(-1)X) (fun_=>Y)f.We don't yet have a need for a predicateConstanton functions; we do already have the operationconstwhich constructs the constant function at a given point.  Every such constant function is, of course, conditionally constant.Definitioncconst_const{XY} (y:Y):ConditionallyConstant(@constXYy).Proof.exists(consty);introsx;reflexivity.Defined.The type of conditionally constant functions is equivalent tomerelyX->Y.Definitionequiv_cconst_from_merely`{Funext} (XY:Type): {f:X->Y&ConditionallyConstantf} <~> (merelyX->Y).Proof.refine(_oE(equiv_sigma_symm_)).refine(equiv_sigma_contr_).Defined.If a function factors through any hprop, it is conditionally constant.Definitioncconst_factors_hprop{XY:Type} (f:X->Y)(P:Type) `{IsHPropP}(g:X->P) (h:P->Y) (p:hog==f):ConditionallyConstantf.Proof.pose(g':=Trunc_recg:merelyX->P).exists(hog');introsx.applyp.Defined.Thus, if it factors through a type thatXimplies is contractible, then it is also conditionally constant.Definitioncconst_factors_contr`{Funext}  {XY:Type} (f:X->Y)(P:Type) {Pc:X->ContrP}(g:X->P) (h:P->Y) (p:hog==f):ConditionallyConstantf.Proof.assert(merelyX->IsHPropP).{applyTrunc_rec.Uses funextintrosx;pose(Pcx);applyistrunc_succ. }pose(g':=Trunc_ind(fun_=>P)g:merelyX->P).exists(hog');introsx.applyp.Defined.Any weakly constant function with collapsible domain is conditionally constant.Definitioncconst_wconst_collapsible{XY:Type} `{CollapsibleX}(f:X->Y) {wc:WeaklyConstantf}:ConditionallyConstantf.Proof.exists(fosplitsupp_collapsible);introsx.unfoldsplitsupp_collapsible;simpl.applywconst.Defined.The image of a weakly constant function with hset codomain is an hprop. In fact, we just need to assume thatmerelyX->IsHSetY.Local Instancehprop_image_wconst_hset_if_merely_domain{XY:Type} (f:X->Y){Ys:merelyX->IsHSetY} {wc:WeaklyConstantf}:IsHProp(image(-1)f).Proof.applyhprop_allpath.intros[bm] [b'm'].applypath_sigma_hprop;cbn.assert(Ys':IsHSetY).{applyYs.strip_truncations.exact(trm.1). }strip_truncations.destructmas[xp],m'as[x'p'].exact(p^ @wcxx'@p').Defined.WhenmerelyX->IsHSetY, any weakly constant functionX->Yis conditionally constant.Definitioncconst_wconst_hset_if_merely_domain{XY:Type} (f:X->Y){Ys:merelyX->IsHSetY} {wc:WeaklyConstantf}:ConditionallyConstantf.Proof.srapply(cconst_factors_hpropf(image(-1)f)).-applyfactor1.-applyfactor2.-applyfact_factors.Defined.The previous result will be most often used when we knowYis an hset, so we specialize to this case.Definitioncconst_wconst_hset{XY:Type} (f:X->Y){Ys:IsHSetY} {wc:WeaklyConstantf}:ConditionallyConstantf:=cconst_wconst_hset_if_merely_domainf(Ys:=fun_=>Ys).We can decompose this into an "induction principle" and its computation rule.Definitionmerely_rec_hset{XY:Type} (f:X->Y){Ys:IsHSetY} {wc:WeaklyConstantf}:merelyX->Y:= (cconst_wconst_hsetf).1.The computation rule is(cconst_wconst_hsetf).2x, but that's reflexivity.Definitionmerely_rec_hset_beta{XY:Type} (f:X->Y){Ys:IsHSetY} {wc:WeaklyConstantf}(x:X):merely_rec_hsetf(trx) =fx:=idpath.If we assumeFunext, then we can weaken the hypothesis frommerelyX->IsHSetYtoX->IsHSetY, since withFunext, we know thatIsHSetYis an hprop.Definitioncconst_wconst_hset_if_domain`{Funext} {XY:Type} (f:X->Y){Ys:X->IsHSetY} {wc:WeaklyConstantf}:ConditionallyConstantf:=cconst_wconst_hset_if_merely_domainf(Ys:=Trunc_recYs).We record the corresponding induction principle, but not the computation principle, since it is again definitional.Definitionmerely_rec_hset_if_domain`{Funext} {XY:Type} (f:X->Y){Ys:X->IsHSetY} {wc:WeaklyConstantf}:merelyX->Y:= (cconst_wconst_hset_if_domainf).1.The type of weakly constant functionsX->Y, whenYis a set, is equivalent tomerelyX->Y. This usesFunextfor the main argument, so we may as well state it with the more general assumptionX->IsHSetY.Definitionequiv_merely_rec_hset_if_domain`{Funext} (XY:Type){Ys:X->IsHSetY}: {f:X->Y&WeaklyConstantf} <~> (merelyX->Y).Proof.poseproof(Ys':=Trunc_recYs:merelyX->IsHSetY).snrapplyequiv_adjointify.-intros[fwc].exact(merely_rec_hset_if_domainf(wc:=wc)).-introg.exists(gotr).introsxy;apply(apg),path_ishprop.-introsg;applypath_arrow;introsmx.poseproof(Ys'mx).strip_truncations;reflexivity.-intros[fwc].snrapplypath_sigma;cbn.+reflexivity.+cbn.funextxy.pose(Ysx);applypath_ishprop.Defined.

--- Miscellaneous\ConstantDiagram.html ---
ConstantDiagramLibrary ConstantDiagramRequireImportBasics.RequireImportCone.RequireImportCocone.RequireImportDiagram.RequireImportGraph.Constant diagramSectionConstantDiagram.Context{G:Graph}.Definitiondiagram_const(C:Type) :DiagramG.Proof.srapplyBuild_Diagram.1:exact(fun_=>C).introsijk.exactidmap.Defined.Definitiondiagram_const_functor{AB:Type} (f:A->B):DiagramMap(diagram_constA) (diagram_constB).Proof.srapplyBuild_DiagramMap.1:introi;exactf.reflexivity.Defined.Definitiondiagram_const_functor_comp{ABC:Type}(f:A->B) (g:B->C):diagram_const_functor(gof)=diagram_comp(diagram_const_functorg) (diagram_const_functorf).Proof.reflexivity.Defined.Definitiondiagram_const_functor_idmap{A:Type}:diagram_const_functor(idmap:A->A) =diagram_idmap(diagram_constA).Proof.reflexivity.Defined.Definitionequiv_diagram_const_cocone`{Funext} (D:DiagramG) (X:Type):DiagramMapD(diagram_constX) <~>CoconeDX.Proof.srapplyequiv_adjointify.1,2:intros[?w];econstructor.1,2:introsxyzz';symmetry;revertxyzz'.1,2:exactw.1,2:intros[].1:srapplypath_cocone.3:srapplypath_DiagramMap.1,3:reflexivity.all:cbn;intros;hott_simpl.Defined.Definitionequiv_diagram_const_cone`{Funext} (X:Type) (D:DiagramG):DiagramMap(diagram_constX)D<~>ConeXD.Proof.srapplyequiv_adjointify.1,2:intros[?w];econstructor.1,2:exactw.1,2:intros[].1:srapplypath_cone.3:srapplypath_DiagramMap.1,3:reflexivity.all:cbn;intros;hott_simpl.Defined.EndConstantDiagram.

--- Miscellaneous\Contractible.html ---
ContractibleLibrary ContractibleContractibilityRequireImportOverturePathGroupoids.Local OpenScopepath_scope.Naming convention: we consistently abbreviate "contractible" as "contr".  A theorem about a spaceXbeing contractible (which will usually be an instance of the typeclassContr) is calledcontr_X.Allow ourselves to implicitly generalize over typesAandB, and a functionf.Generalizable VariablesABf.If a space is contractible, then any two points in it are connected by a path in a canonical way.Definitionpath_contr`{ContrA} (xy:A) :x=y:= (contrx)^ @ (contry).Any space of paths in a contractible space is contractible.Global Instancecontr_paths_contr`{ContrA} (xy:A) :Contr(x=y) | 10000.Proof.apply(Build_Contr_(path_contrxy)).intror;destructr;applyconcat_Vp.Defined.It follows that  any two parallel paths in a contractible space are homotopic, which is just the principle UIP.Definitionpath2_contr`{ContrA} {xy:A} (pq:x=y) :p=q:=path_contrpq.Also, the total space of any based path space is contractible.  We define thecontrfields as separate definitions, so that we can give themsimplnomatchannotations.Definitionpath_basedpaths{X:Type} {xy:X} (p:x=y): (x;1) = (y;p) :> {z:X&x=z}.Proof.destructp;reflexivity.Defined.Argumentspath_basedpaths{Xxy}p:simplnomatch.Global Instancecontr_basedpaths{X:Type} (x:X) :Contr{y:X&x=y} | 100.Proof.apply(Build_Contr_(x;1)).intros[yp];applypath_basedpaths.Defined.(* Sometimes we end up with a sigma of a one-sided path type that's not eta-expanded, which Coq doesn't seem able to match with the previous instance. *)Global Instancecontr_basedpaths_etashort{X:Type} (x:X) :Contr(sig(@pathsXx)) | 100:=contr_basedpathsx.Based path types with the second variable fixed.Definitionpath_basedpaths'{X:Type} {xy:X} (p:y=x): (x;1) = (y;p) :> {z:X&z=x}.Proof.destructp;reflexivity.Defined.Argumentspath_basedpaths'{Xxy}p:simplnomatch.Global Instancecontr_basedpaths'{X:Type} (x:X) :Contr{y:X&y=x} | 100.Proof.refine(Build_Contr_(x;1)_).intros[yp];applypath_basedpaths'.Defined.Some useful computation laws for based path spacesDefinitionap_pr1_path_contr_basedpaths{X:Type}{xyz:X} (p:x=y) (q:x=z):appr1(path_contr((y;p) : {y':X&x=y'}) (z;q)) =p^ @q.Proof.destructp,q;reflexivity.Defined.Definitionap_pr1_path_contr_basedpaths'{X:Type}{xyz:X} (p:y=x) (q:z=x):appr1(path_contr((y;p) : {y':X&y'=x}) (z;q)) =p@q^.Proof.destructp,q;reflexivity.Defined.Definitionap_pr1_path_basedpaths{X:Type}{xy:X} (p:x=y):appr1(path_basedpathsp) =p.Proof.destructp;reflexivity.Defined.Definitionap_pr1_path_basedpaths'{X:Type}{xy:X} (p:y=x):appr1(path_basedpaths'p) =p^.Proof.destructp;reflexivity.Defined.If the domain is contractible, the function is propositionally constant.Definitioncontr_dom_equiv{AB} (f:A->B) `{ContrA} :forallxy:A,fx=fy:=funxy=>apf((contrx)^ @contry).Any retract of a contractible type is contractibleDefinitioncontr_retract{XY:Type} `{ContrX}(r:X->Y) (s:Y->X) (h:forally,r(sy) =y):ContrY:=Build_Contr_(r(centerX)) (funy=> (apr(contr_)) @h_).Sometimes the easiest way to prove that a type is contractible doesn't produce the definitionally-simplest center.  (In particular, this can affect performance, as Coq spends a long time tracing through long proofs of contractibility to find the center.)  So we give a way to modify the center.Definitioncontr_change_center{A:Type} (a:A) `{ContrA}:ContrA.Proof.apply(Build_Contr_a).intros;applypath_contr.Defined.The automatically generated induction principle forIsTrunc_internalproduces two goals, so we define a custom induction principle forContrthat only produces the expected goal.DefinitionContr_ind@{uv|} (A:Type@{u}) (P:ContrA->Type@{v})(H:forall(center:A) (contr:forally,center=y),P(Build_ContrAcentercontr))(C:ContrA):PC:=matchCasC0inIsTruncn_return(matchnasn0returnIsTruncn0_->Type@{v}with|minus_two=>func0=>Pc0|trunc_Sk=>fun_=>UnitendC0)with|Build_Contrcentercontr=>Hcentercontr|istrunc_S__=>ttend.

--- Miscellaneous\Coproducts.html ---
CoproductsLibrary CoproductsRequireImportBasics.OvertureBasics.TacticsBasics.Decidable.RequireImportTypes.Bool.RequireImportWildCat.CoreWildCat.EquivWildCat.ForallWildCat.NatTransWildCat.OppositeWildCat.ProductsWildCat.UniverseWildCat.YonedaWildCat.ZeroGroupoidWildCat.PointedCatWildCat.MonoidalWildCat.Bifunctor.Categories with coproductsDefinitioncat_coprod_rec_inv{IA:Type} `{Is1CatA}(coprod:A) (x:I->A) (z:A) (inj:foralli,xi$->coprod):yon_0gpdzcoprod$->prod_0gpdI(funi=>yon_0gpdz(xi)):=cat_prod_corec_inv(coprod:A^op)xzinj.ClassCoproduct(I:Type) {A:Type} `{Is1CatA} (x:I->A):=prod_co_coprod::Product(A:=A^op)Ix.Definitioncat_coprod(I:Type) {A:Type} (x:I->A) `{CoproductI_x} :A:=cat_prod(A:=A^op)Ix.Definitioncat_in{I:Type} {A:Type} {x:I->A} `{CoproductI_x}:forall(i:I),xi$->cat_coprodIx:=cat_pr(A:=A^op) (x:=x).Global Instancecat_isequiv_cat_coprod_rec_inv{I:Type} {A:Type}{x:I->A} `{CoproductI_x}:forall(z:A),CatIsEquiv(cat_coprod_rec_inv(cat_coprodIx)xzcat_in):=cat_isequiv_cat_prod_corec_inv(A:=A^op) (x:=x).A convenience wrapper for building coproductsDefinitionBuild_Coproduct(I:Type) {A:Type} `{Is1CatA} {x:I->A}(cat_coprod:A) (cat_in:foralli:I,xi$->cat_coprod)(cat_coprod_rec:forallz:A,(foralli:I,xi$->z) -> (cat_coprod$->z))(cat_coprod_beta_in:forall(z:A) (f:foralli,xi$->z) (i:I),cat_coprod_reczf$ocat_ini$==fi)(cat_prod_eta_in:forall(z:A) (fg:cat_coprod$->z),(foralli:I,f$ocat_ini$==g$ocat_ini) ->f$==g):CoproductIx:=Build_ProductI(cat_coprod:A^op)cat_incat_coprod_reccat_coprod_beta_incat_prod_eta_in.SectionLemmata.Context(I:Type) {A:Type} {x:I->A} `{CoproductI_x}.Definitioncate_cat_coprod_rec_inv{z:A}:yon_0gpdz(cat_coprodIx) $<~>prod_0gpdI(funi=>yon_0gpdz(xi)):=cate_cat_prod_corec_invI(A:=A^op) (x:=x).Definitioncate_cat_coprod_rec{z:A}:prod_0gpdI(funi=>yon_0gpdz(xi)) $<~>yon_0gpdz(cat_coprodIx):=cate_cat_prod_corecI(A:=A^op) (x:=x).Definitioncat_coprod_rec{z:A}: (foralli,xi$->z) ->cat_coprodIx$->z:=cat_prod_corecI(A:=A^op) (x:=x).Definitioncat_coprod_beta{z:A} (f:foralli,xi$->z):foralli,cat_coprod_recf$ocat_ini$==fi:=cat_prod_betaI(A:=A^op) (x:=x)f.Definitioncat_coprod_eta{z:A} (f:cat_coprodIx$->z):cat_coprod_rec(funi=>f$ocat_ini) $==f:=cat_prod_etaI(A:=A^op) (x:=x)f.Definitionnatequiv_cat_coprod_rec_inv:NatEquiv(funz=>yon_0gpdz(cat_coprodIx))(funz:A=>prod_0gpdI(funi=>yon_0gpdz(xi))):=natequiv_cat_prod_corec_invI(A:=A^op) (x:=x).Definitioncat_coprod_rec_eta{z:A} {fg:foralli,xi$->z}: (foralli,fi$==gi) ->cat_coprod_recf$==cat_coprod_recg:=cat_prod_corec_etaI(A:=A^op) (x:=x).Definitioncat_coprod_in_eta{z:A} {fg:cat_coprodIx$->z}: (foralli,f$ocat_ini$==g$ocat_ini) ->f$==g:=cat_prod_pr_etaI(A:=A^op) (x:=x).EndLemmata.Codiagonal / fold mapDefinitioncat_coprod_codiag{I:Type} {A:Type} (x:A) `{CoproductI_(fun_=>x)}:cat_coprodI(fun_=>x) $->x:=cat_prod_diag(A:=A^op)x.Uniqueness of coproductsI-indexed coproducts are unique no matter how they are constructed.Definitioncate_cat_coprod{IJ:Type} (ie:I<~>J) {A:Type} `{HasEquivsA}(x:I->A) `{!CoproductIx} (y:J->A) `{!CoproductJy}(e:forall(i:I),y(iei) $<~>xi):cat_coprodJy$<~>cat_coprodIx:=cate_cat_prod(A:=A^op)iexye.Existence of coproductsClassHasCoproducts(IA:Type) `{Is1CatA}:=has_coproducts::forallx:I->A,CoproductIx.ClassHasAllCoproducts(A:Type) `{Is1CatA}:=has_all_coproducts::forallI:Type,HasCoproductsIA.Coproduct functorLocal Instancehasproductsop_hascoproducts{IA:Type} `{HasCoproductsIA}:HasProductsIA^op:=funx:I->A^op=> @has_coproductsIA_____x.Global Instanceis0functor_cat_coprod(I:Type) `{IsGraphI}(A:Type) `{HasCoproductsIA}: @Is0Functor(I->A)A(isgraph_forallI(fun_=>A))_(funx:I->A=>cat_coprodIx).Proof.applyis0functor_op'.exact(is0functor_cat_prodIA^op).Defined.Global Instanceis1functor_cat_coprod(I:Type) `{IsGraphI}(A:Type) `{HasCoproductsIA}: @Is1Functor(I->A)A___(is1cat_forallI(fun_=>A))____(funx:I->A=>cat_coprodIx)_.Proof.applyis1functor_op'.exact(is1functor_cat_prodIA^op).Defined.Categories with specific kinds of coproductsDefinitionisinitial_coprodempty{A:Type} {z:A}`{CoproductEmptyA(fun_=>z)}:IsInitial(cat_coprodEmpty(fun_=>z)).Proof.introsa.snrefine(cat_coprod_rec__;funf=>cat_coprod_in_eta__);intros[].Defined.Binary coproductsClassBinaryCoproduct{A:Type} `{Is1CatA} (xy:A):=prod_co_bincoprod::BinaryProduct(A:=A^op)xy.Definitioncat_bincoprod{A:Type}  `{Is1CatA} (xy:A) `{!BinaryCoproductxy} :A:=cat_binprod(x:A^op)y.Definitioncat_inl{A:Type} `{Is1CatA} {xy:A} `{!BinaryCoproductxy}:x$->cat_bincoprodxy:=cat_pr1(A:=A^op) (x:=x) (y:=y).Definitioncat_inr{A:Type} `{Is1CatA} {xy:A} `{!BinaryCoproductxy}:y$->cat_bincoprodxy:=cat_pr2(A:=A^op) (x:=x) (y:=y).A category with binary coproducts is a category with a binary coproduct for each pair of objects.ClassHasBinaryCoproducts(A:Type) `{Is1CatA}:=binary_coproducts::forallxy,BinaryCoproductxy.Global Instancehasbinarycoproducts_hascoproductsbool{A:Type}`{HasCoproductsBoolA}:HasBinaryCoproductsA:=funxy=>has_coproducts(funb:Bool=>ifbthenxelsey).A convenience wrapper for building binary coproductsDefinitionBuild_BinaryCoproduct{A:Type} `{Is1CatA} {xy:A}(cat_coprod:A) (cat_inl:x$->cat_coprod) (cat_inr:y$->cat_coprod)(cat_coprod_rec:forallz:A, (x$->z) -> (y$->z) ->cat_coprod$->z)(cat_coprod_beta_inl:forall(z:A) (f:x$->z) (g:y$->z),cat_coprod_reczfg$ocat_inl$==f)(cat_coprod_beta_inr:forall(z:A) (f:x$->z) (g:y$->z),cat_coprod_reczfg$ocat_inr$==g)(cat_coprod_in_eta:forall(z:A) (fg:cat_coprod$->z),f$ocat_inl$==g$ocat_inl->f$ocat_inr$==g$ocat_inr->f$==g):BinaryCoproductxy:=Build_BinaryProduct(cat_coprod:A^op)cat_inlcat_inrcat_coprod_reccat_coprod_beta_inlcat_coprod_beta_inrcat_coprod_in_eta.SectionLemmata.Context{A:Type} {xyz:A} `{BinaryCoproduct_xy}.Definitioncat_bincoprod_rec(f:x$->z) (g:y$->z):cat_bincoprodxy$->z:= @cat_binprod_corecA^op____xy__fg.Definitioncat_bincoprod_beta_inl(f:x$->z) (g:y$->z):cat_bincoprod_recfg$ocat_inl$==f:= @cat_binprod_beta_pr1A^op____xy__fg.Definitioncat_bincoprod_beta_inr(f:x$->z) (g:y$->z):cat_bincoprod_recfg$ocat_inr$==g:= @cat_binprod_beta_pr2A^op____xy__fg.Definitioncat_bincoprod_eta(f:cat_bincoprodxy$->z):cat_bincoprod_rec(f$ocat_inl) (f$ocat_inr) $==f:= @cat_binprod_etaA^op____xy__f.Definitioncat_bincoprod_eta_in{fg:cat_bincoprodxy$->z}:f$ocat_inl$==g$ocat_inl->f$ocat_inr$==g$ocat_inr->f$==g:= @cat_binprod_eta_prA^op____xy__fg.Definitioncat_bincoprod_rec_eta{ff':x$->z} {gg':y$->z}:f$==f'->g$==g'->cat_bincoprod_recfg$==cat_bincoprod_recf'g':= @cat_binprod_corec_etaA^op____xy__ff'gg'.EndLemmata.Binary coproduct functorHint: UseSetPrintingImplicitto see the implicit arguments in the following proofs.Global Instanceis0functor_cat_bincoprod_l{A:Type}`{hbc:HasBinaryCoproductsA}y:Is0Functor(A:=A) (funx=>cat_bincoprodxy).Proof.rapplyis0functor_op'.exact(is0functor_cat_binprod_l(A:=A^op) (H0:=hbc)y).Defined.Global Instanceis1functor_cat_bincoprod_l{A:Type}`{hbc:HasBinaryCoproductsA}y:Is1Functor(funx=>cat_bincoprodxy).Proof.rapplyis1functor_op'.exact(is1functor_cat_binprod_l(A:=A^op) (H0:=hbc)y).Defined.Global Instanceis0functor_cat_bincoprod_r{A:Type}`{hbc:HasBinaryCoproductsA}x:Is0Functor(funy=>cat_bincoprodxy).Proof.rapplyis0functor_op'.exact(is0functor_cat_binprod_r(A:=A^op) (H0:=hbc)x).Defined.Global Instanceis1functor_cat_bincoprod_r{A:Type}`{hbc:HasBinaryCoproductsA}x:Is1Functor(funy=>cat_bincoprodxy).Proof.rapplyis1functor_op'.exact(is1functor_cat_binprod_r(A:=A^op) (H0:=hbc)x).Defined.Global Instanceis0bifunctor_cat_bincoprod{A:Type}`{hbc:HasBinaryCoproductsA}:Is0Bifunctor(funxy=>cat_bincoprodxy).Proof.nrapplyis0bifunctor_op'.exact(is0bifunctor_cat_binprod(A:=A^op) (H0:=hbc)).Defined.Global Instanceis1bifunctor_cat_bincoprod{A:Type}`{hbc:HasBinaryCoproductsA}:Is1Bifunctor(funxy=>cat_bincoprodxy).Proof.nrapplyis1bifunctor_op'.exact(is1bifunctor_cat_binprod(A:=A^op) (H0:=hbc)).Defined.Products and coproducts in the opposite categoryDefinitionhasbinarycoproducts_op_hasbinaryproducts{A:Type}`{hbp:HasBinaryProductsA}:HasBinaryCoproductsA^op:=hbp.Hint Immediatehasbinarycoproducts_op_hasbinaryproducts:typeclass_instances.Definitionhasbinarycoproducts_hasbinaryproducts_op{A:Type}`{Is1CatA,hbp: !HasBinaryProductsA^op}:HasBinaryCoproductsA:=hbp.Hint Immediatehasbinarycoproducts_hasbinaryproducts_op:typeclass_instances.Definitionhasbinaryproducts_op_hasbinarycoproducts{A:Type}`{hbc:HasBinaryCoproductsA}:HasBinaryProductsA^op:=hbc.Hint Immediatehasbinarycoproducts_op_hasbinaryproducts:typeclass_instances.Definitionhasbinaryproducts_hasbinarycoproducts_op{A:Type}`{Is1CatA,hbc: !HasBinaryCoproductsA^op}:HasBinaryProductsA:=hbc.Hint Immediatehasbinaryproducts_hasbinarycoproducts_op:typeclass_instances.Symmetry of coproductsDefinitioncat_bincoprod_swap{A:Type} `{Is1CatA}{hbc:HasBinaryCoproductsA} (xy:A):cat_bincoprodxy$->cat_bincoprodyx.Proof.exact(@cat_binprod_swapA^op____hbc__).Defined.Definitioncate_bincoprod_swap{A:Type} `{HasEquivsA}{hbc:HasBinaryCoproductsA} (xy:A):cat_bincoprodxy$<~>cat_bincoprodyx.Proof.exact(@cate_binprod_swapA^op_____hbc__).Defined.Associativity of coproductsLemmacate_coprod_assoc{A:Type} `{HasEquivsA}{hbc:HasBinaryCoproductsA} (xyz:A):cat_bincoprodx(cat_bincoprodyz)$<~>cat_bincoprod(cat_bincoprodxy)z.Proof.exact(@associator_cat_binprodA^op_____hbcxyz)^-1$.Defined.Definitionassociator_cat_bincoprod{A:Type} `{HasEquivsA}`{!HasBinaryCoproductsA}:Associator(funxy=>cat_bincoprodxy).Proof.unfoldAssociator.snrapplyassociator_op'.1:exact_.nrapplyassociator_cat_binprod.Defined.CodiagonalDefinitioncat_bincoprod_codiag{A:Type}`{Is1CatA} (x:A) `{!BinaryCoproductxx}:cat_bincoprodxx$->x:=cat_binprod_diag(A:=A^op)x.Lemmas aboutcat_bincoprod_recDefinitioncat_bincoprod_fmap01_rec{A:Type}`{Is1CatA, !HasBinaryCoproductsA} {wxyz:A}(f:z$->w) (g:y$->x) (h:x$->w):cat_bincoprod_recfh$ofmap01(funxy=>cat_bincoprodxy)zg$==cat_bincoprod_recf(h$og):= @cat_binprod_fmap01_corecA^op____hasbinaryproducts_op_hasbinarycoproducts____fgh.Definitioncat_bincoprod_fmap10_rec{A:Type}`{Is1CatA, !HasBinaryCoproductsA} {wxyz:A}(f:y$->x) (g:x$->w) (h:z$->w):cat_bincoprod_recgh$ofmap10(funxy=>cat_bincoprodxy)fz$==cat_bincoprod_rec(g$of)h:= @cat_binprod_fmap10_corecA^op____hasbinaryproducts_op_hasbinarycoproducts____fgh.Definitioncat_bincoprod_fmap11_rec{A:Type}`{Is1CatA, !HasBinaryCoproductsA} {vwxyz:A}(f:y$->w) (g:z$->x) (h:w$->v) (i:x$->v):cat_bincoprod_rechi$ofmap11(funxy=>cat_binprodxy)fg$==cat_bincoprod_rec(h$of) (i$og):= @cat_binprod_fmap11_corecA^op____hasbinaryproducts_op_hasbinarycoproducts_____fghi.Definitioncat_bincoprod_rec_associator{A:Type} `{HasEquivsA}{hbc:HasBinaryCoproductsA}{wxyz:A} (f:w$->z) (g:x$->z) (h:y$->z):cat_bincoprod_rec(cat_bincoprod_recfg)h$oassociator_cat_bincoprodwxy$==cat_bincoprod_recf(cat_bincoprod_recgh).Proof.nrapplycate_moveR_eV.symmetry.exact(cat_binprod_associator_corec(HasBinaryProducts0:=hasbinaryproducts_op_hasbinarycoproducts(hbc:=hbc))fgh).Defined.Definitioncat_bincoprod_swap_rec{A:Type} `{Is1CatA}`{!HasBinaryCoproductsA} {abc:A} (f:a$->c) (g:b$->c):cat_bincoprod_recfg$ocat_bincoprod_swapba$==cat_bincoprod_recgf:= @cat_binprod_swap_corecA^op____hasbinaryproducts_op_hasbinarycoproducts_____.Cocartesian Monoidal StructureGlobal Instanceismonoidal_cat_bincoprod{A:Type} `{HasEquivsA}`{!HasBinaryCoproductsA} (zero:A) `{!IsInitialzero}:IsMonoidalA(funxy=>cat_bincoprodxy)zero| 10.Proof.nrapplyismonoidal_op'.nrapply(ismonoidal_cat_binprod(A:=A^op)zero).bynrapplyisterminal_op_isinitial.Defined.Global Instanceissymmetricmonoidal_cat_bincoprod{A:Type} `{HasEquivsA}`{!HasBinaryCoproductsA} (zero:A) `{!IsInitialzero}:IsSymmetricMonoidalA(funxy=>cat_bincoprodxy)zero| 10.Proof.nrapplyissymmetricmonoidal_op'.nrapply(issymmetricmonoidal_cat_binprod(A:=A^op)zero).bynrapplyisterminal_op_isinitial.Defined.Coproducts in TypeTypehas all coproducts.Global Instancehasallcoproducts_type:HasAllCoproductsType.Proof.introsIx.snrapplyBuild_Coproduct.-exact(sig(funi:I=>xi)).-exact(existx).-introsAf[ixi].exact(fixi).-introsAfixi;reflexivity.-introsAfgp[ixi].exact(pixi).Defined.In particular,Typehas all binary coproducts.Global Instancehasbinarycoproducts_type:HasBinaryCoproductsType:= {}.Canonical coproduct-product mapThere is a canonical map from a coproduct to a product when the indexing set has decidable equality and the category is pointed.Definitioncat_coprod_prod{I:Type} `{DecidablePathsI} {A:Type}`{Is1CatA, !IsPointedCatA}(x:I->A) `{!CoproductIx, !ProductIx}:cat_coprodIx$->cat_prodIx.Proof.applycat_coprod_rec.introsi.applycat_prod_corec.introsa.destruct(dec_pathsia)as[p|].-destructp.exact(Id_).-applyzero_morphism.Defined.Definitioncat_bincoprod_binprod{A:Type} `{Is1CatA, !IsPointedCatA}(xy:A) `{!BinaryCoproductxy, !BinaryProductxy}:cat_bincoprodxy$->cat_binprodxy.Proof.nrapplycat_coprod_prod;exact_.Defined.Coproducts in the opposite categoryDefinitioncoproduct_op{IA:Type} (x:I->A)`{Is1CatA} {H':ProductIx}:CoproductI(A:=A^op)x:=H'.Hint Immediatecoproduct_op:typeclass_instances.

--- Miscellaneous\Core.html ---
CoreLibrary CoreRequireImportBasics.OvertureBasics.Tactics.Wild categories, functors, and transformationsDirected graphsClassIsGraph(A:Type) :={Hom:A->A->Type}.Notation"a $-> b" := (Homab).Definitiongraph_hfiber{BC:Type} `{IsGraphC} (F:B->C) (c:C):= {b:B&Fb$->c}.0-categorical structuresA wild (0,1)-category has 1-morphisms and operations on them, but no coherence.ClassIs01Cat(A:Type) `{IsGraphA} :={Id:forall(a:A),a$->a;cat_comp:forall(abc:A), (b$->c) -> (a$->b) -> (a$->c);}.Argumentscat_comp{A__abc}__.Notation"g $o f" := (cat_compgf).Definitioncat_postcomp{A} `{Is01CatA} (a:A) {bc:A} (g:b$->c): (a$->b) -> (a$->c):=cat_compg.Definitioncat_precomp{A} `{Is01CatA} {ab:A} (c:A) (f:a$->b): (b$->c) -> (a$->c):=fung=>g$of.A wild 0-groupoid is a wild (0,1)-category whose morphisms can be reversed.  This is also known as a setoid.ClassIs0Gpd(A:Type) `{Is01CatA} :={gpd_rev:forall{ab:A}, (a$->b) -> (b$->a) }.DefinitionGpdHom{A} `{Is0GpdA} (ab:A) :=a$->b.Notation"a $== b" := (GpdHomab).Global Instancereflexive_GpdHom{A} `{Is0GpdA}:ReflexiveGpdHom:=funa=>Ida.Global Instancereflexive_Hom{A} `{Is01CatA}:ReflexiveHom:=funa=>Ida.Definitiongpd_comp{A} `{Is0GpdA} {abc:A}: (a$==b) -> (b$==c) -> (a$==c):=funpq=>q$op.Infix"$@" :=gpd_comp.Global Instancetransitive_GpdHom{A} `{Is0GpdA}:TransitiveGpdHom:=funabcfg=>f$@g.Global Instancetransitive_Hom{A} `{Is01CatA}:TransitiveHom:=funabcfg=>g$of.Notation"p ^$" := (gpd_revp).Global Instancesymmetric_GpdHom{A} `{Is0GpdA}:SymmetricGpdHom:=funabf=>f^$.Global Instancesymmetric_GpdHom'{A} `{Is0GpdA}:SymmetricHom:=funabf=>f^$.DefinitionHom_path{A:Type} `{Is01CatA} {ab:A} (p:a=b) : (a$->b).Proof.destructp;applyId.Defined.DefinitionGpdHom_path{A} `{Is0GpdA} {ab:A} (p:a=b) :a$==b:=Hom_pathp.A 0-functor acts on morphisms, but satisfies no axioms.ClassIs0Functor{AB:Type} `{IsGraphA} `{IsGraphB} (F:A->B):= {fmap:forall(ab:A) (f:a$->b),Fa$->Fb}.Argumentsfmap{ABisgraph_Aisgraph_B}F{is0functor_Fab}f:rename.ClassIs2Graph(A:Type) `{IsGraphA}:=isgraph_hom:forall(ab:A),IsGraph(a$->b).Global Existing Instanceisgraph_hom| 20.#[global]TypeclassesTransparentIs2Graph.Wild 1-categorical structuresClassIs1Cat(A:Type) `{!IsGraphA, !Is2GraphA, !Is01CatA} :={is01cat_hom:forall(ab:A),Is01Cat(a$->b) ;is0gpd_hom:forall(ab:A),Is0Gpd(a$->b) ;is0functor_postcomp:forall(abc:A) (g:b$->c),Is0Functor(cat_postcompag) ;is0functor_precomp:forall(abc:A) (f:a$->b),Is0Functor(cat_precompcf) ;cat_assoc:forall(abcd:A) (f:a$->b) (g:b$->c) (h:c$->d),(h$og) $of$==h$o(g$of);cat_assoc_opp:forall(abcd:A) (f:a$->b) (g:b$->c) (h:c$->d),h$o(g$of) $== (h$og) $of;cat_idl:forall(ab:A) (f:a$->b),Idb$of$==f;cat_idr:forall(ab:A) (f:a$->b),f$oIda$==f;}.Global Existing Instanceis01cat_hom.Global Existing Instanceis0gpd_hom.Global Existing Instanceis0functor_postcomp.Global Existing Instanceis0functor_precomp.Argumentscat_assoc{_________}fgh.Argumentscat_assoc_opp{_________}fgh.Argumentscat_idl{_______}f.Argumentscat_idr{_______}f.An alternate constructor that doesn't require the proof ofcat_assoc_opp.  This can be used for defining examples of wild categories, but shouldn't be used for the general theory of wild categories.DefinitionBuild_Is1Cat'(A:Type) `{!IsGraphA, !Is2GraphA, !Is01CatA}(is01cat_hom:forallab:A,Is01Cat(a$->b))(is0gpd_hom:forallab:A,Is0Gpd(a$->b))(is0functor_postcomp:forall(abc:A) (g:b$->c),Is0Functor(cat_postcompag))(is0functor_precomp:forall(abc:A) (f:a$->b),Is0Functor(cat_precompcf))(cat_assoc:forall(abcd:A) (f:a$->b) (g:b$->c) (h:c$->d),h$og$of$==h$o(g$of))(cat_idl:forall(ab:A) (f:a$->b),Idb$of$==f)(cat_idr:forall(ab:A) (f:a$->b),f$oIda$==f):Is1CatA:=Build_Is1CatA___is01cat_homis0gpd_homis0functor_postcompis0functor_precompcat_assoc(funabcdfgh=> (cat_assocabcdfgh)^$)cat_idlcat_idr.Whiskering and horizontal composition of 2-cells.Definitioncat_postwhisker{A} `{Is1CatA} {abc:A}{fg:a$->b} (h:b$->c) (p:f$==g):h$of$==h$og:=fmap(cat_postcompah)p.Notation"h $@L p" := (cat_postwhiskerhp).Definitioncat_prewhisker{A} `{Is1CatA} {abc:A}{fg:b$->c} (p:f$==g) (h:a$->b):f$oh$==g$oh:=fmap(cat_precompch)p.Notation"p $@R h" := (cat_prewhiskerph).Definitioncat_comp2{A} `{Is1CatA} {abc:A}{fg:a$->b} {hk:b$->c}(p:f$==g) (q:h$==k):h$of$==k$og:= (q$@R_) $@ (_$@Lp).Notation"q $@@ p" := (cat_comp2qp).Monomorphisms and epimorphisms.DefinitionMonic{A} `{Is1CatA} {bc:A} (f:b$->c):=foralla(gh:a$->b),f$og$==f$oh->g$==h.DefinitionEpic{A} `{Is1CatA} {ab:A} (f:a$->b):=forallc(gh:b$->c),g$of$==h$of->g$==h.Section might be a clearer name but it's better to avoid confusion with Coq keywords.RecordSectionOf{A} `{Is1CatA} {ab:A} (f:a$->b) :={comp_right_inverse:b$->a;is_section:f$ocomp_right_inverse$==Idb}.RecordRetractionOf{A} `{Is1CatA} {ab:A} (f:a$->b) :={comp_left_inverse:b$->a;is_retraction:comp_left_inverse$of$==Ida}.Often, the coherences are actually equalities rather than homotopies.ClassIs1Cat_Strong(A:Type)`{!IsGraphA, !Is2GraphA, !Is01CatA} :={is01cat_hom_strong:forall(ab:A),Is01Cat(a$->b) ;is0gpd_hom_strong:forall(ab:A),Is0Gpd(a$->b) ;is0functor_postcomp_strong:forall(abc:A) (g:b$->c),Is0Functor(cat_postcompag) ;is0functor_precomp_strong:forall(abc:A) (f:a$->b),Is0Functor(cat_precompcf) ;cat_assoc_strong:forall(abcd:A)(f:a$->b) (g:b$->c) (h:c$->d),(h$og) $of=h$o(g$of) ;cat_assoc_opp_strong:forall(abcd:A)(f:a$->b) (g:b$->c) (h:c$->d),h$o(g$of) = (h$og) $of;cat_idl_strong:forall(ab:A) (f:a$->b),Idb$of=f;cat_idr_strong:forall(ab:A) (f:a$->b),f$oIda=f;}.Argumentscat_assoc_strong{_________}fgh.Argumentscat_assoc_opp_strong{_________}fgh.Argumentscat_idl_strong{_______}f.Argumentscat_idr_strong{_______}f.Global Instanceis1cat_is1cat_strong(A:Type) `{Is1Cat_StrongA}:Is1CatA| 1000.Proof.srapplyBuild_Is1Cat.all:introsab.-applyis01cat_hom_strong.-applyis0gpd_hom_strong.-applyis0functor_postcomp_strong.-applyis0functor_precomp_strong.-intros;applyGpdHom_path,cat_assoc_strong.-intros;applyGpdHom_path,cat_assoc_opp_strong.-intros;applyGpdHom_path,cat_idl_strong.-intros;applyGpdHom_path,cat_idr_strong.Defined.Initial objectsDefinitionIsInitial{A:Type} `{Is1CatA} (x:A):=forall(y:A), {f:x$->y&forallg,f$==g}.Existing ClassIsInitial.Definitionmor_initial{A:Type} `{Is1CatA} (xy:A) {h:IsInitialx}:x$->y:= (hy).1.Definitionmor_initial_unique{A:Type} `{Is1CatA} (xy:A) {h:IsInitialx}(f:x$->y):mor_initialxy$==f:= (hy).2f.Terminal objectsDefinitionIsTerminal{A:Type} `{Is1CatA} (y:A):=forall(x:A), {f:x$->y&forallg,f$==g}.Existing ClassIsTerminal.Definitionmor_terminal{A:Type} `{Is1CatA} (xy:A) {h:IsTerminaly}:x$->y:= (hx).1.Definitionmor_terminal_unique{A:Type} `{Is1CatA} (xy:A) {h:IsTerminaly}(f:x$->y):mor_terminalxy$==f:= (hx).2f.Generalizing function extensionality, "Morphism extensionality" states that homwiseGpdHom_pathis an equivalence.ClassHasMorExt(A:Type) `{Is1CatA} := {isequiv_Htpy_path:forallabfg,IsEquiv(@GpdHom_path(a$->b)___fg)}.Global Existing Instanceisequiv_Htpy_path.Definitionpath_hom{A} `{HasMorExtA} {ab:A} {fg:a$->b} (p:f$==g):f=g:=GpdHom_path^-1p.A 1-category with morphism extensionality induces a strong 1-categoryGlobal Instanceis1cat_strong_hasmorext{A:Type} `{HasMorExtA}:Is1Cat_StrongA.Proof.rapplyBuild_Is1Cat_Strong;hnf;intros;applypath_hom.+applycat_assoc.+applycat_assoc_opp.+applycat_idl.+applycat_idr.Defined.A 1-functor acts on 2-cells (satisfying no axioms) and also preserves composition and identities up to a 2-cell.(* The!tells Coq to use typeclass search to find theIsGraphparameters ofIs0Functorinstead of assuming additional copies of them. *)ClassIs1Functor{AB:Type} `{Is1CatA} `{Is1CatB}(F:A->B) `{!Is0FunctorF} :={fmap2:forallab(fg:a$->b), (f$==g) -> (fmapFf$==fmapFg) ;fmap_id:foralla,fmapF(Ida) $==Id(Fa);fmap_comp:forallabc(f:a$->b) (g:b$->c),fmapF(g$of) $==fmapFg$ofmapFf;}.Argumentsfmap2{ABisgraph_Ais2graph_Ais01cat_Ais1cat_Aisgraph_Bis2graph_Bis01cat_Bis1cat_B}F{is0functor_Fis1functor_Fabfg}p:rename.Argumentsfmap_id{ABisgraph_Ais2graph_Ais01cat_Ais1cat_Aisgraph_Bis2graph_Bis01cat_Bis1cat_B}F{is0functor_Fis1functor_F}a:rename.Argumentsfmap_comp{ABisgraph_Ais2graph_Ais01cat_Ais1cat_Aisgraph_Bis2graph_Bis01cat_Bis1cat_B}F{is0functor_Fis1functor_Fabc}fg:rename.ClassFaithful{AB:Type} (F:A->B) `{Is1FunctorABF} :=faithful:forall(xy:A) (fg:x$->y),fmapFf$==fmapFg->f$==g.Identity functorSectionIdentityFunctor.Global Instanceis0functor_idmap{A:Type} `{IsGraphA} :Is0Functoridmap.Proof.byapplyBuild_Is0Functor.Defined.Global Instanceis1functor_idmap{A:Type} `{Is1CatA} :Is1Functoridmap.Proof.byapplyBuild_Is1Functor.Defined.#[export]InstanceisFaithful_idmap{A:Type} `{Is1CatA}:Faithfulidmap.Proof.byunfoldFaithful.Defined.EndIdentityFunctor.Constant functorSectionConstantFunctor.Context{AB:Type}.Global Instanceis01functor_const`{IsGraphA} `{Is01CatB} (x:B):Is0Functor(fun_:A=>x).Proof.srapplyBuild_Is0Functor.introsabf;applyId.Defined.Global Instanceis1functor_const`{Is1CatA} `{Is1CatB} (x:B):Is1Functor(fun_:A=>x).Proof.srapplyBuild_Is1Functor.-introsabfgp;applyId.-intro;applyId.-introsabcfg.cbn.symmetry.applycat_idl.Defined.EndConstantFunctor.Composite functorsGlobal Instanceis0functor_compose{ABC:Type}`{IsGraphA,IsGraphB,IsGraphC}(F:A->B) `{!Is0FunctorF} (G:B->C) `{!Is0FunctorG}:Is0Functor(GoF).Proof.srapplyBuild_Is0Functor.introsabf;exact(fmapG(fmapFf)).Defined.Global Instanceis1functor_compose{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(G:B->C) `{!Is0FunctorG, !Is1FunctorG}:Is1Functor(GoF).Proof.srapplyBuild_Is1Functor.-introsabfgp;exact(fmap2G(fmap2Fp)).-introsa;exact(fmap2G(fmap_idFa) $@fmap_idG(Fa)).-introsabcfg.refine(fmap2G(fmap_compFfg) $@_).exact(fmap_compG(fmapFf) (fmapFg)).Defined.We give all arguments names in order to refer to them later. This allows us to write things likeis0functor(isgraph_A:=_)without having to make all the variables explicit.Argumentsis0functor_compose{ABC} {isgraph_Aisgraph_Bisgraph_C}F{is0functor_F}G{is0functor_G} :rename.Argumentsis1functor_compose{ABC}{isgraph_Ais2graph_Ais01cat_Ais1cat_Aisgraph_Bis2graph_Bis01cat_Bis1cat_Bisgraph_Cis2graph_Cis01cat_Cis1cat_C}F{is0functor_F} {is1functor_F}G{is0functor_G} {is1functor_G}:rename.Wild 1-groupoidsClassIs1Gpd(A:Type) `{Is1CatA, !Is0GpdA} :={gpd_issect:forall{ab:A} (f:a$->b),f^$ $of$==Ida;gpd_isretr:forall{ab:A} (f:a$->b),f$of^$ $==Idb;}.Some more convenient equalities for morphisms in a 1-groupoid. The naming scheme is similar toPathGroupoids.v.Definitiongpd_V_hh{A} `{Is1GpdA} {abc:A} (f:b$->c) (g:a$->b):f^$ $o(f$og) $==g:=(cat_assoc___)^$ $@ (gpd_issectf$@Rg) $@cat_idlg.Definitiongpd_h_Vh{A} `{Is1GpdA} {abc:A} (f:c$->b) (g:a$->b):f$o(f^$ $og) $==g:=(cat_assoc___)^$ $@ (gpd_isretrf$@Rg) $@cat_idlg.Definitiongpd_hh_V{A} `{Is1GpdA} {abc:A} (f:b$->c) (g:a$->b): (f$og) $og^$ $==f:=cat_assoc___$@ (f$@Lgpd_isretrg) $@cat_idrf.Definitiongpd_hV_h{A} `{Is1GpdA} {abc:A} (f:b$->c) (g:b$->a): (f$og^$) $og$==f:=cat_assoc___$@ (f$@Lgpd_issectg) $@cat_idrf.Definitiongpd_moveL_1M{A} `{Is1GpdA} {xy:A} {pq:x$->y}(r:p$oq^$ $==Id_) :p$==q.Proof.refine((cat_idrp)^$ $@ (p$@L(gpd_issectq)^$) $@ (cat_assoc___)^$ $@_).refine((r$@Rq) $@cat_idlq).Defined.Definitiongpd_moveR_V1{A} `{Is1GpdA} {xy:A} {p:x$->y}{q:y$->x} (r:Id_$==p$oq) :p^$ $==q.Proof.refine((cat_idrp^$)^$ $@ (p^$ $@Lr) $@_).applygpd_V_hh.Defined.Definitiongpd_moveR_M1{A:Type} `{Is1GpdA} {xy:A} {pq:x$->y}(r:Id_$==p^$ $oq) :p$==q.Proof.refine(_$@ (cat_assoc___)^$ $@ ((gpd_isretrp) $@Rq) $@ (cat_idlq)).exact((cat_idrp)^$ $@ (p$@Lr)).Defined.Definitiongpd_moveR_1M{A:Type} `{Is1GpdA} {xy:A} {pq:x$->y}(r:Id_$==q$op^$) :p$==q.Proof.refine((cat_idlp)^$ $@_$@cat_idrq).refine(_$@cat_assoc___$@ (q$@L(gpd_issectp)^$)^$).exact(r$@Rp).Defined.Definitiongpd_moveL_1V{A:Type} `{Is1GpdA} {xy:A} {p:x$->y}{q:y$->x} (r:p$oq$==Id_) :p$==q^$.Proof.refine(_$@ (cat_idlq^$)).refine(_$@ (r$@Rq^$)).exact(gpd_hh_V__)^$.Defined.Definitiongpd_moveR_hV{A:Type} `{Is1GpdA} {xyz:A} {p:y$->z}{q:x$->y} {r:x$->z} (s:r$==p$oq):r$oq^$ $==p:= (s$@Rq^$) $@gpd_hh_V__.Definitiongpd_moveR_Vh{A:Type} `{Is1GpdA} {xyz:A} {p:y$->z}{q:x$->y} {r:x$->z} (s:r$==p$oq):p^$ $or$==q:= (p^$ $@Ls) $@gpd_V_hh__.Definitiongpd_moveL_hM{A:Type} `{Is1GpdA} {xyz:A} {p:y$->z}{q:x$->y} {r:x$->z} (s:r$oq^$ $==p):r$==p$oq:= ((gpd_hV_h__)^$ $@ (s$@R_)).Definitiongpd_moveL_hV{A:Type} `{Is1GpdA} {xyz:A} {p:y$->z}{q:x$->y} {r:x$->z} (s:p$oq$==r):p$==r$oq^$:= (gpd_moveR_hVs^$)^$.Definitiongpd_moveL_Mh{A:Type} `{Is1GpdA} {xyz:A} {p:y$->z}{q:x$->y} {r:x$->z} (s:p^$ $or$==q):r$==p$oq:= ((gpd_h_Vh__)^$ $@ (p$@Ls)).Definitiongpd_moveL_Vh{A:Type} `{Is1GpdA} {xyz:A} {p:y$->z}{q:x$->y} {r:x$->z} (s:p$oq$==r):q$==p^$ $or:= (gpd_moveR_Vhs^$)^$.Definitiongpd_rev2{A:Type} `{Is1GpdA} {xy:A} {pq:x$->y}(r:p$==q) :p^$ $==q^$.Proof.applygpd_moveR_V1.applygpd_moveL_hV.exact(cat_idlq$@r^$).Defined.Definitiongpd_rev_pp{A} `{Is1GpdA} {abc:A} (f:b$->c) (g:a$->b): (f$og)^$ $==g^$ $of^$.Proof.applygpd_moveR_V1.refine(_$@cat_assoc___).applygpd_moveL_hV.refine(cat_idl_$@_).exact(gpd_hh_V__)^$.Defined.Definitiongpd_rev_1{A} `{Is1GpdA} {a:A} : (Ida)^$ $==Ida.Proof.refine((gpd_rev2(gpd_issect(Ida)))^$ $@_).refine(gpd_rev_pp__$@_).applygpd_isretr.Defined.Definitiongpd_rev_rev{A} `{Is1GpdA} {a0a1:A} (g:a0$==a1): (g^$)^$ $==g.Proof.applygpd_moveR_V1.exact(gpd_issect_)^$.Defined.1-functors between 1-groupoids preserve identitiesDefinitiongpd_1functor_V{AB} `{Is1GpdA,Is1GpdB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{a0a1:A} (f:a0$==a1):fmapFf^$ $== (fmapFf)^$.Proof.applygpd_moveL_1V.refine((fmap_comp___)^$ $@_$@fmap_id__).rapplyfmap2.applygpd_issect.Defined.Movement lemmas with extensionalityFor more complex movements you probably want to applypath_homand use the lemmas above.Definitiongpd_strong_V_hh{A} `{Is1GpdA, !HasMorExtA} {abc:A} (f:b$->c) (g:a$->b):f^$ $o(f$og) =g:=path_hom(gpd_V_hhfg).Definitiongpd_strong_h_Vh{A} `{Is1GpdA, !HasMorExtA} {abc:A} (f:c$->b) (g:a$->b):f$o(f^$ $og) =g:=path_hom(gpd_h_Vhfg).Definitiongpd_strong_hh_V{A} `{Is1GpdA, !HasMorExtA} {abc:A} (f:b$->c) (g:a$->b): (f$og) $og^$ =f:=path_hom(gpd_hh_Vfg).Definitiongpd_strong_hV_h{A} `{Is1GpdA, !HasMorExtA} {abc:A} (f:b$->c) (g:b$->a): (f$og^$) $og=f:=path_hom(gpd_hV_hfg).Definitiongpd_strong_rev_pp{A} `{Is1GpdA, !HasMorExtA} {abc:A} (f:b$->c) (g:a$->b): (f$og)^$ =g^$ $of^$:=path_hom(gpd_rev_ppfg).Definitiongpd_strong_rev_1{A} `{Is1GpdA, !HasMorExtA} {a:A}: (Ida)^$ =Ida:=path_homgpd_rev_1.Definitiongpd_strong_rev_rev{A} `{Is1GpdA, !HasMorExtA} {a0a1:A} (g:a0$==a1): (g^$)^$ =g:=path_hom(gpd_rev_revg).Definitionfmap_id_strong{AB} `{Is1CatA,Is1CatB, !HasMorExtB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF} (a:A):fmapF(Ida) =Id(Fa):=path_hom(fmap_idFa).Definitiongpd_strong_1functor_V{AB} `{Is1GpdA,Is1GpdB, !HasMorExtB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{a0a1:A} (f:a0$==a1):fmapFf^$ = (fmapFf)^$:=path_hom(gpd_1functor_VFf).ClassIs3Graph(A:Type) `{Is2GraphA}:=isgraph_hom_hom:forall(ab:A),Is2Graph(a$->b).Global Existing Instanceisgraph_hom_hom| 30.#[global]TypeclassesTransparentIs3Graph.Preservation of initial and terminal objectsClassPreservesInitial{AB:Type} (F:A->B)`{Is1FunctorABF} :Type:=isinitial_preservesinitial:forall(x:A),IsInitialx->IsInitial(Fx).Global Existing Instanceisinitial_preservesinitial.The initial morphism is preserved by such a functor.Lemmafmap_initial{AB:Type} (F:A->B)`{PreservesInitialABF} (xy:A) (h:IsInitialx):fmapF(mor_initialxy) $==mor_initial(Fx) (Fy).Proof.exact(mor_initial_unique___)^$.Defined.ClassPreservesTerminal{AB:Type} (F:A->B)`{Is1FunctorABF} :Type:=isterminal_preservesterminal:forall(x:A),IsTerminalx->IsTerminal(Fx).Global Existing Instanceisterminal_preservesterminal.The terminal morphism is preserved by such a functor.Lemmafmap_terminal{AB:Type} (F:A->B)`{PreservesTerminalABF} (xy:A) (h:IsTerminaly):fmapF(mor_terminalxy) $==mor_terminal(Fx) (Fy).Proof.exact(mor_terminal_unique___)^$.Defined.Functors preserving distinguished objectsRecordBasepointPreservingFunctor(BC:Type)`{Is01CatB,Is01CatC} `{IsPointedB,IsPointedC} := {bp_map:B->C;bp_is0functor:Is0Functorbp_map;bp_pointed:bp_map(pointB) $->pointC}.Argumentsbp_pointed{BC}%_type_scope{HH0H1H2H3H4}b.ArgumentsBuild_BasepointPreservingFunctor{BC}%_type_scope{HH0H1H2H3H4}bp_map%_function_scope{bp_is0functor}bp_pointed.Coercionbp_map:BasepointPreservingFunctor>->Funclass.Global Existing Instancebp_is0functor.Notation"B -->* C" := (BasepointPreservingFunctorBC) (atlevel70).Definitionbasepointpreservingfunctor_compose{BCD:Type}`{Is01CatB,Is01CatC,Is01CatD}`{IsPointedB,IsPointedC,IsPointedD}(F:B-->*C) (G:C-->*D):B-->*D.Proof.snrapplyBuild_BasepointPreservingFunctor.-exact(GoF).-exact_.-exact(bp_pointedG$ofmapG(bp_pointedF)).Defined.Notation"G $o* F" := (basepointpreservingfunctor_composeFG) (atlevel40).

--- Miscellaneous\CoreflectiveSubuniverse.html ---
CoreflectiveSubuniverseLibrary CoreflectiveSubuniverseRequireImportHoTT.BasicsHoTT.Types.RequireImportModalities.ModalityModalities.Open.Local OpenScopepath_scope.Coreflective subuniverses.In this file we study "coreflective subuniverses" that are defined dually to reflective subuniverses.  However, it turns out that there are many fewer examples of these.  The "internal" nature of such definitions, which in the reflective case makes the subuniverse automatically an exponential ideal, in the coreflective case has much stronger consequences: it forces the entire coreflection to be determined by the image ofUnit, which can be an arbitrary hprop.  Thus, this file is essentially just a no-go theorem: there are no coreflective subuniverses other than a certain class of fairly simple ones (which we call "co-open" since they are dual to open modalities).In particular, since we do not foresee many applications of this file, we don't bother introducing modules to make the definitions more universe polymorphic the way we did for reflective subuniverses.RecordCoreflectiveSubuniverse:={inF:Type->HProp;F_coreflector:Type->Type;F_inF:forallX,inF(F_coreflectorX) ;fromF:forallX,F_coreflectorX->X;We also don't bother definingooLiftableAlongso as to state the universal property withoutFunext.isequiv_fromF_postcompose:forall{YX} {Y_inF:inFY},IsEquiv(fun(g:Y->F_coreflectorX) =>fromFXog)Similarly, we don't bother asserting repleteness; we'll just use univalence.}.CoercionF_coreflector:CoreflectiveSubuniverse>->Funclass.SectionCoreflectiveSubuniverse.Context`{Univalence}.Context{F:CoreflectiveSubuniverse}.We begin by extracting the corecursor, its computation rule, and its eta principle.DefinitionF_corec{YX} `(inFFY) (f:Y->X) :Y->FX.Proof.refine((fun(g:Y->FX) =>fromFFXog)^-1f).byapplyisequiv_fromF_postcompose.Defined.DefinitionF_corec_beta{YX} (YF:inFFY) (f:Y->X):fromFFXoF_corecYFf==f.Proof.applyap10, (eisretr(fung=>fromFFXog)).Defined.DefinitionF_coindpaths{YX} `(inFFY) (gh:Y->FX)(p:fromFFXog==fromFFXoh):g==h.Proof.applyap10.refine(equiv_inj(funk=>fromFFXok)_).-byapplyisequiv_fromF_postcompose.-byapplypath_arrow.Defined.The functorial action of the coreflector.DefinitionF_functor{XY} (f:X->Y) :FX->FY:=F_corec(F_inFFX) (fofromFFX).The coreflector preserves hprops (since it is a right adjoint and thus preserves limits).Local Instanceishprop_coreflectionA`{IsHPropA} :IsHProp(FA).Proof.applyhprop_allpath;introsxy.exact(F_coindpaths(F_inFFA) (constx) (consty)(fun_=>path_ishprop__)x).Defined.A type lies inFas soon asfromFadmits a section.DefinitioninF_fromF_sectX(s:X->FX) (p:fromFFXos==idmap):inFFX.Proof.refine(transport(inFF) (path_universe(fromFFX)) (F_inFFX)).refine(isequiv_adjointify_sp_).change(sofromFFX==idmap).applyF_coindpaths;tryapplyF_inF.introsx;applyp.Defined.So far, nothing unexpected has happened.  Now, however, we claim thatFis completely determined by the image ofUnit, which byishprop_coreflectionis an hprop.  Specifically, we claim thatXlies inFexactly whenX->FUnit.DefinitioninF_equiv_implies_funitX:inFFX<~> (X->FUnit).Proof.applyequiv_iff_hprop.-intros?.applyF_corec;tryassumption.exact(fun_=>tt).-introsf.simplerefine(inF_fromF_sectX__).+introsx.exact(F_functor(unit_namex) (fx)).+introsx;unfoldF_functor.exact(F_corec_beta(F_inFFUnit) (constx) (fx)).Defined.EndCoreflectiveSubuniverse.Conversely, we will now show that for any hpropU, the typesXsuch thatX->Uare a coreflective subuniverse, which we call "co-open" since it is dual to the open modality.SectionCoOpen.Context`{Funext} (U:HProp).DefinitioncoOp:CoreflectiveSubuniverse.Proof.simplerefine(Build_CoreflectiveSubuniverse(funX=>Build_HProp(X->U))(funX=>X*U)(funX=> @sndXU)(funX=> @fstXU)_);tryexact_.introsYXYU;simplin*.refine(isequiv_adjointify_(funhy=> (hy,YUy))__).-introsg;applypath_arrow;introsy;reflexivity.-introsh;applypath_arrow;introsy.applypath_prod; [reflexivity|byapplypath_ishprop].Defined.Thus, each coreflective subuniverses are uniquely determined by an hprop.  Moreover, the coreflective subuniverse corresponding to an hpropUis closely related to the open modalityOpU.  Specifically, they form anadjoint modality pairin the sense that the subuniverses are canonically equivalent, and the coreflection and reflection respect this equivalence.  In categorical language, this says that the inclusion of an open subtopos is the center of a local geometric morphism in the other direction.  We express this concisely as follows.Definitioncoopen_isequiv_openX:IsEquiv(O_functor(OpU) (fromFcoOpX)).Proof.refine(isequiv_adjointify_(funux=>funu=> (uxu,u))__).-introsux;simplin*.applypath_arrow;introsu.transitivity(O_functor(OpU)fst(to(OpU) (X*U) (uxu,u))u).+applyap10,ap,path_arrow;introsu';simplin*.applypath_prod;simpl; [applyap| ];applypath_ishprop.+exact(ap10(to_O_natural(OpU) (@fstXU) (uxu,u))u).-introsuux;simplin*.applypath_arrow;introsu.applypath_prod; [simpl|applypath_ishprop].transitivity(O_functor(OpU)fst(to(OpU)_(fst(uuxu) ,u))u).+applyap10,ap,path_arrow;introsu'.applypath_prod;simpl.*exact(apfst(apuux(path_ishpropu'u))).*applypath_ishprop.+exact(ap10(to_O_natural(OpU) (@fstXU) (fst(uuxu) ,u))u).Defined.Definitioncoopen_equiv_openX:OpU(coOpX) <~>OpUX:=Build_Equiv__(O_functor(OpU) (fromFcoOpX))(coopen_isequiv_openX).EndCoOpen.

--- Miscellaneous\CoreLaws.html ---
CoreLawsLibrary CoreLawsRequireImportFunctor.CoreNaturalTransformation.Core.RequireImportCategory.Strict.RequireImportFunctor.Composition.Core.RequireImportNaturalTransformation.PathsNaturalTransformation.Composition.Core.RequireImportCategory.MorphismsFunctorCategory.Core.RequireImportPseudofunctor.CorePseudofunctor.RewriteLaws.RequireImportNaturalTransformation.Composition.Laws.RequireImportFunctorCategory.Morphisms.RequireLaxComma.CoreParts.RequireImportHoTT.Tactics.ImportFunctor.Identity.FunctorIdentityNotations.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.Local OpenScopecategory_scope.Quoting David Spivak:David: ok
       so an object ofFC⇓Dis a pair(X,G), whereXis a
       finite category (or a small category or whatever you wanted)
       andG:X-->Dis a functor.
       a morphism inFC⇓Dis a ``natural transformation diagram''
       (as opposed to a commutative diagram, in which the natural
       transformation would be ``identity'')
       so a map inFC⇓Dfrom(X,G)to(X',G')is a pair(F,α)whereF:X-->X'is a functor andα:G-->G'∘Fis a natural transformation
       and the punchline is that there is a functorcolim:FC⇓D-->DDavid: consider for yourself the case whereF:X-->X'is
       identity (X=X') and (separately) the case whereα:G-->G∘Fis identity.
       the point is, you've already done the work to get this colim
       functor.
       because every map inFC⇓Dcan be written as a composition
       of two maps, one where theF-part is identity and one where
       theα-part is identity.
       and you've worked both of those cases out already.ModuleImportLaxCommaCategory.IncludeLaxComma.CoreParts.LaxCommaCategoryParts.Sectionlax_comma_category_parts.Context`{Funext}.VariablesAB:PreCategory.VariableS:PseudofunctorA.VariableT:PseudofunctorB.Context`{forallab,IsHSet(Functor(Sa) (Tb))}.Local Notationobject:= (@object_ABST).Local Notationmorphism:= (@morphism_ABST).Local Notationcompose:= (@compose_ABST).Local Notationidentity:= (@identity_ABST).Local Ltact_do_work:=repeatmatchgoalwith|_=>reflexivity| [ |-context[components_of?T^-1 ?x] ]=>progresschange(T^-1x)with((Tx)^-1)| [ |-context[?F_1?m^-1] ]=>progresschange(F_1m^-1)with((F_1m)^-1)|_=>progressrepeatiso_collapse_inverse_right'end.Local Ltact_start:=simplin*;repeatmatchgoalwith| [H: ?x=_|-_] =>rewriteH;clearH;tryclearxend;path_natural_transformation;simplin*;rewrite!Category.Core.left_identity, !Category.Core.right_identity;rewrite!composition_of.Local Ltact:=t_start;rewrite<- !Category.Core.associativity;A reflective simplifier would be really useful here...repeatmatchgoalwith|_=>progresst_do_work| [ |-context[components_of?T?x] ]=>simplrewrite<- !(commutes_pT_FT)| [ |-context[components_of?T?x] ]=>simplrewrite<- !(commutesT)|_=>iso_move_inverseend.Ugh. The following code constructs the type of the helper lemma:Lemma associativity x1 x2 x3 x4
            (m1 : morphism x1 x2) (m2 : morphism x2 x3) (m3 : morphism x3 x4)
      : compose (compose m3 m2) m1 = compose m3 (compose m2 m1).
      Proof.
        refine (@path_morphism' _ _
                                (compose (compose m3 m2) m1)
                                (compose m3 (compose m2 m1))
                                (Category.Core.associativity _ _ _ _ _ _ _ _)
                                (Category.Core.associativity _ _ _ _ _ _ _ _)
                                _).
        simpl in *.
        repeat match goal with
                 | [ |- context[@morphism_inverse
                                     _ _ _ _
                                     (@isisomorphism_isomorphic
                                        _ _ _
                                        (Category.Morphisms.idtoiso
                                           ?C0
                                           (ap (p_morphism_of ?F (s:=_) (d:=_))
                                               (Category.Core.associativity ?C ?x1 ?x2 ?x3 ?x4 ?m1 ?m2 ?m3))))] ]
                   => generalize (@p_composition_of_coherent_inverse_for_rewrite _ C F x1 x2 x3 x4 m1 m2 m3);
                     generalize (Category.Morphisms.idtoiso
                                   C0
                                   (ap (p_morphism_of F (s:=_) (d:=_))
                                       (Category.Core.associativity C x1 x2 x3 x4 m1 m2 m3)))
                 | [ |- context[Category.Morphisms.idtoiso
                                     ?C0
                                     (ap (p_morphism_of ?F (s:=_) (d:=_))
                                         (Category.Core.associativity ?C ?x1 ?x2 ?x3 ?x4 ?m1 ?m2 ?m3))] ]
                   => generalize (@p_composition_of_coherent_for_rewrite _ C F x1 x2 x3 x4 m1 m2 m3);
                     generalize (Category.Morphisms.idtoiso
                                   C0
                                   (ap (p_morphism_of F (s:=_) (d:=_))
                                       (Category.Core.associativity C x1 x2 x3 x4 m1 m2 m3)))
               end.
        simpl.
        destruct_head morphism.
        destruct_head object.
        simpl in *.
        repeat match goal with
                 | [ |- context[p_composition_of ?F ?x ?y ?z ?m1 ?m2] ]
                   => generalize dependent (p_composition_of F x y z m1 m2)
                 | [ |- context[p_identity_of ?F ?x] ]
                   => generalize dependent (p_identity_of F x)
                 | [ |- context[p_morphism_of ?F ?x] ]
                   => generalize dependent (p_morphism_of F x)
                 | [ |- context[p_object_of ?F ?x] ]
                   => generalize dependent (p_object_of F x)
               end.
        simpl.
        clear.
        repeat (let H := fresh "x" in intro H).
        repeat match goal with H : _ |- _ => revert H end.
        intro.Lemmaassociativity_helper{xx0:PreCategory} {x1:Functorx0x}{x2x3:PreCategory} {x4:Functorx3x2} {x5x6:PreCategory}{x7:Functorx6x5} {x8x9:PreCategory} {x10:Functorx9x8}{x11:Functorx9x6} {x12:Functorx9x3} {x13:Functorx0x6}{x14:Functorx9x6} {x15:Functorx8x5} {x16:Functorxx5}{x17:Functorx9x0} {x18:Functorx8x}{x19:NaturalTransformation(x18ox10) (x1ox17)}{x20:Functorx0x3} {x21:Functorxx2}{x22:NaturalTransformation(x21ox1) (x4ox20)}{x23:Functorx8x2} {x24:Functorx3x6} {x25:Functorx2x5}{x26:NaturalTransformation(x25ox4) (x7ox24)}{x27:Functorx8x5} {x28: @Isomorphic(_->_)x27(x25ox23)%functor}{x29: @Isomorphic(_->_)x23(x21ox18)%functor}{x30: @Isomorphic(_->_)x16(x25ox21)%functor}{x31: @Isomorphic(_->_)x15(x16ox18)%functor}{x32: @Isomorphic(_->_)x14(x13ox17)%functor}{x33: @Isomorphic(_->_)x13(x24ox20)%functor}{x34: @Isomorphic(_->_)x12(x20ox17)%functor}{x35: @Isomorphic(_->_)x11(x24ox12)%functor}{x36: @Isomorphic(_->_)x14x11}(x37: (x36:Category.Core.morphism___) =(x35^-1o(x24oLx34^-1o(associator_1x24x20x17o((x33:Category.Core.morphism___)oRx17o(x32:Category.Core.morphism___)))))%natural_transformation){x38: @Isomorphic(_->_)x15x27}(x39:x38^-1 =(x31^-1o(x30^-1oRx18)oinverse(associator_1x25x21x18)o(x25oL(x29:Category.Core.morphism___))o(x28:Category.Core.morphism___))%natural_transformation): (x7oL(x36:Category.Core.morphism___)o(x7oLx32^-1oassociator_1x7x13x17o(x7oLx33^-1oassociator_1x7x24x20o(x26oRx20)oassociator_2x25x4x20o(x25oLx22)oassociator_1x25x21x1o((x30:Category.Core.morphism___)oRx1)oRx17)oassociator_2x16x1x17o(x16oLx19)oassociator_1x16x18x10o((x31:Category.Core.morphism___)oRx10))o(x38^-1oRx10))%natural_transformation=(x7oLx35^-1oassociator_1x7x24x12o(x26oRx12)oassociator_2x25x4x12o(x25oL(x4oLx34^-1oassociator_1x4x20x17o(x22oRx17)oassociator_2x21x1x17o(x21oLx19)oassociator_1x21x18x10o((x29:Category.Core.morphism___)oRx10)))oassociator_1x25x23x10o((x28:Category.Core.morphism___)oRx10))%natural_transformation.Proof.t.(* 18.647s *)Qed.Lemmaassociativityx1x2x3x4(m1:morphismx1x2) (m2:morphismx2x3) (m3:morphismx3x4):compose(composem3m2)m1=composem3(composem2m1).Proof.refine(@path_morphism'_ABST__(compose(composem3m2)m1)(composem3(composem2m1))(Category.Core.associativity________)(Category.Core.associativity________)_).simpl.applyassociativity_helper.-exact(p_composition_of_coherent_for_rewrite________).-exact(p_composition_of_coherent_inverse_for_rewrite________).Defined.Ugh.  To construct the type of this lemma, the code is:Lemma left_identity (s d : object) (m : morphism s d)
      : compose (identity _) m = m.
      Proof.
        refine (@path_morphism' _ _
                               (compose (identity _) m) m
                               (Category.Core.left_identity _ _ _ _)
                               (Category.Core.left_identity _ _ _ _)
                               _).
        simpl in *.
        repeat match goal with
                 | [ |- context[@morphism_inverse
                                     _ _ _ _
                                     (@isisomorphism_isomorphic
                                        _ _ _
                                        (Category.Morphisms.idtoiso
                                           ?C0
                                           (ap (p_morphism_of ?F (s:=_) (d:=_))
                                               (Category.Core.left_identity ?C ?x ?y ?f))))] ]
                   => generalize (@p_left_identity_of_coherent_inverse_for_rewrite _ C F x y f);
                     generalize (Category.Morphisms.idtoiso
                                   C0
                                   (ap (p_morphism_of F (s:=_) (d:=_))
                                       (Category.Core.left_identity C x y f)))
                 | [ |- context[Category.Morphisms.idtoiso
                                     ?C0
                                     (ap (p_morphism_of ?F (s:=_) (d:=_))
                                         (Category.Core.left_identity ?C ?x ?y ?f))] ]
                   => generalize (@p_left_identity_of_coherent_for_rewrite _ C F x y f);
                     generalize (Category.Morphisms.idtoiso
                                   C0
                                   (ap (p_morphism_of F (s:=_) (d:=_))
                                       (Category.Core.left_identity C x y f)))
               end.
        simpl.
        destruct_head morphism.
        destruct_head object.
        simpl in *.
        repeat match goal with
                 | [ |- context[p_composition_of ?F ?x ?y ?z ?m1 ?m2] ]
                   => generalize dependent (p_composition_of F x y z m1 m2)
                 | [ |- context[p_identity_of ?F ?x] ]
                   => generalize dependent (p_identity_of F x)
                 | [ |- context[p_morphism_of ?F ?x] ]
                   => generalize dependent (p_morphism_of F x)
                 | [ |- context[p_object_of ?F ?x] ]
                   => generalize dependent (p_object_of F x)
               end.
        simpl.
        clear.
        repeat (let H := fresh "x" in intro H).
        repeat match goal with H : _ |- _ => revert H end.
        intro.Lemmaleft_identity_helper{xx0:PreCategory} {x1:Functorx0x}{x2x3:PreCategory} {x4:Functorx3x2} {x5x6:Functorx3x0}{x7:Functorx2x} {x8:NaturalTransformation(x7ox4) (x1ox6)}{x9:Functorx2x} {x10:Functorx0x0} {x11:Functorxx}{x12: @Isomorphic(_->_)x111%functor} {x13: @Isomorphic(_->_)x101%functor}{x14: @Isomorphic(_->_)x9(x11ox7)%functor} {x15: @Isomorphic(_->_)x5(x10ox6)%functor}{x16: @Isomorphic(_->_)x5x6}{x17: (x16:Category.Core.morphism___) =(left_identity_natural_transformation_1x6o((x13:Category.Core.morphism___)oRx6o(x15:Category.Core.morphism___)))%natural_transformation}{x18: @Isomorphic(_->_)x9x7}{x19:x18^-1 =(x14^-1o(x12^-1oRx7)oinverse(left_identity_natural_transformation_1x7))%natural_transformation}: (x1oL(x16:Category.Core.morphism___)o(x1oLx15^-1oassociator_1x1x10x6o(x1oLx13^-1oright_identity_natural_transformation_2x1oleft_identity_natural_transformation_1x1o((x12:Category.Core.morphism___)oRx1)oRx6)oassociator_2x11x1x6o(x11oLx8)oassociator_1x11x7x4o((x14:Category.Core.morphism___)oRx4))o(x18^-1oRx4))%natural_transformation=x8.Proof.t.(* 3.959 s *)Qed.Lemmaleft_identity(sd:object) (m:morphismsd):compose(identity_)m=m.Proof.refine(@path_morphism'_ABST__(compose(identity_)m)m(Category.Core.left_identity____)(Category.Core.left_identity____)_).simpl.refineleft_identity_helper.-exact(p_left_identity_of_coherent_for_rewrite____).-exact(p_left_identity_of_coherent_inverse_for_rewrite____).Defined.To generate the type of this helper lemma, we used:Lemma right_identity (s d : object) (m : morphism s d)
      : compose m (identity _) = m.
      Proof.
        refine (@path_morphism' _ _
                               (compose m (identity _)) m
                               (Category.Core.right_identity _ _ _ _)
                               (Category.Core.right_identity _ _ _ _)
                               _).
        simpl in *.
        repeat match goal with
                 | [ |- context[@morphism_inverse
                                     _ _ _ _
                                     (@isisomorphism_isomorphic
                                        _ _ _
                                        (Category.Morphisms.idtoiso
                                           ?C0
                                           (ap (p_morphism_of ?F (s:=_) (d:=_))
                                               (Category.Core.right_identity ?C ?x ?y ?f))))] ]
                   => generalize (@p_right_identity_of_coherent_inverse_for_rewrite _ C F x y f);
                     generalize (Category.Morphisms.idtoiso
                                   C0
                                   (ap (p_morphism_of F (s:=_) (d:=_))
                                       (Category.Core.right_identity C x y f)))
                 | [ |- context[Category.Morphisms.idtoiso
                                     ?C0
                                     (ap (p_morphism_of ?F (s:=_) (d:=_))
                                         (Category.Core.right_identity ?C ?x ?y ?f))] ]
                   => generalize (@p_right_identity_of_coherent_for_rewrite _ C F x y f);
                     generalize (Category.Morphisms.idtoiso
                                   C0
                                   (ap (p_morphism_of F (s:=_) (d:=_))
                                       (Category.Core.right_identity C x y f)))
               end.
        simpl.
        destruct_head morphism.
        destruct_head object.
        simpl in *.
        repeat match goal with
                 | [ |- context[p_composition_of ?F ?x ?y ?z ?m1 ?m2] ]
                   => generalize dependent (p_composition_of F x y z m1 m2)
                 | [ |- context[p_identity_of ?F ?x] ]
                   => generalize dependent (p_identity_of F x)
                 | [ |- context[p_morphism_of ?F ?x] ]
                   => generalize dependent (p_morphism_of F x)
                 | [ |- context[p_object_of ?F ?x] ]
                   => generalize dependent (p_object_of F x)
               end.
        simpl.
        clear.
        repeat (let H := fresh "x" in intro H).
        repeat match goal with H : _ |- _ => revert H end.
        intro.Lemmaright_identity_helper{xx0:PreCategory} {x1:Functorx0x}{x2x3:PreCategory} {x4:Functorx3x2} {x5x6:Functorx3x0}{x7:Functorx2x} {x8:NaturalTransformation(x7ox4) (x1ox6)}{x9:Functorx2x} {x10:Functorx3x3} {x11:Functorx2x2}{x12: @Isomorphic(_->_)x111%functor} {x13: @Isomorphic(_->_)x101%functor}{x14: @Isomorphic(_->_)x9(x7ox11)%functor} {x15: @Isomorphic(_->_)x5(x6ox10)%functor}{x16: @Isomorphic(_->_)x5x6}{x17: (x16:Category.Core.morphism___) =(right_identity_natural_transformation_1x6o(x6oL(x13:Category.Core.morphism___)o(x15:Category.Core.morphism___)))%natural_transformation}{x18: @Isomorphic(_->_)x9x7}{x19:x18^-1 =(x14^-1o(x7oLx12^-1)oinverse(right_identity_natural_transformation_1x7))%natural_transformation}: (x1oL(x16:Category.Core.morphism___)o(x1oLx15^-1oassociator_1x1x6x10o(x8oRx10)oassociator_2x7x4x10o(x7oL(x4oLx13^-1oright_identity_natural_transformation_2x4oleft_identity_natural_transformation_1x4o((x12:Category.Core.morphism___)oRx4)))oassociator_1x7x11x4o((x14:Category.Core.morphism___)oRx4))o(x18^-1oRx4))%natural_transformation=x8.Proof.t.(* 3.26 s *)Qed.Lemmaright_identity(sd:object) (m:morphismsd):composem(identity_) =m.Proof.refine(@path_morphism'_ABST__(composem(identity_))m(Category.Core.right_identity____)(Category.Core.right_identity____)_).simpl.refineright_identity_helper.-exact(p_right_identity_of_coherent_for_rewrite____).-exact(p_right_identity_of_coherent_inverse_for_rewrite____).Defined.Endlax_comma_category_parts.EndLaxCommaCategory.

--- Miscellaneous\CoreParts.html ---
CorePartsLibrary CorePartsRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportFunctor.Composition.Core.RequireImportNaturalTransformation.PathsNaturalTransformation.Composition.Core.RequireImportCategory.MorphismsFunctorCategory.Core.RequireImportPseudofunctor.Core.RequireImportNaturalTransformation.Composition.Laws.RequireImportTruncTypes.Sigma.RequireImportBasics.Tactics.ImportFunctor.Identity.FunctorIdentityNotations.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.Local OpenScopecategory_scope.Local OpenScopetype_scope.Quoting David Spivak:David: ok
       so an object ofFC⇓Dis a pair(X,G), whereXis a
       finite category (or a small category or whatever you wanted)
       andG:X-->Dis a functor.
       a morphism inFC⇓Dis a ``natural transformation diagram''
       (as opposed to a commutative diagram, in which the natural
       transformation would be ``identity'')
       so a map inFC⇓Dfrom(X,G)to(X',G')is a pair(F,α)whereF:X-->X'is a functor andα:G-->G'∘Fis a natural transformation
       and the punchline is that there is a functorcolim:FC⇓D-->DDavid: consider for yourself the case whereF:X-->X'is
       identity (X=X') and (separately) the case whereα:G-->G∘Fis identity.
       the point is, you've already done the work to get this colim
       functor.
       because every map inFC⇓Dcan be written as a composition
       of two maps, one where theF-part is identity and one where
       theα-part is identity.
       and you've worked both of those cases out already.ModuleImportLaxCommaCategoryParts.Sectionlax_comma_category_parts.Context`{Funext}.VariablesAB:PreCategory.VariableS:PseudofunctorA.VariableT:PseudofunctorB.Context`{forallab,IsHSet(Functor(Sa) (Tb))}.Recordobject:={a:A;b:B;f:Functor(Sa) (Tb)}.Local Notationobject_sig_T:=({a:A| {b:B|Functor(Sa) (Tb) }}).Lemmaissig_object:object_sig_T<~>object.Proof.issig.Defined.Global Instancetrunc_object`{IsTruncnA,IsTruncnB}`{forallsd,IsTruncn(Functor(Ss) (Td))}:IsTruncnobject.Proof.eapplyistrunc_equiv_istrunc;[exactissig_object| ].typeclasseseauto.Qed.Lemmapath_object(xy:object):forall(Ha:x.(a) =y.(a))(Hb:x.(b) =y.(b)),matchHain_=X,Hbin_=YreturnFunctor(SX) (TY)with|idpath,idpath=>x.(f)end=y.(f)->x=y.Proof.destructx,y;simpl.intros;path_induction;reflexivity.Defined.Definitionpath_object_uncurriedxy(H: {HaHb: (x.(a) =y.(a)) * (x.(b) =y.(b))|matchfstHaHbin_=X,sndHaHbin_=YreturnFunctor(SX) (TY)with|idpath,idpath=>x.(f)end=y.(f) }):x=y:= @path_objectxy(fstH.1) (sndH.1)H.2.Lemmaap_a_path_objectxyHaHbHf:ap(@a) (@path_objectxyHaHbHf) =Ha.Proof.destructx,y;simplin*.destructHa,Hb,Hf;simplin*.reflexivity.Qed.Lemmaap_b_path_objectxyHaHbHf:ap(@b) (@path_objectxyHaHbHf) =Hb.Proof.destructx,y;simplin*.destructHa,Hb,Hf;simplin*.reflexivity.Qed.Global Opaquepath_object.Recordmorphism(abfa'b'f':object) :={g:Category.Core.morphismA(abf.(a)) (a'b'f'.(a));h:Category.Core.morphismB(abf.(b)) (a'b'f'.(b));p:NaturalTransformation(p_morphism_ofThoabf.(f))(a'b'f'.(f)op_morphism_ofSg)}.Local Notationmorphism_sig_Tabfa'b'f':=({g:Category.Core.morphismA(abf.(a)) (a'b'f'.(a))| {h:Category.Core.morphismB(abf.(b)) (a'b'f'.(b))|NaturalTransformation(p_morphism_ofThoabf.(f))(a'b'f'.(f)op_morphism_ofSg) }}).Lemmaissig_morphismabfa'b'f': (morphism_sig_Tabfa'b'f')<~>morphismabfa'b'f'.Proof.issig.Defined.Global Instancetrunc_morphismabfa'b'f'`{IsTruncn(Category.Core.morphismA(abf.(a)) (a'b'f'.(a)))}`{IsTruncn(Category.Core.morphismB(abf.(b)) (a'b'f'.(b)))}`{forallm1m2,IsTruncn(NaturalTransformation(p_morphism_ofTm2oabf.(f))(a'b'f'.(f)op_morphism_ofSm1))}:IsTruncn(morphismabfa'b'f').Proof.eapplyistrunc_equiv_istrunc;[exact(issig_morphism__) | ].typeclasseseauto.Qed.Lemmapath_morphismabfa'b'f'(ghg'h':morphismabfa'b'f'):forall(Hg:gh.(g) =g'h'.(g))(Hh:gh.(h) =g'h'.(h)),matchHgin_=g,Hhin_=hreturnNaturalTransformation(p_morphism_ofThoabf.(f))(a'b'f'.(f)op_morphism_ofSg)with|idpath,idpath=>gh.(p)end=g'h'.(p)->gh=g'h'.Proof.introsHgHhHp.destructgh,g'h';simplin*.destructHg,Hh,Hp.reflexivity.Qed.Definitionpath_morphism_uncurriedabfa'b'f'ghg'h'(H: {HgHh: (gh.(g) =g'h'.(g)) * (gh.(h) =g'h'.(h))|matchfstHgHhin_=g,sndHgHhin_=hreturnNaturalTransformation(p_morphism_ofThoabf.(f))(a'b'f'.(f)op_morphism_ofSg)with|idpath,idpath=>gh.(p)end=g'h'.(p) }):gh=g'h':= @path_morphismabfa'b'f'ghg'h'(fstH.1) (sndH.1)H.2.Lemmapath_morphism'_helperabfa'b'f'(ghg'h':morphismabfa'b'f'):forall(Hg:gh.(g) =g'h'.(g))(Hh:gh.(h) =g'h'.(h)),((_oL(Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__S__)Hg) :Category.Core.morphism___))o(gh.(p))o((Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__T__)Hh) :Category.Core.morphism___)^-1oR_)=g'h'.(p))%natural_transformation->matchHgin_=g,Hhin_=hreturnNaturalTransformation(p_morphism_ofThoabf.(f))(a'b'f'.(f)op_morphism_ofSg)with|idpath,idpath=>gh.(p)end=g'h'.(p).Proof.simpl;introsHgHhHp.destructg'h';simplin*.destructHg,Hh,Hp;simplin*.path_natural_transformation.autorewritewithfunctormorphism.reflexivity.Qed.Definitionpath_morphism'abfa'b'f'(ghg'h':morphismabfa'b'f')(Hg:gh.(g) =g'h'.(g))(Hh:gh.(h) =g'h'.(h))(Hp: ((_oL(Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__S__)Hg) :Category.Core.morphism___))o(gh.(p))o((Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__T__)Hh) :Category.Core.morphism___)^-1oR_)=g'h'.(p))%natural_transformation):gh=g'h':= @path_morphismabfa'b'f'ghg'h'HgHh(@path_morphism'_helperabfa'b'f'ghg'h'HgHhHp).Definitionpath_morphism'_uncurriedabfa'b'f'ghg'h'(H: {HgHh: (gh.(g) =g'h'.(g)) * (gh.(h) =g'h'.(h))| ((_oL(Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__S__) (fstHgHh)) :Category.Core.morphism___))o(gh.(p))o((Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__T__) (sndHgHh)) :Category.Core.morphism___)^-1oR_)=g'h'.(p))%natural_transformation}):gh=g'h':= @path_morphism'abfa'b'f'ghg'h'(fstH.1) (sndH.1)H.2.Definitioncomposesdd'(gh:morphismdd') (g'h':morphismsd):morphismsd'.Proof.exists(gh.(g)og'h'.(g)) (gh.(h)og'h'.(h)).exact((_oL(p_composition_ofS_____)^-1)o(associator_1___)o(gh.(p)oR_)o(associator_2___)o(_oLg'h'.(p))o(associator_1___)o((p_composition_ofT_____:Category.Core.morphism___)oR_))%natural_transformation.Defined.Global Argumentscompose_____/ .Definitionidentityx:morphismxx.Proof.exists(identity(x.(a))) (identity(x.(b))).exact((_oL(p_identity_ofS_:Category.Core.morphism___)^-1)o(right_identity_natural_transformation_2_)o(left_identity_natural_transformation_1_)o((p_identity_ofT_:Category.Core.morphism___)oR_))%natural_transformation.Defined.Global Argumentsidentity_/ .Endlax_comma_category_parts.EndLaxCommaCategoryParts.

--- Miscellaneous\Cover.html ---
CoverLibrary CoverRequireImportBasicsTypesHFiberTruncations.CoreTruncations.SeparatedTruncPointedModalities.ReflectiveSubuniverse.Local OpenScopepointed_scope.O-connected coversGiven a reflective subuniverseO, for any typeXandx:OX, theO-connected cover ofXatxis the fibre oftoOXatx.DefinitionO_cover@{u} `{O:ReflectiveSubuniverse@{u}}(X:Type@{u}) (x:OX) :Type@{u}:=hfiber(toO_)x.The "O-connected" cover is in factO-connected whenOis a modality, usingisconnected_hfiber_conn_map. Since Coq can infer this using typeclasses, we don't restate it here.Characterization of paths inO_coveris given byequiv_path_hfiber.(* Ifxis an actual point ofX, then the connected cover is pointed. *)DefinitionO_pcover@{u} (O:ReflectiveSubuniverse@{u})(X:Type@{u}) (x:X) :pType@{u}:=pfiber@{uuu} (ptoO[X,x]).Covers commute with productsDefinitionO_pcover_prod`{O:ReflectiveSubuniverse} {XY:pType@{u}}:O_pcoverO(X*Y)pt<~>* [(O_pcoverOXpt) * (O_pcoverOYpt),_].Proof.srapplyBuild_pEquiv'.{refine(_oEequiv_functor_sigma_id_).2:intro;nrapplyequiv_path_O_prod.nrapplyequiv_sigma_prod_prod. }nrapplypath_prod;cbn.all:snrapplypath_sigma'.1,3:exactidpath.all:cbn.all:byrewriteconcat_p1,concat_Vp.Defined.Functoriality ofO_coverGivenXandx:OX, any mapf:X->Yout ofXinduces a mapO_coverXx->O_coverY(O_functorOfx).Definitionfunctor_O_cover@{uv} `{O:ReflectiveSubuniverse} {XY:Type@{u}}(f:X->Y) (x:OX) :O_cover@{u}Xx->O_cover@{u}Y(O_functorOfx):=functor_hfiber(f:=toO_) (g:=toO_)(h:=f) (k:=O_functorOf) (to_O_naturalOf)x.Definitionequiv_functor_O_cover`{O:ReflectiveSubuniverse}{XY:Type} (f:X->Y) `{IsEquiv__f} (x:OX):O_coverXx<~>O_coverY(O_functorOfx):=Build_Equiv__(functor_O_coverfx)_.Pointed functorialityDefinitionpfunctor_O_pcover`{O:ReflectiveSubuniverse} {XY:pType}(f:X->*Y) :O_pcoverOXpt->*O_pcoverOYpt:=functor_pfiber(pto_O_naturalOf).Definitionpequiv_pfunctor_O_pcover`{O:ReflectiveSubuniverse} {XY:pType}(f:X->*Y) `{IsEquiv__f} :O_pcoverOXpt<~>*O_pcoverOYpt:=Build_pEquiv__(pfunctor_O_pcoverf)_.In the case of truncations,ptr_naturalgives a better proof of pointedness.Definitionpfunctor_pTr_pcover`{n:trunc_index} {XY:pType}(f:X->*Y) :O_pcover(Trn)Xpt->*O_pcover(Trn)Ypt:=functor_pfiber(ptr_naturalnf).Definitionpequiv_pfunctor_pTr_pcover`{n:trunc_index}{XY:pType} (f:X->*Y) `{IsEquiv__f}:O_pcover(Trn)Xpt<~>*O_pcover(Trn)Ypt:=Build_pEquiv__(pfunctor_pTr_pcoverf)_.ComponentsPath components are given by specializing toObeing set-truncation.Definitioncomp:=O_cover(O:=Tr0).Definitionpcomp:=O_pcover(Tr0).Definitionpfunctor_pcomp{XY:pType} := @pfunctor_pTr_pcover(-1)XY.Definitionpequiv_pfunctor_pcomp{XY:pType}:= @pequiv_pfunctor_pTr_pcover(-1)XY.If a property holds at a given point, then it holds for the whole component. This yields equivalences like the following:Definitionequiv_comp_property`{Univalence} {X:Type} (x:X)(P:X->Type) `{forallx,IsHProp(Px)} (Px:Px):comp(sigP) (tr(x;Px)) <~>compX(trx).Proof.unfoldcomp,O_cover,hfiber.simpl.refine(_oE(equiv_sigma_assoc__)^-1).applyequiv_functor_sigma_id;introy.applyequiv_iff_hprop.-intros[pyq].exact(ap(Trunc_functor_pr1)q).-refine(equiv_ind(equiv_path_Tr__)__).applyTrunc_rec;introsp;inductionp.exact(Px;idpath).Defined.For example, we may take components of equivalences among underlying maps.Definitionequiv_comp_equiv_map`{Univalence} {AB:Type} (e:A<~>B):comp(A<~>B) (tre) <~>comp(A->B) (tr(equiv_fune)).Proof.refine(_oEequiv_functor_O_cover(issig_equiv__)^-1_);cbn.rapplyequiv_comp_property.Defined.

--- Miscellaneous\CRing.html ---
CRingLibrary CRingRequireImportWildCat.(* Some of the material in abstract_algebra and canonical names could be selectively exported to the user, as is done in Groups/Group.v. *)RequireImportClasses.interfaces.abstract_algebra.RequireImportAlgebra.AbGroups.RequireExportAlgebra.Rings.RingAlgebra.Rings.IdealAlgebra.Rings.QuotientRing.Commutative RingsLocal OpenScopering_scope.Local OpenScopewc_iso_scope.A commutative ring consists of the following data:RecordCRing:= {An underlying ring.cring_ring:>Ring;Such that they satisfy the axioms of a commutative ring.cring_commutative::Commutative(A:=cring_ring) (.*.);}.Definitionissig_CRing:_<~>CRing:=ltac:(issig).Global Instancecring_plus{R:CRing} :PlusR:=plus_abgroupR.Global Instancecring_zero{R:CRing} :ZeroR:=zero_abgroupR.Global Instancecring_negate{R:CRing} :NegateR:=negate_abgroupR.DefinitionBuild_CRing'(R:AbGroup) `(!OneR, !MultR)(comm:Commutative(.*.)) (assoc:Associative(.*.))(dist_l:LeftDistribute(.*.) (+)) (unit_l:LeftIdentity(.*.) 1):CRing.Proof.snrapplyBuild_CRing.-rapply(Build_RingR);only1,2,4:exact_.+introsxyz.lhsnrapplycomm.lhsrapplydist_l.f_ap.+introsx.lhsrapplycomm.applyunit_l.-exact_.Defined.Properties of commutative ringsDefinitionrng_mult_comm{R:CRing} (xy:R) :x*y=y*x:=commutativityxy.Powers commute with multiplicationLemmarng_power_mult{R:CRing} (xy:R) (n:nat):rng_power(R:=R) (x*y)n=rng_power(R:=R)xn*rng_power(R:=R)yn.Proof.inductionn.1:symmetry;rapplyrng_mult_one_l.simpl.rewrite(rng_mult_assoc(A:=R)).rewrite<- (rng_mult_assoc(A:=R)x_y).rewrite(rng_mult_comm(rng_power(R:=R)xn)y).rewriterng_mult_assoc.rewrite<- (rng_mult_assoc_(rng_power(R:=R)xn)).f_ap.Defined.Definitionrng_mult_permute_2_3{R:CRing} (xyz:R):x*y*z=x*z*y.Proof.lhs_Vnrapplyrng_mult_assoc.rhs_Vnrapplyrng_mult_assoc.applyap,rng_mult_comm.Defined.Definitionrng_mult_move_left_assoc{R:CRing} (xyz:R):x*y*z=y*x*z.Proof.f_ap;applyrng_mult_comm.Defined.Definitionrng_mult_move_right_assoc{R:CRing} (xyz:R):x* (y*z) =y* (x*z).Proof.refine(rng_mult_assoc___@_@ (rng_mult_assoc___)^).applyrng_mult_move_left_assoc.Defined.Definitionisinvertible_cring(R:CRing) (x:R)(inv:R) (inv_l:inv*x= 1):IsInvertibleRx.Proof.snrapplyBuild_IsInvertible.-exactinv.-exactinv_l.-lhsnrapplyrng_mult_comm.exactinv_l.Defined.Ideals in commutative ringsSectionIdealCRing.Context{R:CRing}.The section is meant to complement the IdealLemmas section in Algebra.Rings.Ideal. Since the results here only hold in commutative rings, they have to be kept here.We import ideal notations as used in Algebra.Rings.Ideal but only for this section. Important to note is that↔corresponds to equality of ideals.ImportIdeal.Notation.Local OpenScopeideal_scope.In a commutative ring, the product of two ideals is a subset of the reversed product.Lemmaideal_product_subset_product_commutative(IJ:IdealR):I⋅J⊆J⋅I.Proof.introsrp.strip_truncations.inductionpas[rp| |].2:applyideal_in_zero.2:byapplyideal_in_plus_negate.destructpas[stpq].rewriterng_mult_comm.applytr.applysgt_in.byrapplyipn_in.Defined.Ideal products are commutative in commutative rings. Note that we are using ideal notations here and↔corresponds to equality of ideals. Essentially a subset in each direction.Lemmaideal_product_comm(IJ:IdealR) :I⋅J↔J⋅I.Proof.applyideal_subset_antisymm;applyideal_product_subset_product_commutative.Defined.Product of intersection and sum is a subset of product. Note that this is a generalization of lcm * gcd = productLemmaideal_product_intersection_sum_subset'(IJ:IdealR): (I∩J) ⋅ (I+J) ⊆I⋅J.Proof.etransitivity.2:rapplyideal_sum_self.etransitivity.2:rapplyideal_sum_subset_pres_r.2:rapplyideal_product_comm.applyideal_product_intersection_sum_subset.Defined.If the sum of ideals is the whole ring then their intersection is a subset of their product.Lemmaideal_intersection_subset_product(IJ:IdealR):ideal_unitR⊆ (I+J) ->I∩J⊆I⋅J.Proof.introsp.etransitivity.{applyideal_eq_subset.symmetry.applyideal_product_unit_r. }etransitivity.1:rapply(ideal_product_subset_pres_r___p).rapplyideal_product_intersection_sum_subset'.Defined.This can be combined into a sufficient (but not necessary) condition for equality of intersections and products.Lemmaideal_intersection_is_product(IJ:IdealR):CoprimeIJ->I∩J↔I⋅J.Proof.introsp.applyideal_subset_antisymm.-applyideal_intersection_subset_product.unfoldCoprimeinp.applysymmetryinp.rapplyp.-applyideal_product_subset_intersection.Defined.Lemmaideal_quotient_product(IJK:IdealR): (I::J) ::K↔ (I:: (J⋅K)).Proof.applyideal_subset_antisymm.-introsx[pq];strip_truncations;split;applytr;introsr;rapplyTrunc_rec;introsjk.+inductionjkas[y[zz'jk] | | ? ? ? ? ? ? ].*rewrite(rng_mult_commzz').rewriterng_mult_assoc.destruct(pz'k)as[p'?].revertp';applyTrunc_rec;introsp'.exact(p'zj).*change(I(x* 0)).rewriterng_mult_zero_r.applyideal_in_zero.*change(I(x* (g-h))).rewriterng_dist_l.rewriterng_mult_negate_r.byapplyideal_in_plus_negate.+inductionjkas[y[zz'jk] | | ? ? ? ? ? ? ].*change(I(z*z'*x)).rewrite<-rng_mult_assoc.rewrite(rng_mult_commz).destruct(qz'k)as[q'?].revertq';applyTrunc_rec;introsq'.exact(q'zj).*change(I(0 *x)).rewriterng_mult_zero_l.applyideal_in_zero.*change(I((g-h) *x)).rewriterng_dist_r.rewriterng_mult_negate_l.byapplyideal_in_plus_negate.-introsx[pq];strip_truncations;split;applytr;introsrk;split;applytr;introszj.+rewrite<-rng_mult_assoc.rewrite(rng_mult_commrz).byapplyp,tr,sgt_in,ipn_in.+cbninz.change(I(z* (x*r))).rewrite(rng_mult_commx).rewriterng_mult_assoc.byapplyq,tr,sgt_in,ipn_in.+cbninr.change(I(r*x*z)).rewrite<-rng_mult_assoc.rewrite(rng_mult_commr).rewrite<-rng_mult_assoc.byapplyp,tr,sgt_in,ipn_in.+cbninr,z.change(I(z* (r*x))).rewriterng_mult_assoc.rewriterng_mult_comm.byapplyp,tr,sgt_in,ipn_in.Defined.The ideal quotient is a right adjoint to the product in the monoidal lattice of ideals.Lemmaideal_quotient_subset_prod(IJK:IdealR):I⋅J⊆K<->I⊆ (K::J).Proof.split.-introspri;split;applytr;introssj;cbnins,r.+byapplyp,tr,sgt_in,ipn_in.+change(K(s*r)).rewrite(rng_mult_commsr).byapplyp,tr,sgt_in;rapplyipn_in.-introspx.applyTrunc_rec.introsq.inductionqas[rx| | ].{destructx.specialize(pxs);destructpas[pq].revertp;applyTrunc_rec;introsp.byapplyp. }1:applyideal_in_zero.byapplyideal_in_plus_negate.Defined.Ideal quotients partially cancelLemmaideal_quotient_product_left(IJ:IdealR): (I::J) ⋅J⊆I.Proof.byapplyideal_quotient_subset_prod.Defined.EndIdealCRing.Category of commutative rings.Global Instanceisgraph_CRing:IsGraphCRing:=isgraph_inducedcring_ring.Global Instanceis01cat_CRing:Is01CatCRing:=is01cat_inducedcring_ring.Global Instanceis2graph_CRing:Is2GraphCRing:=is2graph_inducedcring_ring.Global Instanceis1cat_CRing:Is1CatCRing:=is1cat_inducedcring_ring.Global Instancehasequiv_CRing:HasEquivsCRing:=hasequivs_inducedcring_ring.Quotient ringsGlobal Instancecommutative_quotientring_mult(R:CRing) (I:IdealR):Commutative(A:=QuotientRingRI) (.*.).Proof.introsx;srapplyQuotientRing_ind_hprop;introsy;revertx.srapplyQuotientRing_ind_hprop;introsx;hnf.lhs_Vnrapplyrng_homo_mult.rhs_Vnrapplyrng_homo_mult.snrapplyap.applycommutativity.Defined.Definitioncring_quotient(R:CRing) (I:IdealR) :CRing:=Build_CRing(QuotientRingRI)_.Definitioncring_quotient_map{R:CRing} (I:IdealR):R$->cring_quotientRI:=rng_quotient_mapI.

--- Miscellaneous\Cyclic.html ---
CyclicLibrary CyclicRequireImportBasics.OvertureBasics.TacticsWildCat.CoreAbelianGroupAbGroups.ZSpaces.IntGroups.QuotientGroup.Cyclic groupsThen-th cyclic group is the cokernel ofab_muln.Definitioncyclic(n:nat) :AbGroup:=ab_cokernel(ab_mul(A:=abgroup_Z)n).Definitioncyclic_in(n:nat) :abgroup_Z$->cyclicn:=grp_quotient_map.Definitionab_mul_cyclic_in(n:nat) (xy:abgroup_Z):ab_muly(cyclic_innx) =cyclic_inn(y*x)%int.Proof.lhs_Vnrapplyab_mul_natural.applyap,abgroup_Z_ab_mul.Defined.

--- Miscellaneous\DDiagram.html ---
DDiagramLibrary DDiagramRequireImportBasics.RequireImportDiagrams.Graph.RequireImportDiagrams.Diagram.We define here the Graph ∫D, also denoted G·DDefinitionintegral{G:Graph} (D:DiagramG) :Graph.Proof.srapplyBuild_Graph.+exact{i:G&Di}.+introsij.exact{g:Gi.1j.1 &D_fgi.2 =j.2}.Defined.Then, a dependent diagram E over D is just a diagram over ∫D.DefinitionDDiagram{G:Graph} (D:DiagramG):=Diagram(integralD).Given a dependent diagram, we c.an recover a diagram over G by considering the Σ types.Definitiondiagram_sigma{G:Graph} {D:DiagramG} (E:DDiagramD):DiagramG.Proof.srapplyBuild_Diagram.-introi.exact{x:Di&E(i;x)}.-introsijgx.simplin*.exists(D_fgx.1).exact(@arr_E(i;x.1) (j;D_fgx.1) (g;idpath)x.2).Defined.A dependent diagram is said equifibered if all its fibers are equivalences.ClassEquifibered{G:Graph} {D:DiagramG} (E:DDiagramD) := {isequifiberedij(g:Gij) (x:Di):IsEquiv(@arr_E(i;x) (j;D_fgx) (g;idpath));}.#[export]ExistingInstanceisequifibered.

--- Miscellaneous\Decidable.html ---
DecidableLibrary DecidableRequireImportBasics.OvertureBasics.PathGroupoidsBasics.TruncBasics.TacticsBasics.Iff.Local OpenScopetrunc_scope.Local OpenScopepath_scope.DecidabilityDefinitions(* NB: This has to come after our definition ofnot(which is inOverture), so that it refers to ournotrather than the one inCoq.Logic. *)ClassDecidable(A:Type) :=dec:A+ (~A).ArgumentsdecA{_}.Thedecide_typeanddecidetactic allow to automatically prove
decidable claims using previously written decision procedures that
compute.Ltacdecide_typeA:=letK:= (evalhnfin(decA))inmatchKwith|inl?Z=>exactZ|inr?Z=>exactZend.Ltacdecide:=multimatchgoalwith| [|- ?A] =>decide_typeA| [|- ~ ?A] =>decide_typeAend.Definitiondecidable_true{A:Type}(a:A)(P:forall(p:DecidableA),Type)(p:forallx,P(inlx)):forallp,Pp.Proof.intros[x|n].-applyp.-contradictionn.Defined.Replace a termpof the formDecidableAwithinlxif we have a terma:Ashowing thatAis true.Ltacdecidable_truepa:=generalizep;rapply(decidable_truea);tryintro.Definitiondecidable_false{A:Type}(n:notA)(P:forall(p:DecidableA),Type)(p:foralln',P(inrn')):forallp,Pp.Proof.intros[x|n'].-contradictionn.-applyp.Defined.Replace a termpof the formDecidableAwithinrnaif we have a termn:notAshowing thatAis false.Ltacdecidable_falsepn:=generalizep;rapply(decidable_falsen);tryintro.ClassDecidablePaths(A:Type) :=dec_paths:forall(xy:A),Decidable(x=y).Global Existing Instancedec_paths.ClassStableP:=stable: ~~P->P.Global Instancestable_decidableP`{!DecidableP} :StableP.Proof.introsdn;destruct(decP)as[p|n].-assumption.-applyEmpty_rect,dn,n.Qed.Global Instancestable_negationP:Stable(~P).Proof.introsnnnpp.exact(nnnp(funnp=>npp)).Defined.Definitioniff_stableP`(StableP) : ~~P<->P.Proof.split.-applystable.-exact(funxf=>fx).Defined.Becausevm_computeevaluates terms inPROPeagerly
  and does not remove dead code we
  need the decide_rel hack. Suppose we have(x=y)=def(fx=fy), now:
     bool_decide (x = y) -> bool_decide (f x = f y) -> ...
  As we see, the dead codefxandfyis actually evaluated,
  which is of course an utter waste.
  Therefore we introduce decide_rel and bool_decide_rel.
     bool_decide_rel (=) x y -> bool_decide_rel (fun a b => f a = f b) x y -> ...
  Now the definition of equality remains under a lambda and
  our problem does not occur anymore!Definitiondecide_rel{AB} (R:A->B->Type){dec:forallxy,Decidable(Rxy)} (x:A) (y:B):Decidable(Rxy):=decxy.Decidable hpropsContractible types are decidable.Global Instancedecidable_contrX`{ContrX} :DecidableX:=inl(centerX).Thus, hprops have decidable equality.Global Instancedecidablepaths_hpropX`{IsHPropX} :DecidablePathsX:=funxy=>dec(x=y).Empty types are trivial.Global Instancedecidable_empty:DecidableEmpty:=inridmap.Transfer along equivalencesDefinitiondecidable_iff{AB} (f:A<->B):DecidableA->DecidableB.Proof.intros[a|na].-exact(inl(fstfa)).-exact(inr(funb=>na(sndfb))).Defined.Definitiondecidable_equiv'(A:Type) {B:Type} (f:A<~>B):DecidableA->DecidableB:=decidable_ifff.Definitiondecidable_equiv(A:Type) {B:Type} (f:A->B) `{!IsEquivf}:DecidableA->DecidableB:=decidable_equiv'_(Build_Equiv__f_).Definitiondecidablepaths_equiv(A:Type) {B:Type} (f:A->B) `{IsEquivABf}:DecidablePathsA->DecidablePathsB.Proof.introsdxy.destruct(d(f^-1x) (f^-1y))as[e|ne].-applyinl.exact((eisretrfx)^ @apfe@eisretrfy).-applyinr;introsp.applyne,ap,p.Defined.Definitiondecidablepaths_equiv'(A:Type) {B:Type} (f:A<~>B):DecidablePathsA->DecidablePathsB:=decidablepaths_equivAf.Hedberg's theorem: any type with decidable equality is a set.A weakly constant function is one all of whose values are equal (in a specified way).ClassWeaklyConstant{AB} (f:A->B) :=wconst:forallxy,fx=fy.Any map that factors through an hprop is weakly constant.Definitionwconst_through_hprop{ABP} `{IsHPropP}(f:A->P) (g:P->B):WeaklyConstant(gof).Proof.introsxy;apply(apg),path_ishprop.Defined.A type is collapsible if it admits a weakly constant endomap.ClassCollapsible(A:Type) :={collapse:A->A;wconst_collapse:WeaklyConstantcollapse}.Global Existing Instancewconst_collapse.ClassPathCollapsible(A:Type) :=path_coll:forall(xy:A),Collapsible(x=y).Global Existing Instancepath_coll.Global Instancecollapsible_decidable(A:Type) `{DecidableA}:CollapsibleA.Proof.destruct(decA)as[a|na].-exists(consta).introsxy;reflexivity.-existsidmap.introsxy;destruct(nax).Defined.Global Instancepathcoll_decpaths(A:Type) `{DecidablePathsA}:PathCollapsibleA.Proof.introsxy;exact_.Defined.We give this a relatively high-numbered priority so that in deducingIsHProp->IsHSetCoq doesn't detour viaDecidablePaths.Global Instancehset_pathcoll(A:Type) `{PathCollapsibleA}:IsHSetA| 1000.Proof.applyistrunc_S.introsxy.assert(h:forallp:x=y,p= (collapse(idpathx))^ @collapsep).{intros[];symmetry;byapplyconcat_Vp. }applyhprop_allpath;introspq.refine(hp@_@ (hq)^).applywhiskerL.applywconst.Defined.Definitioncollapsible_hprop(A:Type) `{IsHPropA}:CollapsibleA.Proof.existsidmap.introsxy;applypath_ishprop.Defined.Definitionpathcoll_hset(A:Type) `{IsHSetA}:PathCollapsibleA.Proof.introsxy;applycollapsible_hprop;exact_.Defined.Hedberg's TheoremCorollaryhset_decpaths(A:Type) `{DecidablePathsA}:IsHSetA.Proof.exact_.Defined.We can use Hedberg's Theorem to simplify a goal of the formforall(d:Decidable(x=x:>A)),PdwhenAhas decidable paths.Definitiondecidable_paths_refl(A:Type) `{DecidablePathsA}(x:A)(P:forall(d:Decidable(x=x)),Type)(Px:P(inlidpath)):foralld,Pd.Proof.rapply(decidable_trueidpath).introp.We cannot eliminatep:x=xwith path induction, but we can use Hedberg's theorem to replace this withidpath.assert(r: (idpath=p))byapplypath_ishprop.bydestructr.Defined.TruncationHaving decidable equality (which implies being an hset, by Hedberg's theorem above) is itself an hprop.Global Instanceishprop_decpaths`{Funext} (A:Type):IsHProp(DecidablePathsA).Proof.applyhprop_inhabited_contr;introsd.assert(IsHSetA)byexact_.apply(Build_Contr_d).introsd'.funextxy.generalize(dxy);cleard;introsd.generalize(d'xy);cleard';introsd'.destructdas[d|nd];destructd'as[d'|nd'].-applyap,path_ishprop.-elim(nd'd).-elim(ndd').-applyap,path_forall;introsp;elim(ndp).Defined.Logical LawsVarious logical laws don't hold constructively as they do classically due to a required use of excluded middle. For us, this means that some laws require further assumptions on the decidability of propositions.Here we give the dual De Morgan's Law which complements the one given in Iff.v.  One direction requires that one of the two propositions be decidable, while the other direction needs no assumption.  We state the latter property first, to avoid duplication in the proof.Definitionnot_prod_sum_notAB: ~A+ ~B-> ~ (A*B).Proof.intros[na|nb] [ab].-exact(naa).-exact(nbb).Defined.Definitioniff_not_prodAB`{DecidableA}: ~ (A*B) <-> ~A+ ~B.Proof.split.-introsnp.destruct(decA)as[a|na].+exact(inr(funb=>np(a,b))).+exact(inlna).-applynot_prod_sum_not.Defined.Definitioniff_not_prod'AB`{DecidableB}: ~ (A*B) <-> ~A+ ~B.Proof.split.-introsnp.destruct(decB)as[b|nb].+exact(inl(funa=>np(a,b))).+exact(inrnb).-applynot_prod_sum_not.Defined.

--- Miscellaneous\Decimal.html ---
DecimalLibrary Decimal(************************************************************************)(*         *   The Coq Proof Assistant / The Coq Development Team       *)(*  v      *         Copyright INRIA, CNRS and contributors             *)(* <O___,, * (see version control and CREDITS file for authors & dates) *)(*   \VV/  **************************************************************)(*    //   *    This file is distributed under the terms of the         *)(*         *     GNU Lesser General Public License Version 2.1          *)(*         *     (see LICENSE file for the text of the license)         *)(************************************************************************)(************************************************************************)(* This file has been modified for use in the HoTT library              *)(************************************************************************)RequireImportBasics.Overture.Decimal numbersThese numbers coded in base 10 will be used for parsing and printing
    other Coq numeral datatypes in an human-readable way.
    See theNumeralNotationcommand.
    We represent numbers in base 10 as lists of decimal digits,
    in big-endian order (most significant digit comes first).Unsigned integers are just lists of digits.
    For instance, ten is (D1 (D0 Nil))Inductiveuint:Type0:=|Nil|D0(_:uint)|D1(_:uint)|D2(_:uint)|D3(_:uint)|D4(_:uint)|D5(_:uint)|D6(_:uint)|D7(_:uint)|D8(_:uint)|D9(_:uint).Nilis the number terminator. Taken alone, it behaves as zero,
    but rather useD0Nilinstead, since this form will be denoted
    as0, whileNilwill be printed asNil.Notationzero:= (D0Nil).For signed integers, we use two constructorsPosandNeg.Variantint:Type0:=Pos(d:uint) |Neg(d:uint).For decimal numbers, we use two constructorsDecimalandDecimalExp, depending on whether or not they are given with an
    exponent (e.g., 1.02e+01).iis the integral part whilefis
    the fractional part (beware that leading zeroes do matter).Variantdecimal:Type0:=|Decimal(i:int) (f:uint)|DecimalExp(i:int) (f:uint) (e:int).Declare Scopedec_uint_scope.DelimitScopedec_uint_scopewithuint.Bind Scopedec_uint_scopewithuint.Declare Scopedec_int_scope.DelimitScopedec_int_scopewithint.Bind Scopedec_int_scopewithint.Registeruintasnum.uint.type.Registerintasnum.int.type.Registerdecimalasnum.decimal.type.Fixpointnb_digitsd:=matchdwith|Nil=>O|D0d|D1d|D2d|D3d|D4d|D5d|D6d|D7d|D8d|D9d=>S(nb_digitsd)end.This representation favors simplicity over canonicity.
    For normalizing numbers, we need to remove head zero digits,
    and choose our canonical representation of 0 (hereD0Nilfor unsigned numbers andPos(D0Nil)for signed numbers).nzheadremoves all head zero digitsFixpointnzheadd:=matchdwith|D0d=>nzheadd|_=>dend.unorm: normalization of unsigned integersDefinitionunormd:=matchnzheaddwith|Nil=>zero|d=>dend.norm: normalization of signed integersDefinitionnormd:=matchdwith|Posd=>Pos(unormd)|Negd=>matchnzheaddwith|Nil=>Poszero|d=>Negdendend.A few easy operations. For more advanced computations, use the conversions
    with other Coq numeral datatypes (e.g. Z) and the operations on them.Definitionopp(d:int) :=matchdwith|Posd=>Negd|Negd=>Posdend.For conversions with binary numbers, it is easier to operate
    on little-endian numbers.Fixpointrevapp(dd':uint) :=matchdwith|Nil=>d'|D0d=>revappd(D0d')|D1d=>revappd(D1d')|D2d=>revappd(D2d')|D3d=>revappd(D3d')|D4d=>revappd(D4d')|D5d=>revappd(D5d')|D6d=>revappd(D6d')|D7d=>revappd(D7d')|D8d=>revappd(D8d')|D9d=>revappd(D9d')end.Definitionrevd:=revappdNil.Definitionappdd':=revapp(revd)d'.Definitionapp_intd1d2:=matchd1withPosd1=>Pos(appd1d2) |Negd1=>Neg(appd1d2)end.nztailremoves all trailing zero digits and return both the
    result and the number of removed digits.Definitionnztaild:=letfixauxd_rev:=matchd_revwith|D0d_rev=>let(r,n) :=auxd_revinpairr(Sn)|_=>paird_revOendinlet(r,n) :=aux(revd)inpair(revr)n.Definitionnztail_intd:=matchdwith|Posd=>let(r,n) :=nztaildinpair(Posr)n|Negd=>let(r,n) :=nztaildinpair(Negr)nend.ModuleLittle.Successor of little-endian numbersFixpointsuccd:=matchdwith|Nil=>D1Nil|D0d=>D1d|D1d=>D2d|D2d=>D3d|D3d=>D4d|D4d=>D5d|D5d=>D6d|D6d=>D7d|D7d=>D8d|D8d=>D9d|D9d=>D0(succd)end.Doubling little-endian numbersFixpointdoubled:=matchdwith|Nil=>Nil|D0d=>D0(doubled)|D1d=>D2(doubled)|D2d=>D4(doubled)|D3d=>D6(doubled)|D4d=>D8(doubled)|D5d=>D0(succ_doubled)|D6d=>D2(succ_doubled)|D7d=>D4(succ_doubled)|D8d=>D6(succ_doubled)|D9d=>D8(succ_doubled)endwithsucc_doubled:=matchdwith|Nil=>D1Nil|D0d=>D1(doubled)|D1d=>D3(doubled)|D2d=>D5(doubled)|D3d=>D7(doubled)|D4d=>D9(doubled)|D5d=>D1(succ_doubled)|D6d=>D3(succ_doubled)|D7d=>D5(succ_doubled)|D8d=>D7(succ_doubled)|D9d=>D9(succ_doubled)end.EndLittle.Pseudo-conversion functions used when declaring
    Numeral Notations onuintandint.Definitionuint_of_uint(i:uint) :=i.Definitionint_of_int(i:int) :=i.

--- Miscellaneous\dec_fields.html ---
dec_fieldsLibrary dec_fieldsRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.theory.fieldsHoTT.Classes.theory.apartness.RequireExportHoTT.Classes.theory.rings.Generalizable VariablesFfR.Sectioncontents.Context`{IsDecFieldF} `{forallxy:F,Decidable(x=y)}.(* Add Ring F : (stdlib_ring_theory F). *)Global Instancedecfield_zero_product:ZeroProductF.Proof.introsxyE.destruct(dec(x= 0))as[? |Ex];auto.right.rewrite<-(mult_1_ry), <-(dec_recip_inversex)byassumption.rewriteassociativity, (commutativityy),E.applymult_0_l.Qed.Global Instancedecfield_integral_domain:IsIntegralDomainF.Proof.split;tryapply_.Qed.Lemmadec_recip_1: / 1 = 1.Proof.rewrite<-(rings.mult_1_l(/1)).applydec_recip_inverse.solve_propholds.Qed.Lemmadec_recip_distr(xy:F): / (x*y) = /x* /y.Proof.destruct(dec(x= 0))as[Ex|Ex].-rewriteEx,left_absorb,dec_recip_0.applysymmetry,mult_0_l.-destruct(dec(y= 0))as[Ey|Ey].+rewriteEy,dec_recip_0, !mult_0_r.applydec_recip_0.+assert(x*y<> 0)asExyby(applymult_ne_0;trivial).apply(left_cancellation_ne_0(.*.) (x*y));trivial.transitivity(x/x* (y/y)).*rewrite!dec_recip_inversebyassumption.rewritemult_1_l;applyreflexivity.*rewrite!dec_recip_inversebyassumption.rewritemult_assoc, (mult_commx), <-(mult_assocy).rewritedec_recip_inversebyassumption.rewrite(mult_commy), <-mult_assoc.rewritedec_recip_inversebyassumption.reflexivity.Qed.Lemmadec_recip_zerox: /x= 0 <->x= 0.Proof.split;introsE.-applystable.introsEx.destruct(is_ne_01).rewrite<-(dec_recip_inversex),Ebyassumption.applymult_0_r.-rewriteE.applydec_recip_0.Qed.Lemmadec_recip_ne_0_iffx: /x<> 0 <->x<> 0.Proof.split;introsE1E2;destructE1;applydec_recip_zero;trivial.do2apply(snd(dec_recip_zero_)).trivial.Qed.Instancedec_recip_ne_0x:PropHolds(x<> 0) ->PropHolds(/x<> 0).Proof.intro.apply(snd(dec_recip_ne_0_iff_)).trivial.Qed.Lemmaequal_by_one_quotient(xy:F) :x/y= 1 ->x=y.Proof.introExy.destruct(dec(y= 0))as[Ey|Ey].-destruct(is_ne_01).rewrite<-Exy,Ey,dec_recip_0.applymult_0_r.-apply(right_cancellation_ne_0(.*.) (/y)).+applydec_recip_ne_0.trivial.+rewritedec_recip_inverse;trivial.Qed.Global Instancedec_recip_inj:IsInjective(/).Proof.repeat(split;tryapply_).introsxyE.destruct(dec(y= 0))as[Ey|Ey].-rewriteEyin*.rewritedec_recip_0inE.applydec_recip_zero.trivial.-apply(right_cancellation_ne_0(.*.) (/y)).+applydec_recip_ne_0.trivial.+rewritedec_recip_inversebyassumption.rewrite<-E,dec_recip_inverse;trivial.applydec_recip_ne_0_iff.rewriteE.applydec_recip_ne_0.trivial.Qed.Global Instancedec_recip_involutive:Involutive(/).Proof.introsx.destruct(dec(x= 0))as[Ex|Ex].-rewriteEx, !dec_recip_0.trivial.-apply(right_cancellation_ne_0(.*.) (/x)).+applydec_recip_ne_0.trivial.+rewritedec_recip_inversebyassumption.rewritemult_comm,dec_recip_inverse.*reflexivity.*applydec_recip_ne_0.trivial.Qed.Lemmaequal_dec_quotients(abcd:F) :b<> 0 ->d<> 0 ->(a*d=c*b<->a/b=c/d).Proof.split;introE.-apply(right_cancellation_ne_0(.*.)b);trivial.apply(right_cancellation_ne_0(.*.)d);trivial.transitivity(a*d* (b* /b));[|transitivity(c*b* (d* /d))].+rewrite<-!(mult_assoca).applyap.rewrite(mult_commd), (mult_comm_b).reflexivity.+rewriteE,dec_recip_inverse,dec_recip_inverse;trivial.+rewrite<-!(mult_assocc).applyap.rewrite(mult_commd),mult_assoc, (mult_commb).reflexivity.-transitivity(a*d* 1);[rewritemult_1_r;reflexivity|].rewrite<-(dec_recip_inverseb);trivial.transitivity(c*b* 1);[|rewritemult_1_r;reflexivity].rewrite<-(dec_recip_inversed);trivial.rewritemult_comm, <-mult_assoc, (mult_assoc_a), (mult_comm_a),E.rewrite<-mult_assoc.rewrite(mult_comm_d).rewritemult_assoc, (mult_commc).reflexivity.Qed.Lemmadec_quotients(acbd:F):b<> 0 ->d<> 0 ->a/b+c/d= (a*d+c*b) / (b*d).Proof.introsAB.assert(a/b= (a*d) / (b*d))asE1.-applyequal_dec_quotients;auto.+solve_propholds.+rewrite(mult_commb);applyassociativity.-assert(c/d= (b*c) / (b*d))asE2.+applyequal_dec_quotients;trivial.*solve_propholds.*rewritemult_assoc, (mult_commc).reflexivity.+rewriteE1,E2.rewrite(mult_commcb).applysymmetry,simple_distribute_r.Qed.Lemmadec_recip_swap_lxy:x/y= / (/x*y).Proof.rewritedec_recip_distr,involutive.reflexivity.Qed.Lemmadec_recip_swap_rxy: /x*y= / (x/y).Proof.rewritedec_recip_distr,involutive.reflexivity.Qed.Lemmadec_recip_negatex: -(/x) = / (-x).Proof.destruct(dec(x= 0))as[Ex|Ex].-rewriteEx,negate_0,dec_recip_0,negate_0.reflexivity.-apply(left_cancellation_ne_0(.*.) (-x)).+apply(snd(flip_negate_ne_0_)).trivial.+rewritedec_recip_inverse.*rewritenegate_mult_negate.applydec_recip_inverse.trivial.*apply(snd(flip_negate_ne_0_)).trivial.Qed.Endcontents.(* Due to bug 2528 *)#[export]HintExtern7 (PropHolds(/_<> 0)) =>eapply@dec_recip_ne_0:typeclass_instances.(* Given a decidable field we can easily construct a constructive field. *)Sectionis_field.Context`{IsDecFieldF} `{ApartF} `{!TrivialApartF}`{Decidable.DecidablePathsF}.Global Instancerecip_dec_field:RecipF:=funx=> /x.1.Local Existing Instancedec_strong_setoid.Global Instancedecfield_field:IsFieldF.Proof.split;tryapply_.-apply(dec_strong_binary_morphism(+)).-apply(dec_strong_binary_morphism(.*.)).-intros[xPx].rapply(dec_recip_inversex).applytrivial_apart.trivial.Qed.Lemmadec_recip_correct(x:F)Px: /x= // (x;Px).Proof.apply(left_cancellation_ne_0(.*.)x).-applytrivial_apart.trivial.-rewritedec_recip_inverse,reciperse_altby(applytrivial_apart;trivial).reflexivity.Qed.Endis_field.(* Definition stdlib_field_theory F `{DecField F} :Field_theory.field_theory 0 1 (+) (.*.) (fun x y => x - y)(-) (fun x y => x / y) (/) (=).Proof with auto.intros.constructor.apply (theory.rings.stdlib_ring_theory _).apply (is_ne_0 1).reflexivity.intros.rewrite commutativity. by apply dec_recip_inverse.Qed. *)(* Section from_stdlib_field_theory.Context `(ftheory : @field_theory F Fzero Fone Fplus Fmult Fminus FnegateFdiv Frecip Fe)(rinv_0 : Fe (Frecip Fzero) Fzero)`{!@Setoid F Fe}`{!Proper (Fe ==> Fe ==> Fe) Fplus}`{!Proper (Fe ==> Fe ==> Fe) Fmult}`{!Proper (Fe ==> Fe) Fnegate}`{!Proper (Fe ==> Fe) Frecip}.Add Field F2 : ftheory.Definition from_stdlib_field_theory: @DecField F Fe Fplus FmultFzero Fone Fnegate Frecip.Proof with auto.destruct ftheory.repeat (constructor; try assumption); repeat intro; unfold equiv, mon_unit, sg_op, zero_is_mon_unit, plus_is_sg_op,one_is_mon_unit, mult_is_sg_op, plus, mult, recip, negate; try field.unfold recip, mult.simpl.assert (Fe (Fmult x (Frecip x)) (Fmult (Frecip x) x)) as E by ring.rewrite E.Qed.End from_stdlib_field_theory. *)Sectionmorphisms.Context`{IsDecFieldF} `{TrivialApartF} `{Decidable.DecidablePathsF}.Global Instancedec_field_to_domain_inj`{IsIntegralDomainR}`{!IsSemiRingPreserving(f:F->R)} :IsInjectivef.Proof.applyinjective_preserves_0.introsxEfx.applystable.introsEx.destruct(is_ne_0(1:R)).rewrite<-(rings.preserves_1(f:=f)).rewrite<-(dec_recip_inversex)byassumption.rewriterings.preserves_mult,Efx.applyleft_absorb.Qed.Lemmapreserves_dec_recip`{IsDecFieldF2} `{forallxy:F2,Decidable(x=y)}`{!IsSemiRingPreserving(f:F->F2)}x:f(/x) = /fx.Proof.case(dec(x= 0))as[E|E].-rewriteE,dec_recip_0,preserves_0,dec_recip_0.reflexivity.-intros.apply(left_cancellation_ne_0(.*.) (fx)).+applyisinjective_ne_0.trivial.+rewrite<-preserves_mult, 2!dec_recip_inverse.*applypreserves_1.*applyisinjective_ne_0.trivial.*trivial.Qed.Lemmadec_recip_to_recip`{IsFieldF2} `{!IsSemiRingStrongPreserving(f:F->F2)}xPfx:f(/x) = // (fx;Pfx).Proof.assert(x<> 0).-introsEx.destruct(apart_ne(fx) 0Pfx).rewriteEx, (preserves_0(f:=f)).reflexivity.-apply(left_cancellation_ne_0(.*.) (fx)).+applyisinjective_ne_0.trivial.+rewrite<-preserves_mult,dec_recip_inverse,reciperse_altbyassumption.applypreserves_1.Qed.Endmorphisms.

--- Miscellaneous\DependentProduct.html ---
DependentProductLibrary DependentProductDependent Product; oplax limit of a functor to CatRequireImportCategory.CoreFunctor.Core.RequireImportCat.Core.RequireGrothendieck.ToCat.RequireImportCategoryOfSections.Core.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.Sectiondependent_product.Context`{Funext}.VariableC:PreCategory.VariableP:PreCategory->Type.(*Context `{forall C, IsHProp (P C)}.*)Context`{HF:forallCD,PC->PD->IsHSet(FunctorCD)}.Local Notationcat:= (@sub_pre_cat_PHF).VariableF:FunctorCcat.Quoting http://mathoverflow.net/questions/137689/explicit-description-of-the-oplax-limit-of-a-functor-to-cat:The oplax limit is the category of sections for the functor from
      the Grothendieck construction to the base category.The strong limit is the category of cartesian sections
      (every arrow in the base category gets mapped to a cartesian
      one).Notice how this goes along very well with the interpretation as
      dependent product and as ∀: The set theoretic product is just
      the set of sections into the disjoint union.Given a strong functorF:X→Catwe denote the Grothendieck
      construction byGrF.There is a canonical functorπ:GrF→X. Sections of this
      functor are functorss:X→GrFsuch thats∘π=id.Definitiondependent_product:PreCategory:=category_of_sections(Grothendieck.ToCat.pr1F).Enddependent_product.NotationPi:=dependent_product.

--- Miscellaneous\Descent.html ---
DescentLibrary DescentRequireImportHoTT.BasicsHoTT.Types.RequireImportHFiberExtensionsLimits.Pullback.RequireImportModalityAccessibleModalities.Localization.Local OpenScopepath_scope.Local OpenScopesubuniverse_scope.Descent between subuniversesWe study here a strengthening of the relationO<<O'saying thatO-modal type families descend alongO'-equivalences.  Pairs of reflective subuniverses with this relation share nearly all the properties of a reflective subuniverseOpaired with its subuniverseSepOof separated types (seeSeparated.v) and also many of those of a single left exact modality (seeLex.v).  Thus, many of the results herein generalize those of RSS for lex modalities and those of CORS for separated subuniverses.Note that this kind of descent is not the same as the "modal descent" of Cherubini and Rijke.  When we get around to formalizing that, we may need to worry about disambiguating the names.DefinitionsThis definition is an analogue of the statement of Lemma 2.19 of CORS, and of Theorem 3.1(xiii) of RSS.  Note that CORS Lemma 2.19 includes uniqueness of the extension, which we don't assert explicitly.  However, uniqueness follows from theReflectsDparameter -- seeooextendable_TypeO_lex_leqbelow.ClassDescends@{i} (O'O:Subuniverse@{i}) (T:Type@{i})`{ReflectsD@{i}O'OT} :={OO_descend:forall(P:T->Type@{i}) {P_inO:forallx,InO(Px)},O_reflectorO'T->Type@{i} ;OO_descend_inO:forall(P:T->Type@{i}) {P_inO:forallx,InO(Px)} (x:O_reflectorO'T),InO(OO_descendPx) ;OO_descend_beta:forall(P:T->Type@{i}) {P_inO:forallx,InO(Px)} (x:T),OO_descendP(toO'Tx) <~>Px;}.Global Existing InstanceOO_descend_inO.ArgumentsOO_descendO'O{T___}P{P_inO}x.ArgumentsOO_descend_inOO'O{T___}P{P_inO}x.ArgumentsOO_descend_betaO'O{T___}P{P_inO}x.ClassO_lex_leq(O1O2:ReflectiveSubuniverse) `{O1<<O2} :=O_lex_leq_descends:forallA,DescendsO2O1A.Infix"<<<" :=O_lex_leq:subuniverse_scope.Global Existing InstanceO_lex_leq_descends.Unfortunately, it seems that generalizing binders don't work on notations: writing`{O<<<O'}doesn't automatically add the preconditionO<<O', although writing`{O_lex_leqOO'}does.DefinitionO_lex_leq_eq{O1O2O3:ReflectiveSubuniverse}`{O1<=>O2} `{O2<<O3,O2<<<O3}(Hstrong:=O_strong_leq_trans_lO1O2O3):O1<<<O3.Proof.introsA;unshelveeconstructor;introsPP_inO1.all:pose(P_inO2:=funx=>inO_leqO1O2_(P_inO1x)).-apply(OO_descendO3O2P).-introsx;apply(inO_leqO2O1), (OO_descend_inOO3O2P).-apply(OO_descend_betaO3O2P).Defined.Left exactness propertiesWe prove analogues of the properties in section 2.4 of CORS and Theorem 3.1 of RSS, but in a different order, with different proofs, to increase the generality.  The proofs in CORS use Proposition 2.26 for everything else, but it seems that most of the other results are true in the generality of two reflective subuniverses withO<<<O', so we give different proofs for some of them.  (To show that this generality is non-spurious, note that a lex modalityOsatisfiesO<<<O, but does not generally coincide withSepO.)In the case of a single modality, most of these statements are equivalent to lex-ness (as stated in Theorem 3.1 of RSS).  We do not know if anything similar is true more generally.SectionLeftExactness.Universei.Context(O'O:ReflectiveSubuniverse@{i}) `{O<<O',O<<<O'}.Proposition 2.30 of CORS and Theorem 3.1(xii) of RSS: anyO'-equivalence isO-connected.  The special case whenf=toO'Arequires onlyO<<O', but the general case seems to requireO<<<O'. It is convenient to have this as an instance in this file, but we don't make it global, as it requires that Coq guessO'.Local Instanceconn_map_OO_inverts{AB:Type} (f:A->B) `{O_invertsO'f}:IsConnMapOf.Proof.applyconn_map_from_extension_elim.introsPP_inO.assert(E:ExtendableAlong1%natfP); [ |exact(fstE) ].assert(Qp:=OO_descend_betaO'OP).assert(Q_inO:=OO_descend_inOO'OP).set(Q:=OO_descendO'OP)in*.refine(extendable_postcompose'_(QotoO'B)PfQp_).refine(cancelL_extendable_Qf(toO'B)__).1:srapply(extendable_conn_map_inOO).refine(extendable_homotopic__(O_functorO'fotoO'A) (to_O_naturalO'f)_).srapplyextendable_compose.1:srapplyextendable_equiv.srapply(extendable_conn_map_inOO).Defined.A generalization of Lemma 2.27 of CORS:functor_sigmaof a family ofO-equivalences over anO'-equivalence is anO-equivalence.  CORS Lemma 2.27 is the case whenf=toO'Aandgis a family of identities.DefinitionOO_inverts_functor_sigma{AB:Type} {P:A->Type} {Q:B->Type}(f:A->B) (g:foralla,Pa->Q(fa))`{O_invertsO'f} `{foralla,O_invertsO(ga)}:O_invertsO(functor_sigmafg).Proof.srapplyisequiv_homotopic'.-refine(equiv_O_sigma_OO_oE_oE(equiv_O_sigma_OO_)^-1).refine(Build_Equiv__(O_functorO(functor_sigmaf(funx=>O_functorO(gx))))_).-applyO_indpaths.intros[xu];cbn.rewrite!to_O_natural,O_rec_beta;cbn.rewrite!to_O_natural,O_rec_beta.reflexivity.Defined.Families ofO-modal types descend along allO'-equivalences (not just theO'-units, as asserted in the definition of<<<.DefinitionOO_descend_O_inverts{AB:Type} (f:A->B) `{O_invertsO'f}(P:A->Type) {P_inO:forallx,InO(Px)}:B->Type.Proof.introsb.pose(Q:=OO_descendO'OP).exact(Q((O_functorO'f)^-1 (toO'Bb))).Defined.Global InstanceOO_descend_O_inverts_inO{AB:Type} (f:A->B) `{O_invertsO'f}(P:A->Type) {P_inO:forallx,InO(Px)} (b:B):InO(OO_descend_O_invertsfPb):=_.DefinitionOO_descend_O_inverts_beta{AB:Type} (f:A->B) `{O_invertsO'f}(P:A->Type) {P_inO:forallx,InO(Px)} (a:A): (OO_descend_O_invertsfP(fa)) <~>Pa.Proof.unfoldOO_descend_O_inverts.refine(OO_descend_betaO'OPaoE_).assert(p:= (to_O_naturalO'fa)^).applymoveR_equiv_Vinp.exact(equiv_transport_p).Defined.Morally, an equivalent way of sayingO<<<O'is that the universe ofO-modal types isO'-modal.  We can't say this directly since this type lives in a higher universe, but here is a rephrasing of it.Definitionooextendable_TypeO_lex_leq`{Univalence}{AB:Type} (f:A->B) `{O_invertsO'f}:ooExtendableAlongf(fun_=>Type_O).Proof.rapplyooextendable_TypeO_from_extension;introsP.exists(funx=> (OO_descend_O_invertsfPx;OO_descend_O_inverts_inOfPx)).introsx;applypath_TypeO,path_universe_uncurried;cbn.exact(OO_descend_O_inverts_betafPx).Defined.We can also state it in terms of belonging to a subuniverse if we liftO'accessibly (an analogue of Theorem 3.11(iii) of RSS).Global InstanceinO_TypeO_lex_leq`{Univalence} `{IsAccRSUO'}:In(lift_accrsuO') (Type_O):=funi=>ooextendable_TypeO_lex_leq(acc_lgenO'i).Iffis anO'-equivalence, thenapfis anO-equivalence.Global InstanceOO_inverts_ap@{}{AB:Type@{i}} (f:A->B) `{O_invertsO'f} (xy:A):O_invertsO(@ap__fxy).Proof.assert(Pb:=OO_descend_O_inverts_betaf(funy:A=>O(x=y))).assert(P_inO:=OO_descend_O_inverts_inOf(funy:A=>O(x=y))).set(P:=OO_descend_O_invertsf(funy:A=>O(x=y)))in*.clearbodyP;cbnin*.srapplyisequiv_adjointify.-introsq.pose(t:=funp=> @transportBP(fx) (fy)p((Pbx)^-1 (toO(x=x) 1))).exact(Pby(O_rectq)).-applyO_indpaths;introsp;cbn.rewriteO_rec_beta.assert(g:=extension_conn_map_elimO(functor_sigmaf(fun(a:A) (p:P(fa)) =>p))(funbp=>O(fx=bp.1)) (funu=>O_functorO(apf) (Pbu.1u.2))).pose(g1bp:=g.1 (b;p)).cbning1.assert(e: (funu=>g1u.1u.2) ==g.1).1:intros[ab];reflexivity.assert(g2:=funap=>e_@g.2 (a;p));cbning2.refine((g2y_)^ @_).rewrite(ap_transportpg1).rewrite(g2x((Pbx)^-1 (toO(x=x) 1))).rewriteeisretr,to_O_natural;cbn.rewrite<- (ap_transportp(funb=>toO(fx=b))).applyap.rewritetransport_paths_r.applyconcat_1p.-applyO_indpaths;introsp;cbn.rewriteto_O_natural,O_rec_beta.destructp;cbn.srapplyeisretr.Defined.Definitionequiv_O_functor_ap_OO_inverts{AB:Type} (f:A->B) `{O_invertsO'f} (xy:A):O(x=y) <~>O(fx=fy):=Build_Equiv__(O_functorO(apf))_.Theorem 3.1(i) of RSS: path-spaces ofO'-connected types areO-connected.DefinitionOO_isconnected_paths{A:Type} `{IsConnectedO'A} (xy:A):IsConnectedO(x=y).Proof.rapply(contr_equiv'_(equiv_O_functor_ap_OO_inverts(const_tt_)xy)^-1).Defined.Proposition 2.26 of CORS and Theorem 3.1(ix) of RSS; also generalizes Theorem 7.3.12 of the book.  Here we need to add the extra assumption thatO'<=SepO, which is satisfied whenO'=SepObut also whenOis lex andO'=O.  That some such extra hypothesis is necessary can be seen from the fact thatTr(-2)<<<O'for anyO', whereas this statement is certainly not true in that generality.Definitionpath_OO`{O'<=SepO}{X:Type@{i}} (xy:X):O(x=y) -> (toO'Xx=toO'Xy).Proof.nrefine(O_rec(O:=O) (@apX(O'X) (toO'X)xy)).-rapply(@inO_leqO'(SepO)).-exact_.Defined.Global Instanceisequiv_path_OO`{O'<=SepO}{X:Type@{i}} (xy:X):IsEquiv(path_OOxy).Proof.nrefine(isequiv_O_rec_O_invertsO_).Typeclass search can find this, but it's quicker (and may help the reader) to give it explicitly.apply(OO_inverts_ap(toO'X)).Defined.Definitionequiv_path_OO`{O'<=SepO}{X:Type@{i}} (xy:X):O(x=y) <~> (toO'Xx=toO'Xy):=Build_Equiv__(path_OOxy)_.functor_hfiberon a pair ofO'-equivalences is anO-equivalence.Global InstanceOO_inverts_functor_hfiber{ABCD:Type} {f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh) (b:B)`{O_invertsO'h,O_invertsO'k}:O_invertsO(functor_hfiberpb).Proof.unfoldfunctor_hfiber.snrefine(OO_inverts_functor_sigma__).1:exact_.introsa;cbn.refine(isequiv_homotopic(O_functorO(concat(pa)^)oO_functorO(@ap__k(fa)b))_).symmetry;applyO_functor_compose.Defined.Corollary 2.29 of CORS:O'preserves fibers up toO-equivalence.Global InstanceOO_inverts_functor_hfiber_to_O{YX:Type} (f:Y->X) (x:X):O_invertsO(functor_hfiber(funa=> (to_O_naturalO'fa)^)x).Proof.Typeclass search can find this, but it's faster to give it explicitly.exact(OO_inverts_functor_hfiber__).Defined.Definitionequiv_OO_functor_hfiber_to_O{YX:Type@{i} } (f:Y->X) (x:X):O(hfiberfx) <~>O(hfiber(O_functorO'f) (toO'Xx)):=Build_Equiv___(OO_inverts_functor_hfiber_to_Ofx).Theorem 3.1(iii) of RSS: any map betweenO'-connected types isO-connected.  (Part (ii) is just the version for dependent projections.)DefinitionOO_conn_map_isconnected{YX:Type} `{IsConnectedO'Y,IsConnectedO'X} (f:Y->X):IsConnMapOf.Proof.introsx;rapply(contr_equiv'_(equiv_OO_functor_hfiber_to_Ofx)^-1).Defined.DefinitionOO_isconnected_hfiber{YX:Type} `{IsConnectedO'Y,IsConnectedO'X} (f:Y->X) (x:X):IsConnectedO(hfiberfx):=OO_conn_map_isconnectedfx.Theorem 3.1(iv) of RSS: anO-modal map betweenO'-connected types is an equivalence.DefinitionOO_isequiv_mapino_isconnected{YX:Type} `{IsConnectedO'Y,IsConnectedO'X} (f:Y->X) `{MapInO__f}:IsEquivf.Proof.apply(isequiv_conn_ino_mapO).-applyOO_conn_map_isconnected.-assumption.Defined.Theorem 3.1(vi) of RSS (and part (v) is just the analogue for dependent projections).DefinitionOO_conn_map_functor_hfiber{ABCD:Type}{f:A->B} {g:C->D} {h:A->C} {k:B->D}`{IsConnMapO'__h,IsConnMapO'__k}(p:kof==goh) (b:B):IsConnMapO(functor_hfiberpb).Proof.intros[cq].nrefine(isconnected_equiv'O_(hfiber_functor_hfiberpbcq)^-1_).applyOO_isconnected_hfiber.Defined.An enhancement of Corollary 2.29 of CORS, corresponding to Theorem 3.1(viii) of RSS: whenO'is a modality, the map between fibers is not just an O-equivalence but is O-connected.Global InstanceOO_conn_map_functor_hfiber_to_O`{IsModalityO'}{YX:Type} (f:Y->X) (x:X):IsConnMapO(functor_hfiber(funy=> (to_O_naturalO'fy)^)x).Proof.applyOO_conn_map_functor_hfiber.Defined.Theorem 3.1(vii) of RSSDefinitionOO_ispullback_connmap_mapino{ABCD:Type} {f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh)`{O_invertsO'h,O_invertsO'k,MapInO__f,MapInO__g}:IsPullbackp.Proof.applyispullback_isequiv_functor_hfiber;introsb.apply(isequiv_O_invertsO).applyOO_inverts_functor_hfiber;exact_.Defined.functor_pullbackon a triple ofO'-equivalences is anO-equivalence.Global InstanceOO_inverts_functor_pullback{A1B1C1A2B2C2:Type}(f1:B1->A1) (g1:C1->A1)(f2:B2->A2) (g2:C2->A2)(h:A1->A2) (k:B1->B2) (l:C1->C2)(p:f2ok==hof1) (q:g2ol==hog1)`{O_invertsO'h,O_invertsO'k,O_invertsO'l}:O_invertsO(functor_pullbackf1g1f2g2hklpq).Proof.unfoldfunctor_pullback.snrefine(OO_inverts_functor_sigma__).1:exact_.introsb1;cbn.snrefine(OO_inverts_functor_sigma__).1:exact_.introsc1;cbn.pose@isequiv_compose.(* Speed up typeclass search. *)refine(isequiv_homotopic(O_functorO(funr=>r@ (qc1)^)oO_functorO(concat(pb1))oO_functorO(@ap__h(f1b1) (g1c1)))_).introsr;symmetry.refine(_@_).2:applyO_functor_compose.cbn;srapplyO_functor_compose.Defined.Proposition 2.28 of CORS, and Theorem 3.1(x) of RSS: the functorO'preserves pullbacks up toO-equivalence.Global InstanceOO_inverts_functor_pullback_to_O{ABC:Type} (f:B->A) (g:C->A):O_invertsO(functor_pullbackfg(O_functorO'f) (O_functorO'g)(toO'A) (toO'B) (toO'C)(to_O_naturalO'f) (to_O_naturalO'g)).Proof.applyOO_inverts_functor_pullback;exact_.Defined.Definitionequiv_OO_pullback{ABC:Type} (f:B->A) (g:C->A):O(Pullbackfg) <~>O(Pullback(O_functorO'f) (O_functorO'g)):=Build_Equiv___(OO_inverts_functor_pullback_to_Ofg).The "if" direction of CORS Proposition 2.31, and the nontrivial part of Theorem 3.1(xi) of RSS.  Note that we could also deduce Theorem 3.1(iii) of RSS from this.DefinitionOO_cancelL_conn_map{YXZ:Type} (f:Y->X) (g:X->Z)`{IsConnMapO'__(gof)} `{IsConnMapO'__g}:IsConnMapOf.Proof.applyconn_map_OO_inverts.nrapply(cancelL_isequiv(O_functorO'g)).1:exact_.rapply(isequiv_homotopic_(O_functor_composeO'fg)).Defined.EndLeftExactness.Here's the "only if" direction of CORS Proposition 2.31.  Note that the hypotheses are different from those of the "if" direction, and the proof is shorter than the one given in CORS.DefinitionOO_cancelR_conn_map(O'O:ReflectiveSubuniverse@{u}) `{O_leq@{uuu}OO',O'<=SepO}{YXZ:Type} (f:Y->X) (g:X->Z)`{IsConnMapO'__(gof)} `{IsConnMapO__f}:IsConnMapO'g.Proof.applyconn_map_from_extension_elim.introsPP_inOh.exists(conn_map_elimO'(gof)P(hof)).nrefine(conn_map_elimOf__); [exact_| .. ].-introsx.poseproof(funz=>inO_leqO'(SepO) (Pz) (P_inOz)).exact_.-introsy.apply(conn_map_compO'(gof)).Defined.DefinitionOO_isconnected_from_conn_map(O'O:ReflectiveSubuniverse) `{O<=O',O'<=SepO}{YX:Type} (f:Y->X)`{IsConnectedO'Y} `{IsConnMapO__f}:IsConnectedO'X.Proof.applyisconnected_conn_map_to_unit.apply(OO_cancelR_conn_mapO'Of(const_tt_)).Defined.An interesting scholium to Proposition 2.31.DefinitionOO_inverts_conn_map_factor_conn_map(O'O:ReflectiveSubuniverse) `{O<<O',O<<<O',O'<=SepO}{YXZ:Type} (f:Y->X) (g:X->Z)`{IsConnMapO'__(gof)} `{IsConnMapO__f}:O_invertsO'f.Proof.nrapply(cancelL_isequiv(O_functorO'g)).-applyO_inverts_conn_map.apply(OO_cancelR_conn_mapO'Ofg).-rapply(isequiv_homotopic_(O_functor_composeO'fg)).Defined.DefinitionOO_inverts_conn_map_isconnected_domain(O'O:ReflectiveSubuniverse) `{O<<O',O<<<O',O'<=SepO}{YX:Type} (f:Y->X)`{IsConnectedO'Y} `{IsConnMapO__f}:O_invertsO'f.Proof.apply(OO_inverts_conn_map_factor_conn_mapO'Of(const_tt_)).Defined.Here is the converse ofooextendable_TypeO_lex_leq.DefinitionO_lex_leq_extendable_TypeO(O'O:ReflectiveSubuniverse) `{O<<O'}(e:forall(A:Type) (g:A->Type_O),ExtensionAlong(toO'A) (fun_=>Type_O)g):O<<<O'.Proof.introsA;unshelveeconstructor;introsP'P_inO;pose(P:=funx=> (P'x;P_inOx) :Type_O).-exact(funx=> ((eAP).1x).1).-exact(funx=> ((eAP).1x).2).-introsx.applyequiv_path.exact(((eAP).2x)..1).Defined.And a version for the accessible case.DefinitionO_lex_leq_inO_TypeO(O'O:ReflectiveSubuniverse) `{O<<O'}`{IsAccRSUO'} `{In(lift_accrsuO') (Type_O)}:O<<<O'.Proof.applyO_lex_leq_extendable_TypeO.introsAg.assert(O_inverts(lift_accrsuO') (toO'A)).-rapply(O_inverts_O_leq'(lift_accrsuO')O').-exact(fst(ooextendable_O_inverts(lift_accrsuO') (toO'A) (Type_O) 1%nat)g).Defined.

--- Miscellaneous\Diagram.html ---
DiagramLibrary DiagramRequireImportBasics.RequireImportTypes.RequireImportHoTT.Tactics.RequireImportDiagrams.CommutativeSquares.RequireImportDiagrams.Graph.Local OpenScopepath_scope.This file contains the definition of diagrams, diagram maps and equivalences of diagrams.DiagramsADiagramover a graphGassociates a type to each point of the graph and a function to each arrow.RecordDiagram(G:Graph) := {obj:G->Type;arr{ij:G} :Gij->obji->objj}.Argumentsobj[G]Di:rename.Argumentsarr[G]D[ij]gx:rename.Coercionobj:Diagram>->Funclass.Notation"D '_f' g" := (arrDg).SectionDiagram.Context`{Funext} {G:Graph}.path_diagramsays when two diagrams are equals (up to funext).Definitionpath_diagram_naive(D1D2:DiagramG)(P:=funD'=>forallij,Gij-> (D'i->D'j))(path_obj:objD1=objD2)(path_arr:transportPpath_obj(arrD1) =arrD2):D1=D2:=matchpath_arrin(_=v1)returnD1= {|obj:=objD2;arr:=v1|}with|idpath=>matchpath_objin(_=v0)returnD1= {|obj:=v0;arr:=path_obj# (arrD1) |}with|idpath=> 1endend.Definitionpath_diagram(D1D2:DiagramG)(path_obj:foralli,D1i=D2i)(path_arr:forallij(g:Gij)x,transportidmap(path_objj) (D1_fgx)=D2_fg(transportidmap(path_obji)x)):D1=D2.Proof.srapplypath_diagram_naive;funexti.1:applypath_obj.funextjgx.rewrite3transport_forall_constant,transport_arrow.transport_path_forall_hammer.refine(_@path_arrijg(transportidmap(path_obji)^x) @_).{do3f_ap.rewrite<-path_forall_V.funexty.bytransport_path_forall_hammer. }f_ap.exact(transport_pVidmap_x).Defined.Diagram mapA map between two diagrams is a family of maps between the types of the diagrams making commuting the squares formed with the arrows.RecordDiagramMap(D1D2:DiagramG) := {DiagramMap_obj:>foralli,D1i->D2i;DiagramMap_comm:forallij(g:Gij)x,D2_fg(DiagramMap_objix) =DiagramMap_objj(D1_fgx)}.Global ArgumentsDiagramMap_obj[D1D2]mix:rename.Global ArgumentsDiagramMap_comm[D1D2]m[ij]fx:rename.Global ArgumentsBuild_DiagramMap[D1D2]__.path_DiagramMapsays when two maps are equals (up to funext).Definitionpath_DiagramMap{D1D2:DiagramG}{m1m2:DiagramMapD1D2} (h_obj:foralli,m1i==m2i)(h_comm:forallij(g:Gij)x,DiagramMap_commm1gx@h_objj(D1_fgx)=ap(D2_fg) (h_objix) @DiagramMap_commm2gx):m1=m2.Proof.destructm1as[m1_objm1_comm].destructm2as[m2_objm2_comm].simplin*.reverth_objh_comm.set(E:= (@equiv_functor_forall_G(funi=>m1_obji=m2_obji)G(funi=>m1_obji==m2_obji)idmap_(funi=> @apD10__(m1_obji) (m2_obji)))(funi=>isequiv_apD10____)).equiv_introEh_obj.reverth_obj.equiv_intro(@apD10__m1_objm2_obj)h_obj.destructh_obj;simpl.introsh_comm.assert(HH:m1_comm=m2_comm).{funextijfx.apply(concatR(concat_1p_)).apply(concatR(h_comm____)).applyinverse,concat_p1. }destructHH.reflexivity.Defined.Identity and composition for diagram maps.Definitiondiagram_idmap(D:DiagramG) :DiagramMapDD:=Build_DiagramMap(fun_=>idmap) (fun____=> 1).Definitiondiagram_comp{D1D2D3:DiagramG} (m2:DiagramMapD2D3)(m1:DiagramMapD1D2) :DiagramMapD1D3.Proof.apply(Build_DiagramMap(funi=>m2iom1i)).introsijf.exact(comm_square_comp(DiagramMap_commm1f) (DiagramMap_commm2f)).Defined.Diagram equivalencesAn equivalence of diagram is a diagram map whose functions are equivalences.Recorddiagram_equiv(D1D2:DiagramG) :={diag_equiv_map:>DiagramMapD1D2;diag_equiv_isequiv:foralli,IsEquiv(diag_equiv_mapi) }.Global Argumentsdiag_equiv_map[D1D2]e:rename.Global Argumentsdiag_equiv_isequiv[D1D2]ei:rename.Global ArgumentsBuild_diagram_equiv[D1D2]mH:rename.Inverse, section and retraction of equivalences of diagrams.Lemmadiagram_equiv_inv{D1D2:DiagramG} (w:diagram_equivD1D2):DiagramMapD2D1.Proof.apply(Build_DiagramMap(funi=> (Build_Equiv___(diag_equiv_isequivwi))^-1)).introsijf.apply(@comm_square_inverse______(Build_Equiv___(diag_equiv_isequivwi))(Build_Equiv___(diag_equiv_isequivwj))).introsx;applyDiagramMap_comm.Defined.Lemmadiagram_inv_is_section{D1D2:DiagramG}(w:diagram_equivD1D2):diagram_compw(diagram_equiv_invw) =diagram_idmapD2.Proof.destructwas[[w_objw_comm]is_eq_w].simplin*.set(wei:=Build_Equiv___(is_eq_wi)).simplerefine(path_DiagramMap__).-exact(funi=>eisretr(wei)).-simpl.introsijfx.apply(concatR(concat_p1_)^).apply(comm_square_inverse_is_retr(wei) (wej)_x).Defined.Lemmadiagram_inv_is_retraction{D1D2:DiagramG}(w:diagram_equivD1D2):diagram_comp(diagram_equiv_invw)w=diagram_idmapD1.Proof.destructwas[[w_objw_comm]is_eq_w].simplin*.set(wei:=Build_Equiv___(is_eq_wi)).simplerefine(path_DiagramMap__).-exact(funi=>eissect(wei)).-simpl.introsijfx.apply(concatR(concat_p1_)^).apply(comm_square_inverse_is_sect(wei) (wej)_x).Defined.The equivalence of diagram is an equivalence relation.  Those instances allows to use the tactics reflexivity, symmetry and transitivity.Global Instancereflexive_diagram_equiv:Reflexivediagram_equiv| 1:=funD=>Build_diagram_equiv(diagram_idmapD)_.Global Instancesymmetric_diagram_equiv:Symmetricdiagram_equiv| 1:=funD1D2m=>Build_diagram_equiv(diagram_equiv_invm)_.Global Instancetransitive_diagram_equiv:Transitivediagram_equiv| 1.Proof.simplerefine(funD1D2D3m1m2=>Build_diagram_equiv(diagram_compm2m1)_).simpl.introsi;applyisequiv_compose';[applym1|applym2].Defined.EndDiagram.Notation"D1 ~d~ D2" := (diagram_equivD1D2).

--- Miscellaneous\DirectSum.html ---
DirectSumLibrary DirectSumRequireImportBasicsTypesTruncations.Core.RequireImportPointed.Core.RequireImportWildCat.CoreHomotopy.ExactSequence.RequireImportAbGroups.AbelianGroupAbSES.CoreAbGroups.Biproduct.Local OpenScopepointed_scope.Local OpenScopetype_scope.Local OpenScopemc_add_scope.The direct sum of short exact sequencesBiproducts of abelian groups preserve exactness.Lemmaab_biprod_exact{AEBXFY:AbGroup}(i:A$->E) (p:E$->B) `{ex0:IsExact(Tr(-1))___ip}(j:X$->F) (q:F$->Y) `{ex1:IsExact(Tr(-1))___jq}:IsExact(Tr(-1)) (functor_ab_biprodij)(functor_ab_biprodpq).Proof.snrapplyBuild_IsExact.-snrapplyphomotopy_homotopy_hset.1:exact_.introx;applypath_prod;cbn.+applyex0.+applyex1.-intros[[ef]u];cbn.rapplycontr_inhabited_hprop.pose(U:= (equiv_path_prod__)^-1u);cbninU.poseproof(a:=isexact_preimage_ipe(fstU)).poseproof(x:=isexact_preimage_jqf(sndU)).strip_truncations;applytr.exists(ab_biprod_inla.1 +ab_biprod_inrx.1);cbn.pose(IS:=sg_set(ab_biprodBY)).(* This hint speeds up the next line. *)applypath_sigma_hprop;cbn.applypath_prod;cbn.+rewriteright_identity.exacta.2.+rewriteleft_identity.exactx.2.Defined.The pointwise direct sum of two short exact sequences.Definitionabses_direct_sum`{Funext} {BAB'A':AbGroup} (E:AbSESBA) (F:AbSESB'A'):AbSES(ab_biprodBB') (ab_biprodAA'):=Build_AbSES(ab_biprodEF)(functor_ab_biprod(inclusionE) (inclusionF))(functor_ab_biprod(projectionE) (projectionF))(functor_ab_biprod_embedding__)(functor_ab_biprod_surjection__)(ab_biprod_exact____).For any short exact sequencesE,E',F,F', and morphismsf:E->E'andg:F->F'there is a morphismE+F->E'+F'.Lemmafunctor_abses_directsum`{Funext} {AA'BB'CC'DD':AbGroup}{E:AbSESBA} {E':AbSESB'A'} {F:AbSESDC} {F':AbSESD'C'}(f:AbSESMorphismEE') (g:AbSESMorphismFF'):AbSESMorphism(abses_direct_sumEF) (abses_direct_sumE'F').Proof.snrapplyBuild_AbSESMorphism.+exact(functor_ab_biprod(component1f) (component1g)).+exact(functor_ab_biprod(component2f) (component2g)).+exact(functor_ab_biprod(component3f) (component3g)).+introx.applypath_prod;applyleft_square.+introx.applypath_prod;applyright_square.Defined.For any short exact sequenceE, there is a morphismE->abses_direct_sumEE, where each component is ab_diagonal.Definitionabses_diagonal`{Funext} {AB:AbGroup} (E:AbSESBA):AbSESMorphismE(abses_direct_sumEE).Proof.snrapplyBuild_AbSESMorphism.1,2,3:exactab_diagonal.all:reflexivity.Defined.For any short exact sequenceE, there is dually a morphismabses_direct_sumEE->E, with each component being the codiagonal.Definitionabses_codiagonal`{Funext} {AB:AbGroup} (E:AbSESBA):AbSESMorphism(abses_direct_sumEE)E.Proof.snrapplyBuild_AbSESMorphism.1,2,3:exactab_codiagonal.all:introx;cbn;applygrp_homo_op.Defined.There is always a morphismabses_direct_sumEF->abses_direct_sumFEof short exact sequences, for anyE:AbSESBAandF:AbSESB'A'.Definitionabses_swap_morphism`{Funext} {AA'BB':AbGroup}(E:AbSESBA) (F:AbSESB'A'):AbSESMorphism(abses_direct_sumEF) (abses_direct_sumFE).Proof.snrapplyBuild_AbSESMorphism.1,2,3:exactdirect_sum_swap.all:reflexivity.Defined.ForE,F,G:AbSESBA, there is a morphism(E+F)+G->(G+F)+Einduced by the above map, where+denotesabses_direct_sum.Lemmaabses_twist_directsum`{Funext} {AB:AbGroup} (EFG:AbSESBA):AbSESMorphism(abses_direct_sum(abses_direct_sumEF)G)(abses_direct_sum(abses_direct_sumGF)E).Proof.snrapplyBuild_AbSESMorphism.1,2,3:exactab_biprod_twist.all:reflexivity.Defined.

--- Miscellaneous\DiscreteCategory.html ---
DiscreteCategoryLibrary DiscreteCategoryDiscrete categoryRequireImportHoTT.BasicsGroupoidCategory.Core.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.A discrete category is a groupoid which is a 0-typeModuleExportCore.Definitiondiscrete_categoryX`{IsHSetX} :=groupoid_categoryX.Argumentsdiscrete_categoryX{_} / .EndCore.

--- Miscellaneous\Displayed.html ---
DisplayedLibrary DisplayedRequireImportBasics.Overture.RequireImportBasics.PathGroupoids.RequireImportBasics.Tactics.RequireImportTypes.Sigma.RequireImportWildCat.Core.RequireImportWildCat.Prod.ClassIsDGraph{A:Type} `{IsGraphA} (D:A->Type):=DHom:forall{ab:A}, (a$->b) ->Da->Db->Type.ClassIsD01Cat{A:Type} `{Is01CatA} (D:A->Type) `{!IsDGraphD} :={DId:forall{a:A} (a':Da),DHom(Ida)a'a';dcat_comp:forall{abc:A} {g:b$->c} {f:a$->b}{a':Da} {b':Db} {c':Dc},DHomgb'c'->DHomfa'b'->DHom(g$of)a'c';}.Notation"g '$o'' f" := (dcat_compgf).Definitiondcat_postcomp{A:Type} {D:A->Type} `{IsD01CatAD} {abc:A}{g:b$->c} {a':Da} {b':Db} {c':Dc} (g':DHomgb'c'):forall(f:a$->b),DHomfa'b'->DHom(g$of)a'c':=fun_f'=>g'$o'f'.Definitiondcat_precomp{A:Type} {D:A->Type} `{IsD01CatAD} {abc:A}{f:a$->b} {a':Da} {b':Db} {c':Dc} (f':DHomfa'b'):forall(g:b$->c),DHomgb'c'->DHom(g$of)a'c':=fun_g'=>g'$o'f'.ClassIsD0Gpd{A:Type} `{Is0GpdA} (D:A->Type)`{!IsDGraphD, !IsD01CatD}:=dgpd_rev:forall{ab:A} {f:a$==b} {a':Da} {b':Db},DHomfa'b'->DHom(f^$)b'a'.Notation"p ^$'" := (dgpd_revp).DefinitionDGpdHom{A:Type} {D:A->Type} `{IsD0GpdAD} {ab:A}(f:a$==b) (a':Da) (b':Db):=DHomfa'b'.Diagrammatic order to match gpd_compDefinitiondgpd_comp{A:Type} {D:A->Type} `{IsD0GpdAD} {abc:A}{f:a$==b} {g:b$==c} {a':Da} {b':Db} {c':Dc}:DGpdHomfa'b'->DGpdHomgb'c'->DGpdHom(g$of)a'c':=funf'g'=>g'$o'f'.Notation"p '$@'' q" := (dgpd_comppq).DefinitionDHom_path{A:Type} {D:A->Type} `{IsD01CatAD} {ab:A}(p:a=b) {a':Da} {b':Db} (p':transportDpa'=b'):DHom(Hom_pathp)a'b'.Proof.destructp,p';applyDId.Defined.DefinitionDGpdHom_path{A:Type} {D:A->Type} `{IsD0GpdAD} {ab:A}(p:a=b) {a':Da} {b':Db} (p':transportDpa'=b'):DGpdHom(GpdHom_pathp)a'b':=DHom_pathpp'.Global Instancereflexive_DHom{A} {D:A->Type} `{IsD01CatAD} {a:A}:Reflexive(DHom(Ida)):=funa'=>DIda'.Global Instancereflexive_DGpdHom{A} {D:A->Type} `{IsD0GpdAD} {a:A}:Reflexive(DGpdHom(Ida)):=funa'=>DIda'.A displayed 0-functorF'over a 0-functorFacts on displayed objects and 1-cells and satisfies no axioms.ClassIsD0Functor{A:Type} {B:Type}{DA:A->Type} `{IsDGraphADA} {DB:B->Type} `{IsDGraphBDB}(F:A->B) `{!Is0FunctorF} (F':forall(a:A),DAa->DB(Fa)):=dfmap:forall{ab:A} {f:a$->b} {a':DAa} {b':DAb},DHomfa'b'->DHom(fmapFf) (F'aa') (F'bb').Argumentsdfmap{ABDA__DB__}F{_}F'{______}f'.ClassIsD2Graph{A:Type} `{Is2GraphA}(D:A->Type) `{!IsDGraphD}:=isdgraph_hom:forall{ab} {a'} {b'},IsDGraph(fun(f:a$->b) =>DHomfa'b').Global Existing Instanceisdgraph_hom.#[global]TypeclassesTransparentIsD2Graph.ClassIsD1Cat{A:Type} `{Is1CatA}(D:A->Type) `{!IsDGraphD, !IsD2GraphD, !IsD01CatD} :={isd01cat_hom:forall{ab:A} {a':Da} {b':Db},IsD01Cat(funf=>DHomfa'b');isd0gpd_hom:forall{ab:A} {a':Da} {b':Db},IsD0Gpd(funf=>DHomfa'b');isd0functor_postcomp:forall{abc:A} {g:b$->c} {a':Da}{b':Db} {c':Dc} (g':DHomgb'c'),@IsD0Functor__(funf=>DHomfa'b')__(fungf=>DHomgfa'c')__(cat_postcompag)_(dcat_postcompg');isd0functor_precomp:forall{abc:A} {f:a$->b} {a':Da}{b':Db} {c':Dc} (f':DHomfa'b'),@IsD0Functor__(fung=>DHomgb'c')__(fungf=>DHomgfa'c')__(cat_precompcf)_(dcat_precompf');dcat_assoc:forall{abcd:A} {f:a$->b} {g:b$->c} {h:c$->d}{a':Da} {b':Db} {c':Dc} {d':Dd}(f':DHomfa'b') (g':DHomgb'c') (h':DHomhc'd'),DHom(cat_assocfgh) ((h'$o'g') $o'f')(h'$o'(g'$o'f'));dcat_assoc_opp:forall{abcd:A} {f:a$->b} {g:b$->c} {h:c$->d}{a':Da} {b':Db} {c':Dc} {d':Dd}(f':DHomfa'b') (g':DHomgb'c') (h':DHomhc'd'),DHom(cat_assoc_oppfgh) (h'$o'(g'$o'f'))((h'$o'g') $o'f');dcat_idl:forall{ab:A} {f:a$->b} {a':Da} {b':Db}(f':DHomfa'b'),DHom(cat_idlf) (DIdb'$o'f')f';dcat_idr:forall{ab:A} {f:a$->b} {a':Da} {b':Db}(f':DHomfa'b'),DHom(cat_idrf) (f'$o'DIda')f';}.Global Existing Instanceisd01cat_hom.Global Existing Instanceisd0gpd_hom.Global Existing Instanceisd0functor_postcomp.Global Existing Instanceisd0functor_precomp.Definitiondcat_postwhisker{A:Type} {D:A->Type} `{IsD1CatAD}{abc:A} {fg:a$->b} {h:b$->c} {p:f$==g}{a':Da} {b':Db} {c':Dc} {f':DHomfa'b'} {g':DHomga'b'}(h':DHomhb'c') (p':DHompf'g'):DHom(h$@Lp) (h'$o'f') (h'$o'g'):=dfmap(cat_postcompah) (dcat_postcomph')p'.Notation"h $@L' p" := (dcat_postwhiskerhp).Definitiondcat_prewhisker{A:Type} {D:A->Type} `{IsD1CatAD}{abc:A} {f:a$->b} {gh:b$->c} {p:g$==h}{a':Da} {b':Db} {c':Dc} {g':DHomgb'c'} {h':DHomhb'c'}(p':DHompg'h') (f':DHomfa'b'):DHom(p$@Rf) (g'$o'f') (h'$o'f'):=dfmap(cat_precompcf) (dcat_precompf')p'.Notation"p $@R' f" := (dcat_prewhiskerpf).Definitiondcat_comp2{A:Type} {D:A->Type} `{IsD1CatAD} {abc:A}{fg:a$->b} {hk:b$->c} {p:f$==g} {q:h$==k}{a':Da} {b':Db} {c':Dc} {f':DHomfa'b'} {g':DHomga'b'}{h':DHomhb'c'} {k':DHomkb'c'}(p':DHompf'g') (q':DHomqh'k'):DHom(p$@@q) (h'$o'f') (k'$o'g'):=  (k'$@L'p') $o'(q'$@R'f').Notation"q $@@' p" := (dcat_comp2qp).Monomorphisms and epimorphisms.DefinitionDMonic{A} {D:A->Type} `{IsD1CatAD} {bc:A}{f:b$->c} {mon:Monicf} {b':Db} {c':Dc} (f':DHomfb'c'):=forall(a:A) (gh:a$->b) (p:f$og$==f$oh) (a':Da)(g':DHomga'b') (h':DHomha'b'),DGpdHomp(f'$o'g') (f'$o'h') ->DGpdHom(monaghp)g'h'.DefinitionDEpic{A} {D:A->Type} `{IsD1CatAD} {ab:A}{f:a$->b} {epi:Epicf} {a':Da} {b':Db} (f':DHomfa'b'):=forall(c:A) (gh:b$->c) (p:g$of$==h$of) (c':Dc)(g':DHomgb'c') (h':DHomhb'c'),DGpdHomp(g'$o'f') (h'$o'f') ->DGpdHom(epicghp)g'h'.Global Instanceisgraph_total{A:Type} (D:A->Type) `{IsDGraphAD}:IsGraph(sigD).Proof.srapplyBuild_IsGraph.intros[aa'] [bb'].exact{f:a$->b&DHomfa'b'}.Defined.Global Instanceis01cat_total{A:Type} (D:A->Type) `{IsD01CatAD}:Is01Cat(sigD).Proof.srapplyBuild_Is01Cat.-intros[aa'].exact(Ida;DIda').-intros[aa'] [bb'] [cc'] [gg'] [ff'].exact(g$of;g'$o'f').Defined.Global Instanceis0gpd_total{A:Type} (D:A->Type) `{IsD0GpdAD}:Is0Gpd(sigD).Proof.srapplyBuild_Is0Gpd.intros[aa'] [bb'] [ff'].exact(f^$;dgpd_revf').Defined.Global Instanceis0functor_total_pr1{A:Type} (D:A->Type) `{IsDGraphAD}:Is0Functor(pr1:sigD->A).Proof.srapplyBuild_Is0Functor.intros[aa'] [bb'] [ff'].exactf.Defined.Global Instanceis2graph_total{A:Type} (D:A->Type) `{IsD2GraphAD}:Is2Graph(sigD).Proof.intros[aa'] [bb'].srapplyBuild_IsGraph.intros[ff'] [gg'].exact({p:f$->g&DHompf'g'}).Defined.Global Instanceis0functor_total{A:Type} (DA:A->Type) `{IsD01CatADA}{B:Type} (DB:B->Type) `{IsD01CatBDB} (F:A->B) `{!Is0FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF'}:Is0Functor(functor_sigmaFF').Proof.srapplyBuild_Is0Functor.intros[aa'] [bb'].intros[ff'].exact(fmapFf;dfmapFF'f').Defined.Global Instanceis1cat_total{A:Type} (D:A->Type) `{IsD1CatAD}:Is1Cat(sigD).Proof.srapplyBuild_Is1Cat.-intros[aa'] [bb'] [cc'] [ff'].applyBuild_Is0Functor.intros[gg'] [hh'] [pp'].exact(f$@Lp;f'$@L'p').-intros[aa'] [bb'] [cc'] [ff'].applyBuild_Is0Functor.intros[gg'] [hh'] [pp'].exact(p$@Rf;p'$@R'f').-intros[aa'] [bb'] [cc'] [dd'] [ff'] [gg'] [hh'].exact(cat_assocfgh;dcat_assocf'g'h').-intros[aa'] [bb'] [cc'] [dd'] [ff'] [gg'] [hh'].exact(cat_assoc_oppfgh;dcat_assoc_oppf'g'h').-intros[aa'] [bb'] [ff'].exact(cat_idlf;dcat_idlf').-intros[aa'] [bb'] [ff'].exact(cat_idrf;dcat_idrf').Defined.Global Instanceis1functor_pr1{A:Type} {D:A->Type} `{IsD1CatAD}:Is1Functor(pr1:sigD->A).Proof.srapplyBuild_Is1Functor.-intros[aa'] [bb'] [ff'] [gg'] [pp'].exactp.-intros[aa'].applyId.-intros[aa'] [bb'] [cc'] [ff'] [gg'].applyId.Defined.ClassIsD1Cat_Strong{A:Type} `{Is1Cat_StrongA}(D:A->Type)`{!IsDGraphD, !IsD2GraphD, !IsD01CatD} :={isd01cat_hom_strong:forall{ab:A} {a':Da} {b':Db},IsD01Cat(funf=>DHomfa'b');isd0gpd_hom_strong:forall{ab:A} {a':Da} {b':Db},IsD0Gpd(funf=>DHomfa'b');isd0functor_postcomp_strong:forall{abc:A} {g:b$->c} {a':Da}{b':Db} {c':Dc} (g':DHomgb'c'),@IsD0Functor__(funf=>DHomfa'b')__(fungf=>DHomgfa'c')__(cat_postcompag)_(dcat_postcompg');isd0functor_precomp_strong:forall{abc:A} {f:a$->b} {a':Da}{b':Db} {c':Dc} (f':DHomfa'b'),@IsD0Functor__(fung=>DHomgb'c')__(fungf=>DHomgfa'c')__(cat_precompcf)_(dcat_precompf');dcat_assoc_strong:forall{abcd:A} {f:a$->b} {g:b$->c} {h:c$->d}{a':Da} {b':Db} {c':Dc} {d':Dd}(f':DHomfa'b') (g':DHomgb'c') (h':DHomhc'd'),(transport(funk=>DHomka'd') (cat_assoc_strongfgh)((h'$o'g') $o'f')) =h'$o'(g'$o'f');dcat_assoc_opp_strong:forall{abcd:A} {f:a$->b} {g:b$->c} {h:c$->d}{a':Da} {b':Db} {c':Dc} {d':Dd}(f':DHomfa'b') (g':DHomgb'c') (h':DHomhc'd'),(transport(funk=>DHomka'd') (cat_assoc_opp_strongfgh)(h'$o'(g'$o'f'))) = (h'$o'g') $o'f';dcat_idl_strong:forall{ab:A} {f:a$->b} {a':Da} {b':Db}(f':DHomfa'b'),(transport(funk=>DHomka'b') (cat_idl_strongf)(DIdb'$o'f')) =f';dcat_idr_strong:forall{ab:A} {f:a$->b} {a':Da} {b':Db}(f':DHomfa'b'),(transport(funk=>DHomka'b') (cat_idr_strongf)(f'$o'DIda')) =f';}.Global Existing Instanceisd01cat_hom_strong.Global Existing Instanceisd0gpd_hom_strong.Global Existing Instanceisd0functor_postcomp_strong.Global Existing Instanceisd0functor_precomp_strong.(* If in the future we make aBuild_Is1Cat_Strong'that lets the user omit the second proof of associativity, this shows how it can be recovered from the original proof:Definition dcat_assoc_opp_strong {A : Type} {D : A -> Type} `{IsD1Cat_Strong A D}{a b c d : A}  {f : a -> c} {h : c o' (g' o' g') *)Global Instanceisd1cat_isd1catstrong{A:Type} (D:A->Type)`{IsD1Cat_StrongAD} :IsD1CatD.Proof.srapplyBuild_IsD1Cat.-introsabcdfgha'b'c'd'f'g'h'.exact(DHom_path(cat_assoc_strongfgh) (dcat_assoc_strongf'g'h')).-introsabcdfgha'b'c'd'f'g'h'.exact(DHom_path(cat_assoc_opp_strongfgh) (dcat_assoc_opp_strongf'g'h')).-introsabfa'b'f'.exact(DHom_path(cat_idl_strongf) (dcat_idl_strongf')).-introsabfa'b'f'.exact(DHom_path(cat_idr_strongf) (dcat_idr_strongf')).Defined.Global Instanceis1catstrong_total{A:Type}(D:A->Type) `{IsD1Cat_StrongAD}:Is1Cat_Strong(sigD).Proof.srapplyBuild_Is1Cat_Strong.-introsaa'bb'cc'dd'[ff'] [gg'] [hh'].exact(path_sigma'_(cat_assoc_strongfgh) (dcat_assoc_strongf'g'h')).-introsaa'bb'cc'dd'[ff'] [gg'] [hh'].exact(path_sigma'_(cat_assoc_opp_strongfgh) (dcat_assoc_opp_strongf'g'h')).-introsaa'bb'[ff'].exact(path_sigma'_(cat_idl_strongf) (dcat_idl_strongf')).-introsaa'bb'[ff'].exact(path_sigma'_(cat_idr_strongf) (dcat_idr_strongf')).Defined.ClassIsD1Functor{AB:Type} {DA:A->Type} `{IsD1CatADA} {DB:B->Type} `{IsD1CatBDB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF'} :={dfmap2:forall{ab:A} {fg:a$->b} {p:f$==g} {a':DAa}{b':DAb} (f':DHomfa'b') (g':DHomga'b'),DHompf'g'->DHom(fmap2Fp) (dfmapFF'f') (dfmapFF'g');dfmap_id:forall{a:A} (a':DAa),DHom(fmap_idFa) (dfmapFF'(DIda')) (DId(F'aa'));dfmap_comp:forall{abc:A} {f:a$->b} {g:b$->c} {a':DAa}{b':DAb} {c':DAc} (f':DHomfa'b') (g':DHomgb'c'),DHom(fmap_compFfg) (dfmapFF'(g'$o'f'))(dfmapFF'g'$o'dfmapFF'f');}.Argumentsdfmap2{ABDA________DB________}F{__}F'{__abfgpa'b'f'g'}p'.Argumentsdfmap_id{ABDA________DB________}F{__}F'{__a}a'.Argumentsdfmap_comp{ABDA________DB________}F{__}F'{__abcfga'b'c'}f'g'.Global Instanceis1functor_total{AB:Type} (DA:A->Type) (DB:B->Type)(F:A->B) (F':forall(a:A),DAa->DB(Fa)) `{IsD1FunctorABDADBFF'}:Is1Functor(functor_sigmaFF').Proof.srapplyBuild_Is1Functor.-intros[aa'] [bb'] [ff'] [gg'] [pp'].exists(fmap2Fp).exact(dfmap2FF'p').-intros[aa'].exact(fmap_idFa;dfmap_idFF'a').-intros[aa'] [bb'] [cc'] [ff'] [gg'].exact(fmap_compFfg;dfmap_compFF'f'g').Defined.SectionIdentityFunctor.Global Instanceisd0functor_idmap{A:Type} `{Is01CatA}(DA:A->Type) `{!IsDGraphDA, !IsD01CatDA}:IsD0Functor(idmap) (funaa'=>a').Proof.introsabfa'b'f'.assumption.Defined.Global Instanceisd1functor_idmap{A:Type} (DA:A->Type)`{IsD1CatADA}:IsD1Functor(idmap) (funaa'=>a').Proof.applyBuild_IsD1Functor.-introsabfgpa'b'f'g'p'.assumption.-introsaa'.applyDId.-introsabcfga'b'c'f'g'.applyDId.Defined.EndIdentityFunctor.SectionConstantFunctor.Global Instanceisd0functor_const{A:Type} `{IsGraphA}{B:Type} `{Is01CatB} (DA:A->Type) `{!IsDGraphDA}(DB:B->Type) `{!IsDGraphDB, !IsD01CatDB} (x:B) (x':DBx):IsD0Functor(fun_:A=>x) (fun__=>x').Proof.introsabfa'b'f'.applyDId.Defined.Global Instanceisd1functor_const{A:Type} {B:Type}(DA:A->Type)`{IsD1CatADA}(DB:B->Type)`{IsD1CatBDB}(x:B) (x':DBx):IsD1Functor(fun_=>x) (fun__=>x').Proof.snrapplyBuild_IsD1Functor.-introsabfgpa'b'f'g'p'.applyDId.-introsaa'.applyDId.-introsabcfga'b'c'f'g'.applydgpd_rev.applydcat_idl.Defined.EndConstantFunctor.SectionCompositeFunctor.Context{ABC:Type} {DA:A->Type} {DB:B->Type} {DC:C->Type}(F:A->B) (G:B->C)(F':forall(a:A),DAa->DB(Fa))(G':forall(b:B),DBb->DC(Gb)).Global Instanceisd0functor_compose`{IsDGraphADA} `{IsDGraphBDB} `{IsDGraphCDC}`{!Is0FunctorF} `{!Is0FunctorG}`{!IsD0FunctorFF'} `{!IsD0FunctorGG'}:IsD0Functor(GoF) (funaa'=> (G'(Fa)o(F'a))a').Proof.introsabfa'b'f'.exact(dfmapGG'(dfmapFF'f')).Defined.Global Instanceisd1functor_compose`{IsD1CatADA} `{IsD1CatBDB} `{IsD1CatCDC}`{!Is0FunctorF, !Is1FunctorF} `{!Is0FunctorG, !Is1FunctorG}`{!IsD0FunctorFF', !IsD1FunctorFF'}`{!IsD0FunctorGG', !IsD1FunctorGG'}:IsD1Functor(GoF) (funaa'=> (G'(Fa)o(F'a))a').Proof.snrapplyBuild_IsD1Functor.-introsabfgpa'b'f'g'p'.apply(dfmap2__(dfmap2FF'p')).-introsaa'.apply(dfmap2__(dfmap_idFF'a') $@'dfmap_idGG'_).-introsabcfga'b'c'f'g'.apply(dfmap2__(dfmap_compFF'f'g') $@'dfmap_compGG'__).Defined.EndCompositeFunctor.Local Definitionpointwise_prod{AB:Type} (DA:A->Type) (DB:B->Type)(x:A*B) :=DA(fstx) *DB(sndx).Global Instanceisdgraph_prod{AB:Type} (DA:A->Type) `{IsDGraphADA}(DB:B->Type) `{IsDGraphBDB}:IsDGraph(pointwise_prodDADB).Proof.intros[a1b1] [a2b2] [fg] [a1'b1'] [a2'b2'].exact(DHomfa1'a2'*DHomgb1'b2').Defined.Global Instanceisd01cat_prod{AB:Type} (DA:A->Type) `{IsD01CatADA}(DB:B->Type) `{IsD01CatBDB}:IsD01Cat(pointwise_prodDADB).Proof.srapplyBuild_IsD01Cat.-intros[ab] [a'b'].exact(DIda',DIdb').-intros[a1b1] [a2b2] [a3b3] [f2g2] [f1g1] [a1'b1'] [a2'b2'] [a3'b3'].intros[f2'g2'] [f1'g1'].exact(f2'$o'f1',g2'$o'g1').Defined.Global Instanceisd0gpd_prod{AB:Type} (DA:A->Type) `{IsD0GpdADA}(DB:B->Type) `{IsD0GpdBDB}:IsD0Gpd(pointwise_prodDADB).Proof.intros[a1b1] [a2b2] [fg] [a1'b1'] [a2'b2'] [f'g'].exact(f'^$',g'^$').Defined.Global Instanceisd2graph_prod{AB:Type} (DA:A->Type) `{IsD2GraphADA}(DB:B->Type) `{IsD2GraphBDB}:IsD2Graph(pointwise_prodDADB).Proof.intros[a1b1] [a2b2] [a1'b1'] [a2'b2'].srapplyisdgraph_prod.Defined.Global Instanceisd1cat_prod{AB:Type} (DA:A->Type) `{IsD1CatADA}(DB:B->Type) `{IsD1CatBDB}:IsD1Cat(pointwise_prodDADB).Proof.snrapplyBuild_IsD1Cat.-introsab1ab2ab1'ab2'.srapplyisd01cat_prod.-introsab1ab2ab1'ab2'.srapply(isd0gpd_prod__).-introsab1ab2ab3fgab1'ab2'ab3'[f'g'].introshk1hk2pqhk1'hk2'[p'q'].exact(f'$@L'p',g'$@L'q').-introsab1ab2ab3fgab1'ab2'ab3'[f'g'].introshk1hk2pqhk1'hk2'[p'q'].exact(p'$@R'f',q'$@R'g').-introsab1ab2ab3ab4fg1fg2fg3.introsab1'ab2'ab3'ab4'[f1'g1'] [f2'g2'] [f3'g3'].exact(dcat_assocf1'f2'f3',dcat_assocg1'g2'g3').-introsab1ab2ab3ab4fg1fg2fg3.introsab1'ab2'ab3'ab4'[f1'g1'] [f2'g2'] [f3'g3'].exact(dcat_assoc_oppf1'f2'f3',dcat_assoc_oppg1'g2'g3').-introsab1ab2fgab1'ab2'[f'g'].exact(dcat_idlf',dcat_idlg').-introsab1ab2fgab1'ab2'[f'g'].exact(dcat_idrf',dcat_idrg').Defined.

--- Miscellaneous\DisplayedEquiv.html ---
DisplayedEquivLibrary DisplayedEquivRequireImportBasics.Overture.RequireImportBasics.Tactics.RequireImportBasics.Equivalences.RequireImportTypes.Sigma.RequireImportWildCat.Core.RequireImportWildCat.Displayed.RequireImportWildCat.Equiv.Equivalences in displayed wild categoriesClassDHasEquivs{A:Type} `{HasEquivsA}(D:A->Type) `{!IsDGraphD, !IsD2GraphD, !IsD01CatD, !IsD1CatD} :={DCatEquiv:forall{ab}, (a$<~>b) ->Da->Db->Type;DCatIsEquiv:forall{ab} {f:a$->b} {fe:CatIsEquivf} {a'} {b'},DHomfa'b'->Type;dcate_fun:forall{ab} {f:a$<~>b} {a'} {b'},DCatEquivfa'b'->DHomfa'b';dcate_isequiv:forall{ab} {f:a$<~>b} {a'} {b'}(f':DCatEquivfa'b'),DCatIsEquiv(dcate_funf');dcate_buildequiv:forall{ab} {f:a$->b} `{!CatIsEquivf} {a'} {b'}(f':DHomfa'b') {fe':DCatIsEquivf'},DCatEquiv(Build_CatEquivf)a'b';dcate_buildequiv_fun:forall{ab} {f:a$->b} `{!CatIsEquivf}{a'} {b'} (f':DHomfa'b') {fe':DCatIsEquivf'},DGpdHom(cate_buildequiv_funf)(dcate_fun(dcate_buildequivf'(fe':=fe')))f';dcate_inv':forall{ab} {f:a$<~>b} {a'} {b'} (f':DCatEquivfa'b'),DHom(cate_inv'__f)b'a';dcate_issect':forall{ab} {f:a$<~>b} {a'} {b'} (f':DCatEquivfa'b'),DGpdHom(cate_issect'__f) (dcate_inv'f'$o'dcate_funf') (DIda');dcate_isretr':forall{ab} {f:a$<~>b} {a'} {b'} (f':DCatEquivfa'b'),DGpdHom(cate_isretr'__f) (dcate_funf'$o'dcate_inv'f') (DIdb');dcatie_adjointify:forall{ab} {f:a$->b} {g:b$->a}{r:f$og$==Idb} {s:g$of$==Ida} {a'} {b'} (f':DHomfa'b')(g':DHomgb'a') (r':DGpdHomr(f'$o'g') (DIdb'))(s':DGpdHoms(g'$o'f') (DIda')),@DCatIsEquiv___(catie_adjointifyfgrs)__f';}.Being an equivalence is a typeclass.Existing ClassDCatIsEquiv.Global Existing Instancedcate_isequiv.Coerciondcate_fun:DCatEquiv>->DHom.DefinitionBuild_DCatEquiv{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$->b} `{!CatIsEquivf} {a':Da} {b':Db}(f':DHomfa'b') {fe':DCatIsEquivf'}:DCatEquiv(Build_CatEquivf)a'b':=dcate_buildequivf'(fe':=fe').ConstructDCatEquivvia adjointify.Definitiondcate_adjointify{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$->b} {g:b$->a}{r:f$og$==Idb} {s:g$of$==Ida} {a'} {b'}(f':DHomfa'b') (g':DHomgb'a') (r':DHomr(f'$o'g') (DIdb'))(s':DHoms(g'$o'f') (DIda')):DCatEquiv(cate_adjointifyfgrs)a'b':=Build_DCatEquivf'(fe':=dcatie_adjointifyf'g'r's').Construct the entire inverse equivalenceDefinitiondcate_inv{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$<~>b} {a':Da} {b':Db} (f':DCatEquivfa'b'):DCatEquiv(f^-1$)b'a'.Proof.snrapplydcate_adjointify.-exact(dcate_inv'f').-exactf'.-exact(dcate_issect'f').-exact(dcate_isretr'f').Defined.Notation"f ^-1$'" := (dcate_invf).Witness thatf'is a section ofdcate_invf'in addition todcate_inv'f'.Definitiondcate_issect{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$<~>b} {a':Da} {b':Db} (f':DCatEquivfa'b'):DGpdHom(cate_issectf) (dcate_funf'^-1$' $o'f') (DIda').Proof.refine(_$@'dcate_issect'f').refine(_$@R'(dcate_funf')).applydcate_buildequiv_fun.Defined.Witness thatf'is a retraction ofdcate_invf'in addition todcate_inv'f'.Definitiondcate_isretr{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$<~>b} {a':Da} {b':Db} (f':DCatEquivfa'b'):DGpdHom(cate_isretrf) (dcate_funf'$o'f'^-1$') (DIdb').Proof.refine(_$@'dcate_isretr'f').refine(dcate_funf'$@L'_).applydcate_buildequiv_fun.Defined.Ifg'is a section of an equivalence, then it is the inverse.Definitiondcate_inverse_sect{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$<~>b} {g:b$->a} {p:f$og$==Idb}{a':Da} {b':Db} (f':DCatEquivfa'b') (g':DHomgb'a')(p':DGpdHomp(dcate_funf'$o'g') (DIdb')):DGpdHom(cate_inverse_sectfgp) (dcate_funf'^-1$')g'.Proof.refine((dcat_idr_)^$' $@'_).refine((_$@L'p'^$') $@'_).1:exactisd0gpd_hom.refine(dcat_assoc_opp___$@'_).refine(dcate_issectf'$@R'_$@'_).applydcat_idl.Defined.Ifg'is a retraction of an equivalence, then it is the inverse.Definitiondcate_inverse_retr{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$<~>b} {g:b$->a} {p:g$of$==Ida}{a':Da} {b':Db} (f':DCatEquivfa'b') (g':DHomgb'a')(p':DGpdHomp(g'$o'f') (DIda')):DGpdHom(cate_inverse_retrfgp) (dcate_funf'^-1$')g'.Proof.refine((dcat_idl_)^$' $@'_).refine((p'^$' $@R'_) $@'_).1:exactisd0gpd_hom.refine(dcat_assoc___$@'_).refine(_$@L'dcate_isretrf'$@'_).applydcat_idr.Defined.It follows that the inverse of the equivalence you get by adjointification is homotopic to the inverseg'provided.Definitiondcate_inv_adjointify{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$->b} {g:b$->a} {r:f$og$==Idb}{s:g$of$==Ida} {a':Da} {b':Db} (f':DHomfa'b')(g':DHomgb'a') (r':DGpdHomr(f'$o'g') (DIdb'))(s':DGpdHoms(g'$o'f') (DIda')):DGpdHom(cate_inv_adjointifyfgrs)(dcate_fun(dcate_adjointifyf'g'r's')^-1$')g'.Proof.applydcate_inverse_sect.exact((dcate_buildequiv_funf'$@R'_) $@'r').Defined.If the base category has equivalences and the displayed category has displayed equivalences, then the total category has equivalences.Global Instancehasequivs_total{A} (D:A->Type) `{DHasEquivsAD}:HasEquivs(sigD).Proof.snrapplyBuild_HasEquivs.1:{intros[aa'] [bb'].exact{f:a$<~>b&DCatEquivfa'b'}. }all:introsaa'bb'[ff'].-exact{fe:CatIsEquivf&DCatIsEquivf'}.-existsf.exactf'.-exact(cate_isequivf;dcate_isequivf').-intros[fefe'].exact(Build_CatEquivf(fe:=fe);Build_DCatEquivf'(fe':=fe')).-intros?;exists(cate_buildequiv_funf).exact(dcate_buildequiv_funf').-exists(f^-1$).exact(f'^-1$').-exact(cate_issectf;dcate_issectf').-exact(cate_isretrf;dcate_isretrf').-intros[gg'] [rr'] [ss'].exact(catie_adjointifyfgrs;dcatie_adjointifyf'g'r's').Defined.The identity morphism is an equivalenceGlobal Instancedcatie_id{A} {D:A->Type} `{DHasEquivsAD}{a:A} (a':Da):DCatIsEquiv(DIda'):=dcatie_adjointify(DIda') (DIda') (dcat_idl(DIda')) (dcat_idr(DIda')).Definitiondid_cate{A} {D:A->Type} `{DHasEquivsAD}{a:A} (a':Da):DCatEquiv(id_catea)a'a':=Build_DCatEquiv(DIda').Global Instancereflexive_dcate{A} {D:A->Type} `{DHasEquivsAD} {a:A}:Reflexive(DCatEquiv(id_catea)):=did_cate.Anything homotopic to an equivalence is an equivalence. This should not be an instance.Definitiondcatie_homotopic{A} {D:A->Type} `{DHasEquivsAD} {ab:A}{f:a$->b} `{!CatIsEquivf} {g:a$->b} {p:f$==g} {a':Da}{b':Db} (f':DHomfa'b') `{fe': !DCatIsEquivf'} {g':DHomga'b'}(p':DGpdHompf'g'):DCatIsEquiv(fe:=catie_homotopicfp)g'.Proof.snrapplydcatie_adjointify.-exact(Build_DCatEquiv(fe':=fe')f')^-1$'.-refine(p'^$' $@R'_$@'_).1:exactisd0gpd_hom.refine((dcate_buildequiv_funf')^$' $@R'_$@'_).1:exactisd0gpd_hom.applydcate_isretr.-refine(_$@L'p'^$' $@'_).1:exactisd0gpd_hom.refine(_$@L'(dcate_buildequiv_funf')^$' $@'_).1:exactisd0gpd_hom.applydcate_issect.Defined.Equivalences can be composed.Global Instancedcompose_catie{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {g:b$<~>c} {f:a$<~>b} {a':Da} {b':Db} {c':Dc}(g':DCatEquivgb'c') (f':DCatEquivfa'b'):DCatIsEquiv(dcate_fung'$o'f').Proof.snrapplydcatie_adjointify.-exact(dcate_funf'^-1$' $o'g'^-1$').-refine(dcat_assoc___$@'_).refine(_$@L'dcat_assoc_opp___$@'_).refine(_$@L'(dcate_isretr_$@R'_) $@'_).refine(_$@L'dcat_idl_$@'_).applydcate_isretr.-refine(dcat_assoc_opp___$@'_).refine(dcat_assoc___$@R'_$@'_).refine(((_$@L'dcate_issect_) $@R'_) $@'_).refine((dcat_idr_$@R'_) $@'_).applydcate_issect.Defined.Global Instancedcompose_catie'{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {g:b$->c} `{!CatIsEquivg} {f:a$->b} `{!CatIsEquivf}{a':Da} {b':Db} {c':Dc}(g':DHomgb'c') `{ge': !DCatIsEquivg'}(f':DHomfa'b') `{fe': !DCatIsEquivf'}:DCatIsEquiv(fe:=compose_catie'gf) (g'$o'f').Proof.pose(ff:=Build_DCatEquiv(fe':=fe')f').pose(gg:=Build_DCatEquiv(fe':=ge')g').nrefine(dcatie_homotopic(fe':=dcompose_catieggff)__).exact(dcate_buildequiv_fun_$@@'dcate_buildequiv_fun_).Defined.Definitiondcompose_cate{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {g:b$<~>c} {f:a$<~>b} {a':Da} {b':Db} {c':Dc}(g':DCatEquivgb'c') (f':DCatEquivfa'b'):DCatEquiv(compose_categf)a'c':=Build_DCatEquiv(dcate_fung'$o'f').Notation"g $oE' f" := (dcompose_categf).Composing equivalences commutes with composing the underlying maps.Definitiondcompose_cate_fun{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {g:b$<~>c} {f:a$<~>b} {a':Da} {b':Db} {c':Dc}(g':DCatEquivgb'c') (f':DCatEquivfa'b'):DGpdHom(compose_cate_fungf)(dcate_fun(g'$oE'f')) (dcate_fung'$o'f'):=dcate_buildequiv_fun_.Definitiondcompose_cate_funinv{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {g:b$<~>c} {f:a$<~>b} {a':Da} {b':Db} {c':Dc}(g':DCatEquivgb'c') (f':DCatEquivfa'b'):DGpdHom(compose_cate_funinvgf)(dcate_fung'$o'f') (dcate_fun(g'$oE'f')).Proof.applydgpd_rev.applydcate_buildequiv_fun.Defined.The underlying map of the identity equivalence is homotopic to the identity.Definitiondid_cate_fun{A} {D:A->Type} `{DHasEquivsAD} {a:A} (a':Da):DGpdHom(id_cate_funa) (dcate_fun(did_catea')) (DIda'):=dcate_buildequiv_fun_.Composition of equivalences is associative.Definitiondcompose_cate_assoc{A} {D:A->Type} `{DHasEquivsAD}{abcd:A} {f:a$<~>b} {g:b$<~>c} {h:c$<~>d} {a'} {b'} {c'} {d'}(f':DCatEquivfa'b') (g':DCatEquivgb'c') (h':DCatEquivhc'd'):DGpdHom(compose_cate_assocfgh) (dcate_fun((h'$oE'g') $oE'f'))(dcate_fun(h'$oE'(g'$oE'f'))).Proof.refine(dcompose_cate_fun_f'$@'_$@'dcat_assoc(dcate_funf')g'h'$@'_$@'dcompose_cate_funinvh'_).-apply(dcompose_cate_funh'g'$@R'_).-apply(_$@L'dcompose_cate_funinvg'f').Defined.Definitiondcompose_cate_idl{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$<~>b}  {a':Da} {b':Db} (f':DCatEquivfa'b'):DGpdHom(compose_cate_idlf) (dcate_fun(did_cateb'$oE'f'))(dcate_funf').Proof.refine(dcompose_cate_fun_f'$@'_$@'dcat_idl(dcate_funf')).apply(dcate_buildequiv_fun_$@R'_).Defined.Definitiondcompose_cate_idr{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {f:a$<~>b} {a':Da} {b':Db} (f':DCatEquivfa'b'):DGpdHom(compose_cate_idrf) (dcate_fun(f'$oE'did_catea'))(dcate_funf').Proof.refine(dcompose_cate_funf'_$@'_$@'dcat_idr(dcate_funf')).rapply(_$@L'dcate_buildequiv_fun_).Defined.Some more convenient equalities for equivalences. The naming scheme is similar toPathGroupoids.v.Definitiondcompose_V_hh{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {f:b$<~>c} {g:a$->b} {a':Da} {b':Db} {c':Dc}(f':DCatEquivfb'c') (g':DHomga'b'):DGpdHom(compose_V_hhfg) (dcate_funf'^-1$' $o'(dcate_funf'$o'g'))g':= (dcat_assoc_opp___) $@' (dcate_issectf'$@R'g') $@'dcat_idlg'.Definitiondcompose_h_Vh{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {f:c$<~>b} {g:a$->b} {a':Da} {b':Db} {c':Dc}(f':DCatEquivfc'b') (g':DHomga'b'):DGpdHom(compose_h_Vhfg) (dcate_funf'$o'(dcate_funf'^-1$' $o'g'))g':= (dcat_assoc_opp___) $@' (dcate_isretrf'$@R'g') $@'dcat_idlg'.Definitiondcompose_hh_V{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {f:b$->c} {g:a$<~>b} {a':Da} {b':Db} {c':Dc}(f':DHomfb'c') (g':DCatEquivga'b'):DGpdHom(compose_hh_Vfg) ((f'$o'g') $o'g'^-1$')f':=dcat_assoc___$@' (f'$@L'dcate_isretrg') $@'dcat_idrf'.Definitiondcompose_hV_h{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {f:b$->c} {g:b$<~>a} {a':Da} {b':Db} {c':Dc}(f':DHomfb'c') (g':DCatEquivgb'a'):DGpdHom(compose_hV_hfg) ((f'$o'g'^-1$') $o'g')f':=dcat_assoc___$@' (f'$@L'dcate_issectg') $@'dcat_idrf'.Equivalences are both monomorphisms and epimorphisms (but not the converse).Definitiondcate_monic_equiv{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {e:a$<~>b} {a':Da} {b':Db} (e':DCatEquivea'b'):DMonic(mon:=cate_monic_equive) (dcate_fune').Proof.introscfgpc'f'g'p'.refine((dcompose_V_hhe'_)^$' $@'_$@'dcompose_V_hhe'_).1:exactisd0gpd_hom.exact(_$@L'p').Defined.Definitiondcate_epic_equiv{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {e:a$<~>b} {a':Da} {b':Db} (e':DCatEquivea'b'):DEpic(epi:=cate_epic_equive) (dcate_fune').Proof.introscfgpc'f'g'p'.refine((dcompose_hh_V_e')^$' $@'_$@'dcompose_hh_V_e').1:exactisd0gpd_hom.exact(p'$@R'_).Defined.Some lemmas for moving equivalences around.  Naming based on EquivGroupoids.v.Definitiondcate_moveR_eM{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {e:b$<~>a} {f:a$->c} {g:b$->c}{p:f$==g$oe^-1$} {a':Da} {b':Db} {c':Dc}(e':DCatEquiveb'a') (f':DHomfa'c') (g':DHomgb'c')(p':DGpdHompf'(g'$o'e'^-1$')):DGpdHom(cate_moveR_eMefgp) (f'$o'e')g'.Proof.apply(dcate_epic_equive'^-1$').exact(dcompose_hh_V__$@'p').Defined.Definitiondcate_moveR_Ve{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {e:b$<~>c} {f:a$->c} {g:a$->b}{p:f$==e$og} {a':Da} {b':Db} {c':Dc}(e':DCatEquiveb'c') (f':DHomfa'c') (g':DHomga'b')(p':DGpdHompf'(dcate_fune'$o'g')):DGpdHom(cate_moveR_Veefgp) (dcate_fune'^-1$' $o'f')g'.Proof.apply(dcate_monic_equive').exact(dcompose_h_Vh__$@'p').Defined.Definitiondcate_moveL_V1{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {e:a$<~>b} {f:b$->a} {p:e$of$==Idb}{a':Da} {b':Db} {e':DCatEquivea'b'}(f':DHomfb'a') (p':DGpdHomp(dcate_fune'$o'f') (DIdb')):DGpdHom(cate_moveL_V1fp)f'(dcate_fune'^-1$').Proof.apply(dcate_monic_equive').nrapply(p'$@' (dcate_isretre')^$').exactisd0gpd_hom.Defined.Definitiondcate_moveL_1V{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {e:a$<~>b} {f:b$->a} {p:f$oe$==Ida}{a':Da} {b':Db} {e':DCatEquivea'b'}(f':DHomfb'a') (p':DGpdHomp(f'$o'e') (DIda')):DGpdHom(cate_moveL_1Vfp)f'(dcate_fune'^-1$').Proof.apply(dcate_epic_equive').nrapply(p'$@' (dcate_issecte')^$').exactisd0gpd_hom.Defined.Definitiondcate_moveR_V1{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {e:a$<~>b} {f:b$->a} {p:Idb$==e$of}{a':Da} {b':Db} {e':DCatEquivea'b'}(f':DHomfb'a') (p':DGpdHomp(DIdb') (dcate_fune'$o'f')):DGpdHom(cate_moveR_V1fp) (dcate_fune'^-1$')f'.Proof.apply(dcate_monic_equive').exact(dcate_isretre'$@'p').Defined.Definitiondcate_moveR_1V{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {e:a$<~>b} {f:b$->a} {p:Ida$==f$oe}{a':Da} {b':Db} {e':DCatEquivea'b'}(f':DHomfb'a') (p':DGpdHomp(DIda') (f'$o'e')):DGpdHom(cate_moveR_1Vfp) (dcate_fune'^-1$')f'.Proof.apply(dcate_epic_equive').exact(dcate_issecte'$@'p').Defined.Lemmas about the underlying map of an equivalence.Definitiondcate_inv2{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {ef:a$<~>b} {p:cate_fune$==cate_funf}{a':Da} {b':Db} {e':DCatEquivea'b'} {f':DCatEquivfa'b'}(p':DGpdHomp(dcate_fune') (dcate_funf')):DGpdHom(cate_inv2p) (dcate_fune'^-1$') (dcate_funf'^-1$').Proof.applydcate_moveL_V1.rapply((p'^$' $@R'_) $@'dcate_isretr_).exactisd0gpd_hom.Defined.Definitiondcate_inv_compose{A} {D:A->Type} `{DHasEquivsAD}{abc:A} {e:a$<~>b} {f:b$<~>c} {a':Da} {b':Db} {c':Dc}(e':DCatEquivea'b') (f':DCatEquivfb'c'):DGpdHom(cate_inv_composeef)(dcate_fun(f'$oE'e')^-1$') (dcate_fun(e'^-1$' $oE'f'^-1$')).Proof.refine(_$@' (dcompose_cate_fune'^-1$'f'^-1$')^$').-snrapplydcate_inv_adjointify.-exactisd0gpd_hom.Defined.Definitiondcate_inv_V{A} {D:A->Type} `{DHasEquivsAD}{ab:A} {e:a$<~>b} {a':Da} {b':Db}(e':DCatEquivea'b'):DGpdHom(cate_inv_Ve) (dcate_fun(e'^-1$')^-1$') (dcate_fune').Proof.applydcate_moveR_V1.applydgpd_rev.applydcate_issect.Defined.Any sufficiently coherent displayed functor preserves displayed equivalences.Global Instancediemap{AB:Type}{DA:A->Type} `{DHasEquivsADA} {DB:B->Type} `{DHasEquivsBDB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF', !IsD1FunctorFF'}{ab:A} {f:a$<~>b} {a':DAa} {b':DAb} (f':DCatEquivfa'b'):DCatIsEquiv(fe:=iemapFf) (dfmapFF'(dcate_funf')).Proof.refine(dcatie_adjointify(dfmapFF'(dcate_funf')) (dfmapFF'(dcate_funf'^-1$'))__).-refine((dfmap_compFF'(dcate_funf'^-1$')f')^$' $@'_$@'_).+exact(dfmap2FF'(dcate_isretr_)).+exact(dfmap_idFF'_).-refine((dfmap_compFF'(dcate_funf')f'^-1$')^$' $@'_$@'_).+exact(dfmap2FF'(dcate_issect_)).+exact(dfmap_idFF'_).Defined.Definitiondemap{AB:Type}{DA:A->Type} `{DHasEquivsADA} {DB:B->Type} `{DHasEquivsBDB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF', !IsD1FunctorFF'}{ab:A} {f:a$<~>b} {a':DAa} {b':DAb} (f':DCatEquivfa'b'):DCatEquiv(emapFf) (F'aa') (F'bb'):=Build_DCatEquiv(dfmapFF'(dcate_funf')).Definitiondemap_id{AB:Type}{DA:A->Type} `{DHasEquivsADA} {DB:B->Type} `{DHasEquivsBDB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF', !IsD1FunctorFF'}{a:A} {a':DAa}:DGpdHom(emap_idF)(dcate_fun(demapFF'(did_catea'))) (dcate_fun(did_cate(F'aa'))).Proof.refine(dcate_buildequiv_fun_$@'_).refine(dfmap2FF'(did_cate_funa') $@'_$@'_).-rapplydfmap_id.-applydgpd_rev.exact(did_cate_fun(F'aa')).Defined.Definitiondemap_compose{AB:Type}{DA:A->Type} `{DHasEquivsADA} {DB:B->Type} `{DHasEquivsBDB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF',isd1f: !IsD1FunctorFF'}{abc:A} {f:a$<~>b} {g:b$<~>c} {a':DAa} {b':DAb} {c':DAc}(f':DCatEquivfa'b') (g':DCatEquivgb'c'):DGpdHom(emap_composeFfg) (dcate_fun(demapFF'(g'$oE'f')))(dfmapFF'(dcate_fung') $o'dfmapFF'(dcate_funf')).Proof.refine(dcate_buildequiv_fun_$@'_).refine(dfmap2FF'(dcompose_cate_fun__) $@'_).nrapplydfmap_comp;exactisd1f.Defined.A variant.Definitiondemap_compose'{AB:Type}{DA:A->Type} `{DHasEquivsADA} {DB:B->Type} `{DHasEquivsBDB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF', !IsD1FunctorFF'}{abc:A} {f:a$<~>b} {g:b$<~>c} {a':DAa} {b':DAb} {c':DAc}(f':DCatEquivfa'b') (g':DCatEquivgb'c'):DGpdHom(emap_compose'Ffg) (dcate_fun(demapFF'(g'$oE'f')))(dcate_fun((demapFF'g') $oE'(demapFF'f'))).Proof.refine(demap_composeFF'f'g'$@'_).applydgpd_rev.refine(dcompose_cate_fun__$@'_).exact(dcate_buildequiv_fun_$@@'dcate_buildequiv_fun_).Defined.Definitiondemap_inv{AB:Type}{DA:A->Type} `{DHasEquivsADA} {DB:B->Type} `{DHasEquivsBDB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}(F':forall(a:A),DAa->DB(Fa)) `{!IsD0FunctorFF', !IsD1FunctorFF'}{ab:A} {e:a$<~>b} {a':DAa} {b':DAb} (e':DCatEquivea'b'):DGpdHom(emap_invFe)(dcate_fun(demapFF'e')^-1$') (dcate_fun(demapFF'e'^-1$')).Proof.refine(dcate_inv_adjointify____$@'_).applydgpd_rev.exact(dcate_buildequiv_fun_).Defined.When we have equivalences, we can define what it means for a displayed category to be univalent.Definitiondcat_equiv_path{A} {D:A->Type} `{DHasEquivsAD}{ab:A} (p:a=b) (a':Da) (b':Db):transportDpa'=b'->DCatEquiv(cat_equiv_pathabp)a'b'.Proof.introp'.destructp,p'.reflexivity.Defined.ClassIsDUnivalent1Cat{A} (D:A->Type) `{DHasEquivsAD} :={isequiv_dcat_equiv_path:forall{ab:A} (p:a=b)a'b',IsEquiv(dcat_equiv_pathpa'b')}.Global Existing Instanceisequiv_dcat_equiv_path.Definitiondcat_path_equiv{A} {D:A->Type} `{IsDUnivalent1CatAD}{ab:A} (p:a=b) (a':Da) (b':Db):DCatEquiv(cat_equiv_pathabp)a'b'->transportDpa'=b':= (dcat_equiv_pathpa'b')^-1.IfIsUnivalent1CatAandIsDUnivalent1CatD, then this is an equivalence byisequiv_functor_sigma.Definitiondcat_equiv_path_total{A} {D:A->Type} `{DHasEquivsAD}{ab:A} (a':Da) (b':Db): {p:a=b&p#a'=b'} -> {e:a$<~>b&DCatEquivea'b'}:=functor_sigma(cat_equiv_pathab) (funp=>dcat_equiv_pathpa'b').If the base category and the displayed category are both univalent, then the total category is univalent.Global Instanceisunivalent1cat_total{A} `{IsUnivalent1CatA} (D:A->Type)`{!IsDGraphD, !IsD2GraphD, !IsD01CatD, !IsD1CatD, !DHasEquivsD}`{!IsDUnivalent1CatD}:IsUnivalent1Cat(sigD).Proof.snrapplyBuild_IsUnivalent1Cat.introsaa'bb'.apply(isequiv_homotopic(dcat_equiv_path_total__o(path_sigma_uncurriedDaa'bb')^-1)).intros[];reflexivity.Defined.

--- Miscellaneous\Division.html ---
DivisionLibrary DivisionRequireImportBasics.OvertureBasics.TacticsBasics.TruncBasics.ClassesBasics.PathGroupoidsBasics.EquivalencesTypes.SigmaSpaces.Nat.CoreBasics.DecidableBasics.IffTypes.ProdList.TheoryTypes.SumTypes.Arrow.LocalSetUniverseMinimizationToSet.Local OpenScopenat_scope.Division of natural numbersDivisibilityWe define divisibility as a relation between natural numbers.ClassNatDivides(nm:nat) :Type0:=nat_divides: {k:nat&k*n=m}.Notation"( n | m )" := (NatDividesnm) :nat_scope.Any number divides0.Global Instancenat_divides_zero_rn: (n| 0):= (0;idpath).1divides any number.Global Instancenat_divides_one_ln: (1 |n):= (n;nat_mul_one_r_).Any number divides itself. Divisibility is a reflexive relation.Global Instancenat_divides_refln: (n|n):= (1;nat_mul_one_l_).Global Instancereflexive_nat_divides:ReflexiveNatDivides:=nat_divides_refl.Divisibility is transitive.Definitionnat_divides_trans{nml} : (n|m) -> (m|l) -> (n|l).Proof.intros[xp] [yq].exists(y*x).lhs_Vnrapplynat_mul_assoc.lhsnrapply(ap_p).exactq.Defined.Hint Immediatenat_divides_trans:typeclass_instances.Global Instancetransitive_nat_divides:TransitiveNatDivides:= @nat_divides_trans.A left factor divides a product.Global Instancenat_divides_mul_l'nm: (n|n*m):= (m;nat_mul_comm__).A right factor divides a product.Global Instancenat_divides_mul_r'nm: (m|n*m):= (n;idpath).Divisibility of the product is implied by divisibility of the left factor.Global Instancenat_divides_mul_l{nm}l: (n|m) -> (n|m*l):=funH=>nat_divides_trans__.Divisibility of the product is implied by divisibility of the right factor.Global Instancenat_divides_mul_r{nm}l: (n|m) -> (n|l*m):=funH=>nat_divides_trans__.Multiplication is monotone with respect to divisibility.Global Instancenat_divides_mul_monotonenmlp: (n|m) -> (l|p) -> (n*l|m*p).Proof.intros[xr] [yq].exists(x*y).destructr,q.lhsnrapplynat_mul_assoc.rhsnrapplynat_mul_assoc.nrapply(ap(funx=>nat_mulx_)).lhs_Vnrapplynat_mul_assoc.rhs_Vnrapplynat_mul_assoc.nrapplyap.applynat_mul_comm.Defined.Divisibility of the sum is implied by divisibility of the summands.Global Instancenat_divides_addnml: (n|m) -> (n|l) -> (n|m+l).Proof.intros[xp] [yq].exists(x+y).destructp,q.nrapplynat_dist_r.Defined.Ifndivides a sum and the left summand, thenndivides the right summand.Definitionnat_divides_add_rnml: (n|m) -> (n|m+l) -> (n|l).Proof.intros[xp] [yq].exists(y-x).lhsnrapplynat_dist_sub_r.applynat_moveR_nV.lhsnrapplyq.lhsnrapplynat_add_comm.exact(ap_p^).Defined.Ifndivides a sum and the right summand, thenndivides the left summand.Definitionnat_divides_add_lnml: (n|l) -> (n|m+l) -> (n|m).Proof.rewritenat_add_comm;applynat_divides_add_r.Defined.Divisibility of the difference is implied by divisibility of the minuend and subtrahend.Global Instancenat_divides_subnml: (n|m) -> (n|l) -> (n|m-l).Proof.intros[xp] [yq].exists(x-y).destructp,q.nrapplynat_dist_sub_r.Defined.The divisor is greater than zero when the divident is greater than zero.Definitiongt_zero_dividesnm(d: (n|m)) (gt0: 0 <m): 0 <n.Proof.destructdas[dH].destructH.destruct(nat_zero_or_gt_zeron)as[z|s].2:exacts.(* The remaining case is impossible. *)destructz;cbningt0.rewritenat_mul_zero_ringt0.exactgt0.Defined.Divisibility implies that the divisor is less than or equal to the dividend.Definitionleq_dividesnm: 0 <m-> (n|m) ->n<=m.Proof.introsH1[xp].destructp,x.1:contradiction(not_lt_zero_r_H1).rapply(leq_mul_l__0).Defined.The divisor is strictly less than the dividend when the other factor is greater than one.Definitionlt_dividesnm(d: (n|m)) (gt0: 0 <m) (gt1: 1 <d.1):n<m.Proof.rewrite<-d.2.snrapply(lt_leq_lt_trans(m:=1*n)).1:rapply(leq_mul_l__0).srapply(nat_mul_r_strictly_monotone(l:=0)).rapply(gt_zero_dividesnm).Defined.Divisibility is antisymmetricDefinitionnat_divides_antisymnm: (n|m) -> (m|n) ->n=m.Proof.introsH1H2.destructm;only1:exact(H2.2^ @nat_mul_zero_r_).destructn;only1:exact((nat_mul_zero_r_)^ @H1.2).snrapplyleq_antisym;nrapplyleq_divides;exact_.Defined.Global Instanceantisymmetric_divides:AntiSymmetricNatDivides:=nat_divides_antisym.Ifndividesm, then the other factor also dividesm.Global Instancedivides_divisornm(H: (n|m)) : (H.1 |m).Proof.existsn.lhsnrapplynat_mul_comm.exactH.2.Defined.Properties of divisionLocal Definitionnat_div_mod_unique_helperbq1q2r1r2:r1<b->r2<b->q1<q2->b*q1+r1<>b*q2+r2.Proof.introsH1H2H3p.rewrite2 (nat_add_comm(b*_))inp.applynat_moveL_nVinp.rewritenat_sub_l_add_rinp;only2:rapplynat_mul_l_monotone.rewrite<-nat_dist_sub_linp.rewritenat_add_comminp.applynat_moveR_nVinp.nrapply(snd(@leq_iff_not_gtb(r1-r2))).2:exact(lt_leq_lt_trans_H1).rewritep.snrapply(leq_mul_r__0).byapplyequiv_lt_lt_sub.Defined.Quotients and remainders are uniquely determined.Definitionnat_div_mod_uniquedq1q2r1r2:r1<d->r2<d->d*q1+r1=d*q2+r2->q1=q2/\r1=r2.Proof.introsH1H2p.destruct(nat_trichotomyq1q2)as[[q|q] |q].-contradiction(nat_div_mod_unique_helperdq1q2r1r2).-split;trivial.destructq.byapplyisinj_nat_add_linp.-bycontradiction(nat_div_mod_unique_helperdq2q1r2r1).Defined.Divisibility by a positive natural number is a hprop.Global Instanceishprop_nat_dividesnm: 0 <n->IsHProp(n|m).Proof.introsH.applyhprop_allpath.intros[xp] [yq].rapplypath_sigma_hprop.destructHas[|n];simpl.1:exact((nat_mul_one_r_)^ @p@q^ @nat_mul_one_r_).refine(fst(nat_div_mod_uniquen.+1xy0 0___)).lhsnrapplynat_add_zero_r.rhsnrapplynat_add_zero_r.rewrite2 (nat_mul_commn.+1).exact(p@q^).Defined.This specifies the behaviour ofnat_div_mod_helperwhenu<=y.Definitionnat_div_mod_helper_specxyqu(H:u<=y):let(q',u') :=nat_div_modxyquinx+y.+1 *q+ (y-u) =y.+1 *q'+ (y-u') /\u'<=y.Proof.introsdr.inductionxas[|xIHx]iny,q,u,H,d,r|- *;only1:bysplit.destructuas[|u].-destruct(IHxyq.+1y_)as[pH'].split;trivial.rewrite<-p,nat_sub_zero_r,nat_sub_cancel,nat_add_zero_r.simpl.byrewritenat_add_succ_r, <- 2nat_add_assoc,nat_mul_succ_r.-destruct(IHxyqu_)as[pH'].split;trivial.rewrite<-p, 2nat_add_succ_l, <-nat_add_succ_r.snrapplyap.rewritenat_sub_succ_r.applynat_succ_pred.rapplylt_moveL_nV.Defined.Division and modulo can be put in quotient-remainder form.Definitionnat_div_mod_specxy:x=y* (x/y) +xmody.Proof.destructyas[|y];only1:reflexivity.poseproof(p:=fst(nat_div_mod_helper_specxy0y_)).byrewritenat_mul_zero_r,nat_sub_cancel, 2nat_add_zero_rinp.Defined.Definitionnat_div_mod_spec'xy:x-y* (x/y) =xmody.Proof.applynat_moveR_nV.rhsnrapplynat_add_comm.applynat_div_mod_spec.Defined.Definitionnat_div_mod_spec''xy:x-xmody=y* (x/y).Proof.applynat_moveR_nV.applynat_div_mod_spec.Defined.Definitionnat_mod_lt_r'nmr:r<m->nmodm<m.Proof.introsH;destructH;only1:exact_.rapply(lt_leq_lt_trans(m:=m)).Defined.Hint Immediatenat_mod_lt_r':typeclass_instances.nmodulomis less thanm.Global Instancenat_mod_lt_rnm: 0 <m->nmodm<m:=nat_mod_lt_r'nm0.nmodulomis less than or equal tom.Global Instancenat_mod_leq_lnm:nmodm<=n.Proof.rewrite<-nat_div_mod_spec'.rapplyleq_moveR_nV.Defined.Division is unique.Definitionnat_div_uniquexyqr(H:r<y) (p:y*q+r=x) :x/y=q:=fst(nat_div_mod_uniquey(x/y)q(xmody)r__(p@nat_div_mod_specxy)^).Modulo is unique.Definitionnat_mod_uniquexyqr(H:r<y) (p:y*q+r=x) :xmody=r:=snd(nat_div_mod_uniquey(x/y)q(xmody)r__(p@nat_div_mod_specxy)^).0divided by any number is0.Definitionnat_div_zero_ln: 0 /n= 0.Proof.byinductionn.Defined.ndivided by0is0by convention.Definitionnat_div_zero_rn:n/ 0 = 0 :=idpath.ndivided by1isn.Definitionnat_div_one_rn:n/ 1 =n.Proof.lhs_Vnrapplynat_mul_one_l.lhs_Vnrapplynat_add_zero_r.symmetry;applynat_div_mod_spec.Defined.ndivided bynis1.Definitionnat_div_canceln: 0 <n->n/n= 1.Proof.intros[|m_];trivial.nrapply(nat_div_unique___0);only1:exact_.lhsnrapplynat_add_zero_r.nrapplynat_mul_one_r.Defined.A number divided by a larger number is 0.Definitionnat_div_ltnm:n<m->n/m= 0.Proof.introsH.snrapply(nat_div_unique____H).byrewritenat_mul_zero_r,nat_add_zero_l.Defined.n*mdivided bynism.Definitionnat_div_mul_cancel_lnm: 0 <n-> (n*m) /n=m.Proof.introsH.nrapply(nat_div_unique____H).applynat_add_zero_r.Defined.n*mdivided bynism.Definitionnat_div_mul_cancel_rnm: 0 <m-> (n*m) /m=n.Proof.rewritenat_mul_comm.applynat_div_mul_cancel_l.Defined.More generally,n*m+kdivided bynism+k/n.Definitionnat_div_mul_add_cancel_lnmk: 0 <n-> (n*m+k) /n=m+k/n.Proof.introsH.rapply(nat_div_unique___(kmodn)_).rewritenat_dist_l.lhs_Vnrapplynat_add_assoc.f_ap.symmetry;applynat_div_mod_spec.Defined.Definitionnat_div_mul_add_cancel_rnmk: 0 <m-> (n*m+k) /m=n+k/m.Proof.rewritenat_mul_comm.applynat_div_mul_add_cancel_l.Defined.Ifkis positive, then multiplication on the left is injective; that is, ifk*m=k*n, thenm=n.Definitionisinj_nat_mul_lk: 0 <k->IsInjective(nat_mulk).Proof.introskpmnp.lhs_Vrapply(nat_div_mul_cancel_lk).rhs_Vrapply(nat_div_mul_cancel_lk).exact(ap(funx=>x/k)p).Defined.Ifkis positive, then multiplication on the right is injective; that is, ifm*k=n*k, thenm=n.Definitionisinj_nat_mul_rk: 0 <k->IsInjective(funn=>nat_mulnk).Proof.introskpmnp.lhs_Vrapply(nat_div_mul_cancel_r_k).rhs_Vrapply(nat_div_mul_cancel_r_k).exact(ap(funx=>x/k)p).Defined.Whenddivides one of the summands, division distributes over addition.Definitionnat_div_distnmd: (d|n) -> (n+m) /d=n/d+m/d.Proof.destructd.1:reflexivity.intros[x[]].rewritenat_div_mul_cancel_r. 2:exact_.rapplynat_div_mul_add_cancel_r.Defined.Definitionnat_div_dist'nmd: (d|m) -> (n+m) /d=n/d+m/d.Proof.introsH.rewrite(nat_add_commnm).rhs_Vnrapplynat_add_comm.rapplynat_div_dist.Defined.In general,n*(m/n)is less than or equal tom.Definitionnat_leq_mul_div_lnm:n* (m/n) <=m.Proof.set(tmp:=n* (m/n));rewrite(nat_div_mod_specmn);unfoldtmp;cleartmp.exact_.Defined.Whenndividesm, they are equal.Definitionnat_mul_div_cancel_rnm: (n|m) -> (m/n) *n=m.Proof.destructn.{intros[k[]].cbn.symmetry;applynat_mul_zero_r. }intros[k[]].f_ap.rapplynat_div_mul_cancel_r.Defined.Definitionnat_mul_div_cancel_lnm: (n|m) ->n* (m/n) =m.Proof.rewritenat_mul_comm.applynat_mul_div_cancel_r.Defined.Division by non-zerokis strictly monotone ifkdivides the larger number.Definitionnat_div_strictly_monotone_r{nml}k:l<k->n<m-> (k|m) ->n/k<m/k.Proof.introslknmkm.applygt_iff_not_leq.intromknk.apply(@gt_iff_not_leqmn);only1:applynm.rewrite<- (nat_mul_div_cancel_lkmkm).nrapply(leq_trans(y:=k* (n/k))).-rapplynat_mul_l_monotone.-applynat_leq_mul_div_l.Defined.0modulonis0.Definitionnat_mod_zero_ln: 0modn= 0.Proof.inductionn;trivial.applynat_sub_cancel.Defined.nmodulo0isn.Definitionnat_mod_zero_rn:nmod0 =n:=idpath.Definitionnat_mod_ltnk:k<n->kmodn=k.Proof.introsH.lhs_Vnrapplynat_div_mod_spec'.rewritenat_div_lt.-rewritenat_mul_zero_r.applynat_sub_zero_r.-exactH.Defined.nmodulo1is0.Definitionnat_mod_one_rn:nmod1 = 0.Proof.byinductionn.Defined.Ifmdividesn, thennmodm=0.Definitionnat_mod_dividesnm: (m|n) ->nmodm= 0.Proof.intros[xp].destructp.destructm.{simpl.applynat_mul_zero_r. }lhs_Vnrapplynat_div_mod_spec'.rewritenat_div_mul_cancel_r;only2:exact_.applynat_moveR_nV,nat_mul_comm.Defined.nmodm=0iffmdividesn.Definitionnat_mod_iff_dividesnm:nmodm= 0 <-> (m|n) .Proof.split.2:exact(nat_mod_divides__).introsp.exists(n/m).rewritenat_mul_comm.lhs_Vnrapplynat_add_zero_r.rewrite<-p.symmetry.nrapplynat_div_mod_spec.Defined.Divisibility is therefore decidable.Global Instancedecidable_nat_dividesnm:Decidable(n|m).Proof.nrapplydecidable_iff.1:applynat_mod_iff_divides.exact_.Defined.nmodulonis0.Definitionnat_mod_canceln:nmodn= 0.Proof.destructn;trivial.snrapply(nat_mod_unique__1);only1:exact_.lhsnrapplynat_add_zero_r.nrapplynat_mul_one_r.Defined.A number can be corrected so that it is divisible by subtracting the modulo.Global Instancenat_divides_sub_modnm: (n|m-mmodn).Proof.rewritenat_div_mod_spec''.exact_.Defined.Further Properties of division and moduloWe can cancel common factors on the left in a division.Definitionnat_div_cancel_mul_lnmk: 0 <k-> (k*n) / (k*m) =n/m.Proof.introkp.destruct(nat_zero_or_gt_zerom)as[[] |mp].1:byrewritenat_mul_zero_r.nrapply(nat_div_unique___(k* (nmodm))).1:rapplynat_mul_l_strictly_monotone.rewrite<-nat_mul_assoc.rewrite<-nat_dist_l.applyap.symmetry;applynat_div_mod_spec.Defined.We can cancel common factors on the right in a division.Definitionnat_div_cancel_mul_rnmk: 0 <k-> (n*k) / (m*k) =n/m.Proof.rewrite2 (nat_mul_comm_k).nrapplynat_div_cancel_mul_l.Defined.We can swap the order of division and multiplication on the left under certain conditions.Definitionnat_div_mul_lnmk: (m|n) ->k* (n/m) = (k*n) /m.Proof.introsH.destruct(nat_zero_or_gt_zerom)as[[] |mp].1:snrapplynat_mul_zero_r.rapply(nat_div_unique___0__)^.lhsnrapplynat_add_zero_r.lhsnrapplynat_mul_assoc.lhsnrapply(ap(funx=>x*_)).1:nrapplynat_mul_comm.lhs_Vnrapplynat_mul_assoc.snrapplyap.lhs_Vnrapplynat_add_zero_r.rhsnrapply(nat_div_mod_specnm).snrapplyap.symmetry.rapplynat_mod_divides.Defined.We can swap the order of division and multiplication on the right under certain conditions.Definitionnat_div_mul_rnmk: (m|n) -> (n/m) *k= (n*k) /m.Proof.rewrite2 (nat_mul_comm_k).snrapplynat_div_mul_l.Defined.Definitionnat_div_sub_modnm:n/m= (n-nmodm) /m.Proof.destruct(nat_zero_or_gt_zerom)as[[] |mp].1:reflexivity.symmetry.rewritenat_div_mod_spec''.rapplynat_div_mul_cancel_l.Defined.Dividing a quotient is the same as dividing by the product of the divisors.Definitionnat_div_div_lnmk: (n/m) /k=n/ (m*k).Proof.destruct(nat_zero_or_gt_zerok)as[[] |kp].1:byrewritenat_mul_zero_r.destruct(nat_zero_or_gt_zerom)as[[] |mp].1:snrapplynat_div_zero_l.applynat_div_uniquewith(r:= (nmod(m*k)) /m).{apply(lt_lt_leq_trans(m:=(m*k)/m)).-rapplynat_div_strictly_monotone_r.nrapply(nat_mod_lt_r'__0_).exact(nat_mul_strictly_monotonempkp).-byrewritenat_div_mul_cancel_l. }transitivity((m* (k* (n/ (m*k)))) /m+ (nmod(m*k)) /m).-f_ap.symmetry;rapplynat_div_mul_cancel_l.-rewritenat_mul_assoc.lhs_Vnrapplynat_div_dist.1:exact_.apply(ap(funx=>x/m)).symmetry;applynat_div_mod_spec.Defined.Dividing a number by a quotient is the same as dividing the product of the number with the denominator of the quotient by the numerator of the quotient.Definitionnat_div_div_rnmk: (k|m) ->n/ (m/k) = (n*k) /m.Proof.intros[dr].destruct(nat_zero_or_gt_zerok)as[[] |kp].1:byrewritenat_mul_zero_r,nat_div_zero_l.destructr.rhsnrapplynat_div_cancel_mul_r.2:exact_.applyap.rapplynat_div_mul_cancel_r.Defined.A variant ofnat_div_div_rwithout the divisibility assumption, by modifyingmto become divisible.Definitionnat_div_div_r'nmk:n/ (m/k) = (n*k) / (m-mmodk).Proof.rewrite(nat_div_sub_modmk).rapplynat_div_div_r.Defined.We can cancel common factors on the left in a modulo.Definitionnat_mod_mul_lnmk: (k*n)mod(k*m) =k* (nmodm).Proof.destruct(nat_zero_or_gt_zerok)as[[] |kp].1:reflexivity.destruct(nat_zero_or_gt_zerom)as[[] |mp].1:byrewritenat_mul_zero_r.apply(nat_mod_unique__(n/m)).1:rapplynat_mul_l_strictly_monotone.rewrite<-nat_mul_assoc.rewrite<-nat_dist_l.applyap.symmetry;applynat_div_mod_spec.Defined.We can cancel common factors on the right in a modulo.Definitionnat_mod_mul_rnmk: (n*k)mod(m*k) = (nmodm) *k.Proof.rewrite3 (nat_mul_comm_k).nrapplynat_mod_mul_l.Defined.Greatest Common DivisorThe greatest common divisor of0and a number is the number itself.Definitionnat_gcd_zero_ln:nat_gcd0n=n:=idpath.The greatest common divisor of a number and0is the number itself.Definitionnat_gcd_zero_rn:nat_gcdn0 =n.Proof.inductionn;simpl;only1:reflexivity.byrewritenat_sub_cancel.Defined.The greatest common divisor of1and any number is1.Definitionnat_gcd_one_ln:nat_gcd1n= 1 :=idpath.The greatest common divisor of any number and1is1.Definitionnat_gcd_one_rn:nat_gcdn1 = 1.Proof.destructn;trivial.simpl.destructn;trivial.rewritenat_sub_succ_l;only2:exact_.byrewritenat_sub_cancel.Defined.Idempotency.Definitionnat_gcd_idemn:nat_gcdnn=n.Proof.inductionn.1:reflexivity.unfoldnat_gcd;foldnat_gcd.byrewritenat_mod_cancel.Defined.We can prove that the greatest common divisor ofnandmdivides bothnandm. This proof requires strong induction.Definitionnat_divides_l_gcdnm: (nat_gcdnm|n) /\ (nat_gcdnm|m).Proof.revertnm;snrapplynat_ind_strong;introsnIHnm.destructn.1:split;exact_.destruct(IHn(mmodn.+1)_n.+1)as[H1H2].unfoldnat_gcd;foldnat_gcd.set(n':=n.+1)in*.split;only1:exactH2.set(r:=mmodn');rewrite(nat_div_mod_specmn');unfoldr;clearr.exact_.Defined.The greatest common divisor ofnandmdividesn.Global Instancenat_divides_l_gcd_lnm: (nat_gcdnm|n):=fst(nat_divides_l_gcdnm).The greatest common divisor ofnandmdividesm.Global Instancedivides_l_nat_gcd_rnm: (nat_gcdnm|m):=snd(nat_divides_l_gcdnm).We can prove that any common divisor ofnandmdivides the greatest common divisor ofnandm. It is in that sense the greatest.Global Instancenat_divides_r_gcdnmp: (p|n) -> (p|m) -> (p|nat_gcdnm).Proof.revertnmp;snrapplynat_ind_strong;introsnIHnmpH1H2.destructn;only1:exact_.unfoldnat_gcd;foldnat_gcd.applyIHn;only1,3:exact_.rewrite(nat_div_mod_specmn.+1)inH2.applynat_divides_add_rinH2;exact_.Defined.Definitionnat_divides_r_iff_divides_r_gcdnmp: (p|n) * (p|m) <-> (p|nat_gcdnm).Proof.split; [intros[H1H2] |introsH;split];exact_.Defined.Ifpis divisible by all common divisors ofnandm, andpis also a common divisor, then it must necesserily be equal to the greatest common divisor.Definitionnat_gcd_uniquenmp(H:forallq, (q|n) -> (q|m) -> (q|p)): (p|n) -> (p|m) ->nat_gcdnm=p.Proof.introsH1H2.rapplynat_divides_antisym.Defined.As a corollary of uniquness, we get that the greatest common divisor operation is commutative.Definitionnat_gcd_commnm:nat_gcdnm=nat_gcdmn.Proof.rapplynat_gcd_unique.Defined.nat_gcdis associative.Definitionnat_gcd_assocnmk:nat_gcdn(nat_gcdmk) =nat_gcd(nat_gcdnm)k.Proof.nrapplynat_gcd_unique.-introsqH1H2.rapplynat_divides_r_gcd.-rapply(nat_divides_trans(nat_divides_l_gcd_l__)).-applynat_divides_r_gcd;rapplynat_divides_trans.Defined.Ifnat_gcdnmis0, thennmust also be0.Definitionnat_gcd_is_zero_lnm:nat_gcdnm= 0 ->n= 0.Proof.introsH.generalize(nat_divides_l_gcd_lnm).rewriteH.intros[xp].exact(p^ @nat_mul_zero_r_).Defined.Ifnat_gcdnmis0, thenmmust also be0.Definitionnat_gcd_is_zero_rnm:nat_gcdnm= 0 ->m= 0.Proof.rewritenat_gcd_comm.applynat_gcd_is_zero_l.Defined.nat_gcdnmis0if and only if bothnandmare0.Definitionnat_gcd_zero_iff_zeronm:nat_gcdnm= 0 <->n= 0 /\m= 0.Proof.split.-split.+byapply(nat_gcd_is_zero_l_m).+byapply(nat_gcd_is_zero_rn).-intros[-> ->].reflexivity.Defined.nat_gcdis positive for positive inputs.Global Instancenat_gcd_posnm: 0 <n-> 0 <m-> 0 <nat_gcdnm.Proof.introsH1H2.applylt_iff_not_geq.introsH3;hnfinH3.applypath_zero_leq_zero_rinH3.applynat_gcd_zero_iff_zeroinH3.destructH3as[->].contradiction(not_lt_zero_r_H1).Defined.Definitionnat_gcd_l_add_r_mulnmk:nat_gcd(n+k*m)m=nat_gcdnm.Proof.rapplynat_gcd_unique.introsqH1H2.rapplynat_divides_r_gcd.rapply(nat_divides_add_l__(k*m)).Defined.Definitionnat_gcd_r_add_r_mulnmk:nat_gcdn(m+k*n) =nat_gcdnm.Proof.lhsnrapplynat_gcd_comm.rhsnrapplynat_gcd_comm.nrapplynat_gcd_l_add_r_mul.Defined.Definitionnat_gcd_l_add_rnm:nat_gcd(n+m)m=nat_gcdnm.Proof.rhs_Vnrapply(nat_gcd_l_add_r_mulnm1).byrewritenat_mul_one_l.Defined.Definitionnat_gcd_r_add_rnm:nat_gcdn(m+n) =nat_gcdnm.Proof.lhsnrapplynat_gcd_comm.rhsnrapplynat_gcd_comm.nrapplynat_gcd_l_add_r.Defined.Definitionnat_gcd_l_subnm:m<=n->nat_gcd(n-m)m=nat_gcdnm.Proof.introsH.lhs_Vnrapplynat_gcd_l_add_r.byrewrite(nat_add_sub_l_cancelH).Defined.Definitionnat_gcd_r_subnm:n<=m->nat_gcdn(m-n) =nat_gcdnm.Proof.introsH.lhsnrapplynat_gcd_comm.rhsnrapplynat_gcd_comm.rapplynat_gcd_l_sub.Defined.Bezout's IdentityBezout's identity states that for any two numbersnandm, their greatest common divisor can be written as a linear combination ofnandm. This is easy to state for the integers, however since we are working with the natural numbers, we need to be more careful. This is why we write the linear combination asa*n=d+b*mrather than the usuala*n+b*m=d.We define a predicate for triples of integers satisfying Bezout's identity.DefinitionNatBezoutnmd:Type0:=existsab,a*n=d+b*m.Existing ClassNatBezout.Global Instancenat_bezout_refl_lnk:NatBezoutnkn.Proof.byexists1, 0.Defined.Ifa*n=1+b*m, then the gcd ofnandmis1.Definitionnat_bezout_coprimenm:NatBezoutnm1 ->nat_gcdnm= 1.Proof.intros[a[bp]].rapplynat_gcd_unique.introsqH1H2.rapply(nat_divides_add_l__(b*m)).destructp;exact_.Defined.Definitionnat_bezout_commnmd: 0 <m->NatBezoutnmd->NatBezoutmnd.Proof.introsH[a[bp]].destruct(@equiv_leq_lt_or_eq0a_)as[|q].-exists(n*a.+1 *b.+1 -b), (m*a.+1 *b.+1 -a).rewrite2nat_dist_sub_r.applynat_moveR_nV.rewrite<-nat_add_comm,nat_add_assoc, <- (nat_add_commd).rewrite<-nat_sub_l_add_r.2: {applynat_mul_r_monotone.rewrite2nat_mul_succ_r.nrapply(leq_trans_(leq_add_l__)).rapply(leq_trans_(leq_add_r__)). }applynat_moveL_nV.rewritenat_add_comm.snrapply(ap011nat_addp).lhsnrapplynat_mul_comm.rhs_Vnrapplynat_mul_assoc.rhs_Vnrapplynat_mul_assoc.snrapplyap.lhs_Vnrapplynat_mul_assoc.rhsnrapplynat_mul_assoc.applynat_mul_comm.-destructq.exists0, 0.rewrite2nat_mul_zero_l,nat_add_zero_rin*.symmetryinp;symmetry.applyequiv_nat_add_zeroinp.bydestructp.Defined.Hint Immediatenat_bezout_comm:typeclass_instances.Global Instancenat_bezout_pos_lnm: 0 <n->NatBezoutnm(nat_gcdnm).Proof.pose(k:=n+m);assert(p:n+m=k)byreflexivity;clearbodyk.revertknmp;snrapplynat_ind_strong;hnf;introskIHknmqH.Given a sumn+m, we can always find another pairn'+m'equal to that sum such thatn'<m'. This extra hypothesis lets us prove the statement more directly.assert(H':foralln'm',n+m=n'+m'-> 0 <n'->n'<m'->NatBezoutn'm'(nat_gcdn'm')).{introsn'm'pH1H2;destructq.assert(m'<n+m)by(rewritep;change(0 +m'<n'+m');exact_).destruct(IHkm'_n'(m'-n') (nat_add_sub_r_cancel_)_)as[a[br]].exists(a+b),b.rewritenat_dist_r,r,nat_dist_sub_l, <-nat_add_assoc.rewritenat_add_sub_l_cancel;only2:rapplynat_mul_l_monotone.snrapply(ap(funx=>x+_)).rapplynat_gcd_r_sub. }destruct(nat_trichotomynm)as[[l|p] |r].-byapplyH'.-destructp.rewritenat_gcd_idem;exact_.-destruct(@equiv_leq_lt_or_eq0m_).+rewritenat_gcd_comm.rapplynat_bezout_comm.rapplyH'.applynat_add_comm.+destructp.rewritenat_gcd_zero_r;exact_.Defined.For strictly positive numbers, we have Bezout's identity in both directions.Definitionnat_bezout_posnm: 0 <n-> 0 <m->NatBezoutnm(nat_gcdnm) /\NatBezoutmn(nat_gcdnm).Proof.introsH1H2;split; [|applynat_bezout_comm];exact_.Defined.For arbitrary natural numbers, we have Bezout's identity in at least one direction.Definitionnat_bezoutnm:NatBezoutnm(nat_gcdnm) +NatBezoutmn(nat_gcdnm).Proof.destructn; [right|left];exact_.Defined.Prime NumbersA prime number is a number greater than1that is only divisible by1and itself.ClassIsPrime(n:nat) :Type0:= {gt_one_isprime:: 1 <n;isprime:forallm, (m|n) -> (m= 1) + (m=n);}.Definitionissig_IsPrimen:_<~>IsPrimen:=ltac:(issig).Global Instanceishprop_isprime`{Funext}n:IsHProp(IsPrimen).Proof.nrapplyistrunc_equiv_istrunc.1:applyissig_IsPrime.rapplyistrunc_sigma.introsH1.snrapplyistrunc_forall.introsm.snrapplyistrunc_forall.introsd.rapplyishprop_sum.introspq.nrapply(sndneq_iff_lt_or_gt_(p^ @q)).byleft.Defined.0is not a prime number.Definitionnot_isprime_zero: ~IsPrime0.Proof.introsH.rapplynot_lt_zero_r.Defined.1is not a prime number.Definitionnot_isprime_one: ~IsPrime1.Proof.introsH.rapply(lt_irrefl1).Defined.Being prime is a decidable property. We give an inefficient procedure for determining primality. More efficient procedures can be given, but for proofs this suffices.Global Instancedecidable_isprime@{}n:Decidable(IsPrimen).Proof.First we begin by discarding then=0case as we can easily prove that0is not prime.destructn.1:right;applynot_isprime_zero.Next, we rewriteIsPrimen.+1as the equivalent sigma type.nrapplydecidable_equiv'.1:nrapplyissig_IsPrime.The condition in the first component inIsPrimeis clearly decidable, so we can proceed to the second component.nrapplydecidable_equiv'.1:exact(equiv_sigma_prod0__)^-1%equiv.snrapplydecidable_prod.1:exact_.In order to show that thisforallis decidable, we will exhibit it as afor_allstatement over a given list. The predicate will be the conclusion we wish to reach here, and the list will consist of all numbers with a condition equivalent to the divisibility condition.pose(P:=funm=> ((m= 1) + (m=n.+1))%type:Type0).pose(l:=list_filter(seqn.+2) (funx=> (x|n.+1))_).rapply(decidable_iff(A:=for_allPl)).split.-introsPlxd.applyinlist_for_allwithlxinPl.1:exactPl.applyinlist_filter.split;only2:assumption.applyinlist_seq.applyleq_dividesind.1,2:exact_.-introsH.applyfor_all_inlist.introsxH'.applyinlist_filterinH'.destructH'as[pH'].applyinlist_seqinp.rapplyH.Defined.We can show that the first 8 primes are prime as expected.Global Instanceisprime_2:IsPrime2 :=ltac:(decide).Global Instanceisprime_3:IsPrime3 :=ltac:(decide).Global Instanceisprime_5:IsPrime5 :=ltac:(decide).Global Instanceisprime_7:IsPrime7 :=ltac:(decide).Global Instanceisprime_11:IsPrime11 :=ltac:(decide).Global Instanceisprime_13:IsPrime13 :=ltac:(decide).Global Instanceisprime_17:IsPrime17 :=ltac:(decide).Global Instanceisprime_19:IsPrime19 :=ltac:(decide).Similarly, we can see that other natural numbers are not prime.Definitionnot_isprime_0:not(IsPrime0) :=ltac:(decide).Definitionnot_isprime_1:not(IsPrime1) :=ltac:(decide).Definitionnot_isprime_4:not(IsPrime4) :=ltac:(decide).We can define the type of prime numbers as a subtype of natural numbers.DefinitionPrime:Type0:= {n:nat&IsPrimen}.Coercionnat_of_prime(p:Prime) :nat:=p.1.Global Instanceisprime_prime(p:Prime) :IsPrimep:=p.2.Global Instancelt_zero_prime(p:Prime) : 0 <p:=lt_trans_gt_one_isprime.A primepis coprime to a natural numberniffpdoes not dividen.Definitionnat_coprime_iff_not_divides(p:Prime)n:nat_gcdpn= 1 <-> ~ (p|n).Proof.split.-introsq[dr].destructr.rewrite(nat_gcd_r_add_r_mulp0)inq.rewritenat_gcd_zero_rinq.apply(@neq_iff_lt_or_gtp1).1:right;exact_.exactq.-introsnd.rapplynat_gcd_unique.introsqH1H2.applyisprimeinH1.destructH1as[H1|H1].+destructH1;exact_.+destructH1;contradiction.Defined.When a prime number divides a multiple, then the prime must divide one of the factors.Definitionnat_divides_prime_l(p:Prime)nm: (p|n*m) -> (p|n) + (p|m).Proof.introsd.destruct(dec(p|n))as[H|H].1:byleft.right.applynat_coprime_iff_not_dividesinH.destruct(nat_bezout_pos_lpn_)as[x[yq]].destructH^;clearH.destructdas[dr].exists(x*m-y*d).lhsnrapplynat_dist_sub_r.rewrite<- 2nat_mul_assoc.rewrite<- (nat_mul_commp).destructr^;clearr.rewrite2nat_mul_assoc.lhs_Vnrapplynat_dist_sub_r.rhs_Vnrapplynat_mul_one_l.apply(ap(funx=>nat_mulxm)).applynat_moveR_nV.exactq.Defined.Composite NumbersA natural number larger than1is composite if it has a divisor other than1and itself.ClassIsCompositen:Type0:=iscomposite:existsa, 1 <a<n/\ (a|n).Definitiongt_1_iscomposite@{}n:IsCompositen-> 1 <n.Proof.intros[a[[H1H2]H3]].exact_.Defined.Hint Immediategt_1_iscomposite:typeclass_instances.Being composite is a decidable property.Global Instancedecidable_iscomposite@{}n:Decidable(IsCompositen).Proof.unfoldIsComposite.rapply(decidable_exists_natn).introskc.exact(snd(fstc)).Defined.For a number larger than1, being prime is equivalent to not being composite.Definitionisprime_iff_not_iscomposite@{}n:IsPrimen<-> 1 <n/\ ~IsCompositen.Proof.split.-introsH.split;only1:exact_.intros[a[[H2H3]H4]].applyisprimeinH4.destructH4as[H4|H4];destructH4;exact(lt_irrefl__).-intros[H1H].rapplyBuild_IsPrime.introsmd.destruct(dec(1 <d.1))as[H2|H2].+poseproof(divides_divisor__d)asd'.applyleq_dividesind'.2:exact_.applyequiv_leq_lt_or_eqind'.destructd'as[d'|d'].*assert(H':IsCompositen).{existsd.1.split;only1:split;exact_. }contradictionH.*destructdas[dr].simplin*.destructd'.left.rewrite<-nat_div_cancelwithd.2:exact_.rewrite<-nat_div_mul_cancel_lwithdm.2:exact_.byapply(ap(funx=>x/d)).+applygeq_iff_not_ltinH2.destructdas[dr].simplin*;hnfinH2.destructd.{rewritenat_mul_zero_linr.destructn.1:contradiction(not_lt_zero_r_H1).contradiction(neq_nat_zero_succ_r). }destructd.{rewritenat_mul_one_linr.byright. }applyleq_pred'inH2.contradiction(not_lt_zero_rd).Defined.And sinceIsCompositeis decidable, we can show that being not prime is equivalent to being composite.Definitionnot_isprime_iff_iscomposite@{}n: 1 <n/\ ~IsPrimen<->IsCompositen.Proof.nrapplyiff_compose.-nrapplyiff_functor_prod.1:nrapplyiff_refl.nrapplyiff_compose.+applyiff_not.rapplyisprime_iff_not_iscomposite.+rapplyiff_not_prod.-nrapplyiff_compose.1:nrapplysum_distrib_l.nrapplyiff_compose.+nrapplyiff_functor_sum.1:applyiff_contradiction.nrapplyiff_functor_prod.1:nrapplyiff_refl.rapplyiff_stable.+nrapplyiff_compose.1:rapplysum_empty_l.split;only1:exactsnd.introsH;split;only2:exactH.exact_.Defined.Fundamental theorem of arithmeticEvery natural number greater than1has a prime divisor.Definitionexists_prime_divisor@{}n: 1 <n->exists(p:Prime), (p|n).Proof.revertn;snrapplynat_ind_strong;hnf;introsnIHnH.destruct(dec(IsPrimen))as[x|x].1:exists(_;x);exact_.pose(r:= (H,x)).applynot_isprime_iff_iscompositeinr.destructras[d[[H1H2]H3]].destruct(IHnd__)as[pr].existsp.exact_.Defined.Any natural number can either be written as a product of primes or is zero.Definitionprime_factorization@{}n: 0 <n->exists(l:listPrime),n=fold_right(fun(p:Prime)n=>nat_mulpn) 1l.Proof.revertn;snrapplynat_ind_strong;hnf;introsnIHnH.destructHas[|nIH].1:existsnil;reflexivity.destruct(exists_prime_divisorn.+1_)as[pd].poseproof(l:=lt_dividesd.1n.+1___).destructdas[kH].destruct(IHnkl)as[fr].{destructH,k.1:contradiction(lt_irrefl0).exact_. }exists(p::f)%list.simpl;destructr.symmetry.lhsnrapplynat_mul_comm.exactH.Defined.TODO: show that any two prime factorizations are unique up to permutation of the lists.

--- Miscellaneous\DPath.html ---
DPathLibrary DPathRequireImportBasics.RequireImportTypes.PathsTypes.SigmaTypes.Forall.Declare Scopedpath_scope.DelimitScopedpath_scopewithdpath.Local OpenScopedpath_scope.DefinitionDPath{A} (P:A->Type) {a0a1} (p:a0=a1)(b0:Pa0) (b1:Pa1) :Type:=transportPpb0=b1.This allows DPaths to collapse to paths under cbnArgumentsDPath_/___:simplnomatch.Global Instanceistrunc_dp{A:Type} {P:A->Type} {n:trunc_index}{a0a1} {p:a0=a1} {b0:Pa0} {b1:Pa1} `{IsTruncn.+1 (Pa0)}`{IsTruncn.+1 (Pa1)} :IsTruncn(DPathPpb0b1) :=_.Definitiondp_ishprop{A:Type} (P:A->Type) {a0a1} {p:a0=a1}{b0:Pa0} {b1:Pa1} `{IsHProp(Pa0)} `{IsHProp(Pa1)}:DPathPpb0b1.Proof.applypath_ishprop.Defined.We have reflexivity for DPaths, this helps coq guess laterDefinitiondp_id{A} {P:A->Type} {a:A} {x:Pa} :DPathP1xx:= 1%path.Although1%dpathis definitionally1%path, when1%pathis used where a dependent path is expected, Coq sometimes has trouble interpreting this. So we make a custom notation for1indpath_scope.Notation"1" :=dp_id:dpath_scope.DPath inductionDefinitionDPath_ind(A:Type) (P:A->Type) (P0:forall(a0a1:A)(p:a0=a1) (b0:Pa0) (b1:Pa1),DPathPpb0b1->Type): (forall(x:A) (y:Px),P0xx1%pathyy1) ->forall(a0a1:A) (p:a0=a1) (b0:Pa0) (b1:Pa1)(d:DPathPpb0b1),P0a0a1pb0b1d.Proof.introsXa0a1[]b0b1[];applyX.Defined.A DPath over a constant family is just a pathDefinitionequiv_dp_const{AC} {a0a1:A} {p:a0=a1} {xy}: (x=y) <~>DPath(fun_=>C)pxy.Proof.bydestructp.Defined.Notationdp_const:=equiv_dp_const.dp_apD of a non-dependent map is just a constant DPathDefinitiondp_apD_const{AB} (f:A->B) {a0a1:A}(p:a0=a1) :apDfp=dp_const(apfp).Proof.bydestructp.Defined.An alternate version useful for proving recursion computation rules from induction onesDefinitiondp_apD_const'{AB:Type} {f:A->B} {a0a1:A}{p:a0=a1} :dp_const^-1 (apDfp) =apfp.Proof.applymoveR_equiv_V.applydp_apD_const.Defined.Concatenation of dependent pathsDefinitiondp_concat{A} {P:A->Type} {a0a1a2}{p:a0=a1} {q:a1=a2} {b0:Pa0} {b1:Pa1} {b2:Pa2}:DPathPpb0b1->DPathPqb1b2->DPathP(p@q)b0b2.Proof.destructp,q.exactconcat.Defined.Notation"x '@Dp' y" := (dp_concatxy) :dpath_scope.Concatenation of dependent paths with non-dependent pathsDefinitiondp_concat_r{A} {P:A->Type} {a0a1}{p:a0=a1} {b0:Pa0} {b1b2:Pa1}:DPathPpb0b1-> (b1=b2) ->DPathPpb0b2.Proof.destructp;exactconcat.Defined.Notation"x '@Dr' y" := (dp_concat_rxy) :dpath_scope.Definitiondp_concat_l{A} {P:A->Type} {a1a2}{q:a1=a2} {b0b1:Pa1} {b2:Pa2}: (b0=b1) ->DPathPqb1b2->DPathPqb0b2.Proof.destructq;exactconcat.Defined.Notation"x '@Dl' y" := (dp_concat_lxy) :dpath_scope.Inverse of dependent pathsDefinitiondp_inverse{A} {P:A->Type} {a0a1} {p:a0=a1}{b0:Pa0} {b1:Pa1} :DPathPpb0b1->DPathPp^b1b0.Proof.destructp.exactinverse.Defined.Notation"x '^D'" := (dp_inversex) :dpath_scope.dp_apD distributes over concatenationDefinitiondp_apD_pp(A:Type) (P:A->Type) (f:foralla,Pa){a0a1a2:A} (p:a0=a1) (q:a1=a2):apDf(p@q) = (apDfp) @Dp(apDfq).Proof.bydestructp,q.Defined.dp_apD respects inversesDefinitiondp_apD_V(A:Type) (P:A->Type) (f:foralla,Pa){a0a1:A} (p:a0=a1) :apDfp^ = (apDfp)^D.Proof.bydestructp.Defined.dp_constpreserves concatenationDefinitiondp_const_pp{AB:Type} {a0a1a2:A}{p:a0=a1} {q:a1=a2} {xyz:B} (r:x=y) (s:y=z):dp_const(p:=p@q) (r@s) = (dp_const(p:=p)r) @Dp(dp_const(p:=q)s).Proof.bydestructp,q.Defined.dp_constpreserves inversesDefinitiondp_const_V{AB:Type} {a0a1:A} {p:a0=a1} {xy:B} (r:x=y):dp_constr^ = (dp_const(p:=p)r)^D.Proof.bydestructp.Defined.Horizontal composition and whiskering of dependent pathsDefinitiondp_concat2{A} {P:A->Type} {a0a1a2}{p:a0=a1} {q:a1=a2} {b0:Pa0} {b1:Pa1} {b2:Pa2}{rr':DPathPpb0b1} {ss':DPathPqb1b2}(h:r=r') (k:s=s'):r@Dps=r'@Dps'.Proof.bydestructh,k.Defined.Definitiondp_whiskerL{A:Type} {P:A->Type} {a0a1a2:A}{p:a0=a1} {q:a1=a2} {b0:Pa0} {b1:Pa1} {b2:Pa2}(r:DPathPpb0b1) {ss':DPathPqb1b2} (h:s=s'):r@Dps=r@Dps':=dp_concat21h.Definitiondp_whiskerR{A:Type} {P:A->Type} {a0a1a2:A}{p:a0=a1} {q:a1=a2} {b0:Pa0} {b1:Pa1} {b2:Pa2}{rr':DPathPpb0b1} (s:DPathPqb1b2) (h:r=r'):r@Dps=r'@Dps:=dp_concat2h1.SectionDGroupoid.Context{A} {P:A->Type} {a0a1} {p:a0=a1}{b0:Pa0} {b1:Pa1} {dp:DPathPpb0b1}.Definitiondp_concat_p1:DPath(funt:a0=a1=>DPathPtb0b1) (concat_p1p) (dp@Dp1)dp.Proof.destructp.applyconcat_p1.Defined.Definitiondp_concat_1p:DPath(funt:a0=a1=>DPathPtb0b1) (concat_1pp) (1 @Dpdp)dp.Proof.destructp.applyconcat_1p.Defined.Definitiondp_concat_Vp:DPath(funt:a1=a1=>DPathPtb1b1) (concat_Vpp) (dp^D@Dpdp) 1.Proof.destructp.applyconcat_Vp.Defined.Definitiondp_concat_pV:DPath(funt:a0=a0=>DPathPtb0b0) (concat_pVp) (dp@Dpdp^D) 1.Proof.destructp.applyconcat_pV.Defined.SectionConcat.Context{a2a3} {q:a1=a2} {r:a2=a3}{b2:Pa2} {b3:Pa3}(dq:DPathPqb1b2) (dr:DPathPrb2b3).Definitiondp_concat_pp_p:DPath(funt:a0=a3=>DPathPtb0b3) (concat_pp_ppqr)((dp@Dpdq) @Dpdr) (dp@Dp(dq@Dpdr)).Proof.destructp,q,r.applyconcat_pp_p.Defined.Definitiondp_concat_p_pp:DPath(funt:a0=a3=>DPathPtb0b3) (concat_p_pppqr)(dp@Dp(dq@Dpdr)) ((dp@Dpdq) @Dpdr).Proof.destructp,q,r.applyconcat_p_pp.Defined.EndConcat.EndDGroupoid.Dependent paths over paths  These can be found under names such as dp_paths_l akin to transport_paths_lDefinitionequiv_dp_paths_l{A:Type} {x1x2y:A} (p:x1=x2) (q:x1=y)r:p^ @q=r<~>DPath(funx=>x=y)pqr.Proof.applyequiv_concat_l,transport_paths_l.Defined.Notationdp_paths_l:=equiv_dp_paths_l.Definitionequiv_dp_paths_r{A:Type} {xy1y2:A} (p:y1=y2) (q:x=y1)r:q@p=r<~>DPath(funy=>x=y)pqr.Proof.applyequiv_concat_l,transport_paths_r.Defined.Notationdp_paths_r:=equiv_dp_paths_r.Definitionequiv_dp_paths_lr{A:Type} {x1x2:A} (p:x1=x2) (q:x1=x1)r: (p^ @q) @p=r<~>DPath(funx:A=>x=x)pqr.Proof.applyequiv_concat_l,transport_paths_lr.Defined.Notationdp_paths_lr:=equiv_dp_paths_lr.Definitionequiv_dp_paths_Fl{AB} {f:A->B} {x1x2:A} {y:B} (p:x1=x2)(q:fx1=y)r:  (apfp)^ @q=r<~>DPath(funx=>fx=y)pqr.Proof.applyequiv_concat_l,transport_paths_Fl.Defined.Notationdp_paths_Fl:=equiv_dp_paths_Fl.Definitionequiv_dp_paths_Fr{AB} {g:A->B} {y1y2:A} {x:B} (p:y1=y2)(q:x=gy1)r:q@apgp=r<~>DPath(funy:A=>x=gy)pqr.Proof.applyequiv_concat_l,transport_paths_Fr.Defined.Notationdp_paths_Fr:=equiv_dp_paths_Fr.Definitionequiv_dp_paths_FFlr{AB} {f:A->B} {g:B->A} {x1x2:A}(p:x1=x2) (q:g(fx1) =x1)r: ((apg(apfp))^ @q) @p=r<~>DPath(funx:A=>g(fx) =x)pqr.Proof.applyequiv_concat_l,transport_paths_FFlr.Defined.Notationdp_paths_FFlr:=equiv_dp_paths_FFlr.Definitionequiv_dp_paths_FlFr{AB} {fg:A->B} {x1x2:A} (p:x1=x2)(q:fx1=gx1)r: ((apfp)^ @q) @apgp=r<~>DPath(funx:A=>fx=gx)pqr.Proof.applyequiv_concat_l,transport_paths_FlFr.Defined.Notationdp_paths_FlFr:=equiv_dp_paths_FlFr.Definitionequiv_dp_paths_lFFr{AB} {f:A->B} {g:B->A} {x1x2:A}(p:x1=x2) (q:x1=g(fx1))r:  (p^ @q) @apg(apfp) =r<~>DPath(funx:A=>x=g(fx))pqr.Proof.applyequiv_concat_l,transport_paths_lFFr.Defined.Notationdp_paths_lFFr:=equiv_dp_paths_lFFr.Definitionequiv_dp_paths_FlFr_D{AB} (fg:foralla:A,Ba){x1x2:A} (p:x1=x2) (q:fx1=gx1) (r:fx2=gx2): ((apDfp)^ @ap(transportBp)q) @apDgp=r<~>DPath(funx:A=>fx=gx)pqr.Proof.applyequiv_concat_l,transport_paths_FlFr_D.Defined.Notationdp_paths_FlFr_D:=equiv_dp_paths_FlFr_D.Definitionequiv_dp_compose'{AB} (f:A->B) (P:B->Type) {xy:A}{p:x=y} {q:fx=fy} (r:apfp=q) {u:P(fx)} {v:P(fy)}:DPath(funx=>P(fx))puv<~>DPathPquv.Proof.bydestructr,p.Defined.Notationdp_compose':=equiv_dp_compose'.Definitionequiv_dp_compose{AB} (f:A->B) (P:B->Type) {xy:A}(p:x=y) {u:P(fx)} {v:P(fy)}:DPath(funx=>P(fx))puv<~>DPathP(apfp)uv:=dp_compose'fP(idpath(apfp)).Notationdp_compose:=equiv_dp_compose.Definitiondp_apD_compose'{AB:Type} (f:A->B) (P:B->Type){xy:A} {p:x=y} {q:fx=fy} (r:apfp=q) (g:forallb:B,Pb):apD(gof)p= (dp_compose'fPr)^-1 (apDgq).Proof.bydestructr,p.Defined.Definitiondp_apD_compose{AB:Type} (f:A->B) (P:B->Type){xy:A} (p:x=y) (g:forallb:B,Pb):apD(gof)p= (dp_composefPp)^-1 (apDg(apfp)):=dp_apD_compose'fP(idpath(apfp))g.Definitiondp_apD_compose_inv'{AB:Type} (f:A->B) (P:B->Type){xy:A} {p:x=y} {q:fx=fy} (r:apfp=q) (g:forallb:B,Pb):apDgq= (dp_compose'fPr) (apD(gof)p).Proof.bydestructr,p.Defined.Definitiondp_apD_compose_inv{AB:Type} (f:A->B) (P:B->Type){xy:A} {p:x=y} (g:forallb:B,Pb):apDg(apfp) = (dp_composefPp) (apD(gof)p):=dp_apD_compose_inv'fP(idpath(apfp))g.Type constructorsMany of these lemmas exist already for transports but we prove them for
   DPaths anyway. If we change the definition of DPath to the transport,
   then these will no longer be needed. It is however, far more readable
   to keep such lemmas seperate, since it is difficult to otherwise search
   for a DPath lemma if they are all written using transports.A version ofequiv_path_sigmaforDPathsDefinitionequiv_path_sigma_dp{AP} {xx':A} {y:Px} {y':Px'}: {p:x=x'&DPathPpyy'} <~> (x;y) = (x';y'):=equiv_path_sigmaP(x;y) (x';y').Notationpath_sigma_dp:=equiv_path_sigma_dp.Definitionap_pr1_path_sigma_dp{A:Type} {P:A->Type}{xx':A} {y:Px} {y':Px'} (p:x=x') (q:DPathPpyy'):appr1(path_sigma_dp(p;q)) =p.Proof.applyap_pr1_path_sigma.Defined.(* DPath over a forall *)Definitionequiv_dp_forall`{Funext} {A:Type} {B:A->Type} {C:sigB->Type}{a1a2:A} {p:a1=a2} {f:forallx,C(a1;x)} {g:forallx,C(a2;x)}: (forall(x:Ba1) (y:Ba2) (q:DPathBpxy),DPathC(path_sigma_dp(p;q)) (fx) (gy))<~>DPath(funa=>forallx,C(a;x))pfg.Proof.symmetry.destructp;cbn.refine(equiv_compose'_(equiv_apD10___)).applyequiv_functor_forall_id.introa.srapplyequiv_adjointify.+byintros? ? [].+introF;exact(Fa1).+repeat(intro;applypath_forall).byintros[].+byintro.Defined.Notationdp_forall:=equiv_dp_forall.(* DPath over an arrow *)Definitionequiv_dp_arrow`{Funext} {A:Type} {BC:A->Type}{a1a2:A} {p:a1=a2} {f:Ba1->Ca1} {g:Ba2->Ca2}: (forallx,DPathCp(fx) (g(p#x)))<~>DPath(funx=>Bx->Cx)pfg.Proof.destructp.applyequiv_path_forall.Defined.Notationdp_arrow:=equiv_dp_arrow.(* Restricted version allowing us to pull the domain of a forall out *)Definitionequiv_dp_forall_domain`{Funext} {D:Type} {A:Type} {B:D->A->Type}{t1t2:D} {d:t1=t2} {f:forallx,Bt1x} {g:forallx,Bt2x}: (forallx,DPath(funt=>Btx)d(fx) (gx))<~>DPath(funt=>forallx,Btx)dfg.Proof.destructd.applyequiv_path_forall.Defined.Notationdp_forall_domain:=equiv_dp_forall_domain.Definitionequiv_dp_sigma{A:Type} {B:A->Type}{C:sigB->Type} {x1x2:A} {p:x1=x2}(y1: {y:Bx1&C(x1;y) }) (y2: {y:Bx2&C(x2;y) }): {n:DPathBpy1.1y2.1 &DPathC(path_sigma_dp(p;n))y1.2y2.2}<~>DPath(funx=> {y:Bx&C(x;y) })py1y2.Proof.destructp.refine(path_sigma_dpoE_).applyequiv_functor_sigma_id.cbn;introq.destructy1as[y11y12],y2as[y21y22].cbnin*.bydestructq.Defined.Notationdp_sigma:=equiv_dp_sigma.

--- Miscellaneous\DPathCube.html ---
DPathCubeLibrary DPathCubeRequireImportBasics.RequireImportCubical.DPath.RequireImportCubical.PathSquare.RequireImportCubical.DPathSquare.RequireImportCubical.PathCube.Declare Scopedcube_scope.DelimitScopedcube_scopewithdcube.(* In this file we define a dependent cube *)(* Dependent cubes *)DefinitionDPathCube{A} (B:A->Type){x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110}{pi00:x000=x100} {pi10:x010=x110}{p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111}{p00i:x000=x001} {p01i:x010=x011}{p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i}{s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10}{sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01}{si1i:PathSquarep01ip11ipi10pi11}(cube:PathCubes0iis1iisii0sii1si0isi1i){b000:Bx000} {b010:Bx010} {b100:Bx100} {b110:Bx110}{b001:Bx001} {b011:Bx011} {b101:Bx101} {b111:Bx111}{bp0i0:DPathBp0i0b000b010} {bp1i0:DPathBp1i0b100b110}{bpi00:DPathBpi00b000b100} {bpi10:DPathBpi10b010b110}{bp0i1:DPathBp0i1b001b011} {bp1i1:DPathBp1i1b101b111}{bpi01:DPathBpi01b001b101} {bpi11:DPathBpi11b011b111}{bp00i:DPathBp00ib000b001} {bp01i:DPathBp01ib010b011}{bp10i:DPathBp10ib100b101} {bp11i:DPathBp11ib110b111}(bs0ii:DPathSquareBs0iibp0i0bp0i1bp00ibp01i)(bs1ii:DPathSquareBs1iibp1i0bp1i1bp10ibp11i)(bsii0:DPathSquareBsii0bp0i0bp1i0bpi00bpi10)(bsii1:DPathSquareBsii1bp0i1bp1i1bpi01bpi11)(bsi0i:DPathSquareBsi0ibp00ibp10ibpi00bpi01)(bsi1i:DPathSquareBsi1ibp01ibp11ibpi10bpi11) :Type.Proof.destructcube.exact(PathCubebs0iibs1iibsii0bsii1bsi0ibsi1i).Defined.Definitionequiv_dc_const'{AB:Type}{x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110}{pi00:x000=x100} {pi10:x010=x110}{p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111}{p00i:x000=x001} {p01i:x010=x011}{p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i}{s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10}{sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01}{si1i:PathSquarep01ip11ipi10pi11}{cube:PathCubes0iis1iisii0sii1si0isi1i}{b000b010b100b110b001b011b101b111:B}{bp0i0:DPath(fun_=>B)p0i0b000b010}{bp1i0:DPath(fun_=>B)p1i0b100b110}{bpi00:DPath(fun_=>B)pi00b000b100}{bpi10:DPath(fun_=>B)pi10b010b110}{bp0i1:DPath(fun_=>B)p0i1b001b011}{bp1i1:DPath(fun_=>B)p1i1b101b111}{bpi01:DPath(fun_=>B)pi01b001b101}{bpi11:DPath(fun_=>B)pi11b011b111}{bp00i:DPath(fun_=>B)p00ib000b001}{bp01i:DPath(fun_=>B)p01ib010b011}{bp10i:DPath(fun_=>B)p10ib100b101}{bp11i:DPath(fun_=>B)p11ib110b111}{bs0ii:DPathSquare(fun_=>B)s0iibp0i0bp0i1bp00ibp01i}{bs1ii:DPathSquare(fun_=>B)s1iibp1i0bp1i1bp10ibp11i}{bsii0:DPathSquare(fun_=>B)sii0bp0i0bp1i0bpi00bpi10}{bsii1:DPathSquare(fun_=>B)sii1bp0i1bp1i1bpi01bpi11}{bsi0i:DPathSquare(fun_=>B)si0ibp00ibp10ibpi00bpi01}{bsi1i:DPathSquare(fun_=>B)si1ibp01ibp11ibpi10bpi11}:PathCube(ds_const'^-1bs0ii) (ds_const'^-1bs1ii) (ds_const'^-1bsii0)(ds_const'^-1bsii1) (ds_const'^-1bsi0i) (ds_const'^-1bsi1i)<~>DPathCube(fun_=>B)cubebs0iibs1iibsii0bsii1bsi0ibsi1i.Proof.bydestructcube.Defined.Notationdc_const':=equiv_dc_const'.Definitionequiv_dc_const{AB:Type}{x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110}{pi00:x000=x100} {pi10:x010=x110}{p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111}{p00i:x000=x001} {p01i:x010=x011}{p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i}{s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10}{sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01}{si1i:PathSquarep01ip11ipi10pi11}{cube:PathCubes0iis1iisii0sii1si0isi1i}{b000b010b100b110b001b011b101b111:B}{bp0i0:b000=b010} {bp1i0:b100=b110}{bpi00:b000=b100} {bpi10:b010=b110}{bp0i1:b001=b011} {bp1i1:b101=b111}{bpi01:b001=b101} {bpi11:b011=b111}{bp00i:b000=b001} {bp01i:b010=b011}{bp10i:b100=b101} {bp11i:b110=b111}{bs0ii:PathSquarebp0i0bp0i1bp00ibp01i}{bs1ii:PathSquarebp1i0bp1i1bp10ibp11i}{bsii0:PathSquarebp0i0bp1i0bpi00bpi10}{bsii1:PathSquarebp0i1bp1i1bpi01bpi11}{bsi0i:PathSquarebp00ibp10ibpi00bpi01}{bsi1i:PathSquarebp01ibp11ibpi10bpi11}:PathCubebs0iibs1iibsii0bsii1bsi0ibsi1i<~>DPathCube(fun_=>B)cube(ds_constbs0ii) (ds_constbs1ii) (ds_constbsii0)(ds_constbsii1) (ds_constbsi0i) (ds_constbsi1i).Proof.bydestructcube.Defined.Notationdc_const:=equiv_dc_const.Dependent Kan fillersSectionKan.Context{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}{s1ii:PathSquarep1i0p1i1p10ip11i} {s0ii:PathSquarep0i0p0i1p00ip01i}{sii0:PathSquarep0i0p1i0pi00pi10} {sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01} {si1i:PathSquarep01ip11ipi10pi11}(c:PathCubes0iis1iisii0sii1si0isi1i){P:A->Type} {y000y010y100y110y001y011y101y111}{q0i0:DPathPp0i0y000y010} {q1i0:DPathPp1i0y100y110} {qi00:DPathPpi00y000y100}{qi10:DPathPpi10y010y110} {q0i1:DPathPp0i1y001y011} {q1i1:DPathPp1i1y101y111}{qi01:DPathPpi01y001y101} {qi11:DPathPpi11y011y111} {q00i:DPathPp00iy000y001}{q01i:DPathPp01iy010y011} {q10i:DPathPp10iy100y101} {q11i:DPathPp11iy110y111}.Definitiondc_fill_left(t1ii:DPathSquarePs1iiq1i0q1i1q10iq11i)(tii0:DPathSquarePsii0q0i0q1i0qi00qi10) (tii1:DPathSquarePsii1q0i1q1i1qi01qi11)(ti0i:DPathSquarePsi0iq00iq10iqi00qi01) (ti1i:DPathSquarePsi1iq01iq11iqi10qi11): {t0ii:DPathSquarePs0iiq0i0q0i1q00iq01i&DPathCubePct0iit1iitii0tii1ti0iti1i}.Proof.destructc.applycu_fill_left.Defined.Definitiondc_fill_right(t0ii:DPathSquarePs0iiq0i0q0i1q00iq01i)(tii0:DPathSquarePsii0q0i0q1i0qi00qi10) (tii1:DPathSquarePsii1q0i1q1i1qi01qi11)(ti0i:DPathSquarePsi0iq00iq10iqi00qi01) (ti1i:DPathSquarePsi1iq01iq11iqi10qi11): {t1ii:DPathSquarePs1iiq1i0q1i1q10iq11i&DPathCubePct0iit1iitii0tii1ti0iti1i}.Proof.destructc.applycu_fill_right.Defined.Definitiondc_fill_top(t0ii:DPathSquarePs0iiq0i0q0i1q00iq01i) (t1ii:DPathSquarePs1iiq1i0q1i1q10iq11i)(tii1:DPathSquarePsii1q0i1q1i1qi01qi11)(ti0i:DPathSquarePsi0iq00iq10iqi00qi01) (ti1i:DPathSquarePsi1iq01iq11iqi10qi11): {tii0:DPathSquarePsii0q0i0q1i0qi00qi10&DPathCubePct0iit1iitii0tii1ti0iti1i}.Proof.destructc.applycu_fill_top.Defined.Definitiondc_fill_bottom(t0ii:DPathSquarePs0iiq0i0q0i1q00iq01i) (t1ii:DPathSquarePs1iiq1i0q1i1q10iq11i)(tii0:DPathSquarePsii0q0i0q1i0qi00qi10)(ti0i:DPathSquarePsi0iq00iq10iqi00qi01) (ti1i:DPathSquarePsi1iq01iq11iqi10qi11): {tii1:DPathSquarePsii1q0i1q1i1qi01qi11&DPathCubePct0iit1iitii0tii1ti0iti1i}.Proof.destructc.applycu_fill_bottom.Defined.Definitiondc_fill_front(t0ii:DPathSquarePs0iiq0i0q0i1q00iq01i) (t1ii:DPathSquarePs1iiq1i0q1i1q10iq11i)(tii0:DPathSquarePsii0q0i0q1i0qi00qi10) (tii1:DPathSquarePsii1q0i1q1i1qi01qi11)(ti1i:DPathSquarePsi1iq01iq11iqi10qi11): {ti0i:DPathSquarePsi0iq00iq10iqi00qi01&DPathCubePct0iit1iitii0tii1ti0iti1i}.Proof.destructc.applycu_fill_front.Defined.Definitiondc_fill_back(t0ii:DPathSquarePs0iiq0i0q0i1q00iq01i) (t1ii:DPathSquarePs1iiq1i0q1i1q10iq11i)(tii0:DPathSquarePsii0q0i0q1i0qi00qi10) (tii1:DPathSquarePsii1q0i1q1i1qi01qi11)(ti0i:DPathSquarePsi0iq00iq10iqi00qi01): {ti1i:DPathSquarePsi1iq01iq11iqi10qi11&DPathCubePct0iit1iitii0tii1ti0iti1i}.Proof.destructc.applycu_fill_back.Defined.EndKan.

--- Miscellaneous\DPathSquare.html ---
DPathSquareLibrary DPathSquareRequireImportBasics.RequireImportTypes.Paths.RequireImportCubical.DPath.RequireImportCubical.PathSquare.Declare Scopedsquare_scope.DelimitScopedsquare_scopewithdsquare.Local OpenScopedpath_scope.(* Dependent squares *)DefinitionDPathSquare{A} (P:A->Type) {a00a10a01a11}{px0:a00=a10} {px1:a01=a11} {p0xp1x}(s:PathSquarepx0px1p0xp1x) {b00b10b01b11}(qx0:DPathPpx0b00b10) (qx1:DPathPpx1b01b11)(q0x:DPathPp0xb00b01) (q1x:DPathPp1xb10b11) :Type.Proof.destructs.exact(PathSquareqx0qx1q0xq1x).Defined.Definitionds_id{A} {P:A->Type} {a00b00}:DPathSquarePsq_id1 1 1 1 (a00:=a00) (b00:=b00).Proof.applysq_id.Defined.Notation"1" :=ds_id:dsquare_scope.SectionDPathSquareConstructors.(* Different ways of constructing dependent squares *)Context{A} {a0a1:A} {p:a0=a1} {P:A->Type}{b0b1} (dp:DPathPpb0b1).Definitionds_refl_h:DPathSquareP(sq_refl_h_)dpdp1 1.Proof.destructp.applysq_refl_h.Defined.Definitionds_refl_v:DPathSquareP(sq_refl_v_) 1 1dpdp.Proof.destructp.applysq_refl_v.Defined.EndDPathSquareConstructors.(* DPathSquares can be given by 2-dimensional DPaths *)Definitionequiv_ds_dpath{A} (P:A->Type) {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}(s:px0@p1x=p0x@px1) {b00b10b01b11}{qx0:DPathPpx0b00b10} {qx1:DPathPpx1b01b11}{q0x:DPathPp0xb00b01} {q1x:DPathPp1xb10b11}:DPath(funp=>DPathPpb00b11)s(qx0@Dpq1x) (q0x@Dpqx1)<~>DPathSquareP(sq_paths)qx0qx1q0xq1x.Proof.set(s':=sq_paths).rewrite<- (eissectsq_paths:sq_path^-1s'=s).clearbodys';clears.destructs';cbn.applysq_path.Defined.Notationds_dpath:=equiv_ds_dpath.(* We have an apD for DPathSquares *)Definitionds_apD{A} {B:A->Type} (f:foralla,Ba) {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0xp1x} (s:PathSquarepx0px1p0xp1x):DPathSquareBs(apDfpx0) (apDfpx1) (apDfp0x) (apDfp1x).Proof.bydestructs.Defined.(* A DPathSquare over a constant family is given by just a square *)Definitionds_const{AP:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}{s:PathSquarepx0px1p0xp1x} {b00b10b01b11:P}{qx0:b00=b10} {qx1:b01=b11} {q0x:b00=b01} {q1x:b10=b11}:PathSquareqx0qx1q0xq1x<~>DPathSquare(fun_=>P)s(dp_constqx0)(dp_constqx1) (dp_constq0x) (dp_constq1x).Proof.bydestructs.Defined.(* Sometimes we want the DPathSquare to be typed differently *)(* This could be achieved with some clever rewriting of squares and DPathSquares *)(* It seems that writing it like this might get in the way, Cube.v hassome examples of this. *)Definitionequiv_ds_const'{AP:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}{s:PathSquarepx0px1p0xp1x} {b00b10b01b11:P}{qx0:DPath(fun_=>P)px0b00b10}{qx1:DPath(fun_=>P)px1b01b11}{q0x:DPath(fun_=>P)p0xb00b01}{q1x:DPath(fun_=>P)p1xb10b11}:PathSquare(dp_const^-1qx0) (dp_const^-1qx1)(dp_const^-1q0x) (dp_const^-1q1x)<~>DPathSquare(fun_=>P)sqx0qx1q0xq1x.Proof.bydestructs.Defined.Notationds_const':=equiv_ds_const'.(* dp_apD fits into a natural square *)Definitiondp_apD_nat{A} {P:A->Type} {fg:forallx,Px} {xy:A}(q:f==g) (p:x=y):DPathSquareP(sq_refl_h_) (apDfp) (apDgp) (qx) (qy).Proof.destructp.byapplysq_1G.Defined.Definitionequiv_ds_G1{A} (P:A->Type) {a00a10}{px0px1:a00=a10} {p:px0=px1} {b00b10}(qx0:DPathPpx0b00b10) (qx1:DPathPpx1b00b10):DPath(funx=>DPathPxb00b10)pqx0qx1<~>DPathSquareP(sq_G1p)qx0qx11 1.Proof.destructp,px0.applysq_G1.Defined.Notationds_G1:=equiv_ds_G1.A DPath in a path-type is naturally a DPathSquare.Definitionequiv_ds_dp{A:Type} {B:A->Type} (fg:foralla:A,Ba){x1x2:A} (p:x1=x2) (q1:fx1=gx1) (q2:fx2=gx2):DPath(funx:A=>fx=gx)pq1q2<~>DPathSquareB(sq_refl_hp) (apDfp) (apDgp)q1q2.Proof.destructp.exactsq_1G.Defined.Notationds_dp:=equiv_ds_dp.Dependent Kan operationsSectionKan.Context{A:Type} {P:A->Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0xp1x}(s:PathSquarepx0px1p0xp1x){b00:Pa00} {b10:Pa10} {b01:Pa01} {b11:Pa11}.Definitionds_fill_l(qx1:DPathPpx1b01b11)(q0x:DPathPp0xb00b01) (q1x:DPathPp1xb10b11): {qx0:DPathPpx0b00b10&DPathSquarePsqx0qx1q0xq1x}.Proof.destructs;applysq_fill_l.Defined.Definitionds_fill_l_uniq{qx1:DPathPpx1b01b11}{q0x:DPathPp0xb00b01} {q1x:DPathPp1xb10b11}{qx0:DPathPpx0b00b10}(t:DPathSquarePsqx0qx1q0xq1x){qx0':DPathPpx0b00b10}(t':DPathSquarePsqx0'qx1q0xq1x):qx0=qx0'.Proof.destructs.exact(sq_fill_l_uniqtt').Defined.Definitionds_fill_r(qx0:DPathPpx0b00b10)(q0x:DPathPp0xb00b01) (q1x:DPathPp1xb10b11): {qx1:DPathPpx1b01b11&DPathSquarePsqx0qx1q0xq1x}.Proof.destructs;applysq_fill_r.Defined.Definitionds_fill_r_uniq{qx0:DPathPpx0b00b10}{q0x:DPathPp0xb00b01} {q1x:DPathPp1xb10b11}{qx1:DPathPpx1b01b11}(t:DPathSquarePsqx0qx1q0xq1x){qx1':DPathPpx1b01b11}(t':DPathSquarePsqx0qx1'q0xq1x):qx1=qx1'.Proof.destructs.exact(sq_fill_r_uniqtt').Defined.Definitionequiv_ds_fill_lr{q0x:DPathPp0xb00b01} {q1x:DPathPp1xb10b11}: (DPathPpx0b00b10) <~> (DPathPpx1b01b11).Proof.srapplyequiv_adjointify.-introsqx0;exact(ds_fill_rqx0q0xq1x).1.-introsqx1;exact(ds_fill_lqx1q0xq1x).1.-introsqx1.exact(ds_fill_r_uniq(ds_fill_r_q0xq1x).2(ds_fill_lqx1q0xq1x).2).-introsqx0.exact(ds_fill_l_uniq(ds_fill_l_q0xq1x).2(ds_fill_rqx0q0xq1x).2).Defined.Definitionds_fill_t(qx0:DPathPpx0b00b10)(qx1:DPathPpx1b01b11) (q1x:DPathPp1xb10b11): {q0x:DPathPp0xb00b01&DPathSquarePsqx0qx1q0xq1x}.Proof.destructs;applysq_fill_t.Defined.Definitionds_fill_b(qx0:DPathPpx0b00b10)(qx1:DPathPpx1b01b11) (q0x:DPathPp0xb00b01): {q1x:DPathPp1xb10b11&DPathSquarePsqx0qx1q0xq1x}.Proof.destructs;applysq_fill_b.Defined.EndKan.Another equivalent formulation of a dependent square over reflexivityDefinitionequiv_ds_transport_dpath{A} {a0a1:A} {p:a0=a1}{P:A->Type} {b00b10b01b11}(qx0:DPathPpb00b10) (qx1:DPathPpb01b11)(q0x:b00=b01) (q1x:b10=b11):DPathSquareP(sq_refl_hp)qx0qx1q0xq1x<~>transport(funy=>DPathPpyb11)q0x(transport(funy=>DPathPpb00y)q1xqx0) =qx1.Proof.destructp;cbn.refine(_oEsq_path^-1).refine(equiv_concat_l__oE_).{applytransport_paths_l. }refine(equiv_moveR_Vp___oE_).refine(equiv_concat_l__).applytransport_paths_r.Defined.Notationds_transport_dpath:=equiv_ds_transport_dpath.

--- Miscellaneous\DProp.html ---
DPropLibrary DPropDecidable propositionsRequireImportHoTT.BasicsHoTT.Types.RequireImportTruncTypeHProp.RequireImportTruncations.CoreModalities.ReflectiveSubuniverse.Local OpenScopepath_scope.DefinitionsA decidable proposition is, morally speaking, an HProp that is decidable.  However, we only require that it be an HProp under the additional assumption ofFunext; this enables decidable propositions to usually be used withoutFunexthypotheses.RecordDProp:= {dprop_type:Type;ishprop_dprop:Funext->IsHPropdprop_type;dec_dprop:Decidabledprop_type}.A fancier definition, which would have the property that negation is judgmentally involutive, would beRecord DProp :=
  { dprop_holds : Type ;
    ishprop_holds : Funext -> IsHProp dprop_holds ;
    dprop_denies : Type ;
    ishprop_denies : Funext -> IsHProp dprop_denies ;
    holds_or_denies : dprop_holds + dprop_denies ;
    denies_or_holds : dprop_denies + dprop_holds ;
    not_holds_and_denies : dprop_holds -> dprop_denies -> Empty
  }.At some point we may want to go that route, but it would be more work.  In particualar,Instances ofDecidablewouldn't be automatically computed for us, and the characterization of the homotopy type ofDPropitself would be a lot harder.Coerciondprop_type:DProp>->Sortclass.Global Existing Instanceishprop_dprop.Global Existing Instancedec_dprop.Sometimes, however, we have decidable props that are hprops without funext, and we want to remember that.RecordDHProp:={dhprop_hprop:HProp;dec_dhprop:Decidabledhprop_hprop}.Coerciondhprop_hprop:DHProp>->HProp.Global Existing Instancedec_dhprop.Definitiondhprop_to_dprop:DHProp->DProp:=funP=>Build_DPropP(fun_=>_)_.Coerciondhprop_to_dprop:DHProp>->DProp.In particular,TrueandFalseare always hprops.DefinitionTrue:DHProp:=Build_DHPropUnit_hp(inltt).DefinitionFalse:DHProp:=Build_DHPropFalse_hp(inridmap).Decidable props can be coerced toBool.Definitiondprop_to_bool(P:DProp) :Bool:=ifdecPthentrueelsefalse.Coerciondprop_to_bool:DProp>->Bool.And back again, but we don't declare that as a coercion.Definitionbool_to_dhprop(b:Bool) :DHProp:=ifbthenTrueelseFalse.The type of decidable propsDefinitionissig_dprop: {X:Type& {_:Funext->IsHPropX&DecidableX} } <~>DProp.Proof.issig.Defined.Definitionequiv_path_dprop`{Funext} (PQ:DProp): (P=Q:>Type) <~> (P=Q:>DProp).Proof.destructPas[PhPdP].destructQas[QhQdQ].refine(((equiv_ap'issig_dprop^-1__)^-1)oE_);cbn.refine((equiv_ap'(equiv_sigma_assoc'__)^-1((P;hP);dP) ((Q;hQ);dQ))oE_).refine(equiv_path_sigma_hprop__oE_);cbn.{intros[XhX];exact_. }refine(equiv_path_sigma_hprop(P;hP) (Q;hQ)).Defined.Definitionpath_dprop`{Funext} {PQ:DProp}: (P=Q:>Type) -> (P=Q:>DProp):=equiv_path_dpropPQ.Definitionissig_dhprop: {X:HProp&DecidableX} <~>DHProp.Proof.issig.Defined.Definitionequiv_path_dhprop'`{Funext} (PQ:DHProp): (P=Q:>HProp) <~> (P=Q:>DHProp).Proof.destructPas[PdP].destructQas[QdQ].refine(((equiv_ap'issig_dhprop^-1__)^-1)oE_);cbn.refine((equiv_path_sigma_hprop(P;dP) (Q;dQ))).Defined.Definitionequiv_path_dhprop`{Univalence} (PQ:DHProp): (P=Q:>Type) <~> (P=Q:>DHProp).Proof.assert(eq_type_hprop: (P=Q:>Type) <~> (P=Q:>HProp))byapplyequiv_path_trunctype'.assert(eq_hprop_dhprop: (P=Q:>HProp) <~> (P=Q:>DHProp))byapplyequiv_path_dhprop'.refine(eq_hprop_dhpropoEeq_type_hprop).Defined.Definitionpath_dhprop`{Univalence} {PQ:DHProp}: (P=Q:>Type) -> (P=Q:>DHProp):=equiv_path_dhpropPQ.Global Instanceishset_dprop`{Univalence} :IsHSetDProp.Proof.applyistrunc_S;introsPQ.refine(istrunc_equiv_istrunc_(n:= -1) (equiv_path_dpropPQ)).Defined.Global Instanceisequiv_dprop_to_bool`{Univalence}:IsEquivdprop_to_bool.Proof.refine(isequiv_adjointifydprop_to_boolbool_to_dhprop__).-intros[];reflexivity.-introsP;unfolddprop_to_bool.destruct(decP);symmetry;applypath_dprop,path_universe_uncurried.+applyif_hprop_then_equiv_Unit; [exact_|assumption].+applyif_not_hprop_then_equiv_Empty; [exact_|assumption].Defined.Definitionequiv_dprop_to_bool`{Univalence}:DProp<~>Bool:=Build_Equiv__dprop_to_bool_.OperationsWe define the logical operations on decidable hprops to be the operations on ordinary hprops, with decidability carrying over.  For the operations which preserve hprops without funext, we define separate versions that act onDHProp.Definitiondand(b1b2:DProp) :DProp:=Build_DProp(b1*b2)__.Definitiondhand(b1b2:DHProp) :DHProp:=Build_DHProp(Build_HProp(b1*b2))_.Definitiondor(b1b2:DProp) :DProp:=Build_DProp(horb1b2)__.Definitiondhor(b1b2:DHProp) :DHProp:=Build_DHProp(Build_HProp(horb1b2))_.Definitiondneg(b:DProp) :DProp:=Build_DProp(~b)__.Definitiondimpl(b1b2:DProp) :DProp:=Build_DProp(b1->b2)__.Declare Scopedprop_scope.DelimitScopedprop_scopewithdprop.Bind Scopedprop_scopewithDProp.Declare Scopedhprop_scope.DelimitScopedhprop_scopewithdhprop.Bind Scopedhprop_scopewithDHProp.Infix"&&" :=dand:dprop_scope.Infix"&&" :=dhand:dhprop_scope.Infix"||" :=dor:dprop_scope.Infix"||" :=dhor:dhprop_scope.Infix"->" :=dimpl:dprop_scope.Notation"!! P" := (dnegP) :dprop_scope.Local OpenScopedprop_scope.ComputationIn order to be able to "compute" withDProps like booleans, we define a couple of typeclasses.ClassIsTrue(P:DProp) :=dprop_istrue:P.ClassIsFalse(P:DProp) :=dprop_isfalse: ~P.Note that we are not usingTypeclassesStrictResolutionforIsTrueandIsFalse; this enables us to write simplydprop_istrueas a proof of some true dprop, and Coq will infer from context what the dprop is that we're proving.Global Instancetrue_istrue:IsTrueTrue:=tt.Global Instancefalse_isfalse:IsFalseFalse:=idmap.Global Instancedand_true_true{PQ} `{IsTrueP} `{IsTrueQ}:IsTrue(P&&Q).Proof.exact(dprop_istrue,dprop_istrue).Defined.Global Instancedand_false_l{PQ} `{IsFalseP}:IsFalse(P&&Q).Proof.intros[pq].exact(dprop_isfalsep).Defined.Global Instancedand_false_r{PQ} `{IsFalseQ}:IsFalse(P&&Q).Proof.intros[pq].exact(dprop_isfalseq).Defined.Global Instancedhand_true_true{PQ:DHProp} `{IsTrueP} `{IsTrueQ}:IsTrue(P&&Q)%dhprop.Proof.We have to givePas an explicit argument here.  This is apparently because with twoIsTrueinstances in the context, when we write simplydprop_istrue, Coq guesses one of them during typeclass resolution, and isn't willing to backtrack once it realizes that that choice fails to be what's needed to solve the goal.  Coq currently seems to consistently guessQrather thanP, so that we don't have to give the argumentQto the second call todprop_istrue; but rather than depend on such behavior, we give both arguments explicitly.  (The problem doesn't arise withdand_true_truebecause in that case, unification, which fires before typeclass search, is able to guess that the argument must beP.)exact(@dprop_istrueP_, @dprop_istrueQ_).Defined.Global Instancedhand_false_l{PQ:DHProp} `{IsFalseP}:IsFalse(P&&Q)%dhprop.Proof.intros[pq].exact(dprop_isfalsep).Defined.Global Instancedhand_false_r{PQ:DHProp} `{IsFalseQ}:IsFalse(P&&Q)%dhprop.Proof.intros[pq].exact(dprop_isfalseq).Defined.Global Instancedor_true_l{PQ} `{IsTrueP}:IsTrue(P||Q).Proof.exact(tr(inlQdprop_istrue)).Defined.Global Instancedor_true_r{PQ} `{IsTrueQ}:IsTrue(P||Q).Proof.exact(tr(inrPdprop_istrue)).Defined.Global Instancedor_false_false{PQ} `{IsFalseP} `{IsFalseQ}:IsFalse(P||Q).Proof.introspq.strip_truncations.destructpqas[p|q].-exact(dprop_isfalsep).-exact(dprop_isfalseq).Defined.Global Instancedhor_true_l{PQ:DHProp} `{IsTrueP}:IsTrue(P||Q)%dhprop.Proof.exact(tr(inlQdprop_istrue)).Defined.Global Instancedhor_true_r{PQ:DHProp} `{IsTrueQ}:IsTrue(P||Q)%dhprop.Proof.exact(tr(inrPdprop_istrue)).Defined.Global Instancedhor_false_false{PQ:DHProp} `{IsFalseP} `{IsFalseQ}:IsFalse(P||Q)%dhprop.Proof.introspq.strip_truncations.destructpqas[p|q].See comment in the proof ofdhand_true_true.-exact(@dprop_isfalseP_p).-exact(@dprop_isfalseQ_q).Defined.Global Instancedneg_true{P} `{IsTrueP}:IsFalse(!!P).Proof.introsnp;exact(npdprop_istrue).Defined.Global Instancedneg_false{P} `{IsFalseP}:IsTrue(!!P).Proof.exactdprop_isfalse.Defined.Global Instancedimpl_true_r{PQ} `{IsTrueQ}:IsTrue(P->Q).Proof.introsp.exactdprop_istrue.Defined.Global Instancedimpl_false_l{PQ} `{IsFalseP}:IsTrue(P->Q).Proof.introsp.elim(dprop_isfalsep).Defined.Global Instancedimpl_true_false{PQ} `{IsTrueP} `{IsFalseQ}:IsFalse(P->Q).Proof.introsf.exact(dprop_isfalse(fdprop_istrue)).Defined.Lemmapath_dec(A:Type) `{IsHPropA} `{DecidableA} `{Univalence} :A=is_inl(decA).Proof.refine(path_universe_uncurried_).applyequiv_iff_hprop_uncurried.split.-introsb.destruct(decA);simpl;auto.-destruct(decA);simpl;auto.intros[].Defined.

--- Miscellaneous\Dual.html ---
DualLibrary DualOpposite natural transformationsRequireCategory.DualFunctor.Dual.ImportCategory.Dual.CategoryDualNotationsFunctor.Dual.FunctorDualNotations.RequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Definition ofTᵒᵖDefinitionoppositeCD(FG:FunctorCD)(T:NaturalTransformationFG):NaturalTransformationG^opF^op:=Build_NaturalTransformation'(G^op) (F^op)(components_ofT)(funsd=>commutes_symTds)(funsd=>commutesTds).Local Notation"T ^op" := (oppositeT) :natural_transformation_scope.ᵒᵖis judgmentally involutiveLocal OpenScopenatural_transformation_scope.Definitionopposite_involutiveCD(FG:FunctorCD) (T:NaturalTransformationFG): (T^op)^op=T:=idpath.ModuleExportNaturalTransformationDualNotations.Notation"T ^op" := (oppositeT) :natural_transformation_scope.EndNaturalTransformationDualNotations.

--- Miscellaneous\DualFunctor.html ---
DualFunctorLibrary DualFunctorThe functorᵒᵖ:cat→catRequireImportCategory.CoreFunctor.Core.RequireImportCategory.DualFunctor.Dual.RequireImportFunctor.Composition.CoreFunctor.Identity.RequireImportCat.CoreFunctor.Paths.RequireImportBasics.TruncTypes.SigmaHoTT.TacticsTypes.Forall.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Sectionopposite.Context`{Funext}.VariableP:PreCategory->Type.Context`{forallC,IsHProp(PC)}.Context`{HF:forallCD,PC->PD->IsHSet(FunctorCD)}.Letcat:= (@sub_pre_cat_PHF).Hypothesishas_op:forallC:cat,PC.1^op.Definitionopposite_functor:Functorcatcat:=Build_Functorcatcat(funC=> (C.1^op;has_op_))(fun__F=>F^op)%functor(fun_____=>idpath)(fun_=>idpath).Letopposite_functor_involutive_helper(x:cat): (x.1^op^op;has_op(_;has_op_)) =x:=path_sigma_uncurriedP(((x.1^op)^op)%category;has_op((x.1^op)%category;has_opx))x(Category.Dual.opposite_involutivex.1;path_ishprop__).Local OpenScopefunctor_scope.Local Argumentspath_sigma_uncurried:simplnever.Definitionopposite_functor_involutive:opposite_functoroopposite_functor= 1.Proof.path_functor.refine(path_forall__opposite_functor_involutive_helper;_).repeat(applypath_forall;intro).rewrite!transport_forall_constant.transport_path_forall_hammer.unfoldopposite_functor_involutive_helper.rewrite!transport_pr1_path_sigma_uncurried.simplin*.repeatprogresschange(funx=> ?fx)withfin*.matchgoalwith| [ |-context[transport(funx'=> ?fx'.1 ?y)(@path_sigma_uncurried?A?P?u?v?pq)] ]=>rewrite(@transport_pr1_path_sigma_uncurriedAPuvpq(funx=>fxy))end.simplin*.hnfin*.subst_body.destruct_head@sig.destruct_head@Functor.destruct_head@PreCategory.reflexivity.Qed.Endopposite.

--- Miscellaneous\Empty.html ---
EmptyLibrary EmptyTheorems about the empty typeRequireImportBasics.OvertureBasics.EquivalencesBasics.Trunc.LocalSetUniverseMinimizationToSet.Local OpenScopepath_scope.UnpackingEta conversionPathsTransportFunctorial actionEquivalencesUniversal mapping propertiesGlobal Instancecontr_from_Empty@{u} {_:Funext} (A:Empty->Type@{u}):Contr@{u} (forallx:Empty,Ax).Proof.refine(Build_Contr@{u}_(Empty_indA)_).introsf;applypath_forall@{Setuu};introsx;elimx.Defined.LemmaEmpty_rec{T:Type} (falso:Empty) :T.Proof.casefalso.Defined.Global Instanceisequiv_empty_rec@{u} `{Funext} (A:Type@{u}):IsEquiv@{Setu} (fun(_:Unit) => @Empty_recA) | 0:=isequiv_adjointify@{Setu}_(fun_=>tt)(funf=>path_forall@{Setuu}__(funx=>Empty_recx))(funx=>matchxwithtt=>idpathend).Definitionequiv_empty_rec@{u} `{Funext} (A:Type@{u}):Unit<~> ((Empty->A) :Type@{u}):= (Build_Equiv@{Setu}__(fun(_:Unit) => @Empty_recA)_).Behavior with respect to truncationGlobal Instanceistrunc_Empty@{} (n:trunc_index) :IsTruncn.+1Empty.Proof.refine(@istrunc_leq(-1)n.+1tt__).applyistrunc_S.intros[].Defined.Global Instanceisequiv_all_to_empty(T:Type) (f:T->Empty) :IsEquivf.Proof.refine(Build_IsEquiv___(Empty_ind(fun_=>T))(* := equiv_inv *)(funfals:Empty=>matchfalswithend)(* : f o equiv_inv == idmap *)(funt:T=>match(ft)withend)(* : equiv_inv o f == idmap *)(_)(* adjointify part *)).introt.exact(Empty_rec(ft)).Defined.Definitionequiv_to_empty{T:Type} (f:T->Empty) :T<~>Empty:=Build_EquivTEmptyf_.PathsWe could probably prove some theorems about non-existing paths inEmpty, but this is really quite useless. As soon as an element ofEmptyis hypothesized, we can prove whatever we like with a simple elimination.

--- Miscellaneous\EmptyCat.html ---
EmptyCatLibrary EmptyCatRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.Empty categoryGlobal Instanceisgraph_empty:IsGraphEmpty.Proof.byapplyBuild_IsGraph.Defined.Global Instanceis01cat_empty:Is01CatEmpty.Proof.srapplyBuild_Is01Cat;intros[].Defined.Global Instanceis0gpd_empty:Is0GpdEmpty.Proof.constructor;intros[].Defined.Global Instanceis2graph_empty:Is2GraphEmpty.Proof.introsfg.byapplyBuild_IsGraph.Defined.Global Instanceis1cat_empty:Is1CatEmpty.Proof.snrapplyBuild_Is1Cat;intros[].Defined.

--- Miscellaneous\EMSpace.html ---
EMSpaceLibrary EMSpaceRequireImportBasicsTypes.RequireImportPointed.RequireImportCubical.DPath.RequireImportAlgebra.AbGroups.RequireImportHomotopy.Suspension.RequireImportHomotopy.ClassifyingSpace.RequireImportHomotopy.HSpace.Coherent.RequireImportHomotopy.HomotopyGroup.RequireImportHomotopy.Hopf.RequireImportTruncations.CoreTruncations.Connectedness.RequireImportWildCat.Eilenberg-Mac Lane spacesLocal OpenScopepointed_scope.Local OpenScopenat_scope.Local OpenScopemc_mult_scope.The definition of the Eilenberg-Mac Lane spaces.  Note that while we allowGto be non-abelian forn>1, later results will need to assume thatGis abelian.FixpointEilenbergMacLane(G:Group) (n:nat) :pType:=matchnwith| 0    =>G| 1    =>pClassifyingSpaceG|m.+1 =>pTrm.+1 (psusp(EilenbergMacLaneGm))end.Notation"'K(' G , n )" := (EilenbergMacLaneGn).SectionEilenbergMacLane.Context`{Univalence}.Global Instanceistrunc_em{G:Group} {n:nat} :IsTruncnK(G,n).Proof.destructnas[|[]];exact_.Defined.This is subsumed by the next result, but Coq doesn't always find the next result when it should.Global Instanceisconnected_em{G:Group} (n:nat):IsConnectednK(G,n.+1).Proof.inductionn;exact_.Defined.Global Instanceisconnected_em'{G:Group} (n:nat):IsConnectedn.-1K(G,n).Proof.destructn.1:exact(is_minus_one_connected_pointed_).applyisconnected_em.Defined.Global Instanceis0connected_em{G:Group} (n:nat):IsConnected0K(G,n.+1).Proof.rapply(is0connected_isconnectedn.-2).Defined.Local OpenScopetrunc_scope.This is a variant ofpequiv_ptr_loop_psuspfrom pSusp.v. All we are really using is thatn.+2<=n+2+n, but because of the use ofisconnmap_pred_add, the proof is a bit more specific to this case.Local Lemmapequiv_ptr_loop_psusp'(X:pType) (n:nat) `{IsConnectedn.+1X}:pTrn.+2X<~>*pTrn.+2 (loops(psuspX)).Proof.snrapplyBuild_pEquiv.1:rapply(fmap(pTr_) (loop_susp_unit_)).nrapplyO_inverts_conn_map.nrapply(isconnmap_pred_addn.-2).rewrite2trunc_index_add_succ.apply(conn_map_loop_susp_unitnX).Defined.Lemmapequiv_loops_em_em(G:AbGroup) (n:nat):K(G,n) <~>*loopsK(G,n.+1).Proof.destructn.1:applypequiv_g_loops_bg.change(K(G,n.+1) <~>*loops(pTrn.+2 (psusp(K(G,n.+1))))).refine(ptr_loops__o*E_).destructn.1:srapply(licata_finster(m:=-2)).refine(_o*Epequiv_ptr(n:=n.+2)).rapplypequiv_ptr_loop_psusp'.Defined.Definitionpequiv_loops_em_g(G:AbGroup) (n:nat):G<~>*iterated_loopsnK(G,n).Proof.inductionn.-reflexivity.-refine((unfold_iterated_loops'__)^-1*o*E_o*EIHn).exact(emap(iterated_loopsn) (pequiv_loops_em_em__)).Defined.For positive indices, we in fact get a group isomorphism.Definitionequiv_g_pi_n_em(G:AbGroup) (n:nat):GroupIsomorphismG(Pin.+1K(G,n.+1)).Proof.inductionn.-applygrp_iso_g_pi1_bg.-nrefine(grp_iso_compose_IHn).nrefine(grp_iso_compose_(groupiso_pi_functor_(pequiv_loops_em_em__))).symmetry;apply(groupiso_pi_loops__).Defined.Definitioniscohhspace_em{G:AbGroup} (n:nat):IsCohHSpaceK(G,n).Proof.nrapplyiscohhspace_equiv_cohhspace.2:applypequiv_loops_em_em.applyiscohhspace_loops.Defined.IfGandG'are isomorphic, thenK(G,n)andK(G',n)are equivalent.  TODO:  We should show thatK(-,n)is a functor, which implies this.Definitionpequiv_em_group_iso{GG':Group} (n:nat)(e:G$<~>G'):K(G,n) <~>*K(G',n).Proof.bydestruct(equiv_path_groupe).Defined.Every pointed (n-1)-connected n-type is an Eilenberg-Mac Lane space.Definitionpequiv_em_connected_truncated(X:pType)(n:nat) `{IsConnectednX} `{IsTruncn.+1X}:K(Pin.+1X,n.+1) <~>*X.Proof.generalizedependentX;inductionn;introsXisCisT.1:rapplypequiv_pclassifyingspace_pi1.(* The equivalence will be the composite<<K( (Pi n.+2 X) n.+2)<~>* K( (Pi n.+1 (loops X)), n.+2)= pTr n.+2 (psusp K( (Pi n.+1 (loops X)), n.+1))bydefinition<~>* pTr n.+2 (psusp (loops X))<~>* pTr n.+2 X<~>* X>>and we'll work from right to left.*)refine((pequiv_ptr(n:=n.+2))^-1*o*E_).refine(pequiv_ptr_psusp_loopsXno*E_).change(K(?G,n.+2))with(pTrn.+2 (psuspK(G,n.+1 ))).refine(emap(pTrn.+2opsusp)_).refine((IHn(loopsX)__)o*E_).applypequiv_em_group_iso.applygroupiso_pi_loops.Defined.EndEilenbergMacLane.

--- Miscellaneous\EncodeDecode.html ---
EncodeDecodeLibrary EncodeDecodeRequireImportBasicsPointed.RequireImportTruncations.Core.Encode-decode method of characterizing identity typesSee PathAny.v for a related characterization of identity types.Definitionencode_decode(A:Type) (a0:A) (code:A->Type)(c0:codea0) (decode:forallx,codex->a0=x)(s:forall(c:codea0),decode_c#c0=c)(r:decode_c0=idpath) (a1:A):a0=a1<~>codea1.Proof.srapplyequiv_adjointify.-exact(funp=>p#c0).-applydecode.-introp.destruct(decode_p)inp.applys.-intros[].exactr.Defined.Encode-decode for truncated identity-typesDefinitionencode_decode_truncn(A:Type) (a0:A) (code:A->Type) `{foralla,IsTruncn(codea)}(c0:codea0) (decode:forallx,codex->Trn(a0=x))(s:forall(c:codea0),Trunc_rec(funp=>p#c0) (decode_c) =c)(r:decode_c0=tridpath) (a1:A):Trn(a0=a1) <~>codea1.Proof.srapplyequiv_adjointify.-apply(Trunc_rec(funp=>p#c0)).-applydecode.-introp.pose(decode_p)asp'.clearbodyp'.strip_truncations.destructp'inp.applys.-introsp.strip_truncations.destructp.exactr.Defined.Encode-decode for loop spacesDefinitionencode_decode_loops(A:pType) (code:pFamA)(decode:forallx,codex->pointA=x)(s:forall(c:code(pointA)),decode_c# (dpointcode) =c)(r:decode_(dpointcode) =idpath):loopsA<~>code(pointA):=encode_decode__code(dpointcode)decodesr_.Encode-decode for truncated loop spacesDefinitionencode_decode_trunc_loopsn(A:pType) (code:pFamA) `{foralla,IsTruncn(codea)}(decode:forallx,codex->Trn(pointA=x))(s:forall(c:code(pointA)),Trunc_rec(fun(p:loopsA) =>p# (dpointcode)) (decode_c) =c)(r:decode_(dpointcode) =tridpath):pTrn(loopsA) <~>code(pointA):=encode_decode_trunc___code(dpointcode)decodesr_.

--- Miscellaneous\epi.html ---
epiLibrary epiRequireImportBasics.RequireImportTypes.RequireImportTruncType.RequireImportReflectiveSubuniverse.RequireImportColimits.PushoutTruncations.CoreHIT.SetCone.Local OpenScopepath_scope.SectionAssumingUA.Context`{ua:Univalence}.We will now prove that for sets, epis and surjections are equivalent.Definitionisepi{XY} `(f:X->Y) :=forallZ:HSet,forallgh:Y->Z,gof=hof->g=h.Definitionisepi_funext{XY:Type} (f:X->Y):=forallZ:HSet,forallg0g1:Y->Z,g0of==g1of->g0==g1.Definitionisepi'{XY} `(f:X->Y) :=forall(Z:HSet) (g:Y->Z),Contr{h:Y->Z|gof=hof}.Lemmaequiv_isepi_isepi'{XY}f: @isepiXYf<~> @isepi'XYf.Proof.unfoldisepi,isepi'.apply(@equiv_functor_forall'_____(equiv_idmap_));introZ.apply(@equiv_functor_forall'_____(equiv_idmap_));introg.unfoldequiv_idmap;simpl.refine(transitivity(@equiv_sig_ind_(funh:Y->Z=>gof=hof) (funh=>g=h.1))_).TODO(JasonGross): Can we do this entirely by chaining equivalences?applyequiv_iff_hprop.{introhepi.nrapply(Build_Contr_(g;idpath)).introxy;specialize(hepixy).applypath_sigma_uncurried.existshepi.applypath_ishprop. }{introshepixy.exact(appr1((contr(g; 1))^ @contrxy)). }Defined.Definitionequiv_isepi_isepi_funext{XY:Type} (f:X->Y):isepif<~>isepi_funextf.Proof.applyequiv_iff_hprop.-introse?g0g1h.applyequiv_path_arrow.applye.byapplypath_arrow.-introse?g0g1p.applypath_arrow.applye.byapplyequiv_path_arrow.Defined.Sectioncones.Lemmaisepi'_contr_cone`{Funext} {AB:HSet} (f:A->B) :isepi'f->Contr(setconef).Proof.introshepi.apply(Build_Contr_(setcone_point_)).pose(alpha1:= @pglueABUnitf(const_tt_)).pose(tot:= {h:B->setconef&tropushoinlof=hof}).transparentassert(l:tot).{simplerefine(tro_oinl;_).{refinepush. }{refineidpath. } }pose(r:= (@constB(setconef) (setcone_point_); (ap(funf=> @tr0_of) (path_forall__alpha1))) :tot).substtot.assert(X:l=r).{letlem:=constr:(funXpush'=>hepi(Build_HSet(setconef)) (tropush'o@inl_X))inpose(lem_push).refine(path_contrlr). }substlr.pose(I0b:=ap10(X..1)b).refine(Trunc_ind__).pose(funa:B+Unit=> (matchaasareturnsetcone_point_=tr(pusha)with|inla'=> (I0a')^|inrtt=>idpathend))asI0f.refine(Pushout_ind_(funa'=>I0f(inla')) (funu=> (I0f(inru)))_).simpl.substalpha1.intros.unfoldsetcone_point.substI0.simpl.pose(X..2)asp.simplinp.rewrite(transport_precomposef__X..1)inp.assert(H':=concat(ap(funx=>ap10xa)p) (ap10_ap_postcomposetr(path_arrow(pushlof) (pushroconst_tt_)pglue)_)).rewriteap10_path_arrowinH'.clearp.Apparentlypose;clearbodyis only ~.8 seconds, whileposeproofis ~4 seconds?pose(concat(ap10_ap_precomposef(X..1)a)^H')asp.clearbodyp.simplinp.rewritep.rewritetransport_paths_Fr.applyconcat_Vp.Qed.Endcones.Lemmaissurj_isepi{XY} (f:X->Y):IsSurjectionf->isepif.Proof.introssur? ? ?ep.applypath_forall.introy.specialize(sury).pose(center(merely(hfiberfy))).apply(Trunc_rec(n:=-1) (A:=(sig(funx:X=>fx=y))));tryassumption.intros[xp].set(p0:=apD10epx).transitivity(g(fx)).-byapplyap.-transitivity(h(fx));autowithpath_hints.byapplyap.Qed.Corollaryissurj_isepi_funext{XY} (f:X->Y) :IsSurjectionf->isepi_funextf.Proof.intros.applyequiv_isepi_isepi_funext.byapplyissurj_isepi.Defined.Old-style proof using polymorphic Omega. Needs resizing for the isepi proof to live in the
 same universe as X and Y (the Z quantifier is instantiated with an HSet at a level higher)Lemma isepi_issurj {X Y} (f:X->Y): isepi f -> issurj f.
Proof.
  intros epif y.
  set (g :=fun _:Y => Unit_hp).
  set (h:=(fun y:Y => (hp (hexists (fun _ : Unit => {x:X & y = (f x)})) _ ))).
  assert (X1: g o f = h o f ).
  - apply path_forall. intro x. apply path_equiv_biimp_rec;[|done].
    intros _ . apply min1. exists tt. by (exists x).
  - specialize (epif _ g h).
    specialize (epif X1). clear X1.
    set (p:=apD10 epif y).
    apply (@minus1Trunc_map (sig (fun _ : Unit => sig (fun x : X => y = f x)))).
    + intros [ _ [x eq]].
      exists x.
        by symmetry.
    + apply (transport hproptype p tt).
Defined.Sectionisepi_issurj.Context{XY:HSet} (f:X->Y) (Hisepi:isepif).Definitionepif:=equiv_isepi_isepi'_Hisepi.Definitionfam(c:setconef) :HProp.Proof.pose(fiby:=hexists(funx:X=>fx=y)).apply(funf=> @Trunc_rec__HProp_fc).refine(Pushout_recHPropfib(fun_=>Unit_hp) (funx=>_)).Prove that the truncated sigma is equivalent to Unitpose(contr_inhabited_hprop(fib(fx)) (tr(x;idpath)))asi.applypath_hprop.simpl.simplini.apply(equiv_contr_unit).Defined.Lemmaisepi_issurj:IsSurjectionf.Proof.introsy.pose(i:=isepi'_contr_cone_epif).assert(X0:forallx:setconef,famx=fam(setcone_pointf)).{intros.applycontr_dom_equiv.applyi. }specialize(X0(tr(push(inly)))).simplinX0.unfoldIsConnected.refine(transport(funA=>ContrA) (aptrunctype_typeX0)^_);exact_.Defined.Endisepi_issurj.Lemmaisepi_isequivXY(f:X->Y) `{IsEquiv__f}:isepif.Proof.intros?ghH'.applyap10inH'.applypath_forall.introx.transitivity(g(f(f^-1x))).-byrewriteeisretr.-transitivity(h(f(f^-1x))).*applyH'.*byrewriteeisretr.Qed.EndAssumingUA.

--- Miscellaneous\Equalizer.html ---
EqualizerLibrary EqualizerRequireImportBasicsTypes.SigmaTypes.Paths.EqualizersDefinitionEqualizer{AB} (fg:A->B):= {x:A&fx=gx}.Definitionfunctor_equalizer{ABA'B'} (fg:A->B)(f'g':A'->B')(h:B->B') (k:A->A')(p:hof==f'ok) (q:hog==g'ok):Equalizerfg->Equalizerf'g'.Proof.intros[xr].exists(kx).exact((px)^ @ (aphr) @ (qx)).Defined.Definitionequiv_functor_equalizer{ABA'B'} (fg:A->B)(f'g':A'->B')(h:B<~>B') (k:A<~>A')(p:hof==f'ok) (q:hog==g'ok):Equalizerfg<~>Equalizerf'g'.Proof.unfoldEqualizer.srapply(equiv_functor_sigma'k).-introa;cbn.refine(_oE_).2:rapply(equiv_aph).exact(equiv_concat_r(qa)_oEequiv_concat_l(pa)^_).Defined.

--- Miscellaneous\Equiv.html ---
EquivLibrary EquivRequireImportBasics.Utf8Basics.OvertureBasics.TacticsBasics.Equivalences.RequireImportWildCat.Core.RequireImportWildCat.Opposite.We declare a scope for printingCatEquivas≅Declare Scopewc_iso_scope.Equivalences in wild categoriesWe could define equivalences in any wild 1-category as bi-invertible maps, or in a wild 2-category as half-adjoint equivalences.  However, in concrete cases there is often an equivalent definition of equivalences that we want to use instead, and the important property we need is that it's logically equivalent to (quasi-)isomorphism. Incat_hasequivsbelow, we show that bi-invertible maps do provide aHasEquivsstructure for any wild 1-category.ClassHasEquivs(A:Type) `{Is1CatA} :={CatEquiv':A->A->Typewhere"a $<~> b" := (CatEquiv'ab);CatIsEquiv':forallab, (a$->b) ->Type;cate_fun':forallab, (a$<~>b) -> (a$->b);cate_isequiv':forallab(f:a$<~>b),CatIsEquiv'ab(cate_fun'abf);cate_buildequiv':forallab(f:a$->b),CatIsEquiv'abf->CatEquiv'ab;cate_buildequiv_fun':forallab(f:a$->b) (fe:CatIsEquiv'abf),cate_fun'ab(cate_buildequiv'abffe) $==f;cate_inv':forallab(f:a$<~>b),b$->a;cate_issect':forallab(f:a$<~>b),cate_inv'__f$ocate_fun'__f$==Ida;cate_isretr':forallab(f:a$<~>b),cate_fun'__f$ocate_inv'__f$==Idb;catie_adjointify':forallab(f:a$->b) (g:b$->a)(r:f$og$==Idb) (s:g$of$==Ida),CatIsEquiv'abf;}.Since apparently a field of a record can't be the source of a coercion (Coq complains about the uniform inheritance condition, although as officially stated that condition appears to be satisfied), we redefine all the fields ofHasEquivs.DefinitionCatEquiv{A} `{HasEquivsA} (ab:A):= @CatEquiv'A_____ab.Notation"a $<~> b" := (CatEquivab).Infix"≅" :=CatEquiv:wc_iso_scope.ArgumentsCatEquiv:simplnever.Definitioncate_fun{A} `{HasEquivsA} {ab:A} (f:a$<~>b):a$->b:= @cate_fun'A_____abf.Coercioncate_fun:CatEquiv>->Hom.(* Being an equivalence should be a typeclass, but we have to redefine it to work around https://github.com/coq/coq/issues/8994 . *)ClassCatIsEquiv{A} `{HasEquivsA} {ab:A} (f:a$->b):=catisequiv:CatIsEquiv'abf.Global Instancecate_isequiv{A} `{HasEquivsA} {ab:A} (f:a$<~>b):CatIsEquivf:=cate_isequiv'abf.DefinitionBuild_CatEquiv{A} `{HasEquivsA} {ab:A}(f:a$->b) {fe:CatIsEquivf}:a$<~>b:=cate_buildequiv'abffe.Definitioncate_buildequiv_fun{A} `{HasEquivsA} {ab:A}(f:a$->b) {fe:CatIsEquivf}:cate_fun(Build_CatEquivf) $==f:=cate_buildequiv_fun'abffe.Definitioncatie_adjointify{A} `{HasEquivsA} {ab:A}(f:a$->b) (g:b$->a)(r:f$og$==Idb) (s:g$of$==Ida):CatIsEquivf:=catie_adjointify'abfgrs.Definitioncate_adjointify{A} `{HasEquivsA} {ab:A}(f:a$->b) (g:b$->a)(r:f$og$==Idb) (s:g$of$==Ida):a$<~>b:=Build_CatEquivf(fe:=catie_adjointifyfgrs).This one we define to construct the whole inverse equivalence.Definitioncate_inv{A} `{HasEquivsA} {ab:A} (f:a$<~>b) :b$<~>a.Proof.simplerefine(cate_adjointify____).-exact(cate_inv'abf).-exactf.-exact(cate_issect'abf).-exact(cate_isretr'abf).Defined.Notation"f ^-1$" := (cate_invf).Opposite categories preserve having equivalences.Global Instancehasequivs_op{A} `{HasEquivsA} :HasEquivsA^op.Proof.snrapplyBuild_HasEquivs;introsab;unfoldopina,b;cbn.-exact(b$<~>a).-applyCatIsEquiv.-applycate_fun'.-applycate_isequiv'.-applycate_buildequiv'.-rapplycate_buildequiv_fun'.-applycate_inv'.-rapplycate_isretr'.-rapplycate_issect'.-introsfgst.exact(catie_adjointifyfgts).Defined.Global Instanceisequiv_op{A:Type} `{HasEquivsA}{ab:A} (f:a$->b) {ief:CatIsEquivf}: @CatIsEquivA^op_____baf:=ief.Definitioncate_issect{A} `{HasEquivsA} {ab} (f:a$<~>b):f^-1$ $of$==Ida.Proof.refine(_$@cate_issect'abf).refine(_$@Rf).applycate_buildequiv_fun'.Defined.Definitioncate_isretr{A} `{HasEquivsA} {ab} (f:a$<~>b):f$of^-1$ $==Idb:=cate_issect(A:=A^op) (b:=a) (a:=b)f.Ifgis a section of an equivalence, then it is the inverse.Definitioncate_inverse_sect{A} `{HasEquivsA} {ab} (f:a$<~>b)(g:b$->a) (p:f$og$==Idb):cate_funf^-1$ $==g.Proof.refine((cat_idr_)^$ $@_).refine((_$@Lp^$) $@_).refine(cat_assoc_opp___$@_).refine(cate_issectf$@R_$@_).applycat_idl.Defined.Ifgis a retraction of an equivalence, then it is the inverse.Definitioncate_inverse_retr{A} `{HasEquivsA} {ab} (f:a$<~>b)(g:b$->a) (p:g$of$==Ida):cate_funf^-1$ $==g:=cate_inverse_sect(A:=A^op) (a:=b) (b:=a)fgp.It follows that the inverse of the equivalence you get by adjointification is homotopic to the inversegprovided.Definitioncate_inv_adjointify{A} `{HasEquivsA} {ab:A}(f:a$->b) (g:b$->a) (r:f$og$==Idb) (s:g$of$==Ida):cate_fun(cate_adjointifyfgrs)^-1$ $==g.Proof.applycate_inverse_sect.exact((cate_buildequiv_funf$@R_) $@r).Defined.The identity morphism is an equivalenceGlobal Instancecatie_id{A} `{HasEquivsA} (a:A):CatIsEquiv(Ida):=catie_adjointify(Ida) (Ida) (cat_idl(Ida)) (cat_idr(Ida)).Definitionid_cate{A} `{HasEquivsA} (a:A):a$<~>a:=Build_CatEquiv(Ida).Global Instancereflexive_cate{A} `{HasEquivsA}:Reflexive(@CatEquivA_____):=id_cate.Global Instancesymmetric_cate{A} `{HasEquivsA}:Symmetric(@CatEquivA_____):=funabf=>cate_invf.Anything homotopic to an equivalence is an equivalence. This should not be an instance.Definitioncatie_homotopic{A} `{HasEquivsA} {ab:A}(f:a$->b) `{!CatIsEquivf} {g:a$->b} (p:f$==g):CatIsEquivg.Proof.snrapplycatie_adjointify.-exact(Build_CatEquivf)^-1$.-refine(p^$ $@R_$@_).refine((cate_buildequiv_funf)^$ $@R_$@_).applycate_isretr.-refine(_$@Lp^$ $@_).refine(_$@L(cate_buildequiv_funf)^$ $@_).applycate_issect.Defined.Equivalences can be composed.  In order to make use of duality, we factor out parts of the proof as two lemmas.Definitioncompose_catie_isretr{A} `{HasEquivsA} {abc:A}(g:b$<~>c) (f:a$<~>b):g$of$o(f^-1$ $og^-1$) $==Idc.Proof.refine(cat_assoc___$@_).refine((_$@Lcat_assoc_opp___) $@_).refine((_$@L(cate_isretr_$@R_)) $@_).refine((_$@Lcat_idl_) $@_).applycate_isretr.Defined.Definitioncompose_catie_issect{A} `{HasEquivsA} {abc:A}(g:b$<~>c) (f:a$<~>b): (f^-1$ $og^-1$ $o(g$of) $==Ida):=compose_catie_isretr(A:=A^op) (a:=c) (b:=b) (c:=a)fg.Global Instancecompose_catie{A} `{HasEquivsA} {abc:A}(g:b$<~>c) (f:a$<~>b):CatIsEquiv(g$of).Proof.refine(catie_adjointify_(f^-1$ $og^-1$)__).-applycompose_catie_isretr.-applycompose_catie_issect.Defined.Global Instancecompose_catie'{A} `{HasEquivsA} {abc:A}(g:b$->c) `{!CatIsEquivg} (f:a$->b) `{!CatIsEquivf}:CatIsEquiv(g$of):=catie_homotopic_(cate_buildequiv_fun_$@@cate_buildequiv_fun_).Definitioncompose_cate{A} `{HasEquivsA} {abc:A}(g:b$<~>c) (f:a$<~>b) :a$<~>c:=Build_CatEquiv(g$of).Notation"g $oE f" := (compose_categf).Definitioncompose_cate_fun{A} `{HasEquivsA}{abc:A} (g:b$<~>c) (f:a$<~>b):cate_fun(g$oEf) $==g$of.Proof.applycate_buildequiv_fun.Defined.Definitioncompose_cate_funinv{A} `{HasEquivsA}{abc:A} (g:b$<~>c) (f:a$<~>b):g$of$==cate_fun(g$oEf).Proof.applygpd_rev.applycate_buildequiv_fun.Defined.Definitionid_cate_fun{A} `{HasEquivsA} (a:A):cate_fun(id_catea) $==Ida.Proof.applycate_buildequiv_fun.Defined.Definitioncompose_cate_assoc{A} `{HasEquivsA}{abcd:A} (f:a$<~>b) (g:b$<~>c) (h:c$<~>d):cate_fun((h$oEg) $oEf) $==cate_fun(h$oE(g$oEf)).Proof.refine(compose_cate_fun_f$@_$@cat_assocfgh$@_$@compose_cate_funinvh_).-refine(compose_cate_funhg$@R_).-refine(_$@Lcompose_cate_funinvgf).Defined.Definitioncompose_cate_assoc_opp{A} `{HasEquivsA}{abcd:A} (f:a$<~>b) (g:b$<~>c) (h:c$<~>d):cate_fun(h$oE(g$oEf)) $==cate_fun((h$oEg) $oEf).Proof.Opaquecompose_catie_isretr.(* We useexact_no_checkjust to save a small amount of time. *)exact_no_check(compose_cate_assoc(A:=A^op) (a:=d) (b:=c) (c:=b) (d:=a)hgf).Defined.Transparentcompose_catie_isretr.Definitioncompose_cate_idl{A} `{HasEquivsA}{ab:A} (f:a$<~>b):cate_fun(id_cateb$oEf) $==cate_funf.Proof.refine(compose_cate_fun_f$@_$@cat_idlf).refine(cate_buildequiv_fun_$@R_).Defined.Definitioncompose_cate_idr{A} `{HasEquivsA}{ab:A} (f:a$<~>b):cate_fun(f$oEid_catea) $==cate_funf:=compose_cate_idl(A:=A^op) (a:=b) (b:=a)f.Global Instancetransitive_cate{A} `{HasEquivsA}:Transitive(@CatEquivA_____):=funabcfg=>g$oEf.Some more convenient equalities for equivalences. The naming scheme is similar toPathGroupoids.v.Definitioncompose_V_hh{A} `{HasEquivsA} {abc:A} (f:b$<~>c) (g:a$->b) :f^-1$ $o(f$og) $==g:=(cat_assoc_opp___) $@ (cate_issectf$@Rg) $@cat_idlg.Definitioncompose_h_Vh{A} `{HasEquivsA} {abc:A} (f:c$<~>b) (g:a$->b) :f$o(f^-1$ $og) $==g:=(cat_assoc_opp___) $@ (cate_isretrf$@Rg) $@cat_idlg.Definitioncompose_hh_V{A} `{HasEquivsA} {abc:A} (f:b$->c) (g:a$<~>b) :(f$og) $og^-1$ $==f:=cat_assoc___$@ (f$@Lcate_isretrg) $@cat_idrf.Definitioncompose_hV_h{A} `{HasEquivsA} {abc:A} (f:b$->c) (g:b$<~>a) :(f$og^-1$) $og$==f:=cat_assoc___$@ (f$@Lcate_issectg) $@cat_idrf.Equivalences are both monomorphisms and epimorphisms (but not the converse).Definitioncate_monic_equiv{A} `{HasEquivsA} {ab:A} (e:a$<~>b):Monice.Proof.introscfgp.refine((compose_V_hhe_)^$ $@_$@compose_V_hhe_).exact(_$@Lp).Defined.Definitioncate_epic_equiv{A} `{HasEquivsA} {ab:A} (e:a$<~>b):Epice:=cate_monic_equiv(A:=A^op) (a:=b) (b:=a)e.Movement LemmasThese lemmas can be used to move equivalences around in an equation.Definitioncate_moveL_eM{A} `{HasEquivsA} {abc:A}(e:a$<~>b) (f:a$->c) (g:b$->c)(p:f$oe^-1$ $==g):f$==g$oe.Proof.apply(cate_epic_equive^-1$).exact(p$@ (compose_hh_V__)^$).Defined.Definitioncate_moveR_eM{A} `{HasEquivsA} {abc:A}(e:b$<~>a) (f:a$->c) (g:b$->c)(p:f$==g$oe^-1$):f$oe$==g.Proof.apply(cate_epic_equive^-1$).exact(compose_hh_V__$@p).Defined.Definitioncate_moveL_Me{A} `{HasEquivsA} {abc:A}(e:b$<~>c) (f:a$->c) (g:a$->b)(p:e^-1$ $of$==g):f$==e$og:=cate_moveL_eM(A:=A^op) (a:=c) (b:=b) (c:=a)efgp.Definitioncate_moveR_Me{A} `{HasEquivsA} {abc:A}(e:c$<~>b) (f:a$->c) (g:a$->b)(p:f$==e^-1$ $og):e$of$==g:=cate_moveR_eM(A:=A^op) (a:=c) (b:=b) (c:=a)efgp.Definitioncate_moveL_eV{A} `{HasEquivsA} {abc:A}(e:a$<~>b) (f:b$->c) (g:a$->c)(p:f$oe$==g):f$==g$oe^-1$.Proof.apply(cate_epic_equive).exact(p$@ (compose_hV_h__)^$).Defined.Definitioncate_moveR_eV{A} `{HasEquivsA} {abc:A}(e:b$<~>a) (f:b$->c) (g:a$->c)(p:f$==g$oe):f$oe^-1$ $==g.Proof.apply(cate_epic_equive).exact(compose_hV_h__$@p).Defined.Definitioncate_moveL_Ve{A} `{HasEquivsA} {abc:A}(e:b$<~>c) (f:a$->b) (g:a$->c)(p:e$of$==g):f$==e^-1$ $og:=cate_moveL_eV(A:=A^op) (a:=c) (b:=b) (c:=a)efgp.Definitioncate_moveR_Ve{A} `{HasEquivsA} {abc:A}(e:b$<~>c) (f:a$->c) (g:a$->b)(p:f$==e$og):e^-1$ $of$==g:=cate_moveR_eV(A:=A^op) (a:=b) (b:=c) (c:=a)efgp.Definitioncate_moveL_V1{A} `{HasEquivsA} {ab:A} {e:a$<~>b} (f:b$->a)(p:e$of$==Id_):f$==cate_fune^-1$.Proof.apply(cate_monic_equive).exact(p$@ (cate_isretre)^$).Defined.Definitioncate_moveL_1V{A} `{HasEquivsA} {ab:A} {e:a$<~>b} (f:b$->a)(p:f$oe$==Id_):f$==cate_fune^-1$:=cate_moveL_V1(A:=A^op) (a:=b) (b:=a)fp.Definitioncate_moveR_V1{A} `{HasEquivsA} {ab:A} {e:a$<~>b} (f:b$->a)(p:Id_$==e$of):cate_fune^-1$ $==f.Proof.apply(cate_monic_equive).exact(cate_isretre$@p).Defined.Definitioncate_moveR_1V{A} `{HasEquivsA} {ab:A} {e:a$<~>b} (f:b$->a)(p:Id_$==f$oe):cate_fune^-1$ $==f:=cate_moveR_V1(A:=A^op) (a:=b) (b:=a)fp.Lemmas about the underlying map of an equivalence.Definitioncate_inv2{A} `{HasEquivsA} {ab:A} {ef:a$<~>b} (p:cate_fune$==cate_funf):cate_fune^-1$ $==cate_funf^-1$.Proof.applycate_moveL_V1.exact((p^$ $@R_) $@cate_isretr_).Defined.Definitioncate_inv_compose{A} `{HasEquivsA} {abc:A} (e:a$<~>b) (f:b$<~>c):cate_fun(f$oEe)^-1$ $==cate_fun(e^-1$ $oEf^-1$).Proof.refine(_$@ (compose_cate_fun__)^$).applycate_inv_adjointify.Defined.Definitioncate_inv_compose'{A} `{HasEquivsA} {abc:A} (e:a$<~>b) (f:b$<~>c):cate_fun(f$oEe)^-1$ $==e^-1$ $of^-1$.Proof.nrefine(_$@cate_buildequiv_fun_).nrapplycate_inv_compose.Defined.Definitioncate_inv_V{A} `{HasEquivsA} {ab:A} (e:a$<~>b):cate_fun(e^-1$)^-1$ $==cate_fune.Proof.applycate_moveR_V1.symmetry;applycate_issect.Defined.Any sufficiently coherent functor preserves equivalences.Global Instanceiemap{AB:Type} `{HasEquivsA} `{HasEquivsB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{ab:A} (f:a$<~>b):CatIsEquiv(fmapFf).Proof.refine(catie_adjointify(fmapFf) (fmapFf^-1$)__).-refine((fmap_compFf^-1$f)^$ $@fmap2F(cate_isretr_) $@fmap_idF_).-refine((fmap_compFff^-1$)^$ $@fmap2F(cate_issect_) $@fmap_idF_).Defined.Definitionemap{AB:Type} `{HasEquivsA} `{HasEquivsB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{ab:A} (f:a$<~>b):Fa$<~>Fb:=Build_CatEquiv(fmapFf).Definitionemap_id{AB:Type} `{HasEquivsA} `{HasEquivsB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF} {a:A}:cate_fun(emapF(id_catea)) $==cate_fun(id_cate(Fa)).Proof.refine(cate_buildequiv_fun_$@_).refine(fmap2F(id_cate_funa) $@_$@ (id_cate_fun(Fa))^$).rapplyfmap_id.Defined.Definitionemap_compose{AB:Type} `{HasEquivsA} `{HasEquivsB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{abc:A} (f:a$<~>b) (g:b$<~>c):cate_fun(emapF(g$oEf)) $==fmapF(cate_fung) $ofmapF(cate_funf).Proof.refine(cate_buildequiv_fun_$@_).refine(fmap2F(compose_cate_fun__) $@_).rapplyfmap_comp.Defined.A variant.Definitionemap_compose'{AB:Type} `{HasEquivsA} `{HasEquivsB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{abc:A} (f:a$<~>b) (g:b$<~>c):cate_fun(emapF(g$oEf)) $==cate_fun((emapFg) $oE(emapFf)).Proof.refine(emap_composeFfg$@_).symmetry.refine(compose_cate_fun__$@_).exact(cate_buildequiv_fun_$@@cate_buildequiv_fun_).Defined.Definitionemap_inv{AB:Type} `{HasEquivsA} `{HasEquivsB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{ab:A} (e:a$<~>b):cate_fun(emapFe)^-1$ $==cate_fun(emapFe^-1$).Proof.refine(cate_inv_adjointify____$@_).exact(cate_buildequiv_fun_)^$.Defined.Definitionemap_inv'{AB:Type} `{HasEquivsA} `{HasEquivsB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF}{ab:A} (e:a$<~>b):cate_fun(emapFe)^-1$ $==fmapFe^-1$:=emap_invFe$@cate_buildequiv_fun_.When we have equivalences, we can define what it means for a category to be univalent.Definitioncat_equiv_path{A:Type} `{HasEquivsA} (ab:A): (a=b) -> (a$<~>b).Proof.intros[];reflexivity.Defined.ClassIsUnivalent1Cat(A:Type) `{HasEquivsA}:= {isequiv_cat_equiv_path:forallab,IsEquiv(@cat_equiv_pathA_____ab) }.Global Existing Instanceisequiv_cat_equiv_path.Definitioncat_path_equiv{A:Type} `{IsUnivalent1CatA} (ab:A): (a$<~>b) -> (a=b):= (cat_equiv_pathab)^-1.Core of a 1-categoryRecordcore(A:Type) := {uncore:A}.Argumentsuncore{A}c.ArgumentsBuild_core{A}a:rename.Global Instanceisgraph_core{A:Type} `{HasEquivsA}:IsGraph(coreA).Proof.srapplyBuild_IsGraph.introsab;exact(uncorea$<~>uncoreb).Defined.Global Instanceis01cat_core{A:Type} `{HasEquivsA}:Is01Cat(coreA).Proof.srapplyBuild_Is01Cat;cbv.-intros;applyid_cate.-introsabc;applycompose_cate.Defined.Global Instanceis2graph_core{A:Type} `{HasEquivsA}:Is2Graph(coreA).Proof.introsab.applyBuild_IsGraph.introsfg;exact(cate_funf$==cate_fung).Defined.Global Instanceis01cat_core_hom{A:Type} `{HasEquivsA} (ab:coreA):Is01Cat(a$->b).Proof.srapplyBuild_Is01Cat.-introf;cbn;applyId.-introsfgh;cbn;applycat_comp.Defined.Global Instanceis0gpd_core_hom{A:Type} `{HasEquivsA} (ab:coreA):Is0Gpd(a$->b).Proof.applyBuild_Is0Gpd.introsfg;cbv.applygpd_rev.Defined.Global Instanceis0functor_core_postcomp{A:Type} `{HasEquivsA}(abc:coreA) (h:b$->c) :Is0Functor(cat_postcompah).Proof.applyBuild_Is0Functor.introsfgal;cbninh.exact(compose_cate_funhf$@ (h$@Lal)$@ (compose_cate_funhg)^$).Defined.Global Instanceis0functor_core_precomp{A:Type} `{HasEquivsA}(abc:coreA) (h:a$->b) :Is0Functor(cat_precompch).Proof.applyBuild_Is0Functor.introsfgal;cbninh.Why can't coq resolve this?refine(compose_cate_funfh$@ (_$@Rh)$@ (compose_cate_fungh)^$).exactal.Defined.Global Instanceis1cat_core{A:Type} `{HasEquivsA}:Is1Cat(coreA).Proof.rapplyBuild_Is1Cat.-intros;applycompose_cate_assoc.-intros;applycompose_cate_assoc_opp.-intros;applycompose_cate_idl.-intros;applycompose_cate_idr.Defined.Global Instanceis0gpd_core{A:Type} `{HasEquivsA}:Is0Gpd(coreA).Proof.applyBuild_Is0Gpd.introsabf;cbnin*;exact(f^-1$).Defined.Global Instanceis1gpd_core{A:Type} `{HasEquivsA}:Is1Gpd(coreA).Proof.applyBuild_Is1Gpd;cbn;introsabf;refine(compose_cate_fun__$@_$@ (id_cate_fun_)^$).-applycate_issect.-applycate_isretr.Defined.Global Instancehasequivs_core{A:Type} `{HasEquivsA}:HasEquivs(coreA).Proof.srapplyBuild_HasEquivs.1:exact(funab=>a$->b).(* IncoreA, i.e.CatEquiv'(uncorea)(uncoreb). *)all:introsabf;cbn;intros.-exactUnit.(* OrCatIsEquiv'(uncorea)(uncoreb)(cate_funf)? *)-exactf.-exacttt.(* Orcate_isequiv'___? *)-exactf.-reflexivity.-exactf^-1$.-refine(compose_cate_fun__$@_).refine(cate_issect_$@_).symmetry;applyid_cate_fun.-refine(compose_cate_fun__$@_).refine(cate_isretr_$@_).symmetry;applyid_cate_fun.-exacttt.Defined.Global Instancehasmorext_core{A:Type} `{HasEquivsA, !HasMorExtA}`{forallxy(fg:uncorex$<~>uncorey),IsEquiv(ap(x:=f) (y:=g)cate_fun)}:HasMorExt(coreA).Proof.snrapplyBuild_HasMorExt.introsXYfg;cbnin*.snrapplyisequiv_homotopic.-exact(GpdHom_patho(ap(x:=f) (y:=g)cate_fun)).-rapplyisequiv_compose.-introp;byinductionp.Defined.Initial objects and terminal objects are all respectively equivalent.Lemmacate_isinitialA`{HasEquivsA} (xy:A):IsInitialx->IsInitialy->x$<~>y.Proof.introsinxiny.srapply(cate_adjointify(inxy).1 (inyx).1).1:exact(((iny_).2_)^$ $@ (iny_).2_).1:exact(((inx_).2_)^$ $@ (inx_).2_).Defined.Definitioncate_isterminalA`{HasEquivsA} (xy:A):IsTerminalx->IsTerminaly->y$<~>x:=cate_isinitialA^opxy.Lemmaisinitial_cateA`{HasEquivsA} (xy:A):x$<~>y->IsInitialx->IsInitialy.Proof.introsfinxz.exists((inxz).1 $of^-1$).introsg.refine(_$@compose_hh_V_f).refine(_$@R_).exact((inxz).2_).Defined.Definitionisterminal_cateA`{HasEquivsA} (xy:A):y$<~>x->IsTerminalx->IsTerminaly:=isinitial_cateA^opxy.There is a default notion of equivalence for a 1-category, namely bi-invertibility.We do not use the half-adjoint definition, since we can't prove adjointification for that definition.ClassCat_IsBiInv{A} `{Is1CatA} {xy:A} (f:x$->y) := {cat_equiv_inv:y$->x;cat_eisretr:f$ocat_equiv_inv$==Idy;cat_equiv_inv':y$->x;cat_eissect':cat_equiv_inv'$of$==Idx;}.Argumentscat_equiv_inv{A}%_type_scope{____xy}f{_}.Argumentscat_eisretr{A}%_type_scope{____xy}f{_}.Argumentscat_equiv_inv'{A}%_type_scope{____xy}f{_}.Argumentscat_eissect'{A}%_type_scope{____xy}f{_}.ArgumentsBuild_Cat_IsBiInv{A}%_type_scope{____xyf}cat_equiv_invcat_eisretrcat_equiv_inv'cat_eissect'.RecordCat_BiInvA`{Is1CatA} (xy:A) := {cat_equiv_fun:>x$->y;cat_equiv_isequiv:Cat_IsBiInvcat_equiv_fun;}.Global Existing Instancecat_equiv_isequiv.The two inverses are necessarily homotopic.Definitioncat_inverses_homotopic{A} `{Is1CatA} {xy:A} (f:x$->y) {bif:Cat_IsBiInvf}:cat_equiv_invf$==cat_equiv_inv'f.Proof.refine((cat_idl_)^$ $@_).refine(cat_prewhisker(cat_eissect'f)^$_$@_).refine(cat_assoc___$@_).refine(cat_postwhisker_(cat_eisretrf) $@_).applycat_idr.Defined.Therefore we can proveeissectfor the first inverse as well.Definitioncat_eissect{A} `{Is1CatA} {xy:A} (f:x$->y) {bif:Cat_IsBiInvf}:cat_equiv_invf$of$==Idx:= (cat_inverses_homotopicf$@Rf) $@cat_eissect'f.This shows that any 1-category satisfiesHasEquivs.  We do not make it an instance, since we may want to use a differentHasEquivsstructure in particular cases.Definitioncat_hasequivsA`{Is1CatA} :HasEquivsA.Proof.srapplyBuild_HasEquivs;introsxy.1:exact(Cat_BiInv_xy).all:introsf;cbnbetain*.-exact(Cat_IsBiInvf).-exactf.-exact_.-applyBuild_Cat_BiInv.-intros;reflexivity.-exact(cat_equiv_invf).-applycat_eissect.-applycat_eisretr.-introsgrs.exact(Build_Cat_IsBiInvgrgs).Defined.

--- Miscellaneous\EquivalenceInduction.html ---
EquivalenceInductionLibrary EquivalenceInductionEquivalence inductionRequireImportBasics.OvertureBasics.EquivalencesBasics.Tactics.RequireImportTypes.EquivTypes.ProdTypes.ForallTypes.SigmaTypes.Universe.We define typeclasses and tactics for doing equivalence induction.Local OpenScopeequiv_scope.ClassRespectsEquivalenceL@{ijks0s1} (A:Type@{i}) (P:forall(B:Type@{j}), (A<~>B) ->Type@{k}):=respects_equivalenceL:sig@{s0s1} (fune':forallB(e:A<~>B),PA(equiv_idmapA) <~>PBe=>Funext->equiv_idmap_=e'A(equiv_idmap_) ).ClassRespectsEquivalenceR@{ijks0s1} (A:Type@{i}) (P:forall(B:Type@{j}), (B<~>A) ->Type@{k}):=respects_equivalenceR:sig@{s0s1} (fune':forallB(e:B<~>A),PA(equiv_idmapA) <~>PBe=>Funext->equiv_idmap_=e'A(equiv_idmap_) ).We use a sigma type rather than a record for two reasons:1. In the dependent cases, where one equivalence-respectfulness proof will show up in the body of another goal, it might be the case that using sigma types allows us to reuse the respectfulness lemmas of sigma types, rather than writing new ones for this type.2. We expect it to be significantly useful to see the type of the fields than the type of the record, because we expect this type to show up as a goal infrequently.  Sigma types have more informative notations than record type names; the user can run hnf to see what is left to do in the side conditions.Global ArgumentsRespectsEquivalenceL:clearimplicits.Global ArgumentsRespectsEquivalenceR:clearimplicits.When doing equivalence induction, typeclass inference will either fully solve the respectfulness side-conditions, or not make any progress.  We would like to progress as far as we can on the side-conditions, so that we leave the user with as little to prove as possible.  To do this, we create a "database", implemented using typeclasses, to look up the refinement lemma, keyed on the head of the term we want to respect equivalence.Classrespects_equivalence_db{KTVT} (Key:KT) {lem:VT} :Type0:=make_respects_equivalence_db:Unit.Definitionget_lem'{KTVT}Key{lem} `{@respects_equivalence_dbKTVTKeylem} :VT:=lem.Notationget_lemkey:=ltac:(letres:=constr:(get_lem'key)inletres':= (evalunfoldget_lem'inres)inexactres') (onlyparsing).Sectionconst.Context{A:Type} {T:Type}.Global Instanceconst_respects_equivalenceL:RespectsEquivalenceLA(fun__=>T).Proof.refine(fun__=>equiv_idmapT;fun_=>_).exactidpath.Defined.Global Instanceconst_respects_equivalenceR:RespectsEquivalenceRA(fun__=>T).Proof.refine(fun__=>equiv_idmap_;fun_=>_).exactidpath.Defined.Endconst.Global Instance:forall{T}, @respects_equivalence_db__T(funA=> @const_respects_equivalenceLAT) :=fun_=>tt.Sectionid.Context{A:Type}.Global Instanceidmap_respects_equivalenceL:RespectsEquivalenceLA(funB_=>B).Proof.refine(funBe=>e;fun_=>_).exactidpath.Defined.Global Instanceidmap_respects_equivalenceR:RespectsEquivalenceRA(funB_=>B).Proof.refine(funBe=>equiv_inversee;fun_=>path_equiv_).applypath_forall;intro;reflexivity.Defined.Endid.Sectionunit.Context{A:Type}.Definitionunit_respects_equivalenceL:RespectsEquivalenceLA(fun__=>Unit):= @const_respects_equivalenceLAUnit.Definitionunit_respects_equivalenceR:RespectsEquivalenceRA(fun__=>Unit):= @const_respects_equivalenceRAUnit.Endunit.Sectionprod.Global Instanceprod_respects_equivalenceL{A} {PQ:forallB, (A<~>B) ->Type}`{RespectsEquivalenceLAP,RespectsEquivalenceLAQ}:RespectsEquivalenceLA(funBe=>PBe*QBe).Proof.refine((funBe=>equiv_functor_prod'(respects_equivalenceL.1Be) (respects_equivalenceL.1Be));_).exact(funfs=>transport(fune'=>_=equiv_functor_prod'e'_) (respects_equivalenceL.2_)(transport(fune'=>_=equiv_functor_prod'_e') (respects_equivalenceL.2_)idpath)).Defined.Global Instanceprod_respects_equivalenceR{A} {PQ:forallB, (B<~>A) ->Type}`{RespectsEquivalenceRAP,RespectsEquivalenceRAQ}:RespectsEquivalenceRA(funBe=>PBe*QBe).Proof.refine((funBe=>equiv_functor_prod'(respects_equivalenceR.1Be) (respects_equivalenceR.1Be));_).exact(funfs=>transport(fune'=>_=equiv_functor_prod'e'_) (respects_equivalenceR.2_)(transport(fune'=>_=equiv_functor_prod'_e') (respects_equivalenceR.2_)idpath)).Defined.Global Instance: @respects_equivalence_db__(@prod) (@prod_respects_equivalenceL) :=tt.Endprod.A tactic to solve the identity-preservation part of equivalence-respectfulness.Local Ltact_step:=idtac;matchgoalwith| [ |-_=_:> (_<~>_) ] =>applypath_equiv|_=>reflexivity|_=>assumption|_=>intro| [ |-_=_:> (forall_,_) ] =>applypath_forall|_=>progressunfoldfunctor_forall,functor_sigma|_=>progresscbnin*| [ |-context[?x.1] ] =>letH:=freshindestructxas[?H];trydestructH| [H:_=_|-_] =>destructH| [H: ?A-> ?B,H': ?A|-_] =>specialize(HH')| [H: ?A-> ?B,H': ?A|-_] =>generalizedependent(HH');clearH|_=>progressrewrite?eisretr, ?eissectend.Local Ltact:=repeatt_step.Sectionpi.Global Instanceforall_respects_equivalenceL`{Funext} {A} {P:forallB, (A<~>B) ->Type} {Q:forallBe,PBe->Type}`{HP:RespectsEquivalenceLAP}`{HQ:foralla:PA(equiv_idmapA),RespectsEquivalenceLA(funBe=>QBe(respects_equivalenceL.1Bea))}:RespectsEquivalenceLA(funBe=>forallx:PBe,QBex).Proof.simplerefine(funBe=>_;_).{refine(equiv_functor_forall'(equiv_inverse((@respects_equivalenceL__HP).1Be))(funb=>_)).refine(equiv_compose'(equiv_path__(ap(QBe) (eisretr__)))(equiv_compose'((HQ(equiv_inverse((@respects_equivalenceL__HP).1Be)b)).1Be)(equiv_path__(ap(QA(equiv_idmap_))_)))).refine(ap10(apequiv_fun(respects_equivalenceL.2_))_). }{t. }Defined.Global Instanceforall_respects_equivalenceR`{Funext} {A} {P:forallB, (B<~>A) ->Type} {Q:forallBe,PBe->Type}`{HP:RespectsEquivalenceRAP}`{HQ:foralla:PA(equiv_idmapA),RespectsEquivalenceRA(funBe=>QBe(respects_equivalenceR.1Bea))}:RespectsEquivalenceRA(funBe=>forallx:PBe,QBex).Proof.simplerefine(funBe=>_;_).{refine(equiv_functor_forall'(equiv_inverse((@respects_equivalenceR__HP).1Be))(funb=>_)).refine(equiv_compose'(equiv_path__(ap(QBe) (eisretr__)))(equiv_compose'((HQ(equiv_inverse((@respects_equivalenceR__HP).1Be)b)).1Be)(equiv_path__(ap(QA(equiv_idmap_))_)))).refine(ap10(apequiv_fun(respects_equivalenceR.2_))_). }{t. }Defined.Endpi.Sectionsigma.Global Instancesigma_respects_equivalenceL`{Funext} {A} {P:forallB, (A<~>B) ->Type} {Q:forallBe,PBe->Type}`{HP:RespectsEquivalenceLAP}`{HQ:foralla:PA(equiv_idmapA),RespectsEquivalenceLA(funBe=>QBe(respects_equivalenceL.1Bea))}:RespectsEquivalenceLA(funBe=>sig(QBe)).Proof.simplerefine((funBe=>equiv_functor_sigma'(respects_equivalenceL.1Be) (funb=>_));_).{refine(equiv_compose'((HQb).1Be)(equiv_path__(ap(QA(equiv_idmap_))_))).refine(ap10(apequiv_fun(respects_equivalenceL.2_))_). }{t. }Defined.Global Instancesigma_respects_equivalenceR`{Funext} {A} {P:forallB, (B<~>A) ->Type} {Q:forallBe,PBe->Type}`{HP:RespectsEquivalenceRAP}`{HQ:foralla:PA(equiv_idmapA),RespectsEquivalenceRA(funBe=>QBe(respects_equivalenceR.1Bea))}:RespectsEquivalenceRA(funBe=>sig(QBe)).Proof.simplerefine((funBe=>equiv_functor_sigma'(respects_equivalenceR.1Be) (funb=>_));_).{refine(equiv_compose'((HQb).1Be)(equiv_path__(ap(QA(equiv_idmap_))_))).refine(ap10(apequiv_fun(respects_equivalenceR.2_))_). }{t. }Defined.Global Instance: @respects_equivalence_db__(@sig) (@sigma_respects_equivalenceL) :=tt.Endsigma.Sectionequiv_transfer.Definitionrespects_equivalenceL_equiv{AA'} {P:forallB, (A<~>B) ->Type} {P':forallB,A'<~>B->Type}(eA:A<~>A')(eP:forallBe,PB(equiv_compose'eeA) <~>P'Be)`{HP:RespectsEquivalenceLAP}:RespectsEquivalenceLA'P'.Proof.simplerefine((funBe=>_);_).{refine(equiv_compose'(eP__)(equiv_compose'(equiv_compose'(HP.1__)(equiv_inverse(HP.1__)))(equiv_inverse(eP__)))). }{t. }Defined.Definitionrespects_equivalenceR_equiv{AA'} {P:forallB, (B<~>A) ->Type} {P':forallB,B<~>A'->Type}(eA:A'<~>A)(eP:forallBe,PB(equiv_compose'eAe) <~>P'Be)`{HP:RespectsEquivalenceRAP}:RespectsEquivalenceRA'P'.Proof.simplerefine((funBe=>_);_).{refine(equiv_compose'(eP__)(equiv_compose'(equiv_compose'(HP.1__)(equiv_inverse(HP.1__)))(equiv_inverse(eP__)))). }{t. }Defined.Definitionrespects_equivalenceL_equiv'{A} {PP':forallB, (A<~>B) ->Type}(eP:forallBe,PBe<~>P'Be)`{HP:RespectsEquivalenceLAP}:RespectsEquivalenceLAP'.Proof.simplerefine((funBe=>_);_).{refine(equiv_compose'(eP__)(equiv_compose'(equiv_compose'(HP.1__)(equiv_inverse(HP.1__)))(equiv_inverse(eP__)))). }{t. }Defined.Definitionrespects_equivalenceR_equiv'{A} {PP':forallB, (B<~>A) ->Type}(eP:forallBe,PBe<~>P'Be)`{HP:RespectsEquivalenceRAP}:RespectsEquivalenceRAP'.Proof.simplerefine((funBe=>_);_).{refine(equiv_compose'(eP__)(equiv_compose'(equiv_compose'(HP.1__)(equiv_inverse(HP.1__)))(equiv_inverse(eP__)))). }{t. }Defined.Endequiv_transfer.Sectionequiv.Global Instanceequiv_respects_equivalenceL`{Funext} {A} {PQ:forallB, (A<~>B) ->Type}`{HP:RespectsEquivalenceLAP}`{HQ:RespectsEquivalenceLAQ}:RespectsEquivalenceLA(funBe=>PBe<~>QBe).Proof.simplerefine(funBe=>_;fun_=>_).{refine(equiv_functor_equiv__);applyrespects_equivalenceL.1. }{t. }Defined.Global Instanceequiv_respects_equivalenceR`{Funext} {A} {PQ:forallB, (B<~>A) ->Type}`{HP:RespectsEquivalenceRAP}`{HQ:RespectsEquivalenceRAQ}:RespectsEquivalenceRA(funBe=>PBe<~>QBe).Proof.simplerefine(funBe=>_;fun_=>_).{refine(equiv_functor_equiv__);applyrespects_equivalenceR.1. }{t. }Defined.Global Instance: @respects_equivalence_db__(@Equiv) (@equiv_respects_equivalenceL) :=tt.Endequiv.Sectionap.Global Instanceequiv_ap_respects_equivalenceL{A} {PQ:forallB, (A<~>B) ->A}`{HP:RespectsEquivalenceLA(funB(e:A<~>B) =>PBe=QBe)}:RespectsEquivalenceLA(fun(B:Type) (e:A<~>B) =>e(PBe) =e(QBe)).Proof.simplerefine(funBe=>_;fun_=>_).{refine(equiv_ap'___oE_);simpl.refine(respects_equivalenceL.1Be). }{t. }Defined.Global Instanceequiv_ap_inv_respects_equivalenceL{A} {PQ:forallB, (A<~>B) ->B}`{HP:RespectsEquivalenceLA(funB(e:A<~>B) =>PBe=QBe)}:RespectsEquivalenceLA(fun(B:Type) (e:A<~>B) =>e^-1 (PBe) =e^-1 (QBe)).Proof.simplerefine(funBe=>_;fun_=>_).{refine(equiv_ap'___oE_);simpl.refine(respects_equivalenceL.1Be). }{t. }Defined.Global Instanceequiv_ap_respects_equivalenceR{A} {PQ:forallB, (B<~>A) ->B}`{HP:RespectsEquivalenceRA(funB(e:B<~>A) =>PBe=QBe)}:RespectsEquivalenceRA(fun(B:Type) (e:B<~>A) =>e(PBe) =e(QBe)).Proof.simplerefine(funBe=>_;fun_=>_).{refine(equiv_ap'___oE_);simpl.refine(respects_equivalenceR.1Be). }{t. }Defined.Global Instanceequiv_ap_inv_respects_equivalenceR{A} {PQ:forallB, (B<~>A) ->A}`{HP:RespectsEquivalenceRA(funB(e:B<~>A) =>PBe=QBe)}:RespectsEquivalenceRA(fun(B:Type) (e:B<~>A) =>e^-1 (PBe) =e^-1 (QBe)).Proof.simplerefine(funBe=>_;fun_=>_).{refine(equiv_ap'___oE_);simpl.refine(respects_equivalenceR.1Be). }{t. }Defined.Endap.We now write the tactic that partially solves the respectfulness side-condition.  We include cases for generic typeclass resolution, keys (heads) with zero, one, two, and three arguments, and a few cases that cannot be easily keyed (where the head is one of the arguments, orforall), or the head ispaths, for which we have only ad-hoc solutions at the moment.Ltacstep_respects_equiv:=idtac;matchgoalwith|_=>progressintros|_=>assumption|_=>progressunfoldrespects_equivalenceL|_=>progresscbn|_=>exact_(* case for fully solving the side-condition, when possible *)| [ |-RespectsEquivalenceL_(fun__=> ?T) ] =>rapply(get_lemT)| [ |-RespectsEquivalenceL_(fun__=> ?T_) ] =>rapply(get_lemT)| [ |-RespectsEquivalenceL_(fun__=> ?T__) ] =>rapply(get_lemT)| [ |-RespectsEquivalenceL_(fun__=> ?T___) ] =>rapply(get_lemT)| [ |-RespectsEquivalenceL_(funBe=>equiv_fune_=equiv_fune_) ] =>refineequiv_ap_respects_equivalenceL| [ |-RespectsEquivalenceL_(funBe=>equiv_inve_=equiv_inve_) ] =>refineequiv_ap_inv_respects_equivalenceL| [ |-RespectsEquivalenceL_(funB_=>B) ] =>refineidmap_respects_equivalenceL| [ |-RespectsEquivalenceL_(fun__=>forall_,_) ] =>refineforall_respects_equivalenceLend.Ltacequiv_inductionp:=generalizedependentp;letp':=freshinintrop';lety:=matchtypeofp'with?x<~> ?y=>constr:(y)endinmovep'attop;generalizedependenty;letP:=matchgoalwith|-forallyp, @?Pyp=>constr:(P)endin(* We use(funx=>x)_to block automatic typeclass resolution in the hole for the equivalence respectful proof. *)refine((fungHBe=> (@respects_equivalenceL_PH).1Beg)_(_: (funx=>x)_));[intros|repeatstep_respects_equiv].Goalforall`{Funext}AB(e:A<~>B),A-> {y:B&forallQ,ContrQ-> ((e^-1y=e^-1y) <~> (y=y)) *Q}.intros? ? ? ?a.equiv_inductione.-simpl.existsa.introsQq.exact(1,center_).Abort.

--- Miscellaneous\Equivalences.html ---
EquivalencesLibrary EquivalencesEquivalencesRequireImportBasics.OvertureBasics.PathGroupoidsBasics.ContractibleBasics.Tactics.Local OpenScopepath_scope.We now give many ways to construct equivalences.  In each case, we define an instance of the typeclassIsEquivnamedisequiv_X, followed by an element of the record typeEquivnamedequiv_X.Whenever we need to assume, as a hypothesis, that a certain function is an equivalence, we do it by assuming separately a function and a proof ofIsEquiv.  This is more general than assuming an inhabitant ofEquiv, since the latter has an implicit coercion and an existing instance to give us the former automatically.  Moreover, implicit generalization makes it easy to assume a function and a proof ofIsEquiv.A word on naming: some of the lemmas about equivalences are analogues of those for paths in PathGroupoids.  We name them in an analogous way but adding_equivin an appropriate place, e.g. instead ofmoveR_Mwe havemoveR_equiv_M.Generalizable VariablesABCfg.The identity map is an equivalence.Global Instanceisequiv_idmap(A:Type) :IsEquividmap| 0 :=Build_IsEquivAAidmapidmap(fun_=> 1) (fun_=> 1) (fun_=> 1).Definitionequiv_idmap(A:Type) :A<~>A:=Build_EquivAAidmap_.Argumentsequiv_idmap{A} ,A.Notation"1" :=equiv_idmap:equiv_scope.Global Instancereflexive_equiv:ReflexiveEquiv| 0 := @equiv_idmap.Argumentsreflexive_equiv/.The composition of equivalences is an equivalence.Global Instanceisequiv_compose`{IsEquivABf} `{IsEquivBCg}:IsEquiv(gof) | 1000:=Build_IsEquivAC(gof)(f^-1og^-1)(func=>apg(eisretrf(g^-1c)) @eisretrgc)(funa=>ap(f^-1) (eissectg(fa)) @eissectfa)(funa=>(whiskerL_(eisadjg(fa))) @(ap_ppg__)^ @ap02g( (concat_A1p(eisretrf) (eissectg(fa)))^ @(ap_composef^-1f_@@eisadjfa) @(ap_ppf__)^) @(ap_composefg_)^).(* An alias ofisequiv_compose, with some arguments explicit; often convenient when type class search fails. *)Definitionisequiv_compose'{AB:Type} (f:A->B) (_:IsEquivf){C:Type} (g:B->C) (_:IsEquivg):IsEquiv(gof):=isequiv_compose.Definitionequiv_compose{ABC:Type} (g:B->C) (f:A->B)`{IsEquivBCg} `{IsEquivABf}:A<~>C:=Build_EquivAC(gof)_.Definitionequiv_compose'{ABC:Type} (g:B<~>C) (f:A<~>B):A<~>C:=equiv_composegf.We putgandfinequiv_scopeexplicitly.  This is a partial work-around for https://github.com/coq/coq/issues/3990, which is that implicitly bound scopes don't nest well.Notation"g 'oE' f" := (equiv_compose'g%equivf%equiv) :equiv_scope.(* The TypeClassTransitivehas a different order of parameters thanequiv_compose.  Thus in declaring the instance we have to switch the order of arguments. *)Global Instancetransitive_equiv:TransitiveEquiv| 0 :=fun___fg=>equiv_composegf.Argumentstransitive_equiv/.A tactic to simplify "oE".  Seeev_equivbelow for a more extensive tactic.Ltacchange_apply_equiv_compose:=matchgoalwith| [ |-context[equiv_fun(?foE?g) ?x] ] =>change((foEg)x)with(f(gx))end.Transporting is an equivalence.SectionEquivTransport.Context{A:Type} (P:A->Type) {xy:A} (p:x=y).Global Instanceisequiv_transport:IsEquiv(transportPp) | 0:=Build_IsEquiv(Px) (Py) (transportPp) (transportPp^)(transport_pVPp) (transport_VpPp) (transport_pVpPp).Definitionequiv_transport:Px<~>Py:=Build_Equiv__(transportPp)_.EndEquivTransport.In all the above cases, we were able to directly construct all the structure of an equivalence.  However, as is evident, sometimes it is quite difficult to prove the adjoint law.The following adjointification theorem allows us to be lazy about this if we wish.  It says that if we have all the data of an (adjoint) equivalence except the triangle identity, then we can always obtain the triangle identity by modifying the datumequiv_is_section(orequiv_is_retraction).  The proof is the same as the standard categorical argument that any equivalence can be improved to an adjoint equivalence.As a stylistic matter, we try to avoid using adjointification in the library whenever possible, to preserve the homotopies specified by the user.SectionAdjointify.Context{AB:Type} (f:A->B) (g:B->A).Context(isretr:fog==idmap) (issect:gof==idmap).(* This is the modifiedeissect. *)Letissect':=funx=>apg(apf(issectx)^)  @apg(isretr(fx))  @issectx.Local Definitionis_adjoint'(a:A) :isretr(fa) =apf(issect'a).Proof.unfoldissect'.applymoveR_M1.repeatrewriteap_pp,concat_p_pp;rewrite<-ap_compose.rewrite(concat_pA1(funb=> (isretrb)^) (apf(issecta)^)).repeatrewriteconcat_pp_p;rewriteap_V;applymoveL_Vp;rewriteconcat_p1.rewriteconcat_p_pp, <-ap_compose.rewrite(concat_pA1(funb=> (isretrb)^) (isretr(fa))).rewriteconcat_pV,concat_1p;reflexivity.Qed.We don't make this a typeclass instance, because we want to control when we are applying it.Definitionisequiv_adjointify:IsEquivf:=Build_IsEquivABfgisretrissect'is_adjoint'.Definitionequiv_adjointify:A<~>B:=Build_EquivABfisequiv_adjointify.EndAdjointify.Argumentsisequiv_adjointify{AB}%_type_scope(fg)%_function_scopeisretrissect.Argumentsequiv_adjointify{AB}%_type_scope(fg)%_function_scopeisretrissect.Anything homotopic to an equivalence is an equivalence. This should not be an instance; it can cause the unifier to spin forever searching for functions to be homotopic to.Definitionisequiv_homotopic{AB:Type} (f:A->B) {g:A->B}`{IsEquivABf} (h:f==g):IsEquivg.Proof.snrapplyisequiv_adjointify.-exactf^-1.-introb.exact((h_)^ @eisretrfb).-introa.exact(apf^-1 (ha)^ @eissectfa).Defined.Definitionisequiv_homotopic'{AB:Type} (f:A<~>B) {g:A->B} (h:f==g):IsEquivg:=isequiv_homotopicfh.Definitionequiv_homotopic{AB:Type} (f:A->B) {g:A->B}`{IsEquivABf} (h:f==g):A<~>B:=Build_Equiv__g(isequiv_homotopicfh).Ifeis an equivalence,fis homotopic toe, andgis homotopic toe^-1, then there is an equivalence whose underlying map isfand whose inverse isg, definitionally.Definitionequiv_homotopic_inverse{AB} (e:A<~>B){f:A->B} {g:B->A} (h:f==e) (k:g==e^-1):A<~>B.Proof.snrapplyequiv_adjointify.-exactf.-exactg.-introa.exact(apf(ka) @h_@eisretrea).-introb.exact(apg(hb) @k_@eissecteb).Defined.An involution is an endomap that is its own inverse.Definitionisequiv_involution{X:Type} (f:X->X) (isinvol:fof==idmap):IsEquivf:=isequiv_adjointifyffisinvolisinvol.Definitionequiv_involution{X:Type} (f:X->X) (isinvol:fof==idmap):X<~>X:=equiv_adjointifyffisinvolisinvol.Several lemmas useful for rewriting.DefinitionmoveR_equiv_M`{IsEquivABf} (x:A) (y:B) (p:x=f^-1y): (fx=y):=apfp@eisretrfy.DefinitionmoveR_equiv_M'`(f:A<~>B) (x:A) (y:B) (p:x=f^-1y): (fx=y):=moveR_equiv_Mxyp.DefinitionmoveL_equiv_M`{IsEquivABf} (x:A) (y:B) (p:f^-1y=x): (y=fx):= (eisretrfy)^ @apfp.DefinitionmoveL_equiv_M'`(f:A<~>B) (x:A) (y:B) (p:f^-1y=x): (y=fx):=moveL_equiv_Mxyp.DefinitionmoveR_equiv_V`{IsEquivABf} (x:B) (y:A) (p:x=fy): (f^-1x=y):=ap(f^-1)p@eissectfy.DefinitionmoveR_equiv_V'`(f:A<~>B) (x:B) (y:A) (p:x=fy): (f^-1x=y):=moveR_equiv_Vxyp.DefinitionmoveL_equiv_V`{IsEquivABf} (x:B) (y:A) (p:fy=x): (y=f^-1x):= (eissectfy)^ @ap(f^-1)p.DefinitionmoveL_equiv_V'`(f:A<~>B) (x:B) (y:A) (p:fy=x): (y=f^-1x):=moveL_equiv_Vxyp.Equivalence preserves contractibility (which of course is trivial under univalence).Lemmacontr_equivA{B} (f:A->B) `{IsEquivABf} `{ContrA}:ContrB.Proof.apply(Build_Contr_(f(centerA))).introy.applymoveR_equiv_M.applycontr.Defined.Definitioncontr_equiv'A{B} `(f:A<~>B) `{ContrA}:ContrB:=contr_equivAf.Any two contractible types are equivalent.Global Instanceisequiv_contr_contr{AB:Type}`{ContrA} `{ContrB} (f:A->B):IsEquivf:=Build_IsEquiv__f(fun_=> (centerA))(funx=>path_contr__)(funx=>path_contr__)(funx=>path_contr__).Definitionequiv_contr_contr{AB:Type} `{ContrA} `{ContrB}: (A<~>B):=Build_Equiv__(fun_=>centerB)_.The projection from the sum of a family of contractible types is an equivalence.Global Instanceisequiv_pr1{A:Type} (P:A->Type) `{forallx,Contr(Px)}:IsEquiv(@pr1AP).Proof.apply(Build_IsEquiv__(@pr1AP)(funx=> (x;center(Px)))(funx=> 1)(funxy=>matchxywith|existxy=>ap(exist_x) (contr_)end)).intros[xy].rewrite<-ap_compose.symmetry;applyap_const.Defined.Definitionequiv_pr1{A:Type} (P:A->Type) `{forallx,Contr(Px)}: {x:A&Px} <~>A:=Build_Equiv__(@pr1AP)_.Equivalences between path spacesIffis an equivalence, then so isapf.  We are lazy and useadjointify.Global Instanceisequiv_ap`{IsEquivABf} (xy:A):IsEquiv(@apABfxy) | 1000:=isequiv_adjointify(apf)(funq=> (eissectfx)^  @apf^-1q@eissectfy)(funq=>ap_ppf__@whiskerR(ap_ppf__)_@ ((ap_Vf_@inverse2(eisadjf_)^)@@ (ap_composef^-1f_)^@@ (eisadjf_)^)@concat_pA1_p(eisretrf)__@whiskerR(concat_Vp_)_@concat_1p_)(funp=>whiskerR(whiskerL_(ap_composeff^-1_)^)_@concat_pA1_p(eissectf)__@whiskerR(concat_Vp_)_@concat_1p_).Definitionequiv_ap`(f:A->B) `{IsEquivABf} (xy:A): (x=y) <~> (fx=fy):=Build_Equiv__(apf)_.Global Argumentsequiv_ap(AB)%_type_scopef%_function_scope___.Definitionequiv_ap'`(f:A<~>B) (xy:A): (x=y) <~> (fx=fy):=equiv_apfxy.Definitionequiv_inj`(f:A->B) `{IsEquivABf} {xy:A}: (fx=fy) -> (x=y):= (apf)^-1.Assuming function extensionality, composing with an equivalence is itself an equivalenceGlobal Instanceisequiv_precompose`{Funext} {ABC:Type}(f:A->B) `{IsEquivABf}:IsEquiv(fun(g:B->C) =>gof) | 1000:=isequiv_adjointify(fun(g:B->C) =>gof)(funh=>hof^-1)(funh=>path_forall__(funx=>aph(eissectfx)))(fung=>path_forall__(funy=>apg(eisretrfy))).Definitionequiv_precompose`{Funext} {ABC:Type}(f:A->B) `{IsEquivABf}: (B->C) <~> (A->C):=Build_Equiv__(fun(g:B->C) =>gof)_.Definitionequiv_precompose'`{Funext} {ABC:Type} (f:A<~>B): (B->C) <~> (A->C):=Build_Equiv__(fun(g:B->C) =>gof)_.Global Instanceisequiv_postcompose`{Funext} {ABC:Type}(f:B->C) `{IsEquivBCf}:IsEquiv(fun(g:A->B) =>fog) | 1000:=isequiv_adjointify(fun(g:A->B) =>fog)(funh=>f^-1oh)(funh=>path_forall__(funx=>eisretrf(hx)))(fung=>path_forall__(funy=>eissectf(gy))).Definitionequiv_postcompose`{Funext} {ABC:Type}(f:B->C) `{IsEquivBCf}: (A->B) <~> (A->C):=Build_Equiv__(fun(g:A->B) =>fog)_.Definitionequiv_postcompose'`{Funext} {ABC:Type} (f:B<~>C): (A->B) <~> (A->C):=Build_Equiv__(fun(g:A->B) =>fog)_.Conversely, if pre- or post-composing with a function is always an equivalence, then that function is also an equivalence.  This is a form of the Yoneda lemma.  It's convenient to know that we only need to assume the equivalence when the other type is the domain or the codomain.Definitionisequiv_isequiv_precompose{AB:Type} (f:A->B)(precomp:= (fun(C:Type) (h:B->C) =>hof))(Aeq:IsEquiv(precompA)) (Beq:IsEquiv(precompB)):IsEquivf.Proof.set(g:=(precompA)^-1idmap).poseproof(p:=eisretr(precompA)idmap:gof=idmap).refine(isequiv_adjointifyfg(ap10_) (ap10p)).apply(equiv_inj(precompB)).unfoldprecomp;cbn.exact(ap(funk=>fok)p).Defined.Definitionisequiv_isequiv_postcompose{AB:Type} (f:A->B)(postcomp:= (fun(C:Type) (h:C->A) =>foh))(Aeq:IsEquiv(postcompA)) (Beq:IsEquiv(postcompB)):IsEquivf.Proof.set(g:=(postcompB)^-1idmap).poseproof(p:=eisretr(postcompB)idmap:fog=idmap).refine(isequiv_adjointifyfg(ap10p) (ap10_)).apply(equiv_inj(postcompA)).unfoldpostcomp;cbn.exact(ap(funk=>kof)p).Defined.The inverse of an equivalence is an equivalence.Global Instanceisequiv_inverse{AB:Type} (f:A->B) {feq:IsEquivf}:IsEquivf^-1 | 10000.Proof.refine(Build_IsEquivBAf^-1f(eissectf) (eisretrf)_).introb.apply(equiv_inj(apf)).(* We will prove the equality as a composite of four paths, working right to left.The LHS remainsapf(eissectf(f^-1b))throughout the process.Both sides of the equation are paths of typef(f^-1(f(f^-1b)))=f(f^-1b). *)refine(_@_@_@_);revgoals.1:applyap_compose.1:symmetry;apply(ap_homotopic_id(eisretrf)).1:symmetry;applyconcat_pp_V.1:symmetry;applyeisadj.Defined.If the goal isIsEquiv_^-1, then useisequiv_inverse; otherwise, don't pretend worry about if the goal is an evar and we want to add a^-1.#[export]HintExtern0 (IsEquiv_^-1) =>apply@isequiv_inverse:typeclass_instances.EquivABis a symmetric relation.Theoremequiv_inverse{AB:Type} : (A<~>B) -> (B<~>A).Proof.introe.exists(e^-1).applyisequiv_inverse.Defined.Notation"e ^-1" := (@equiv_inverse__e) :equiv_scope.Global Instancesymmetric_equiv:SymmetricEquiv| 0 := @equiv_inverse.Argumentssymmetric_equiv/.Inversion respects compositionDefinitionequiv_inverse_compose{ABC} (f:A<~>B) (g:B<~>C): (goEf)^-1 ==f^-1oEg^-1.Proof.introsx;reflexivity.Defined.Inversion respects homotopiesDefinitionequiv_inverse_homotopy{AB} (fg:A<~>B) (p:f==g):g^-1 ==f^-1.Proof.introsx;refine(_@_@_).1:symmetry;apply(eissectf).1:applyap,p.applyap,eisretr.Defined.Definitionequiv_ap_inv`(f:A->B) `{IsEquivABf} (xy:B): (f^-1x=f^-1y) <~> (x=y):= (@equiv_apBAf^-1_xy)^-1%equiv.Definitionequiv_ap_inv'`(f:A<~>B) (xy:B): (f^-1x=f^-1y) <~> (x=y):= (equiv_ap'f^-1%equivxy)^-1%equiv.Ifg\ofandfare equivalences, so isg.  This is not an Instance because it would require Coq to guessf.DefinitioncancelR_isequiv{ABC} (f:A->B) {g:B->C}`{IsEquivABf} `{IsEquivAC(gof)}:IsEquivg:=isequiv_homotopic((gof)of^-1)(funb=>apg(eisretrfb)).DefinitioncancelR_equiv{ABC} (f:A->B) {g:B->C}`{IsEquivABf} `{IsEquivAC(gof)}:B<~>C:=Build_EquivBCg(cancelR_isequivf).Ifg\ofandgare equivalences, so isf.DefinitioncancelL_isequiv{ABC} (g:B->C) {f:A->B}`{IsEquivBCg} `{IsEquivAC(gof)}:IsEquivf:=isequiv_homotopic(g^-1o(gof))(funa=>eissectg(fa)).DefinitioncancelL_equiv{ABC} (g:B->C) {f:A->B}`{IsEquivBCg} `{IsEquivAC(gof)}:A<~>B:=Build_Equiv__f(cancelL_isequivg).Combining these withisequiv_compose, we see that equivalences can be transported across commutative squares.Definitionisequiv_commsq{ABCD}(f:A->B) (g:C->D) (h:A->C) (k:B->D)(p:kof==goh)`{IsEquiv__f} `{IsEquiv__h} `{IsEquiv__k}:IsEquivg.Proof.refine(@cancelR_isequiv___hg__).refine(isequiv_homotopic_p).Defined.Definitionisequiv_commsq'{ABCD}(f:A->B) (g:C->D) (h:A->C) (k:B->D)(p:goh==kof)`{IsEquiv__g} `{IsEquiv__h} `{IsEquiv__k}:IsEquivf.Proof.refine(@cancelL_isequiv___kf__).refine(isequiv_homotopic_p).Defined.Based homotopy spacesGlobal Instancecontr_basedhomotopy`{Funext}{A:Type} {B:A->Type} (f:forallx,Bx):Contr{g:forallx,Bx&f==g}.Proof.refine(contr_equiv'{g:forallx,Bx&f=g}_).srapplyequiv_adjointify;intros[gh].-exact(g;apD10h).-exact(g;path_forall__h).-applyap,eisretr.-applyap,eissect.Defined.Global Instancecontr_basedhomotopy'`{Funext}{A:Type} {B:A->Type} (f:forallx,Bx):Contr{g:forallx,Bx&g==f}.Proof.refine(contr_equiv'{g:forallx,Bx&g=f}_).srapplyequiv_adjointify;intros[gh].-exact(g;apD10h).-exact(g;path_forall__h).-applyap,eisretr.-applyap,eissect.Defined.The functionequiv_indsays that given an equivalencef:A<~>B, and a hypothesis fromB, one may always assume that the hypothesis is in the image ofe.In fibrational terms, if we have a fibration overBwhich has a section once pulled back along an equivalencef:A<~>B, then it has a section over all ofB.Definitionequiv_ind`{IsEquivABf} (P:B->Type): (forallx:A,P(fx)) ->forally:B,Py:=fungy=>transportP(eisretrfy) (g(f^-1y)).Argumentsequiv_ind{AB}f{_}P__.Definitionequiv_ind_comp`{IsEquivABf} (P:B->Type)(df:forallx:A,P(fx)) (x:A):equiv_indfPdf(fx) =dfx.Proof.unfoldequiv_ind.rewriteeisadj.rewrite<-transport_compose.exact(apDdf(eissectfx)).Defined.Usingequiv_ind, we define a handy little tactic which introduces a variablexand simultaneously substitutes it along an equivalenceE.Ltacequiv_introEx:=matchgoalwith| |-forally, @?Qy=>refine(equiv_indEQ_);introsxend.The same, but for several variables.Tactic Notation"equiv_intros"constr(E)ident(x):=equiv_introEx.Tactic Notation"equiv_intros"constr(E)ident(x)ident(y):=equiv_introEx;equiv_introEy.Tactic Notation"equiv_intros"constr(E)ident(x)ident(y)ident(z):=equiv_introEx;equiv_introEy;equiv_introEz.A lemma that combines equivalence induction with path induction.  Ifeis an equivalence froma=btoX, then to proveforallx,Pxit is enough to proveforallp:a=b,P(ep), and so by path induction it suffices to proveP(e1). The idiom for using this is to firstrevertbX, which allows Coq to determine the familyP. After using this,bwill be replaced byain the goal.Definitionequiv_path_ind{A} {a:A} {X:A->Type}(e:forall(b:A),a=b<~>Xb)(P:forall(b:A),Xb->Type)(r:Pa(ea1)):forall(b:A) (x:Xb),Pbx.Proof.introb.srapply(equiv_ind(eb)).intros[].exactr.Defined.equiv_composeR', a flipped version ofequiv_compose', is (likeconcatR) most often useful partially applied, to give the “first half” of an equivalence one is constructing and leave the rest as a subgoal. One could similarly defineequiv_composeRas a flip ofequiv_compose, but it doesn’t seem so useful since it doesn’t leave the remaining equivalence as a subgoal.Definitionequiv_composeR'{ABC} (f:A<~>B) (g:B<~>C):=equiv_compose'gf.(* Shouldn't this become transitivity mid ? *)Ltacequiv_viamid:=apply@equiv_composeR'with(B:=mid).It's often convenient when constructing a chain of equivalences to useequiv_compose', etc.  But when we treat anEquivobject constructed in that way as a function, via the coercionequiv_fun, Coq sometimes needs a little help to realize that the result is the same as ordinary composition.  This tactic provides that help.Ltacev_equiv:=repeatmatchgoalwith| [ |-context[equiv_fun(equiv_inverse(equiv_inverse?f))] ] =>change(equiv_fun(equiv_inverse(equiv_inversef)))with(equiv_funf)| [ |-context[(@equiv_inv?B?A(equiv_fun(equiv_inverse?f)) ?iseq)] ] =>change(@equiv_invBA(equiv_fun(equiv_inversef))iseq)with(equiv_funf)| [ |-context[((equiv_fun?f)^-1)^-1] ] =>change((equiv_funf)^-1)^-1with(equiv_funf)| [ |-context[equiv_fun(equiv_compose'?g?f) ?a] ] =>change(equiv_fun(equiv_compose'gf)a)with(g(fa))| [ |-context[equiv_fun(equiv_compose?g?f) ?a] ] =>change(equiv_fun(equiv_composegf)a)with(g(fa))| [ |-context[equiv_fun(equiv_inverse?f) ?a] ] =>change(equiv_fun(equiv_inversef)a)with(f^-1a)| [ |-context[equiv_fun(equiv_compose'?g?f)] ] =>change(equiv_fun(equiv_compose'gf))with(gof)| [ |-context[equiv_fun(equiv_compose?g?f)] ] =>change(equiv_fun(equiv_composegf))with(gof)| [ |-context[equiv_fun(equiv_inverse?f)] ] =>change(equiv_fun(equiv_inversef))with(f^-1)end.Building equivalences between nested sigma and record typesThe following tacticmake_equivbuilds an equivalence between two types built out of arbitrarily nested sigma and record types, not necessarily right-associated, as long as they have all the same underyling components.  This is more general thanissigin that it doesn't just prove equivalences between a single record type and a single right-nested tower of sigma types, but less powerful in that it can't deduce the latter nested tower of sigmas automatically: you have to have both sides of the equivalence known.(* Performintrosrepeatedly, recursively destructing all possibly-nested record types. We use a custom induction principle forContr, sinceelimproduces two goals. Thehnfis important, for example to unfoldIsUnitPreservingto an equality, which thelazymatchthen ignores. *)Ltacdecomposing_intros:=letx:=freshinintrosx;hnfinx;cbninx;trylazymatchtypeofxwith| ?a= ?b=>idtacDon't destruct paths|forally:?A, ?B=>idtacDon't apply functions|Contr?A=>revertx;matchgoalwith|- (forally, ?Py) =>snrefine(Contr_indAP_)end|_=>elimx;clearxend;trydecomposing_intros.(* A multi-success version ofassumption.  That is, likeassumption, but if there are multiple hypotheses that match the type of the goal, then after choosing the first one, if a later tactic fails we can backtrack and choose another one. *)Ltacmulti_assumption:=multimatchgoalwith(* If we wroteH:?A|-?Ahere instead, it would prevent Coq from choosing an assumption that would require instantiating evars, which it has to do in the contr_basedpaths case below. *)[H: ?A|-_] =>exactHend.(* Build an element of a possibly-nested record type out of hypotheses in the context. *)Ltacbuild_record:=cbn;multi_assumption+ (unshelveeconstructor;build_record).(* Construct an equivalence between two possibly-nested record/sigma types that differ only by associativity and permutation of their components.  We could useBuild_Equivand directly constructeisadjby decomposing to reflexivity as well, but often with large nested types it seems to be faster to adjointify. *)Ltacmake_equiv:=snrefine(equiv_adjointify____);[decomposing_intros;build_record|decomposing_intros;build_record|decomposing_intros;exactidpath|decomposing_intros;exactidpath].In case anyone ever needs it, here's the version that doesn't adjointify. It's not the default, because it can be slow.Ltacmake_equiv_without_adjointification:=snrefine(Build_Equiv____);[decomposing_intros;build_record|snrefine(Build_IsEquiv_______);[decomposing_intros;build_record|decomposing_intros;exactidpath|decomposing_intros;exactidpath|decomposing_intros;exactidpath] ].Here are some examples of the use of this tactic that you can uncomment and explore.Goal forall (A : Type) (B : A -> Type) (C : forall a:A, B a -> Type) (D : forall (a:A) (b:B a), C a b -> Type),
     { ab : {a : A & B a } & { c : C ab.1 ab.2 & D ab.1 ab.2 c } }
     <~> { a : A & { bc : { b : B a & C a b } & D a bc.1 bc.2 } }.
  intros A B C D.
  make_equiv.
  Undo.
  (** Here's the eventually successful proof script produced by [make_equiv], extracted from [Info 0 make_equiv] and prettified, so you can step through it and see how the tactic works. *)
  snrefine (equiv_adjointify _ _ _ _).
  - (** Here begins [decomposing_intros] *)
    intros x; cbn in x.
    elim x; clear x.
    intros x; cbn in x.
    elim x; clear x.
    intros a; cbn in a.
    intros b; cbn in b.
    intros x; cbn in x.
    elim x; clear x.
    intros c; cbn in c. 
    intros d; cbn in d.
    (** Here begins [build_record] *)
    cbn; unshelve econstructor.
    { cbn; exact a. }
    { cbn; unshelve econstructor.
      { cbn; unshelve econstructor.
        { cbn; exact b. }
        { cbn; exact c. } }
      { cbn; exact d. } }
  - intros x; cbn in x.
    elim x; clear x.
    intros a; cbn in a.
    intros x; cbn in x.
    elim x; clear x.
    intros x; cbn in x.
    elim x; clear x. 
    intros b; cbn in b.
    intros c; cbn in c.
    intros d; cbn in d.
    cbn; unshelve econstructor.
    { cbn; unshelve econstructor.
      { cbn; exact a. }
      { cbn; exact b. } }
    { cbn; unshelve econstructor.
      { cbn; exact c. }
      { cbn; exact d. } }
  - intros x; cbn in x.
    elim x; clear x.
    intros a; cbn in a.
    intros x; cbn in x.
    elim x; clear x.
    intros x; cbn in x.
    elim x; clear x. 
    intros b; cbn in b.
    intros c; cbn in c.
    intros d; cbn in d.
    cbn; exact idpath.
  - intros x; cbn in x.
    elim x; clear x.
    intros x; cbn in x.
    elim x; clear x.
    intros a; cbn in a.
    intros b; cbn in b.
    intros x; cbn in x.
    elim x; clear x.
    intros c; cbn in c. 
    intros d; cbn in d.
    cbn; exact idpath.
Defined.Here is an example illustrating the need formulti_assumptioninstead of justassumption.Goal forall (A:Type) (R:A->A->Type),
    { x : A & { y : A & R x y } } <~> { xy : A * A & R (fst xy) (snd xy) }.
  intros A R.
  make_equiv.
  Undo.
  snrefine (equiv_adjointify _ _ _ _).
  - intros x; cbn in x.
    elim x; clear x.
    intros a1; cbn in a1.
    intros x; cbn in x.
    elim x; clear x.
    intros a2; cbn in a2.
    intros r; cbn in r.
    cbn; unshelve econstructor.
    { cbn; unshelve econstructor. 
      { (** [build_record] can't guess at this point that it needs to use [a1] instead of [a2], and in fact it tries [a2] first; but later on, [exact r] fails in that case, causing backtracking to this point and a re-try with [a1].  *)
        cbn; exact a1. }
      { cbn; exact a2. } }
    cbn; exact r.
  - intros x; cbn in x.
    elim x; clear x.
    intros x; cbn in x.
    elim x; clear x.
    intros a1; cbn in a1.
    intros a2; cbn in a2.
    intros r; cbn in r.
    cbn; unshelve econstructor.
    { cbn; exact a1. }
    { cbn; unshelve econstructor.
      { cbn; exact a2. }
      { cbn; exact r. } }
  - intros x; cbn in x.
    elim x; clear x.
    intros x; cbn in x.
    elim x; clear x.
    intros a1; cbn in a1.
    intros a2; cbn in a2.
    intros r; cbn in r.
    cbn; exact idpath.
  - intros x; cbn in x.
    elim x; clear x.
    intros a1; cbn in a1.
    intros x; cbn in x.
    elim x; clear x.
    intros a2; cbn in a2.
    intros r; cbn in r.
    cbn; exact idpath.
Defined.Some "real-world" examples wheremake_equivsimplifies things a lot include the associativity/symmetry proofs inTypes/Sigma.v,issig_pequiv'inPointed/pEquiv.v, andloop_susp_adjointinPointed/pSusp.v.Now we give a version ofmake_equivthat can also prove equivalences of nested sigma- and record types that involve contracting based path-spaces on either or both sides.  The basepoint and the path don't have to appear together, but can be in arbitrarily separated parts of the nested structure.  It does this by selectively applying path-induction to based paths appearing on both sides, if needed.We start with a version ofdecomposing_introsthat is willing to destruct paths, though as a second choice.Ltacdecomposing_intros_with_paths:=letx:=freshinintrosx;hnfinx;cbninx;multimatchtypeofxwith|_=>trymatchtypeofxwith|Don't destruct paths at first?a= ?b=>fail1|Don't apply functions at firstforally:?A, ?B=>fail1|_=>elimx;clearxend;trydecomposing_intros_with_paths| ?a= ?b=>Destruct paths as a second choice.  But sometimesdestructisn't smart enough to generalize the other hypotheses that use the free endpoint, so we manually applypaths_ind, or its right-handed version, instead.((movexbeforeb;Ensure thatbandxcome first in theforallgoal resulting fromgeneralizedependent, so thatpaths_indcan apply to it.revertdependentb;assert_fails(movebattop);Check thatbwas actually reverted.  (If it's a section variable that the goal depends on,generalizedependentbwill "succeed", but actually fail to generalize the goal overb(since that can't be done within the section) and not clearbfrom the context.)refine(paths_ind___)) +Try the other endpoint too.(movexbeforea;revertdependenta;assert_fails(moveaattop);refine(paths_ind_r___)));trydecomposing_intros_with_pathsend.Going the other direction, we have to be willing to insert identity paths to fill in the based path-spaces that got destructed.  In facteconstructoris already willing to do that, sinceidpathis the constructor ofpaths.  However, our previousbuild_recordwon't manage to get to the point of being able to applyeconstructorto the necessary paths, since it'll get stuck earlier on trying to find the basepoint.  Thus, we give a version ofbuild_recordthat is willing to create existential variables ("evars") for goals that it can't solve, in hopes that a lateridpath(produced byeconstructor) will determine them by unification.  Note that if there are other fields that depend on the basepoint that occur before theidpath, the evar will -- and, indeed, must -- get instantiated by them instead.  This is whymulti_assumption, above, must be willing to instantiate evars.Ltacbuild_record_with_evars:=(cbn;multi_assumption+ (unshelveeconstructor;build_record_with_evars)) +Create a fresh evar to solve this goal(matchgoalwith|- ?G=>letx:=freshinevar(x:G);exactxend;build_record_with_evars).Now here's the improved version ofmake_equiv.Ltacmake_equiv_contr_basedpaths:=snrefine(equiv_adjointify____);solve[unshelveTAC]ensures thatTACsucceeds without leaving any leftover evars.[decomposing_intros_with_paths;solve[unshelvebuild_record_with_evars]|decomposing_intros_with_paths;solve[unshelvebuild_record_with_evars]|decomposing_intros_with_paths;exactidpath|decomposing_intros_with_paths;exactidpath].As before, we give some examples.Section Examples.
  Context (A : Type) (B : A -> Type) (a0 : A).
  Goal { a : A & { b : B a & a = a0 } } <~> B a0.
  Proof.
    make_equiv_contr_basedpaths.
    Undo.
    snrefine (equiv_adjointify _ _ _ _).
    - (** Here begins [decomposing_intros_with_paths] *)
      intros x; cbn in x.
      elim x; clear x.
      intros a; cbn in a.
      intros x; cbn in x. 
      elim x; clear x.
      intros b; cbn in b.
      intros p; cbn in p.
      (** [decomposing_intros] wouldn't be willing to destruct [p] here, because it's a path.  But [decomposing_intros_with_paths] will try it when all else fails. *)
      move p before a.
      generalize dependent a.
      not (move a at top).
      refine (paths_ind_r _ _ _).
      intros b; cbn in b.
      (** Here begins [build_record_with_evars] *)
      exact b.
    - (** Here begins [decomposing_intros_with_paths] *)
      intros b; cbn in b.
      (** Here begins [build_record_with_evars] *)
      cbn; unshelve econstructor.
      { let x := fresh in evar (x : A); exact x. }
      cbn; unshelve econstructor.
      { (** This instantiates the evar. *)
        exact b. }
      { cbn; unshelve econstructor. }
    - intros b; cbn in b.
      exact idpath.
    - intros x; cbn in x.
      elim x; clear x.
      intros a; cbn in a.
      intros x; cbn in x. 
      elim x; clear x.
      intros b; cbn in b.
      intros p; cbn in p.
      move p before a.
      generalize dependent a.
      not (move a at top).
      refine (paths_ind_r _ _ _).
      intros b; cbn in b.
      exact idpath.
  Defined.
End Examples.Some "real-world" examples wheremake_equiv_contr_basedpathssimplifies things a lot includehfiber_composeinHFiber.v,hfiber_pullback_alonginLimits/Pullback.v, andequiv_Ocodeleft2plusinBlakersMassey.v.

--- Miscellaneous\EquivGpd.html ---
EquivGpdLibrary EquivGpdRequireImportBasics.OvertureBasics.TacticsBasics.Iff.RequireImportWildCat.Core.RequireImportWildCat.NatTrans.RequireImportWildCat.Sigma.Equivalences of 0-groupoids, and split essentially surjective functorsFor a logically equivalent definition of equivalences of 0-groupoids, see ZeroGroupoid.v.We could define these similarly for more general categories too, but we'd need to useHasEquivsand$<~>instead of$==.ClassSplEssSurj{AB:Type} `{Is0GpdA,Is0GpdB}(F:A->B) `{!Is0FunctorF}:=esssurj:forallb:B, {a:A&Fa$==b}.Argumentsesssurj{AB______}F{__}b.A 0-functor between 0-groupoids is an "equivalence" if it is essentially surjective and reflects the existence of morphisms.  This is "surjective and injective" in setoid-language, so we use the nameIsSurjInj.  (To define essential surjectivity for non-groupoids, we would needHasEquivsfromWildCat.Equiv.ClassIsSurjInj{AB:Type} `{Is0GpdA,Is0GpdB}(F:A->B) `{!Is0FunctorF} :={esssurj_issurjinj:SplEssSurjF;essinj:forall(xy:A), (Fx$==Fy) -> (x$==y) ;}.Global Existing Instanceesssurj_issurjinj.Argumentsessinj{AB______}F{__xy}f.Definitionsurjinj_inv{AB:Type} (F:A->B) `{IsSurjInjABF} :B->A:=funb=> (esssurjFb).1.Some of the results below also follow from the logical equivalence withIsEquiv_0Gpdand the fact thatZeroGpdsatisfiesHasEquivs.  But it is sometimes awkward to deduce the results this way, mostly becauseZeroGpdrequires bundled objects rather than typeclass instances.Equivalences have inversesGlobal Instanceis0functor_surjinj_inv{AB:Type} (F:A->B) `{IsSurjInjABF}:Is0Functor(surjinj_invF).Proof.constructor;introsxyf.pose(p:= (esssurjFx).2).pose(q:= (esssurjFy).2).cbnin*.pose(f':=p$@f$@q^$).exact(essinjFf').Defined.The inverse is an inverse, up to unnatural transformationsDefinitioneisretr0gpd_inv{AB:Type} (F:A->B) `{IsSurjInjABF}:Fosurjinj_invF$=>idmap.Proof.introsb.exact((esssurjFb).2).Defined.Definitioneissect0gpd_inv{AB:Type} (F:A->B) `{IsSurjInjABF}:surjinj_invFoF$=>idmap.Proof.introsa.apply(essinjF).applyeisretr0gpd_inv.Defined.Essentially surjective functors and equivalences are preserved by transformations.Definitionisesssurj_transf{AB:Type} {F:A->B} {G:A->B}`{SplEssSurjABF} `{!Is0FunctorG} (alpha:G$=>F):SplEssSurjG.Proof.introsb.exists((esssurjFb).1).refine(_$@ (esssurjFb).2).applyalpha.Defined.Definitionissurjinj_transf{AB:Type} {F:A->B} {G:A->B}`{IsSurjInjABF} `{!Is0FunctorG} (alpha:G$=>F):IsSurjInjG.Proof.constructor.-apply(isesssurj_transfalpha).-introsxyf.apply(essinjF).refine(_$@f$@_).+symmetry;applyalpha.+applyalpha.Defined.Equivalences compose and cancel with each other and with essentially surjective functors.SectionComposeAndCancel.Context{ABC} `{Is0GpdA,Is0GpdB,Is0GpdC}(G:B->C) (F:A->B) `{!Is0FunctorG, !Is0FunctorF}.Global Instanceisesssurj_compose`{!SplEssSurjG, !SplEssSurjF}:SplEssSurj(GoF).Proof.introsc.exists((esssurjF(esssurjGc).1).1).refine(_$@ (esssurjGc).2).apply(fmapG).apply(esssurjF).Defined.Global Instanceissurjinj_compose`{!IsSurjInjG, !IsSurjInjF}:IsSurjInj(GoF).Proof.constructor.-exact_.-introsxyf.apply(essinjF).exact(essinjGf).Defined.DefinitioncancelL_isesssurj`{!IsSurjInjG, !SplEssSurj(GoF)}:SplEssSurjF.Proof.introsb.exists((esssurj(GoF) (Gb)).1).apply(essinjG).exact((esssurj(GoF) (Gb)).2).Defined.DefinitioniffL_isesssurj`{!IsSurjInjG}:SplEssSurj(GoF) <->SplEssSurjF.Proof.split; [apply@cancelL_isesssurj|apply@isesssurj_compose];exact_.Defined.DefinitioncancelL_issurjinj`{!IsSurjInjG, !IsSurjInj(GoF)}:IsSurjInjF.Proof.constructor.-applycancelL_isesssurj.-introsxyf.exact(essinj(GoF) (fmapGf)).Defined.DefinitioniffL_issurjinj`{!IsSurjInjG}:IsSurjInj(GoF) <->IsSurjInjF.Proof.split; [apply@cancelL_issurjinj|apply@issurjinj_compose];exact_.Defined.DefinitioncancelR_isesssurj`{!SplEssSurj(GoF)}:SplEssSurjG.Proof.introsc.exists(F(esssurj(GoF)c).1).exact((esssurj(GoF)c).2).Defined.DefinitioniffR_isesssurj`{!SplEssSurjF}:SplEssSurj(GoF) <->SplEssSurjG.Proof.split; [apply@cancelR_isesssurj|intros;apply@isesssurj_compose];exact_.Defined.DefinitioncancelR_issurjinj`{!IsSurjInjF, !IsSurjInj(GoF)}:IsSurjInjG.Proof.constructor.-applycancelR_isesssurj.-introsxyf.pose(p:= (esssurjFx).2).pose(q:= (esssurjFy).2).cbnin*.refine(p^$ $@_$@q).apply(fmapF).apply(essinj(GoF)).refine(_$@f$@_).+exact(fmapGp).+exact(fmapGq^$).Defined.DefinitioniffR_issurjinj`{!IsSurjInjF}:IsSurjInj(GoF) <->IsSurjInjG.Proof.split; [apply@cancelR_issurjinj|intros;apply@issurjinj_compose];exact_.Defined.EndComposeAndCancel.In particular, essential surjectivity and being an equivalence transfer across commutative squares of functors.Definitionisesssurj_iff_commsq{ABCD:Type}{F:A->B} {G:C->D} {H:A->C} {K:B->D}`{IsSurjInjACH} `{IsSurjInjBDK}`{!Is0FunctorF} `{!Is0FunctorG}(p:KoF$=>GoH):SplEssSurjF<->SplEssSurjG.Proof.split;intros?.-srapply(cancelR_isesssurjGH);tryexact_.apply(isesssurj_transf(funa=> (pa)^$)).-srapply(cancelL_isesssurjKF);tryexact_.apply(isesssurj_transfp).Defined.Definitionissurjinj_iff_commsq{ABCD:Type}{F:A->B} {G:C->D} {H:A->C} {K:B->D}`{IsSurjInjACH} `{IsSurjInjBDK}`{!Is0FunctorF} `{!Is0FunctorG}(p:KoF$=>GoH):IsSurjInjF<->IsSurjInjG.Proof.split;intros?.-srapply(cancelR_issurjinjGH);tryexact_.apply(issurjinj_transf(funa=> (pa)^$)).-srapply(cancelL_issurjinjKF);tryexact_.apply(issurjinj_transfp).Defined.Equivalences and essential surjectivity are preserved by sigmas (for now, just over constant bases), and essential surjectivity at least is also reflected.Definitionisesssurj_iff_sigma{A:Type} (BC:A->Type)`{foralla,IsGraph(Ba)} `{foralla,Is01Cat(Ba)} `{foralla,Is0Gpd(Ba)}`{foralla,IsGraph(Ca)} `{foralla,Is01Cat(Ca)} `{foralla,Is0Gpd(Ca)}(F:foralla,Ba->Ca) {ff:foralla,Is0Functor(Fa)}:SplEssSurj(fun(x:sigB) => (x.1 ;Fx.1x.2))<-> (foralla,SplEssSurj(Fa)).Proof.split.-introsfsac.pose(s:=fs(a;c)).destructsas[[a'b] [pq]];cbnin*.destructp;cbninq.existsb.exactq.-introsfs[ac].exists(a; (esssurj(Fa)c).1);cbn.existsidpath;cbn.exact((esssurj(Fa)c).2).Defined.Definitionissurjinj_sigma{A:Type} (BC:A->Type)`{foralla,IsGraph(Ba)} `{foralla,Is01Cat(Ba)} `{foralla,Is0Gpd(Ba)}`{foralla,IsGraph(Ca)} `{foralla,Is01Cat(Ca)} `{foralla,Is0Gpd(Ca)}(F:foralla,Ba->Ca)`{foralla,Is0Functor(Fa)} `{foralla,IsSurjInj(Fa)}:IsSurjInj(fun(x:sigB) => (x.1 ;Fx.1x.2)).Proof.constructor.-applyisesssurj_iff_sigma;exact_.-intros[a1b1] [a2b2] [pf];cbnin*.destructp;cbnin*.existsidpath;cbn.exact(essinj(Fa1)f).Defined.

--- Miscellaneous\EquivGroupoids.html ---
EquivGroupoidsLibrary EquivGroupoidsThe pregroupoid structure ofEquivRequireImportBasics.OvertureBasics.EquivalencesTypes.Equiv.Local OpenScopeequiv_scope.See PathGroupoids.v for the naming conventions  TODO: Consider using a definition ofIsEquivandEquivfor which more of these are judgmental, or at least don't requireFunext.SectionAssumeFunext.Context`{Funext}.The 1-dimensional groupoid structure.The identity equivalence is a right unit.Lemmaecompose_e1{AB} (e:A<~>B) :eoE1 =e.Proof.applypath_equiv;reflexivity.Defined.The identity is a left unit.Lemmaecompose_1e{AB} (e:A<~>B) : 1oEe=e.Proof.applypath_equiv;reflexivity.Defined.Composition is associative.Definitionecompose_e_ee{ABCD} (e:A<~>B) (f:B<~>C) (g:C<~>D):goE(foEe) = (goEf)oEe.Proof.applypath_equiv;reflexivity.Defined.Definitionecompose_ee_e{ABCD} (e:A<~>B) (f:B<~>C) (g:C<~>D): (goEf)oEe=goE(foEe).Proof.applypath_equiv;reflexivity.Defined.The left inverse law.Lemmaecompose_eV{AB} (e:A<~>B) :eoEe^-1 = 1.Proof.applypath_equiv;applypath_forall;intro;applyeisretr.Defined.The right inverse law.Lemmaecompose_Ve{AB} (e:A<~>B) :e^-1oEe= 1.Proof.applypath_equiv;applypath_forall;intro;applyeissect.Defined.Several auxiliary theorems about canceling inverses across associativity.  These are somewhat redundant, following from earlier theorems.Definitionecompose_V_ee{ABC} (e:A<~>B) (f:B<~>C):f^-1oE(foEe) =e.Proof.applypath_equiv;applypath_forall;intro;simpl;applyeissect.Defined.Definitionecompose_e_Ve{ABC} (e:A<~>B) (f:C<~>B):eoE(e^-1oEf) =f.Proof.applypath_equiv;applypath_forall;intro;simpl;applyeisretr.Defined.Definitionecompose_ee_V{ABC} (e:A<~>B) (f:B<~>C): (foEe)oEe^-1 =f.Proof.applypath_equiv;applypath_forall;intro;simpl;applyap;applyeisretr.Defined.Definitionecompose_eV_e{ABC} (e:B<~>A) (f:B<~>C): (foEe^-1)oEe=f.Proof.applypath_equiv;applypath_forall;intro;simpl;applyap;applyeissect.Defined.Inverse distributes over compositionDefinitioneinv_ee{ABC} (e:A<~>B) (f:B<~>C): (foEe)^-1 =e^-1oEf^-1.Proof.applypath_equiv;reflexivity.Defined.Definitioneinv_Ve{ABC} (e:A<~>C) (f:B<~>C): (f^-1oEe)^-1 =e^-1oEf.Proof.applypath_equiv;reflexivity.Defined.Definitioneinv_eV{ABC} (e:C<~>A) (f:C<~>B): (foEe^-1)^-1 =eoEf^-1.Proof.applypath_equiv;reflexivity.Defined.Definitioneinv_VV{ABC} (e:A<~>B) (f:B<~>C): (e^-1oEf^-1)^-1 =foEe.Proof.applypath_equiv;reflexivity.Defined.Inverse is an involution.Definitioneinv_V{AB} (e:A<~>B): (e^-1)^-1 =e.Proof.applypath_equiv;reflexivity.Defined.Theorems for moving things around in equations.DefinitionemoveR_Me{ABC} (e:B<~>A) (f:B<~>C) (g:A<~>C):e=g^-1oEf->goEe=f.Proof.introh.refine(ap(fune=>goEe)h@ecompose_e_Ve__).Defined.DefinitionemoveR_eM{ABC} (e:B<~>A) (f:B<~>C) (g:A<~>C):g=foEe^-1 ->goEe=f.Proof.introh.refine(ap(fung=>goEe)h@ecompose_eV_e__).Defined.DefinitionemoveR_Ve{ABC} (e:B<~>A) (f:B<~>C) (g:C<~>A):e=goEf->g^-1oEe=f.Proof.introh.refine(ap(fune=>g^-1oEe)h@ecompose_V_ee__).Defined.DefinitionemoveR_eV{ABC} (e:A<~>B) (f:B<~>C) (g:A<~>C):g=foEe->goEe^-1 =f.Proof.introh.refine(ap(fung=>goEe^-1)h@ecompose_ee_V__).Defined.DefinitionemoveL_Me{ABC} (e:A<~>B) (f:A<~>C) (g:B<~>C):g^-1oEf=e->f=goEe.Proof.introh.refine((ecompose_e_Ve__)^ @ap(fune=>goEe)h).Defined.DefinitionemoveL_eM{ABC} (e:A<~>B) (f:A<~>C) (g:B<~>C):foEe^-1 =g->f=goEe.Proof.introh.refine((ecompose_eV_e__)^ @ap(fung=>goEe)h).Defined.DefinitionemoveL_Ve{ABC} (e:A<~>C) (f:A<~>B) (g:B<~>C):goEf=e->f=g^-1oEe.Proof.introh.refine((ecompose_V_ee__)^ @ap(fune=>g^-1oEe)h).Defined.DefinitionemoveL_eV{ABC} (e:A<~>B) (f:B<~>C) (g:A<~>C):foEe=g->f=goEe^-1.Proof.introh.refine((ecompose_ee_V__)^ @ap(fung=>goEe^-1)h).Defined.DefinitionemoveL_1M{AB} (ef:A<~>B):eoEf^-1 = 1 ->e=f.Proof.introh.refine((ecompose_eV_e__)^ @ap(funef=>efoEf)h@ecompose_1e_).Defined.DefinitionemoveL_M1{AB} (ef:A<~>B):f^-1oEe= 1 ->e=f.Proof.introh.refine((ecompose_e_Ve__)^ @ap(funfe=>foEfe)h@ecompose_e1_).Defined.DefinitionemoveL_1V{AB} (e:A<~>B) (f:B<~>A):eoEf= 1 ->e=f^-1.Proof.introh.refine((ecompose_ee_V__)^ @ap(funef=>efoEf^-1)h@ecompose_1e_).Defined.DefinitionemoveL_V1{AB} (e:A<~>B) (f:B<~>A):foEe= 1 ->e=f^-1.Proof.introh.refine((ecompose_V_ee__)^ @ap(funfe=>f^-1oEfe)h@ecompose_e1_).Defined.DefinitionemoveR_M1{AB} (ef:A<~>B): 1 =e^-1oEf->e=f.Proof.introh.refine((ecompose_e1_)^ @ap(funef=>eoEef)h@ecompose_e_Ve__).Defined.DefinitionemoveR_1M{AB} (ef:A<~>B): 1 =foEe^-1 ->e=f.Proof.introh.refine((ecompose_1e_)^ @ap(funfe=>feoEe)h@ecompose_eV_e__).Defined.DefinitionemoveR_1V{AB} (e:A<~>B) (f:B<~>A): 1 =foEe->e^-1 =f.Proof.introh.refine((ecompose_1e_)^ @ap(funfe=>feoEe^-1)h@ecompose_ee_V__).Defined.DefinitionemoveR_V1{AB} (e:A<~>B) (f:B<~>A): 1 =eoEf->e^-1 =f.Proof.introh.refine((ecompose_e1_)^ @ap(funef=>e^-1oEef)h@ecompose_V_ee__).Defined.We could package these up into tactics, much the same as thewith_rassocandrewrite_move*ofPathGroupoids.v.  I have not done so yet because there is currently no place where we would use these tactics.  If there is a use case, they are easy enough to copy fromPathGroupoids.v.EndAssumeFunext.

--- Miscellaneous\EvalIn.html ---
EvalInLibrary EvalInEvaluating tactics on termsRequireImportBasics.OvertureBasics.PathGroupoids.It sometimes happens, in the course of writing a tactic, that we have some term in an Ltac variable (more precisely, we have what Ltac calls a "constr") and we would like to act on it with some tactic such ascbvorrewrite.  Ordinarily, such tactics only act on the current *goal*, and generally they have a version such asrewrite...in...which acts on something in the current *context*, but neither of these is the same as acting on a term held in an Ltac variable.For some tactics, such ascbvandpattern, we can writeevalTACinH, whereHis the term in question; this form *returns* the modified term so we can place it in another Ltac variable.  However, other tactics such asrewritedo not support this syntax.  (There is a feature request for it at https://coq.inria.fr/bugs/show_bug.cgi?id=3677.)The following tacticeval_inTACHfills this gap, allowing us to act byrewriteon terms in Ltac variables.  The argumentTACmust be a tactic that takes one argument, which is an Ltac function that gets passed the name of a hypothesis to act on, such asltac:(funH'=>rewriteHinH').  (Unfortunately, however,eval_incannot be used to exactly generalizeevalpatterninH; see below.)There is also a variant calledeval_in_using, which also accepts a second user-specified tactic and uses it to solve side-conditions generated by the first one.  We actually defineeval_inin terms ofeval_in_usingby passingidtacas the second tactic.Ltaceval_in_usingtac_inusing_tacH:=The syntax$(...)$allows execution of an arbitrary tactic to supply a needed term.  By prefixing it withconstr:which tells Ltac to expect a term, we obtain a patternconstr:($(...)$)which allows us to execute an arbitrary tactic in the situation of a fresh goal.   This way we avoid modifying the existing context, and we can also get our hands on a proof term corresponding to the stateful modification.  We poseHin the fresh context so we can play with it nicely, regardless of if it's a hypothesis or a term.  Then we runtac_inon the hypothesis to modify it, useexactto "return" the modified hypothesis, and give a nice error message ifusing_tacfails to solve some side-condition.letret:=constr:(ltac:(letH':=freshinposeHasH';tac_inH';[exactH'|solve[using_tac|letG:=matchgoalwith|- ?G=>constr:(G)endinrepeatmatchgoalwithH:_|-_=>revertHend;letG':=matchgoalwith|- ?G=>constr:(G)endinfail1"Cannot use"using_tac"to solve side-condition goal"G".""Extended goal with context:"G'].. ]))inFinally, we play some games to format the return value nicely.  We want to zeta-reduce the let-in generated bypose, but not any otherlet-ins; we do this by matching for it and doing the substitution manually.  Additionally,pose/exactalso results in an extraidmap; we remove this withcbvbeta, which unfortunately also beta-reduces everything else.  (This is whyeval_inpatternHdoesn't strictly generalizeevalpatterninH, since the latter doesn't beta-reduce.)  Perhaps we want to zeta-reduce everything, and not beta-reduce anything instead?letT:=typeofretinletret':= (lazymatchretwith|letx:= ?x'in@?Px=>constr:(Px')end)inletret'':= (evalcbvbetainret')inconstr:(ret'':T).Ltaceval_intac_inH:=eval_in_usingtac_inidtacH.Exampleeval_in_example:forallAB:Set,A=B->A->B.Proof.introsABHa.letx:= (eval_inltac:(funH'=>rewriteHinH')a)inposexasb.we get ab:BWeAbort, so that we don't get an extra constant floating around.Abort.Rewriting with reflexivityAs an example application, we define a tactic that takes a lemma whose definition isidpathand behaves likerewrite, except that it doesn't insert any transport lemmas likeOverture.internal_paths_rew_r.  In other words, it does achange, but leverages the pattern-matching and substitution engine ofrewriteto decide what tochangeinto.We use a dummy inductive type sincerewriteacts on the *type* of a hypothesis rather than its body (if any).Inductivedummy(A:Type) :=adummy:dummyA.Ltacrewrite_reflH:=matchgoalwith| [ |- ?X] =>letdX':=eval_inltac:(funH'=>rewriteHinH') (adummyX)inmatchtypeofdX'with|dummy?X'=>changeX'endend.Here's what it would look like with ordinaryrewrite:Examplerewrite_refl_example{AB:Type} (x:A) (f:A->B) :apfidpath=idpath:> (fx=fx).Proof.rewriteap_1.reflexivity.Show Proof.  ==> (fun (A B : Type) (x : A) (f : A -> B) =>
 Overture.internal_paths_rew_r (f x = f x) (ap f 1) 1
   (fun p : f x = f x => p = 1) 1 (ap_1 x f))Abort.And here's what we get withrewrite_refl:Examplerewrite_refl_example{AB:Type} (x:A) (f:A->B) :apfidpath=idpath:> (fx=fx).Proof.rewrite_refl@ap_1.reflexivity.Show Proof.  ==> (fun (A B : Type) (x : A) (f : A -> B) => 1)Abort.

--- Miscellaneous\EvaluationFibration.html ---
EvaluationFibrationLibrary EvaluationFibrationFromHoTTRequireImportBasicsTypesTruncations.CorePointed.CoreHomotopy.Cover.Local OpenScopepointed_scope.Local OpenScopetrunc_scope.Evaluation fibrations and self-maps(* The type of unpointed self maps of A, pointed at the identity map. *)Definitionselfmaps(A:Type) :pType:= [A->A,idmap].The unrestricted evaluation map.Definitionev(A:pType) :selfmapsA->*A:=Build_pMap__(funf:selfmapsA=>fpt)idpath.The evaluation fibration of an unpointed mapX->A.Definitionevfib{X:pType} {A:Type} (f:X->A) :comp(X->A) (trf) ->A:=fung=>g.1pt.Iffis pointed, then the evaluation fibration offis too.Definitionpevfib{AX:pType} (f:X->*A) :pcomp(X->A)f->*A:=Build_pMap__(fung:pcomp(X->A)f=>g.1pt) (point_eqf).(* The evaluation map of the identity. *)Definitionev1(A:pType) :=pevfib(A:=A)pmap_idmap.

--- Miscellaneous\ExactSequence.html ---
ExactSequenceLibrary ExactSequenceRequireImportBasicsTypes.RequireImportSuccessorStructure.RequireImportWildCat.RequireImportPointed.RequireImportModalities.IdentityModalities.Descent.RequireImportTruncations.RequireImportHFiber.RequireImportObjectClassifier.Local OpenScopesucc_scope.OpenScopepointed_scope.Exact sequencesVery short complexesA (very short) complex is a pair of pointed maps whose composite is the zero map.DefinitionIsComplex{FXY} (i:F->*X) (f:X->*Y):= (fo*i==*pconst).This induces a map from the domain ofito the fiber off.Definitioncxfib{FXY:pType} {i:F->*X} {f:X->*Y}(cx:IsComplexif):F->*pfiberf.Proof.srapplyBuild_pMap.-exact(funx=> (ix;cxx)).-cbn.refine(path_sigma'_(point_eqi)_);cbn.refine(transport_paths_Fl__@_).applymoveR_Vp.exact((concat_p1_)^ @point_htpycx).Defined....whose composite with the projectionpfib:pfiberi->Xisi.Definitionpfib_cxfib{FXY:pType} {i:F->*X} {f:X->*Y}(cx:IsComplexif):pfibfo*cxfibcx==*i.Proof.srapplyBuild_pHomotopy.-reflexivity.-cbn.rewriteap_pr1_path_sigma;hott_simpl.Defined.Truncation preserves complexes.Definitioniscomplex_ptr(n:trunc_index) {FXY:pType}(i:F->*X) (f:X->*Y) (cx:IsComplexif):IsComplex(fmap(pTrn)i) (fmap(pTrn)f).Proof.refine((fmap_comp(pTrn)if)^* @*_).refine(_@*ptr_functor_pconstn).rapply(fmap2(pTr_));assumption.Defined.Loop spaces preserve complexes.Definitioniscomplex_loops{FXY:pType}(i:F->*X) (f:X->*Y) (cx:IsComplexif):IsComplex(fmaploopsi) (fmaploopsf).Proof.refine((fmap_comploopsif)^$ $@_$@fmap_zero_morphism_).rapply(fmap2loops);assumption.Defined.Definitioniscomplex_iterated_loops{FXY:pType}(i:F->*X) (f:X->*Y) (cx:IsComplexif) (n:nat):IsComplex(fmap(iterated_loopsn)i) (fmap(iterated_loopsn)f).Proof.inductionnas[|nIHn]; [exactcx| ].applyiscomplex_loops;assumption.Defined.Passage across homotopies preserves complexes.Definitioniscomplex_homotopic_i{FXY:pType}{ii':F->*X} (ii:i'==*i) (f:X->*Y) (cx:IsComplexif):IsComplexi'f:=pmap_postwhiskerfii@*cx.Definitioniscomplex_homotopic_f{FXY:pType}(i:F->*X) {ff':X->*Y} (ff:f'==*f) (cx:IsComplexif):IsComplexif':=pmap_prewhiskeriff@*cx.Definitioniscomplex_cancelL{FXYY':pType}(i:F->*X) (f:X->*Y) (e:Y<~>*Y') (cx:IsComplexi(eo*f)):IsComplexif.Proof.refine(_@*precompose_pconste^-1*).refine((compose_V_hhe(fo*i))^$ $@_).refine(cat_postwhiskere^-1*_).refine((cat_assoc___)^$ $@_).exactcx.Defined.And likewise passage across squares with equivalencesDefinitioniscomplex_equiv_i{FF'XX'Y:pType}(i:F->*X) (i':F'->*X')(g:F'<~>*F) (h:X'<~>*X) (p:ho*i'==*io*g)(f:X->*Y)(cx:IsComplexif):IsComplexi'(fo*h).Proof.refine(pmap_compose_assoc___@*_).refine(pmap_postwhiskerfp@*_).refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhiskergcx@*_).applypostcompose_pconst.Defined.A special version with only an equivalence on the fiber.Definitioniscomplex_equiv_fiber{FF'XY:pType}(i:F->*X) (f:X->*Y) (phi:F'<~>*F)`{cx:IsComplexif}:IsComplex(io*phi)f.Proof.refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhisker_cx@*_).applypostcompose_pconst.Defined.Any pointed map induces a trivial complex.Definitioniscomplex_trivial{XY:pType} (f:X->*Y):IsComplex(@pconstpUnitX)f.Proof.srapplyBuild_pHomotopy.-introx;cbn.exact(point_eqf).-cbn;symmetry.exact(concat_p1_@concat_1p_).Defined.If Y is a set, then IsComplex is an HProp.Global Instanceishprop_iscomplex_hset`{Funext} {FXY:pType} `{IsHSetY}(i:F->*X) (f:X->*Y):IsHProp(IsComplexif) :=_.Very short exact sequences and fiber sequencesA complex isn-exact if the induced mapcxfibisn-connected.Cumulative ClassIsExact(n:Modality) {FXY:pType} (i:F->*X) (f:X->*Y) :={cx_isexact:IsComplexif;conn_map_isexact:IsConnMapn(cxfibcx_isexact)}.Global Existing Instanceconn_map_isexact.Definitionissig_isexact(n:Modality) {FXY:pType} (i:F->*X) (f:X->*Y):_<~>IsExactnif:=ltac:(issig).If Y is a set, then IsExact is an HProp.Global Instanceishprop_isexact_hset`{Univalence} {FXY:pType} `{IsHSetY}(n:Modality) (i:F->*X) (f:X->*Y):IsHProp(IsExactnif).Proof.rapply(transport(funA=>IsHPropA) (x:= {cx:IsComplexif&IsConnMapn(cxfibcx) })).2:exact_.applypath_universe_uncurried;issig.Defined.With exactness we can choose preimages.Lemmaisexact_preimage(O:Modality) {FXY:pType}(i:F->*X) (f:X->*Y) `{IsExactO___if}(x:X) (p:fx=pointY):O(hfiberix).Proof.rapply(O_functorO(A:=hfiber(cxfibcx_isexact) (x;p))).-intros[zq].exact(z;appr1q).-applycenter,conn_map_isexact.Defined.Bundled version of the above.Lemmaisexact_preimage_hfiber(O:Modality) {FXY:pType}(i:F->*X) (f:X->*Y) `{IsExactO___if}(x:hfiberfpt):O(hfiberix.1).Proof.srapplyisexact_preimage;exactx.2.Defined.If the base is contractible, theniisO-connected.Definitionisconnmap_O_isexact_base_contr(O:Modality@{u}) {FXY:pType}`{ContrY} (i:F->*X) (f:X->*Y)`{IsExact@{__uuu}O___if}:IsConnMapOi:=conn_map_compose@{u_u_}O(cxfib@{uu__}cx_isexact)pr1.Passage across homotopies preserves exactness.Definitionisexact_homotopic_in{FXY:pType}{ii':F->*X} (ii:i'==*i) (f:X->*Y)`{IsExactnFXYif}:IsExactni'f.Proof.exists(iscomplex_homotopic_iiifcx_isexact).refine(conn_map_homotopicn(cxfibcx_isexact)___).introsu;cbn.refine(path_sigma'_(iiu)^_).exact(transport_paths_Fl__@ ((inverse2(ap_V__) @inv_V_) @@ 1)).Defined.Definitionisexact_homotopic_fn{FXY:pType}(i:F->*X) {ff':X->*Y} (ff:f'==*f)`{IsExactnFXYif}:IsExactnif'.Proof.exists(iscomplex_homotopic_fiffcx_isexact).pose(e:=equiv_hfiber_homotopic__ffpt).nrefine(cancelL_isequiv_conn_mapn_e).1:applyequiv_isequiv.refine(conn_map_homotopicn(cxfib(cx_isexact))___).introu.simpl.srapplypath_hfiber.1:reflexivity.refine(concat_1p_@concat_V_pp__)^.Defined.And also passage across squares with equivalences.Definitionisexact_equiv_in{FF'XX'Y:pType}(i:F->*X) (i':F'->*X')(g:F'<~>*F) (h:X'<~>*X) (p:ho*i'==*io*g)(f:X->*Y) `{IsExactnFXYif}:IsExactni'(fo*h).Proof.exists(iscomplex_equiv_iii'ghpfcx_isexact);cbn.snrefine(cancelL_equiv_conn_mapn(C:=pfiberf)__).-exact(@equiv_functor_hfiber____(foh)fhequiv_idmap(funx=> 1%path) (pointY)).-cbn;unfoldfunctor_hfiber,functor_sigma;cbn.refine(conn_map_homotopicn(@cxfib___ifcx_isexactog)___).introsu;cbn.refine(path_sigma'_(pu)^_).abstract(rewritetransport_paths_Fl,ap_V,inv_V,!concat_1p,concat_p1,ap_idmap;reflexivity).Defined.In particular, we can transfer exactness across equivalences of the total space.DefinitionmoveL_isexact_equivn{FXX'Y:pType}(i:F->*X) (f:X'->*Y) (phi:X<~>*X')`{IsExactn___(phio*i)f}:IsExactni(fo*phi).Proof.rapply(isexact_equiv_i___pequiv_pmap_idmapphi);cbn.exact(pmap_precompose_idmap_)^*.Defined.Similarly, we can cancel equivalences on the fiber.Definitionisexact_equiv_fibern{FF'XY:pType}(i:F->*X) (f:X->*Y) (phi:F'<~>*F)`{E:IsExactn___if}:IsExactn(io*phi)f.Proof.snrapplyBuild_IsExact.1:applyiscomplex_equiv_fiber,cx_isexact.apply(conn_map_homotopic_(cxfibcx_isexacto*phi)).{introx;cbn.byrewriteconcat_p1,concat_1p. }exact_.Defined.An equivalence of short sequences preserves exactness.Definitionisexact_square_ifn{FF'XX'YY':pType}{i:F->*X} {i':F'->*X'}{f:X->*Y} {f':X'->*Y'}(g:F'<~>*F) (h:X'<~>*X) (k:Y'<~>*Y)(p:ho*i'==*io*g) (q:ko*f'==*fo*h)`{IsExactnFXYif}:IsExactni'f'.Proof.pose(I:=isexact_equiv_inii'ghpf).pose(I2:=isexact_homotopic_fni'q).exists(iscomplex_cancelLi'f'kcx_isexact).epose(e:= (pequiv_pfiberpequiv_pmap_idmapk(pmap_precompose_idmap(ko*f'))^*:pfiberf'<~>*pfiber(ko*f'))).nrefine(cancelL_isequiv_conn_mapn_e).1:applypointed_isequiv.refine(conn_map_homotopicn(cxfib(cx_isexact))___).introu.srapplypath_hfiber.{reflexivity. }cbn.unfoldmoveR_equiv_V.rewrite!concat_1p, !concat_p1,ap_pp_p,ap_pp, (ap_ppk_(eissectk(pointY'))),ap_V, <- !eisadj.rewrite<- !ap_compose,concat_pp_p.rewrite(concat_A1p(eisretrk)),concat_pV_p.rewrite(concat_A1p(eisretrk)),concat_V_pp.reflexivity.Defined.If a complexF->E->BisO-exact, the mapF->BisO-local, and path types inYareO-local, then the induced mapcxfibis an equivalence.Global Instanceisequiv_cxfib{O:Modality} {FXY:pType} {i:F->*X} {f:X->*Y}`{forallyy':Y,InO(y=y')} `{MapInO__i} (ex:IsExactOif):IsEquiv(cxfibcx_isexact).Proof.rapplyisequiv_conn_ino_map.1:applyex.rapply(cancelL_mapinO__pr1).Defined.Definitionequiv_cxfib{O:Modality} {FXY:pType} {i:F->*X} {f:X->*Y}`{forallyy':Y,InO(y=y')} `{MapInO__i} (ex:IsExactOif):F<~>*pfiberf:=Build_pEquiv___(isequiv_cxfibex).Propositionequiv_cxfib_beta{FXY:pType} {i:F->*X} {f:X->*Y}`{forallyy':Y,InO(y=y')} `{MapInO__i} (ex:IsExactOif):iopequiv_inverse(equiv_cxfibex) ==pfib_.Proof.rapplyequiv_ind.1:exact(isequiv_cxfibex).introx.exact(ap(fung=>ig) (eissect_x)).Defined.A purely exact sequence isO-exact for any modalityO.Definitionisexact_purely_O{O:Modality} {FXY:pType}(i:F->*X) (f:X->*Y) `{IsExactpurely___if}:IsExactOif.Proof.srapplyBuild_IsExact.1:applycx_isexact.exact_.Defined.Whennis the identity modalitypurely, so thatcxfibis an equivalence, we get simply a fiber sequence.  In particular, the fiber of a given map yields an purely-exact sequence.Definitioniscomplex_pfib{XY} (f:X->*Y):IsComplex(pfibf)f.Proof.srapplyBuild_pHomotopy.-intros[xp];exactp.-cbn.exact(concat_p1_@concat_1p_)^.Defined.Global Instanceisexact_pfib{XY} (f:X->*Y):IsExactpurely(pfibf)f.Proof.exists(iscomplex_pfibf).exact_.Defined.Fiber sequences can alternatively be defined as an equivalence to the fiber of some map.DefinitionFiberSeq(FXY:pType) := {f:X->*Y&F<~>*pfiberf}.Definitioni_fiberseq{FXY} (fs:FiberSeqFXY):F->*X:=pfibfs.1o*fs.2.Global Instanceisexact_purely_fiberseq{FXY:pType} (fs:FiberSeqFXY):IsExactpurely(i_fiberseqfs)fs.1.Proof.srapplyBuild_IsExact; [srapplyBuild_pHomotopy| ].-introsu;cbn.exact((fs.2u).2).-applymoveL_pV.cbn.refine(concat_p1_@_).applymoveL_Mp.refine(_@ (point_eqfs.2)..2).refine(_@ (transport_paths_Fl__)^).applywhiskerR,inverse2,ap,concat_p1.-intros[xp].applycontr_map_isequiv.change(IsEquivfs.2);exact_.Defined.Definitionpequiv_cxfib{FXY:pType} {i:F->*X} {f:X->*Y}`{IsExactpurelyFXYif}:F<~>*pfiberf:=Build_pEquiv__(cxfibcx_isexact)_.Definitionfiberseq_isexact_purely{FXY:pType} (i:F->*X) (f:X->*Y)`{IsExactpurelyFXYif} :FiberSeqFXY:= (f;pequiv_cxfib).It's easier to show thatloopspreserves fiber sequences than that it preserves purely-exact sequences.Definitionfiberseq_loops{FXY} (fs:FiberSeqFXY):FiberSeq(loopsF) (loopsX) (loopsY).Proof.TODO: doesn't work?!(*   exists (fmap loops fs.1). *)refine(fmaploopsfs.1;_).refine(_o*Eemaploopsfs.2).exact(pfiber_fmap_loopsfs.1)^-1*.Defined.Now we can deduce thatloopspreserves purely-exact sequences. The hardest part is modifying the first map back tofmaploopsi.Global Instanceisexact_loops{FXY} (i:F->*X) (f:X->*Y)`{IsExactpurelyFXYif}:IsExactpurely(fmaploopsi) (fmaploopsf).Proof.refine(@isexact_homotopic_ipurely____(fmaploopsi)_(fmaploopsf)(isexact_purely_fiberseq(fiberseq_loops(fiberseq_isexact_purelyif)))).transitivity(fmaploops(pfibf)o*fmaploops(cxfibcx_isexact)).-refine(_@*fmap_comploops__).rapply(fmap2loops).symmetry;applypfib_cxfib.-refine(_@*pmap_compose_assoc___).refine(pmap_prewhisker(fmaploops(cxfibcx_isexact))_).applymoveR_pequiv_fV.applypr1_pfiber_fmap_loops.Defined.Global Instanceisexact_iterated_loops{FXY}(i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif} (n:nat):IsExactpurely(fmap(iterated_loopsn)i) (fmap(iterated_loopsn)f).Proof.inductionnas[|nIHn]; [assumption|applyisexact_loops;assumption].Defined.(n.+1)-truncation preserves n-exactness.Global Instanceisexact_ptr`{Univalence} (n:trunc_index){FXY:pType} (i:F->*X) (f:X->*Y)`{IsExact(Trn)FXYif}:IsExact(Trn) (fmap(pTrn.+1)i) (fmap(pTrn.+1)f).Proof.exists(iscomplex_ptrn.+1ifcx_isexact).srefine(cancelR_conn_map(Trn) (@trn.+1F)(@cxfib___(fmap(pTrn.+1)i) (fmap(pTrn.+1)f)_)).{introsx;rapplyisconnected_pred. }nrapplyconn_map_homotopic.2:nrapply(conn_map_compose_(cxfib_)(functor_hfiber(funy=> (to_O_natural(Trn.+1)fy)^)(pointY))).3:pose@O_lex_leq_Tr;rapply(OO_conn_map_functor_hfiber_to_O).-introsx;refine(path_sigma'_1_);cbn.(* This is even simpler than it looks, because for truncationsto_O_naturaln.+1:=1,ton.+1:=tr, andcx_const:=H. *)exact(1 @@ (concat_p1_)^).-exact_.Defined.In particular, (n.+1)-truncation takes fiber sequences to n-exact ones.Global Instanceisexact_ptr_purely`{Univalence} (n:trunc_index){FXY:pType} (i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif}:IsExact(Trn) (fmap(pTrn.+1)i) (fmap(pTrn.+1)f).Proof.rapplyisexact_ptr.existscx_isexact.introsz;applyisconnected_contr.exact(conn_map_isexact(f:=f) (i:=i)z).Defined.Connecting mapsIt's useful to seepfib_cxfibas a degenerate square.Definitionsquare_pfib_pequiv_cxfib{FXY:pType}(i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif}:pequiv_pmap_idmapo*i==*pfibfo*pequiv_cxfib.Proof.unfoldSquare.refine(pmap_postcompose_idmap_@*_).symmetry;applypfib_cxfib.Defined.The connecting maps for the long exact sequence of loop spaces, defined as an extension to a fiber sequence.Definitionconnect_fiberseq{FXY}(i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif}:FiberSeq(loopsY)FX.Proof.existsi.exact(((pfiber2_loopsf)o*E(pequiv_pfiber__(square_pfib_pequiv_cxfibif)))^-1*).Defined.Definitionconnecting_map{FXY}(i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif}:loopsY->*F:=i_fiberseq(connect_fiberseqif).Global Instanceisexact_connect_R{FXY}(i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif}:IsExactpurely(fmaploopsf) (connecting_mapif).Proof.refine(isexact_equiv_i(Y:=F)purely(pfib(pfibi)) (fmaploopsf)(((loops_invX)o*E(pfiber2_loops(pfibf))o*E(pequiv_pfiber__(square_pequiv_pfiber__(square_pfib_pequiv_cxfibif))))^-1*)(((pfiber2_loopsf)o*E(pequiv_pfiber__(square_pfib_pequiv_cxfibif)))^-1*)_(pfibi)).refine(vinverse((loops_invX)o*E(pfiber2_loops(pfibf))o*E(pequiv_pfiber__(square_pequiv_pfiber__(square_pfib_pequiv_cxfibif))))((pfiber2_loopsf)o*E(pequiv_pfiber__(square_pfib_pequiv_cxfibif)))_).refine(vconcat(f03:=loops_invXo*pfiber2_loops(pfibf))(f01:=pequiv_pfiber__(square_pequiv_pfiber__(square_pfib_pequiv_cxfibif)))(f23:=pfiber2_loopsf)(f21:=pequiv_pfiber__(square_pfib_pequiv_cxfibif))__).-exact(square_pequiv_pfiber__(square_pequiv_pfiber__(square_pfib_pequiv_cxfibif))).-exact(pfiber2_fmap_loopsf).Defined.The connecting map associated to a pointed family.Definitionconnecting_map_family{Y:pType} (P:pFamY):loopsY->* [Ppt,dpointP].Proof.srapplyBuild_pMap.-introl.apply(transportPl).applyP.-reflexivity.Defined.Long exact sequencesRecordLongExactSequence(k:Modality) (N:SuccStr) :Type:={les_carrier:N->pType;les_fn:foralln,les_carriern.+1 ->*les_carriern;les_isexact:foralln,IsExactk(les_fnn.+1) (les_fnn)}.Coercionles_carrier:LongExactSequence>->Funclass.Argumentsles_fn{kN}Sn:rename.Global Existing Instanceles_isexact.Long exact sequences are preserved by truncation.Definitiontrunc_les`{Univalence} (k:trunc_index) {N:SuccStr}(S:LongExactSequencepurelyN):LongExactSequence(Trk)N:=Build_LongExactSequence(Trk)N(funn=>pTrk.+1 (Sn))(funn=>fmap(pTrk.+1) (les_fnSn))_.LES of loop spaces and homotopy groupsDefinitionloops_carrier(FXY:pType) (n:N3) :pType:=matchnwith| (n,inl(inl(inlx))) =>Empty_ind_x| (n,inl(inl(inrtt))) =>iterated_loopsnY| (n,inl(inrtt)) =>iterated_loopsnX| (n,inrtt) =>iterated_loopsnFend.Starting from a fiber sequence, we can obtain a long purely-exact sequence of loop spaces.Definitionloops_les{FXY:pType}(i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif}:LongExactSequencepurely(N3).Proof.srefine(Build_LongExactSequencepurely(N3) (loops_carrierFXY)__).all:intros[n[[[[]|[]]|[]]|[]]];cbn.{exact(fmap(iterated_loopsn)f). }{exact(fmap(iterated_loopsn)i). }{exact(connecting_map(fmap(iterated_loopsn)i)(fmap(iterated_loopsn)f)). }all:exact_.Defined.And from that, a long exact sequence of homotopy groups (though for now it is just a sequence of pointed sets).DefinitionPi_les`{Univalence} {FXY:pType}(i:F->*X) (f:X->*Y) `{IsExactpurelyFXYif}:LongExactSequence(Tr(-1)) (N3):=trunc_les(-1) (loops_lesif).Classifying fiber sequencesFiber sequences correspond to pointed maps into the universe.Definitionclassify_fiberseq`{Univalence} {YF:pType@{u}}: (Y->* [Type@{u},F]) <~> {X:pType@{u} &FiberSeqFXY}.Proof.refine(_oE_).To applyequiv_sigma_pfibrationwe need to invert the equivalence on the fiber.{do2 (rapplyequiv_functor_sigma_id;intro).applyequiv_pequiv_inverse. }exact((equiv_sigma_assoc__)^-1oEequiv_sigma_pfibration).Defined.

--- Miscellaneous\ExcludedMiddle.html ---
ExcludedMiddleLibrary ExcludedMiddleRequireImportHoTT.BasicsHoTT.Types.The law of excluded middleMonomorphic AxiomExcludedMiddle:Type0.Existing ClassExcludedMiddle.Mark this axiom as a "global axiom", which some of our tactics will automatically handle.Global Instanceis_global_axiom_excludedmiddle:IsGlobalAxiomExcludedMiddle:= {}.AxiomLEM:forall`{ExcludedMiddle} (P:Type),IsHPropP->P+ ~P.DefinitionExcludedMiddle_type:=forall(P:Type),IsHPropP->P+ ~P.LEM means that all propositions are decidableGlobal Instancedecidable_lem`{ExcludedMiddle} (P:Type) `{IsHPropP} :DecidableP:=LEMP_.Double-negation eliminationDefinitionDNE_type:=forallP,IsHPropP-> ~~P->P.DefinitionLEM_to_DNE:ExcludedMiddle->DNE_type.Proof.introslemPhpnnp.case(LEMP_).-auto.-introsnp;elim(nnpnp).Defined.This direction requires Funext.DefinitionDNE_to_LEM`{Funext} :DNE_type->ExcludedMiddle_type.Proof.introsdnPhp.refine(dn(P+ ~P)__).-applyishprop_sum.+exact_.+exact_.+introspnp;exact(npp).-introsnlem.applynlem.applyinr.introsp.applynlem.applyinl.applyp.Defined.DNE is equivalent to "every proposition is a negation".Definitionallneg_from_DNE(H:DNE_type) (P:Type) `{IsHPropP}: {Q:Type&P<-> ~Q}.Proof.exists(~P);split.-introspnp;exact(npp).-applyH;exact_.Defined.DefinitionDNE_from_allneg(H:forallP,IsHPropP-> {Q:Type&P<-> ~Q}):DNE_type.Proof.introsP?nnp.destruct(HP_)as[Qe].applye.introsq.applynnp.introsp.exact(fstepq).Defined.

--- Miscellaneous\ExponentialLaws.html ---
ExponentialLawsLibrary ExponentialLawsExponential LawsWe want to have the following as subdirectories/modules, not at top level.  Unfortunately, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.Laws about the initial categoryx⁰≅10ˣ≅0ifx≠0RequireExponentialLaws.Law0.Laws about the terminal categoryx¹≅x1ˣ≅1RequireExponentialLaws.Law1.The law that a sum in an exponent is a productyⁿ⁺ᵐ≅yⁿ×yᵐRequireExponentialLaws.Law2.The law that exponentiation distributes over product(y×z)ⁿ≅yⁿ×zⁿRequireExponentialLaws.Law3.Currying(yⁿ)ᵐ≅yⁿᵐRequireExponentialLaws.Law4.RequireExponentialLaws.Tactics.IncludeExponentialLaws.Tactics.

--- Miscellaneous\Ext.html ---
ExtLibrary ExtRequireImportBasicsTypesTruncations.Core.RequireImportPointedWildCat.RequireImportTruncations.SeparatedTrunc.RequireImportAbelianGroupAbHomAbProjective.RequireImportAbSES.PullbackAbSES.PushoutAbSES.BaerSumAbSES.Core.Local OpenScopemc_scope.Local OpenScopemc_add_scope.The setExtBAof abelian group extensionsDefinitionExt(BA:AbGroup@{u}) :=pTr0 (AbSESBA).Global Instanceis0bifunctor_ext`{Univalence}:Is0Bifunctor(Ext:AbGroup^op->AbGroup->pType):=is0bifunctor_postcompose__(bf:=is0bifunctor_abses).Global Instanceis1bifunctor_ext`{Univalence}:Is1Bifunctor(Ext:AbGroup^op->AbGroup->pType):=is1bifunctor_postcompose__(bf:=is1bifunctor_abses).An extensionE:AbSESBAis trivial inExtBAif and only ifEmerely splits.Propositioniff_ab_ext_trivial_split`{Univalence} {BA:AbGroup} (E:AbSESBA):merely{s:GroupHomomorphismBE& (projection_) $os==idmap}<~> (trE=point(ExtBA)).Proof.refine(equiv_path_Tr__oE_).srapplyequiv_iff_hprop;applyTrunc_functor;applyiff_abses_trivial_split.Defined.DefinitionExt'(BA:AbGroup@{u}) :=Tr0 (AbSES'BA).Global Instanceis0bifunctor_ext'`{Univalence}:Is0Bifunctor(Ext':AbGroup^op->AbGroup->Type):=is0bifunctor_postcompose__(bf:=is0bifunctor_abses').Global Instanceis1bifunctor_ext'`{Univalence}:Is1Bifunctor(Ext':AbGroup^op->AbGroup->Type):=is1bifunctor_postcompose__(bf:=is1bifunctor_abses').ExtBAis an abelian group for anyAB:AbGroup. The proof of commutativity is a bit faster if we separate out the proof thatExtBAis a group.Definitiongrp_ext`{Univalence} (BA:AbGroup@{u}) :Group.Proof.snrapply(Build_Group(ExtBA)).-introsEF.strip_truncations.exact(tr(abses_baer_sumEF)).-exact(point(ExtBA)).-unfoldNegate.exact(Trunc_functor_(abses_pullback(-grp_homo_id))).-repeatsplit.1:applyistrunc_truncation.all:introE. 1:introsFG.all:strip_truncations;unfoldmon_unit,point;apply(aptr).+symmetry;applybaer_sum_associative.+applybaer_sum_unit_l.+applybaer_sum_unit_r.+applybaer_sum_inverse_r.+applybaer_sum_inverse_l.Defined.The bifunctorab_extDefinitionab_ext@{uv|u<v} `{Univalence} (B:AbGroup@{u}^op) (A:AbGroup@{u}) :AbGroup@{v}.Proof.snrapply(Build_AbGroup(grp_ext@{uv}BA)).introsEF.strip_truncations;cbn.applyap.applybaer_sum_commutative.Defined.Global Instanceis0functor_abext01`{Univalence} (B:AbGroup^op):Is0Functor(ab_extB).Proof.srapplyBuild_Is0Functor;intros? ?f.snrapplyBuild_GroupHomomorphism.1:exact(fmap(ExtB)f).rapplyTrunc_ind;introE0.rapplyTrunc_ind;introE1.apply(aptr);cbn.applybaer_sum_pushout.Defined.Global Instanceis0functor_abext10`{Univalence} (A:AbGroup):Is0Functor(funB:AbGroup^op=>ab_extBA).Proof.srapplyBuild_Is0Functor;intros? ?f;cbn.snrapplyBuild_GroupHomomorphism.1:exact(fmap(fun(B:AbGroup^op) =>ExtBA)f).rapplyTrunc_ind;introE0.rapplyTrunc_ind;introE1.apply(aptr);cbn.applybaer_sum_pullback.Defined.Global Instanceis1functor_abext01`{Univalence} (B:AbGroup^op):Is1Functor(ab_extB).Proof.snrapplyBuild_Is1Functor.-introsACfg.exact(fmap2(ExtB)).-exact(fmap_id(ExtB)).-introsACD.exact(fmap_comp(ExtB)).Defined.Global Instanceis1functor_abext10`{Univalence} (A:AbGroup):Is1Functor(funB:AbGroup^op=>ab_extBA).Proof.snrapplyBuild_Is1Functor.-introsBCfg.exact(fmap2(funB:AbGroup^op=>ExtBA)).-exact(fmap_id(funB:AbGroup^op=>ExtBA)).-introsBCD.exact(fmap_comp(funB:AbGroup^op=>ExtBA)).Defined.Global Instanceis0bifunctor_abext`{Univalence}:Is0Bifunctor(A:=AbGroup^op)ab_ext.Proof.rapplyBuild_Is0Bifunctor''.Defined.Global Instanceis1bifunctor_abext`{Univalence}:Is1Bifunctor(A:=AbGroup^op)ab_ext.Proof.snrapplyBuild_Is1Bifunctor''.1,2:exact_.introsAB.exact(bifunctor_coh(Ext:AbGroup^op->AbGroup->pType)).Defined.We can push out a fixed extension while letting the map vary, and this defines a group homomorphism.Definitionabses_pushout_ext`{Univalence}{BAG:AbGroup@{u}} (E:AbSESBA):GroupHomomorphism(ab_homAG) (ab_extBG).Proof.snrapplyBuild_GroupHomomorphism.1:exact(funf=>fmap01(A:=AbGroup^op)Ext'_f(trE)).introsfg;cbn.nrapply(aptr).exact(baer_sum_distributive_pushoutsfg).Defined.Extensions ending in a projective are trivialPropositionabext_trivial_projective`{Univalence}(P:AbGroup) `{IsAbProjectiveP}:forallA,forallE:AbSESPA,trE=point(ExtPA).Proof.introsAE.applyiff_ab_ext_trivial_split.exact(fst(iff_isabprojective_surjections_splitP)____).Defined.It follows that whenPis projective,ExtPAis contractible.Global Instancecontr_abext_projective`{Univalence}(P:AbGroup) `{IsAbProjectiveP} {A:AbGroup}:Contr(ExtPA).Proof.apply(Build_Contr_(point_));introE.strip_truncations.symmetry;byapplyabext_trivial_projective.Defined.(* Converely, if all extensions ending inPare trivial, thenPis projective. *)Propositionabext_projective_trivial`{Univalence} (P:AbGroup)(ext_triv:forallA,forallE:AbSESPA,trE=point(ExtPA)):IsAbProjectiveP.Proof.applyiff_isabprojective_surjections_split.introsEpissurj_p.apply(iff_ab_ext_trivial_split(abses_from_surjectionp))^-1.applyext_triv.Defined.

--- Miscellaneous\Extensions.html ---
ExtensionsLibrary ExtensionsExtensions and extendible mapsRequireImportHoTT.BasicsHoTT.Types.RequireImportEquiv.PathSplitPathAny.RequireImportCubical.DPathCubical.DPathSquare.RequireImportColimits.CoeqColimits.MappingCylinder.Local OpenScopenat_scope.Local OpenScopepath_scope.GivenC:B->Typeandf:A->B, an extension ofg:foralla,C(fa)alongfis a sectionh:forallb,Cbsuch thath(fa)=gafor alla:A.  This is equivalently the existence of fillers for commutative squares, restricted to the case where the bottom of the square is the identity; type-theoretically, this approach is sometimes more convenient.  In this file we study the type of such extensions.  One of its crucial properties is that a path between extensions is equivalently an extension in a fibration of paths.This turns out to be useful for several reasons.  For instance, by iterating it, we can to formulate universal properties without needingFunext.  It also gives us a way to "quantify" a universal property by the connectedness of the type of extensions.SectionExtensions.(* TODO: consider naming forExtensionAlongand subsequent lemmas.  As a name for the type itself,ExtensionorExtensionAlongseems great; but resultant lemma names such aspath_extension(following existing naming conventions) are rather misleading. *)This elimination rule (and others) can be seen as saying that, given a fibration over the codomain and a section of it over the domain, there is some *extension* of this to a section over the whole codomain.  It can also be considered as an equivalent form of anhfiberof precomposition-with-fthat replaces paths by pointwise paths, thereby avoidingFunext.DefinitionExtensionAlong@{abpm} {A:Type@{a}} {B:Type@{b}} (f:A->B)(P:B->Type@{p}) (d:forallx:A,P(fx)):=(* { s : forall y:B, P y & forall x:A, s (f x) = d x }. *)sig@{mm} (fun(s:forally:B,Py) =>forallx:A,s(fx) =dx).ExtensionAlongtakes 4 universe parameters:the size of Athe size of Bthe size of P>= max(A,B,P)It's occasionally useful to be able to modify those universes.  For each of the universesa,b,p, we give an initial one, a final one, and a "minimum" one smaller than both and where the type actually lives.Definitionlift_extensionalong@{a1a2aminb1b2bminp1p2pminm1m2} {A:Type@{amin}} {B:Type@{bmin}} (f:A->B)(P:B->Type@{pmin}) (d:forallx:A,P(fx)):ExtensionAlong@{a1b1p1m1}fPd->ExtensionAlong@{a2b2p2m2}fPd.Proof.introsext.If we just giveext, it will collapse the universes.  (Anyone stepping through this proof should doSetPrintingUniversesand look at the universes to see that they're different inextand in the goal.)  So we decomposeextinto two components and give them separately.assert(e2:=ext.2);set(e1:=ext.1)ine2.cbnine2.Curiously, without this line we get a spurious universe inequalityp1<=m2.exact(e1;e2).Defined.We called itlift_extensionalong, but in fact it doesn't require the new universes to be bigger than the old ones, only that they both satisfy the max condition.Definitionequiv_path_extension`{Funext} {AB:Type} {f:A->B}{P:B->Type} {d:forallx:A,P(fx)}(extext':ExtensionAlongfPd): (ExtensionAlongf(funy=>pr1exty=pr1ext'y)(funx=>pr2extx@ (pr2ext'x)^))<~>ext=ext'.Proof.revertext'.srapplyequiv_path_from_contr.{unfoldExtensionAlong;cbn.exists(funy=> 1%path).introsx;symmetry;applyconcat_pV. }destructextas[ggd];unfoldExtensionAlong;cbn.refine(contr_sigma_sigma(forally:B,Py) (funs=>forallx:A,s(fx) =dx)(funa=>g==a)(funabc=>forallx:A,c(fx) =gdx@ (bx)^)g(funy:B=>idpath(gy))).refine(contr_equiv'{p:gof==d&gd==p}_).cbn.refine(equiv_functor_sigma_id_);introsp.refine(equiv_functor_forall_id_);introsx;cbn.refine(_oEequiv_path_inverse__).symmetry;applyequiv_moveR_1M.Defined.Definitionpath_extension`{Funext} {AB:Type} {f:A->B}{P:B->Type} {d:forallx:A,P(fx)}(extext':ExtensionAlongfPd): (ExtensionAlongf(funy=>pr1exty=pr1ext'y)(funx=>pr2extx@ (pr2ext'x)^))->ext=ext':=equiv_path_extensionextext'.Global Instanceisequiv_path_extension`{Funext} {AB:Type} {f:A->B}{P:B->Type} {d:forallx:A,P(fx)}(extext':ExtensionAlongfPd):IsEquiv(path_extensionextext') | 0:=equiv_isequiv_.Here is the iterated version.FixpointExtendableAlong@{ijkl}(n:nat) {A:Type@{i}} {B:Type@{j}}(f:A->B) (C:B->Type@{k}) :Type@{l}:=matchnwith| 0 =>Unit|Sn=> (forall(g:foralla,C(fa)),ExtensionAlong@{ijkl}fCg) *forall(hk:forallb,Cb),ExtendableAlongnf(funb=>hb=kb)end.ExtendableAlongtakes 4 universe parameters:size of Asize of Bsize of Csize of result (>= A,B,C)Global ArgumentsExtendableAlongn%_nat_scope{AB}%_type_scope(fC)%_function_scope.We can modify the universes, as withExtensionAlong.Definitionlift_extendablealong@{a1a2aminb1b2bminp1p2pminm1m2}(n:nat) {A:Type@{amin}} {B:Type@{bmin}}(f:A->B) (P:B->Type@{pmin}):ExtendableAlong@{a1b1p1m1}nfP->ExtendableAlong@{a2b2p2m2}nfP.Proof.revertP;simple_inductionnnIH;introsP.-intros_;exacttt.-introsext;split.+introsg;exact(lift_extensionalong@{a1a2aminb1b2bminp1p2pminm1m2}___(fstextg)).+introshk.Unles we give the universe explicitly here,kmingets collapsed tok1.pose(P':= (funb=>hb=kb) :B->Type@{pmin}).exact(IHP'(sndexthk)).Defined.Definitionequiv_extendable_pathsplit`{Funext} (n:nat){AB:Type} (C:B->Type) (f:A->B):ExtendableAlongnfC<~>PathSplitn(fun(g:forallb,Cb) =>goDf).Proof.generalizedependentC;simple_inductionnnIHn;introsC.1:applyequiv_idmap.refine(_*E_);simpl.-refine(equiv_functor_forall'1_);introsg;simpl.refine(equiv_functor_sigma'1_);introsrec.applyequiv_path_forall.-refine(equiv_functor_forall'1_);introsh.refine(equiv_functor_forall'1_);introsk;simpl.refine(_oEIHn(funb=>hb=kb)).applyequiv_inverse.refine(equiv_functor_pathsplitn__(equiv_apD10___) (equiv_apD10___)_).intros[];reflexivity.Defined.Definitionisequiv_extendable`{Funext} (n:nat){AB:Type} {C:B->Type} {f:A->B}:ExtendableAlongn.+2fC->IsEquiv(fung=>goDf):=isequiv_pathsplitno(equiv_extendable_pathsplitn.+2Cf).Global Instanceishprop_extendable`{Funext} (n:nat){AB:Type} (C:B->Type) (f:A->B):IsHProp(ExtendableAlongn.+2fC).Proof.exact(istrunc_equiv_istrunc_(equiv_extendable_pathsplitn.+2Cf)^-1).Defined.Definitionequiv_extendable_isequiv`{Funext} (n:nat){AB:Type} (C:B->Type) (f:A->B):ExtendableAlongn.+2fC<~>IsEquiv(fun(g:forallb,Cb) =>goDf).Proof.etransitivity.-applyequiv_extendable_pathsplit.-applyequiv_pathsplit_isequiv.Defined.(* WithoutFunext, we can prove a small part of the above equivalence.We suspect that the rest requiresFunext. *)Definitionextension_isequiv_precompose{A:Type} {B:Type}(f:A->B) (C:B->Type):IsEquiv(fun(g:forallb,Cb) =>goDf) ->forallg,ExtensionAlongfCg.Proof.introsEg.pose(e:=Build_Equiv___E).exists(e^-1g).applyapD10.exact(eisretreg).Defined.Postcomposition with a known equivalence.  Note that this does not require funext to define, although showing that it is an equivalence would require funext.Definitionextendable_postcompose'(n:nat){AB:Type} (CD:B->Type) (f:A->B)(g:forallb,Cb<~>Db):ExtendableAlongnfC->ExtendableAlongnfD.Proof.generalizedependentC;revertD.simple_inductionnnIH;introsCDg;simpl.1:applyidmap.refine(functor_prod__).-refine(functor_forall(functor_forallidmap(funa=> (g(fa))^-1))_);introsh;simpl.refine(functor_sigma(functor_forallidmapg)_);introsk.refine(functor_forallidmap_);introsa;unfoldfunctor_arrow,functor_forall,composeD;simpl.applymoveR_equiv_M.-refine(functor_forall(functor_forallidmap(funb=> (gb)^-1))_);introsh.refine(functor_forall(functor_forallidmap(funb=> (gb)^-1))_);introsk;simpl;unfoldfunctor_forall.refine(IH___);introsb.applyequiv_inverse,equiv_ap;exact_.Defined.Definitionextendable_postcompose(n:nat){AB:Type} (CD:B->Type) (f:A->B)(g:forallb,Cb->Db) `{forallb,IsEquiv(gb)}:ExtendableAlongnfC->ExtendableAlongnfD:=extendable_postcompose'nCDf(funb=>Build_Equiv__(gb)_).Composition of the maps we extend along.  This also does not require funext.Definitionextendable_compose(n:nat){ABC:Type} (P:C->Type) (f:A->B) (g:B->C):ExtendableAlongngP->ExtendableAlongnf(funb=>P(gb)) ->ExtendableAlongn(gof)P.Proof.revertP;simple_inductionnnIHn;introsPextgextf; [exacttt|split].-introsh.exists((fstextg(fstextfh).1).1);introsa.refine((fstextg(fstextfh).1).2 (fa) @_).exact((fstextfh).2a).-introshk.applyIHn.+exact(sndextghk).+exact(sndextf(hoDg) (koDg)).Defined.And cancellationDefinitioncancelL_extendable(n:nat){ABC:Type} (P:C->Type) (f:A->B) (g:B->C):ExtendableAlongngP->ExtendableAlongn(gof)P->ExtendableAlongnf(funb=>P(gb)).Proof.revertP;simple_inductionnnIHn;introsPextgextgf; [exacttt|split].-introsh.exists((fstextgfh).1oDg);introsa.exact((fstextgfh).2a).-introshk.pose(h':= (fstextgh).1).pose(k':= (fstextgk).1).refine(extendable_postcompose'n(funb=>h'(gb) =k'(gb)) (funb=>hb=kb)f__).+introsb.exact(equiv_concat_lr((fstextgh).2b)^ ((fstextgk).2b)).+apply(IHn(func=>h'c=k'c) (sndextgh'k') (sndextgfh'k')).Defined.DefinitioncancelR_extendable(n:nat){ABC:Type} (P:C->Type) (f:A->B) (g:B->C):ExtendableAlongn.+1f(funb=>P(gb)) ->ExtendableAlongn(gof)P->ExtendableAlongngP.Proof.revertP;simple_inductionnnIHn;introsPextfextgf; [exacttt|split].-introsh.exists((fstextgf(hoDf)).1);introsb.refine((fst(sndextf((fstextgf(hoDf)).1oDg)h)_).1b);introsa.apply((fstextgf(hoDf)).2).-introshk.applyIHn.+apply(sndextf(hoDg) (koDg)).+apply(sndextgfhk).Defined.And transfer across homotopiesDefinitionextendable_homotopic(n:nat){AB:Type} (C:B->Type) (f:A->B) {g:A->B} (p:f==g):ExtendableAlongnfC->ExtendableAlongngC.Proof.revertC;simple_inductionnnIHn;introsCextf; [exacttt|split].-introsh.exists((fstextf(funa=> (pa)^ #ha)).1);introsa.refine((apD((fstextf(funa=> (pa)^ #ha)).1) (pa))^ @_).applymoveR_transport_p.exact((fstextf(funa=> (pa)^ #ha)).2a).-introshk.applyIHn, (sndextfhk).Defined.We can extend along equivalencesDefinitionextendable_equiv(n:nat){AB:Type} (C:B->Type) (f:A->B) `{IsEquiv__f}:ExtendableAlongnfC.Proof.revertC;simple_inductionnnIHn;introsC; [exacttt|split].-introsh.exists(funb=>eisretrfb#h(f^-1b));introsa.refine(transport2C(eisadjfa)_@_).refine((transport_composeCf__)^ @_).exact(apDh(eissectfa)).-introshk.applyIHn.Defined.And into contractible typesDefinitionextendable_contr(n:nat){AB:Type} (C:B->Type) (f:A->B)`{forallb,Contr(Cb)}:ExtendableAlongnfC.Proof.generalizedependentC;simple_inductionnnIHn;introsC?; [exacttt|split].-introsh.exists(fun_=>center_);introsa.applycontr.-introshk.applyIHn;exact_.Defined.This is inherited by types of homotopies.Definitionextendable_homotopy(n:nat){AB:Type} (C:B->Type) (f:A->B)(hk:forallb,Cb):ExtendableAlongn.+1fC->ExtendableAlongnf(funb=>hb=kb).Proof.revertChk;simple_inductionnnIHn;introsChkext; [exacttt|split].-introsp.exact(fst(sndexthk)p).-introspq.applyIHn,ext.Defined.And the oo-version.DefinitionooExtendableAlong@{ijkl}{A:Type@{i}} {B:Type@{j}}(f:A->B) (C:B->Type@{k}) :Type@{l}:=foralln:nat,ExtendableAlong@{ijkl}nfC.Universe parameters are the same as forExtendableAlong.Global ArgumentsooExtendableAlong{AB}%_type_scope(fC)%_function_scope.Universe modification.Definitionlift_ooextendablealong@{a1a2aminb1b2bminp1p2pminm1m2}{A:Type@{amin}} {B:Type@{bmin}}(f:A->B) (P:B->Type@{pmin}):ooExtendableAlong@{a1b1p1m1}fP->ooExtendableAlong@{a2b2p2m2}fP:=funextn=>lift_extendablealong@{a1a2aminb1b2bminp1p2pminm1m2}nfP(extn).We take part of the data fromps1and part fromps2so that the inverse chosen is the expected one.Definitionisequiv_ooextendable`{Funext}{AB:Type} (C:B->Type) (f:A->B):ooExtendableAlongfC->IsEquiv(fung=>goDf):=funps=>isequiv_extendable0 (fst(ps1%nat),snd(ps2)).Definitionequiv_ooextendable_pathsplit`{Funext}{AB:Type} (C:B->Type) (f:A->B):ooExtendableAlongfC<~>ooPathSplit(fun(g:forallb,Cb) =>goDf).Proof.refine(equiv_functor_forall'1_);introsn.applyequiv_extendable_pathsplit.Defined.Global Instanceishprop_ooextendable`{Funext}{AB:Type} (C:B->Type) (f:A->B):IsHProp(ooExtendableAlongfC).Proof.refine(istrunc_equiv_istrunc_(equiv_ooextendable_pathsplitCf)^-1).Defined.Definitionequiv_ooextendable_isequiv`{Funext}{AB:Type} (C:B->Type) (f:A->B):ooExtendableAlongfC<~>IsEquiv(fun(g:forallb,Cb) =>goDf):=equiv_oopathsplit_isequiv_oEequiv_ooextendable_pathsplit__.Definitionooextendable_postcompose{AB:Type} (CD:B->Type) (f:A->B)(g:forallb,Cb->Db) `{forallb,IsEquiv(gb)}:ooExtendableAlongfC->ooExtendableAlongfD:=funpppn=>extendable_postcomposenCDfg(pppn).Definitionooextendable_postcompose'{AB:Type} (CD:B->Type) (f:A->B)(g:forallb,Cb<~>Db):ooExtendableAlongfC->ooExtendableAlongfD:=funpppn=>extendable_postcompose'nCDfg(pppn).Definitionooextendable_compose{ABC:Type} (P:C->Type) (f:A->B) (g:B->C):ooExtendableAlonggP->ooExtendableAlongf(funb=>P(gb)) ->ooExtendableAlong(gof)P:=funextgextfn=>extendable_composenPfg(extgn) (extfn).DefinitioncancelL_ooextendable{ABC:Type} (P:C->Type) (f:A->B) (g:B->C):ooExtendableAlonggP->ooExtendableAlong(gof)P->ooExtendableAlongf(funb=>P(gb)):=funextgextgfn=>cancelL_extendablenPfg(extgn) (extgfn).DefinitioncancelR_ooextendable{ABC:Type} (P:C->Type) (f:A->B) (g:B->C):ooExtendableAlongf(funb=>P(gb)) ->ooExtendableAlong(gof)P->ooExtendableAlonggP:=funextfextgfn=>cancelR_extendablenPfg(extfn.+1) (extgfn).Definitionooextendable_homotopic{AB:Type} (C:B->Type) (f:A->B) {g:A->B} (p:f==g):ooExtendableAlongfC->ooExtendableAlonggC:=funextfn=>extendable_homotopicnCfp(extfn).Definitionooextendable_equiv{AB:Type} (C:B->Type) (f:A->B) `{IsEquiv__f}:ooExtendableAlongfC:=funn=>extendable_equivnCf.Definitionooextendable_contr{AB:Type} (C:B->Type) (f:A->B)`{forallb,Contr(Cb)}:ooExtendableAlongfC:=funn=>extendable_contrnCf.Definitionooextendable_homotopy{AB:Type} (C:B->Type) (f:A->B)(hk:forallb,Cb):ooExtendableAlongfC->ooExtendableAlongf(funb=>hb=kb).Proof.introsextn;applyextendable_homotopy,ext.Defined.Extendability of a familyCalong a mapfcan be detected by extendability of the constant familyCbalong the projection from the corresponding fiber offtoUnit.  Note that this is *not* an if-and-only-if; the hypothesis can be genuinely stronger than the conclusion.Definitionooextendable_isnull_fibers{AB} (f:A->B) (C:B->Type): (forallb,ooExtendableAlong(const_tt(hfiberfb))(fun_=>Cb))->ooExtendableAlongfC.Proof.introsorthn;revertCorth.inductionnas[|nIHn];introsCorth; [exacttt|split].-introsg.exists(funb=> (fst(orthb1%nat) (funx=>x.2 #gx.1)).1tt).introsa.rewrite(path_unittt(const_tt_a)).exact((fst(orth(fa) 1%nat)_).2 (a; 1)).-introshk.applyIHn;introsb.applyooextendable_homotopy,orth.Defined.EndExtensions.Extendability along cofibrationsIf a family is extendable along a cofibration (i.e. a mapping cylinder), it is extendable definitionally.Definitioncyl_extension{AB} (f:A->B) (C:Cylf->Type)(g:foralla,C(cyla))(ext:ExtensionAlongcylCg):ExtensionAlongcylCg.Proof.srefine(Cyl_indCg(ext.1ocyr)_;_);introsa.+refine((ext.2a)^ @Dl_)%dpath.applyapD.+reflexivity.The point is that this equality is now definitional.Defined.Definitioncyl_extendable(n:nat){AB} (f:A->B) (C:Cylf->Type)(ext:ExtendableAlongncylC):ExtendableAlongncylC.Proof.revertCext;simple_inductionnnIH;introsCext; [exacttt|split].-introsg.applycyl_extension.exact(fstextg).-introshk;applyIH.exact(sndexthk).Defined.Definitioncyl_ooextendable{AB} (f:A->B) (C:Cylf->Type)(ext:ooExtendableAlongcylC):ooExtendableAlongcylC:=funn=>cyl_extendablenfC(extn).Definitioncyl_extension'{AB} (f:A->B) (C:B->Type)(g:foralla,C(pr_cyl(cyla)))(ext:ExtensionAlongfCg):ExtensionAlongcyl(Copr_cyl)g.Proof.rapplycyl_extension.exists(ext.1opr_cyl).introsx;applyext.2.Defined.Definitioncyl_extendable'(n:nat){AB} (f:A->B) (C:B->Type)(ext:ExtendableAlongnfC):ExtendableAlongncyl(Co(pr_cyl'f)).Proof.rapplycyl_extendable.refine(cancelL_extendablenCcylpr_cyl_ext).rapplyextendable_equiv.Defined.Definitioncyl_ooextendable'{AB} (f:A->B) (C:B->Type)(ext:ooExtendableAlongfC):ooExtendableAlongcyl(Co(pr_cyl'f)):=funn=>cyl_extendable'nfC(extn).Extendability alongfunctor_prodDefinitionextension_functor_prod{ABA'B'} (f:A->A') (g:B->B')(P:A'*B'->Type)(ef:forallb',ExtendableAlong1f(funa'=>P(a',b')))(eg:foralla',ExtendableAlong1g(funb'=>P(a',b')))(s:forallz,P(functor_prodfgz)):ExtensionAlong(functor_prodfg)Ps.Proof.srefine(_;_).-intros[a'b'];revertb'.refine((fst(ega')_).1).introsb;reverta'.refine((fst(ef(gb))_).1).introsa.exact(s(a,b)).-intros[ab];cbn.refine((fst(eg(fa))_).2b@_).exact((fst(ef(gb))_).2a).Defined.Definitionextendable_functor_prod(n:nat){ABA'B'} (f:A->A') (g:B->B')(P:A'*B'->Type)(ef:forallb',ExtendableAlongnf(funa'=>P(a',b')))(eg:foralla',ExtendableAlongng(funb'=>P(a',b'))):ExtendableAlongn(functor_prodfg)P.Proof.revertPefeg;simple_inductionnnIH;introsPefeg; [exacttt|split].-applyextension_functor_prod.+introsb';exact(fst(efb'),fun__=>tt).+introsa';exact(fst(ega'),fun__=>tt).-introshk;applyIH.+introsb';apply(snd(efb')).+introsa';apply(snd(ega')).Defined.Definitionooextendable_functor_prod{ABA'B'} (f:A->A') (g:B->B')(P:A'*B'->Type)(ef:forallb',ooExtendableAlongf(funa'=>P(a',b')))(eg:foralla',ooExtendableAlongg(funb'=>P(a',b'))):ooExtendableAlong(functor_prodfg)P:=funn=>extendable_functor_prodnfgP(funb'=>efb'n) (funa'=>ega'n).Extendability alongfunctor_sigmaDefinitionextension_functor_sigma_id{A} {PQ:A->Type} (f:foralla,Pa->Qa)(C:sigQ->Type)(ef:foralla,ExtendableAlong1 (fa) (funv=>C(a;v)))(s:forallz,C(functor_sigmaidmapfz)):ExtensionAlong(functor_sigmaidmapf)Cs.Proof.srefine(_;_).-intros[av];revertv.refine((fst(efa)_).1).introsu.exact(s(a;u)).-intros[au];cbn.exact((fst(efa)_).2u).Defined.Definitionextendable_functor_sigma_idn{A} {PQ:A->Type} (f:foralla,Pa->Qa)(C:sigQ->Type)(ef:foralla,ExtendableAlongn(fa) (funv=>C(a;v))):ExtendableAlongn(functor_sigmaidmapf)C.Proof.revertCef;simple_inductionnnIH;introsCef; [exacttt|split].-applyextension_functor_sigma_id.introsa;exact(fst(efa) ,fun__=>tt).-introshk;applyIH.introsa;apply(snd(efa)).Defined.Definitionooextendable_functor_sigma_id{A} {PQ:A->Type} (f:foralla,Pa->Qa)(C:sigQ->Type)(ef:foralla,ooExtendableAlong(fa) (funv=>C(a;v))):ooExtendableAlong(functor_sigmaidmapf)C:=funn=>extendable_functor_sigma_idnfC(funa=>efan).Unfortunately, the technology ofExtensionAlongseems to be insufficient to state a general, funext-free version ofextension_functor_sigmawith a nonidentity map on the bases; the hypothesis on the fiberwise map would have to be the existence of an extension in a function-type "up to pointwise equality".  With wild oo-groupoids we could probably manage it.  For now, we say something a bit hacky.DefinitionHomotopyExtensionAlong{AB} {Q:B->Type}(f:A->B) (C:sigQ->Type)(p:forall(a:A) (v:Q(fa)),C(fa;v)):= {q:forall(b:B) (v:Qb),C(b;v) &forallav,q(fa)v=pav}.FixpointHomotopyExtendableAlong(n:nat){AB} {Q:B->Type} (f:A->B) (C:sigQ->Type) :Type:=matchnwith| 0 =>Unit|Sn=> ((forall(p:forall(a:A) (v:Q(fa)),C(fa;v)),HomotopyExtensionAlongfCp) *(forall(hk:forallz,Cz),HomotopyExtendableAlongnf(funz=>hz=kz)))end.DefinitionooHomotopyExtendableAlong{AB} {Q:B->Type} (f:A->B) (C:sigQ->Type):=foralln,HomotopyExtendableAlongnfC.Definitionextension_functor_sigma{AB} {P:A->Type} {Q:B->Type}(f:A->B) (g:foralla,Pa->Q(fa))(C:sigQ->Type)(ef:HomotopyExtendableAlong1fC)(eg:foralla,ExtendableAlong1 (ga) (funv=>C(fa;v)))(s:forallz,C(functor_sigmafgz)):ExtensionAlong(functor_sigmafg)Cs.Proof.srefine(_;_).-intros[bv];revertbv.refine((fstef_).1).introsa.refine((fst(ega)_).1).introsu.exact(s(a;u)).-intros[au];cbn.refine((fstef_).2__@_).exact((fst(ega)_).2u).Defined.Definitionextendable_functor_sigma(n:nat){AB} {P:A->Type} {Q:B->Type}(f:A->B) (g:foralla,Pa->Q(fa))(C:sigQ->Type)(ef:HomotopyExtendableAlongnfC)(eg:foralla,ExtendableAlongn(ga) (funv=>C(fa;v))):ExtendableAlongn(functor_sigmafg)C.Proof.revertCefeg;simple_inductionnnIH;introsCefeg; [exacttt|split].-applyextension_functor_sigma.+exact(fstef,fun__=>tt).+introsa;exact(fst(ega) ,fun__=>tt).-introshk;applyIH.+exact(sndefhk).+introsa;apply(snd(ega)).Defined.Definitionooextendable_functor_sigma{AB} {P:A->Type} {Q:B->Type}(f:A->B) (g:foralla,Pa->Q(fa))(C:sigQ->Type)(ef:ooHomotopyExtendableAlongfC)(eg:foralla,ooExtendableAlong(ga) (funv=>C(fa;v))):ooExtendableAlong(functor_sigmafg)C:=funn=>extendable_functor_sigmanfgC(efn) (funa=>egan).Extendability alongfunctor_sumDefinitionextension_functor_sum{ABA'B'} (f:A->A') (g:B->B')(P:A'+B'->Type)(ef:ExtendableAlong1f(Poinl))(eg:ExtendableAlong1g(Poinr))(h:forallz,P(functor_sumfgz)):ExtensionAlong(functor_sumfg)Ph.Proof.srefine(sum_ind___;sum_ind___).+exact(fstef(hoinl)).1.+exact(fsteg(hoinr)).1.+exact(fstef(hoinl)).2.+exact(fsteg(hoinr)).2.Defined.Definitionextendable_functor_sum(n:nat){ABA'B'} (f:A->A') (g:B->B')(P:A'+B'->Type)(ef:ExtendableAlongnf(Poinl))(eg:ExtendableAlongng(Poinr)):ExtendableAlongn(functor_sumfg)P.Proof.revertPefeg;inductionnas[|nIH];introsPefeg; [exacttt|split].-introsh;applyextension_functor_sum.+exact(fstef,fun__=>tt).+exact(fsteg,fun__=>tt).-introshk.applyIH.+exact(sndef(hoinl) (koinl)).+exact(sndeg(hoinr) (koinr)).Defined.Definitionooextendable_functor_sum{ABA'B'} (f:A->A') (g:B->B')(P:A'+B'->Type)(ef:ooExtendableAlongf(Poinl))(eg:ooExtendableAlongg(Poinr)):ooExtendableAlong(functor_sumfg)P.Proof.introsn;applyextendable_functor_sum; [applyef|applyeg].Defined.Extendability alongfunctor_coeqThe path algebra in these proofs is terrible on its own.  But by replacing the maps with cofibrations so that many equalities hold definitionally, and modifying the extensions to also be strict, it becomes manageable with a bit of dependent-path technology.First we show that if we can extend inCalongk, and we can extend in appropriate path-types ofCalongh, then we can extend inCalongfunctor_coeq.  This is where the hard work is.Definitionextension_functor_coeq{BAfgB'A'f'g'}{h:B->B'} {k:A->A'}{p:kof==f'oh} {q:kog==g'oh}{C:Coeqf'g'->Type}(ek:ExtendableAlong1k(Cocoeq))(eh:forall(uv:forallx:B',C(coeq(g'x))),ExtendableAlong1h(funx=>ux=vx))(s:forallx,C(functor_coeqhkpqx)):ExtensionAlong(functor_coeqhkpq)Cs.Proof.We start by change the problem to involveCylCoeqwith cofibrations.set(C':=Copr_cylcoeqpq).set(s'x:=pr_cyl_cylcoeqpqx#sx).assert(e:ExtensionAlong(cyl_cylcoeqpq)C's').2:{pose(ex:=fst(extendable_equiv1C(pr_cylcoeqpq))e.1).exists(ex.1);introsx.apply(equiv_inj(transportC(pr_cyl_cylcoeqpqx))).exact(apD_(pr_cyl_cylcoeqpqx) @ex.2_@e.2x). }We have to transfer the hypotheses along those equivalences too.  We do it usingcyl_extendableso that the resulting extensions compute definitionally.  Note that this means we never need to refer to the.2parts of the extensions, since they are identity paths.pose(ea1:=funu=> (fst(cyl_extendable'1__ek)u).1).assert(eb'':foralluv,ExtendableAlong1cyl(funx:Cylh=>DPathC'(cgluex) (ux) (vx))).{introsuv.rapplyextendable_postcompose'.2:{rapply(cancelL_extendable1_cylpr_cyl).-rapplyextendable_equiv.-exact(eh(funx=>cgluex#u(cyrx)) (vocyr)). }introsx;substC'.refine((dp_compose(pr_cylcoeqpq)C_)^-1oE_).symmetry;srapplyequiv_ds_fill_lr.3:rapplyap_pr_cylcoeq_cglue.all:srapply(transport(funr=>DPathCr__)).3:exact(dp_inverse(dp_compose_C_(apDu(eissectpr_cylx) :DPath____))).4:exact(dp_inverse(dp_compose_C_(apDv(eissectpr_cylx) :DPath____))).1:change(funy=>pr_cylcoeqpq(coeq(functor_cylpy)))with(funy=>coeq(f:=f') (g:=g') (pr_cyl(functor_cylpy))).2:change(funy=>pr_cylcoeqpq(coeq(functor_cylqy)))with(funy=>coeq(f:=f') (g:=g') (pr_cyl(functor_cylqy))).all:refine((ap_V_(eissectpr_cylx))^ @_).all:exact(ap_compose(funx=>pr_cyl(functor_cyl_x))coeq_). }pose(eb1:=funuvw=> (fst(cyl_extendable___(eb''uv))w).1).Now we construct an extension using Coeq-induction, and prove that it *is* an extension also using Coeq-induction.srefine(_;_);srapplyCoeq_ind.+exact(ea1(s'ocoeq)).+applyeb1;introsb.rapply(dp_compose'__(ap_cyl_cylcoeq_cgluepqb)).exact(apDs'(cglueb)).+Since we're using cofibrations, this holds definitionally.introsa;reflexivity.+And this one is much simpler than it would be otherwise.introsb.applyds_dp.rapplyds_G1.refine(dp_apD_compose'__(ap_cyl_cylcoeq_cgluepqb)_@_).applymoveR_equiv_V.nrapplyCoeq_ind_beta_cglue.Defined.Now we can easily iterate into higher extendability.Definitionextendable_functor_coeq(n:nat){BAfgB'A'f'g'}{h:B->B'} {k:A->A'}{p:kof==f'oh} {q:kog==g'oh}{C:Coeqf'g'->Type}(ek:ExtendableAlongnk(Cocoeq))(eh:forall(uv:forallx:B',C(coeq(g'x))),ExtendableAlongnh(funx=>ux=vx)):ExtendableAlongn(functor_coeqhkpq)C.Proof.revertCekeh;simple_inductionnnIH;introsCekeh; [exacttt|split].-applyextension_functor_coeq.+exact(fstek,fun__=>tt).+exact(funuv=> (fst(ehuv) ,fun__=>tt)).-introsuv;applyIH.+exact(sndek(uocoeq) (vocoeq)).+exact(snd(eh(uocoeqog') (vocoeqog'))).Defined.Definitionooextendable_functor_coeq{BAfgB'A'f'g'}{h:B->B'} {k:A->A'}{p:kof==f'oh} {q:kog==g'oh}{C:Coeqf'g'->Type}(ek:ooExtendableAlongk(Cocoeq))(eh:forall(uv:forallx:B',C(coeq(g'x))),ooExtendableAlongh(funx=>ux=vx)):ooExtendableAlong(functor_coeqhkpq)C:=funn=>extendable_functor_coeqn(ekn) (funuv=>ehuvn).Since extending at leveln.+1intoCimplies extending at levelninto path-types ofC, we get the following corollary.Definitionextendable_functor_coeq'(n:nat){BAfgB'A'f'g'}{h:B->B'} {k:A->A'}{p:kof==f'oh} {q:kog==g'oh}{C:Coeqf'g'->Type}(ek:ExtendableAlongnk(Cocoeq))(eh:ExtendableAlongn.+1h(Cocoeqog')):ExtendableAlongn(functor_coeqhkpq)C.Proof.applyextendable_functor_coeq.1:assumption.exact(sndeh).Defined.Definitionooextendable_functor_coeq'{BAfgB'A'f'g'}{h:B->B'} {k:A->A'}{p:kof==f'oh} {q:kog==g'oh}{C:Coeqf'g'->Type}(ek:ooExtendableAlongk(Cocoeq))(eh:ooExtendableAlongh(Cocoeqog')):ooExtendableAlong(functor_coeqhkpq)C:=funn=>extendable_functor_coeq'n(ekn) (ehn.+1).

--- Miscellaneous\Factorial.html ---
FactorialLibrary FactorialRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoidsBasics.DecidableSpaces.Nat.CoreSpaces.Nat.DivisionTactics.EvalIn.LocalSetUniverseMinimizationToSet.Local OpenScopenat_scope.FactorialsDefinitionFixpointfactorialn:=matchnwith| 0 => 1|Sn=>Sn*factorialnend.PropertiesThe factorial of0is1.Definitionnat_factorial_zero:factorial0 = 1 :=idpath.The factorial ofn+1isn+1times the factorial ofn.Definitionnat_factorial_succn:factorialn.+1 =n.+1 *factorialn:=idpath.A variant ofnat_factorial_succ.Definitionnat_factorial_predn: 0 <n->factorialn=n*factorial(nat_predn).Proof.intros[];reflexivity.Defined.Every factorial is positive.Global Instancelt_zero_factorialn: 0 <factorialn.Proof.inductionn;exact_.Defined.Except forfactorial0=factorial1, thefactorialfunction is strictly monotone.  We separate out the successor case since it is used twice in the proof of the general result.Definitionnat_factorial_strictly_monotone_succn: 0 <n->factorialn<factorialn.+1.Proof.introH.rewrite<- (nat_mul_one_l(factorialn)).rapply(nat_mul_r_strictly_monotone_).Defined.Global Instancenat_factorial_strictly_monotonenm: 0 <n->n<m->factorialn<factorialm.Proof.introsH1H2;inductionH2.-rapplynat_factorial_strictly_monotone_succ.-apply(lt_transIHleq).rapplynat_factorial_strictly_monotone_succ.Defined.DivisibilityAny number less than or equal tondividesfactorialn.Global Instancenat_divides_factorial_factornm: 0 <n->n<=m-> (n|factorialm).Proof.intros[]H2.1:exact_.inductionH2;exact_.Defined.factorialis a monotone function fromnattonatwith respect to<=and divides.Global Instancenat_divides_factorial_ltnm:n<=m-> (factorialn|factorialm).Proof.introsH;inductionH;exact_.Defined.A product of factorials divides the factorial of the sum.Global Instancenat_divides_factorial_mul_factorial_addnm: (factorialn*factorialm|factorial(n+m)).Proof.remember(n+m)askeqn:p.revertknmp;snrapplynat_ind_strong;hnf;introskIHnmp.destructk.{applyequiv_nat_add_zeroinp.destructpas[pq].destructp^,q^.exact_. }rewrite_reflnat_factorial_succ.rewrite<-p.rewritenat_dist_r.assert(helper:foralln'm'(p':n'+m'=k.+1), (factorialn'*factorialm'|n'*factorialk)).-introsn'm'p'.destructn';only1:exact_.rewritenat_factorial_succ.rewrite<-nat_mul_assoc.rapplynat_divides_mul_monotone.rapplyIH.exact(apnat_predp').-nrapplynat_divides_add.+applyhelper,p.+rewritenat_mul_comm.applyhelper.lhsnrapplynat_add_comm;exactp.Defined.Here is a variant ofnat_divides_factorial_mul_factorial_addthat is more suitable for binomial coefficients.Global Instancenat_divides_factorial_mul_factorial_add'nm:m<=n-> (factorialm*factorial(n-m) |factorialn).Proof.introsH.rewrite<- (apfactorial(nat_add_sub_r_cancelH)).applynat_divides_factorial_mul_factorial_add.Defined.

--- Miscellaneous\Factorization.html ---
FactorizationLibrary FactorizationFactorizations and factorization systems.RequireImportHoTT.BasicsHoTT.Types.RequireImportExtensionsPathAny.Local OpenScopepath_scope.FactorizationsSectionFactorization.Universesctxi.Context{class1class2:forall(XY:Type@{ctxi}), (X->Y) ->Type@{ctxi}}`{forall(XY:Type@{ctxi}) (g:X->Y),IsHProp(class1__g)}`{forall(XY:Type@{ctxi}) (g:X->Y),IsHProp(class2__g)}{AB:Type@{ctxi}} {f:A->B}.A factorization offinto a first factor lying inclass1and a second factor lying inclass2.RecordFactorization:={intermediate:Type@{ctxi} ;factor1:A->intermediate;factor2:intermediate->B;fact_factors:factor2ofactor1==f;inclass1:class1__factor1;inclass2:class2__factor2}.Lemmaissig_Factorization:{I:Type& {g:A->I& {h:I->B& {p:hog==f&{gin1:class1__g&class2__h}}}}}<~>Factorization.Proof.issig.Defined.A path between factorizations is equivalent to a structure of the following sort.RecordPathFactorization{factfact':Factorization} :={path_intermediate:intermediatefact<~>intermediatefact';path_factor1:path_intermediateofactor1fact==factor1fact';path_factor2:factor2fact==factor2fact'opath_intermediate;path_fact_factors:foralla,path_factor2(factor1facta)@ap(factor2fact') (path_factor1a)@fact_factorsfact'a=fact_factorsfacta}.ArgumentsPathFactorizationfactfact':clearimplicits.Lemmaissig_PathFactorization(factfact':Factorization) :{path_intermediate:intermediatefact<~>intermediatefact'&{path_factor1:path_intermediateofactor1fact==factor1fact'&{path_factor2:factor2fact==factor2fact'opath_intermediate&foralla,path_factor2(factor1facta)@ap(factor2fact') (path_factor1a)@fact_factorsfact'a=fact_factorsfacta}}}<~>PathFactorizationfactfact'.Proof.issig.Defined.Definitionequiv_path_factorization`{Univalence}(factfact':Factorization):PathFactorizationfactfact'<~>fact=fact'.Proof.refine(_oE(issig_PathFactorizationfactfact')^-1).revertfactfact';apply(equiv_path_issig_contrissig_Factorization).{intros[I[f1[f2[ff[oc1oc2]]]]].exists(equiv_idmapI);cbn.exists(funx:A=> 1%path);cbn.exists(funx:I=> 1%path);cbn.intros;applyconcat_1p. }intros[I[f1[f2[ff[oc1oc2]]]]].contr_sigsigI(equiv_idmapI);cbn.contr_sigsigf1(funx:A=>idpath(f1x));cbn.contr_sigsigf2(funx:I=>idpath(f2x));cbn.refine(contr_equiv'{ff':f2of1==f&ff==ff'}_).symmetry;srefine(equiv_functor_sigma'(equiv_sigma_contr_)_).{introsh;cbn.srefine(@istrunc_sigma_____); [ |introsa];applycontr_inhabited_hprop;tryexact_;assumption. }intros[ff'[oc1'oc2']];cbn.refine(equiv_functor_forall'(equiv_idmap_)_);introsa.refine(equiv_path_inverse__oE_).applyequiv_concat_l;symmetry;applyconcat_1p.Defined.Definitionpath_factorization`{Univalence} (factfact':Factorization):PathFactorizationfactfact'->fact=fact':=equiv_path_factorizationfactfact'.EndFactorization.ArgumentsFactorizationclass1class2{AB}f.ArgumentsPathFactorization{class1class2ABf}factfact'.(* This enables us to talk about "the image of a map" as a factorization but also as the intermediate object appearing in it, as is common in informal mathematics. *)Coercionintermediate:Factorization>->Sortclass.Factorization SystemsA ("unique" or "orthogonal") factorization system consists of a couple of classes of maps, closed under composition, such that every map admits a unique factorization.RecordFactorizationSystem@{ijk} :={class1:forall{XY:Type@{i}}, (X->Y) ->Type@{j} ;ishprop_class1:forall{XY:Type@{i}} (g:X->Y),IsHProp(class1g) ;class1_isequiv:forall{XY:Type@{i}} (g:X->Y) {geq:IsEquivg},class1g;class1_compose:forall{XYZ:Type@{i}} (g:X->Y) (h:Y->Z),class1g->class1h->class1(hog) ;class2:forall{XY:Type@{i}}, (X->Y) ->Type@{k} ;ishprop_class2:forall{XY:Type@{i}} (g:X->Y),IsHProp(class2g) ;class2_isequiv:forall{XY:Type@{i}} (g:X->Y) {geq:IsEquivg},class2g;class2_compose:forall{XYZ:Type@{i}} (g:X->Y) (h:Y->Z),class2g->class2h->class2(hog) ;Morally, the uniqueness of factorizations says thatFactorizationclass1class2fis contractible.  However, in practice we always *prove* that by way ofpath_factorization, and we frequently want to *use* the components of aPathFactorizationas well.  Thus, as data we store the canonical factorization and aPathFactorizationbetween any two such, and prove in a moment that this implies contractibility of the space of factorizations.factor:forall{XY:Type@{i}} (f:X->Y),Factorization@{i} (@class1) (@class2)f;path_factor:forall{XY:Type@{i}} (f:X->Y)(fact:Factorization@{i} (@class1) (@class2)f)(fact':Factorization@{i} (@class1) (@class2)f),PathFactorization@{i}factfact'}.Global Existing Instancesishprop_class1ishprop_class2.The type of factorizations is, as promised, contractible.Theoremcontr_factor`{Univalence} (factsys:FactorizationSystem){XY:Type} (f:X->Y):Contr(Factorization(@class1factsys) (@class2factsys)f).Proof.applycontr_inhabited_hprop.-applyhprop_allpath.introsfactfact'.applypath_factorization;tryexact_.applypath_factor.-applyfactor.Defined.SectionFactSys.Context(factsys:FactorizationSystem).DefinitionBuild_Factorization'{XY}:= @Build_Factorization(@class1factsys) (@class2factsys)XY.DefinitionBuild_PathFactorization'{XY}:= @Build_PathFactorization(@class1factsys) (@class2factsys)XY.The left class is right-cancellable and the right class is left-cancellable.DefinitioncancelR_class1`{Funext} {XYZ} (f:X->Y) (g:Y->Z):class1factsysf->class1factsys(gof) ->class1factsysg.Proof.introsc1fc1gf.destruct(factorfactsysg)as[Ig1g2gfc1g1c2g2].pose(fact:=Build_Factorization'(gof)Z(gof) (idmap)(funx=> 1)c1gf(class2_isequivfactsysidmap)).pose(fact':=Build_Factorization'(gof)I(g1of)g2(funx=>gf(fx))(class1_composefactsysfg1c1fc1g1)c2g2).destruct(path_factorfactsys(gof)fact'fact)as[qq1q2qf];simplin*.refine(transport(class1factsys) (path_arrow__gf)_).refine(class1_composefactsysg1g2c1g1_).applyclass1_isequiv.apply(isequiv_homotopic_(funi=> (q2i)^)).Defined.DefinitioncancelL_class2`{Funext} {XYZ} (f:X->Y) (g:Y->Z):class2factsysg->class2factsys(gof) ->class2factsysf.Proof.introsc2gc2gf.destruct(factorfactsysf)as[If1f2ffc1f1c2f2].pose(fact:=Build_Factorization'(gof)X(idmap) (gof)(funx=> 1) (class1_isequivfactsysidmap)c2gf).pose(fact':=Build_Factorization'(gof)If1(gof2)(funx=>apg(ffx))c1f1(class2_composefactsysf2gc2f2c2g)).destruct(path_factorfactsys(gof)factfact')as[qq1q2qf];simplin*.refine(transport(class2factsys) (path_arrow__ff)_).refine(class2_composefactsysf1f2_c2f2).applyclass2_isequiv.apply(isequiv_homotopic_q1).Defined.The two classes of maps are automatically orthogonal, i.e. any commutative square from aclass1map to aclass2map has a unique diagonal filler.  For now, we only bother to define the lift; in principle we ought to show that the type of lifts is contractible.Universectxi.Context{ABXY:Type@{ctxi}}(i:A->B) (c1i:class1factsysi)(p:X->Y) (c2p:class2factsysp)(f:A->X) (g:B->Y) (h:pof==goi).First we factorfLetC:Type:=intermediate(factorfactsysf).Letf1:A->C:=factor1(factorfactsysf).Letf2:C->X:=factor2(factorfactsysf).Letff:f2of1==f:=fact_factors(factorfactsysf).andgLetD:Type:=intermediate(factorfactsysg).Letg1:B->D:=factor1(factorfactsysg).Letg2:D->Y:=factor2(factorfactsysg).Letgf:g2og1==g:=fact_factors(factorfactsysg).Now we observe thatpof2andf1, andg2andg1oi, are both factorizations of the common diagonal of the commutative square (for which we usepof, but we could equally well usegoi.Letfact:Factorization(@class1factsys) (@class2factsys) (pof):=Build_Factorization'(pof)Cf1(pof2)(funa=>app(ffa))(inclass1(factorfactsysf))(class2_composefactsysf2p(inclass2(factorfactsysf))c2p).Letfact':Factorization(@class1factsys) (@class2factsys) (pof):=Build_Factorization'(pof)D(g1oi)g2(funa=>gf(ia) @ (ha)^)(class1_composefactsysig1c1i(inclass1(factorfactsysg)))(inclass2(factorfactsysg)).Therefore, by the uniqueness of factorizations, we have an equivalenceqrelating them.Letq:C<~>D:=path_intermediate(path_factorfactsys(pof)factfact').Letq1:qof1==g1oi:=path_factor1(path_factorfactsys(pof)factfact').Letq2:pof2==g2oq:=path_factor2(path_factorfactsys(pof)factfact').Using this, we can define the lift.Definitionlift_factsys:B->X:=f2oq^-1og1.And the commutative triangles making it a liftDefinitionlift_factsys_tri1:lift_factsysoi==f.Proof.introsx.refine(ap(f2oq^-1) (q1x)^ @_).transitivity(f2(f1x)).+applyap,eissect.+applyff.Defined.Definitionlift_factsys_tri2:polift_factsys==g.Proof.introsx.refine(q2_@_).transitivity(g2(g1x)).+applyap,eisretr.+applygf.Defined.And finally prove that these two triangles compose to the given commutative square.Definitionlift_factsys_square(x:A):app(lift_factsys_tri1x)^ @lift_factsys_tri2(ix) =hx.Proof.unfoldlift_factsys_tri1,lift_factsys_tri2.OpenScopelong_path_scope.(* First we use the one aspect of the uniqueness of factorizations that we haven't mentioned yet. *)pose(r:=path_fact_factors(path_factorfactsys(pof)factfact')x:q2(f1x) @apg2(q1x) @ (gf(ix) @ (hx)^) =app(ffx)).rewriteconcat_p_ppinr.applymoveL_pM,moveR_Vpinr.refine(_@r);clearr.(* Now we can cancel some whiskered paths on both sides. *)repeatrewriteinv_pp;repeatrewriteap_pp;rewriteap_V.repeatrewriteconcat_pp_p;applywhiskerL.repeatrewriteconcat_p_pp;applywhiskerR.(* Next we set up for a naturality. *)rewrite(ap_composeq^-1f2), <-ap_pp, <-inv_pp.(* The next line appears to do nothing, but in fact it is necessary for the subsequentrewriteto succeed, becauselift_factsysappears in the invisible implicit point-arguments ofpaths.  One way to discover issues of that sort is to turn on printing of all implicit argumnets withSetPrintingAll; another is to useSetDebugTacticUnificationand inspect the output to see whatrewriteis trying and failing to unify. *)unfoldlift_factsys.rewrite<-ap_pp.rewrite<-ap_V, <-ap_compose.rewrite(concat_Apq2).(* Now we can cancel another path *)rewriteconcat_pp_p;applywhiskerL.(* And set up for an application ofap. *)rewriteap_compose.rewrite<-ap_pp.applyap.(* Now we apply the triangle identityeisadj. *)rewriteinv_pp,ap_pp,ap_V.rewrite<-eisadj.(* Finally, we rearrange and it becomes a naturality square. *)rewriteconcat_pp_p;applymoveR_Vp.rewrite<-ap_V,inv_V, <-ap_compose.exact(concat_A1p(eisretrq) (q1x)).CloseScopelong_path_scope.Qed.EndFactSys.SectionFactsysExtensions.Context{factsys:FactorizationSystem}.We can deduce the lifting property in terms of extensions fairly easily from the version in terms of commutative squares.Definitionextension_factsys{AB:Type}(f:A->B) {c1f:class1factsysf}(P:B->Type) (c2P:class2factsys(@pr1BP))(d:foralla:A,P(fa)):ExtensionAlongfPd.Proof.pose(e:=lift_factsysfactsysfc1fpr1c2P(funa=> (fa;da))idmap(funa=> 1)).pose(e2:=lift_factsys_tri2factsysfc1fpr1c2P(funa=> (fa;da))idmap(funa=> 1)).exists(funa=> (e2a) # (ea).2).introsa.pose(e1:=lift_factsys_tri1factsysfc1fpr1c2P(funa=> (fa;da))idmap(funa=> 1)a:e(fa) = (fa;da)).pose(e3:=moveL_M1__(((ap_V__)^ @@ 1)@lift_factsys_squarefactsysfc1fpr1c2P(funa=> (fa;da))idmap(funa=> 1)a):e2(fa) =pr1_pathe1).refine(ap(funp=>transportPp(e(fa)).2)e3@_).exact(pr2_pathe1).Defined.EndFactsysExtensions.

--- Miscellaneous\family_prod.html ---
family_prodLibrary family_prodRequireImportHoTT.Utf8MinimalHoTT.Basics.OvertureTypes.UnitHoTT.Spaces.List.Core.Local OpenScopelist_scope.The following section implements a datatypeFamilyProdwhich
    is a kind of product/tuple.Sectionfamily_prod.Context{I:Type}.FamilyProdFℓis a product type defined byFamilyProd F [i1;i2;...;in] = F i1 * F i2 * ... * F in * UnitIt is convenient to have theUnitin the end.DefinitionFamilyProd(F:I→Type) :listI→Type:=fold_right(λ(i:I) (A:Type),Fi*A)Unit.Map function forFamilyProdFℓ,map_family_prod f (x1, x2, ..., xn, tt)
        = (f x1, f x2, ..., f xn, tt)Fixpointmap_family_prod{FG:I→Type} {ℓ:listI}(f: ∀i,Fi→Gi):FamilyProdFℓ→FamilyProdGℓ:=matchℓwith|nil=>const_tt_|i::ℓ'=>λ'(x,s), (fix,map_family_prodfs)end.for_all_family_prodFP(x1,...,xn,tt)=TrueifPi1x1∧Pi2x2∧...∧Pinxnholds.Fixpointfor_all_family_prod(F:I→Type) {ℓ:listI}(P: ∀i,Fi->Type) :FamilyProdFℓ→Type:=matchℓwith|nil=>λ_,Unit|i::_=>λ'(x,s),Pix∧for_all_family_prodFPsend.for_all_2_family_prodFGR(x1,...,xn,tt)(y1,...,yn,tt)=TrueifRi1x1y1∧Ri2x2y2∧...∧Pinxnynholds.Fixpointfor_all_2_family_prod(FG:I→Type) {ℓ:listI}(R: ∀i,Fi->Gi->Type):FamilyProdFℓ→FamilyProdGℓ→Type:=matchℓwith|nil=>λ__,Unit|i::_=>λ'(x,s) '(y,t),Rixy∧for_all_2_family_prodFGRstend.IfR:∀i,relation(Fi)is a family of relations indexed byi:IandRiis reflexive for alli, thenfor_all_2_family_prod F F R s sholds.Lemmareflexive_for_all_2_family_prod(F:I→Type)(R: ∀i,Relation(Fi)) `{!∀i,Reflexive(Ri)}{ℓ:listI} (s:FamilyProdFℓ):for_all_2_family_prodFFRss.Proofwithtryreflexivity.inductionℓ...split...applyIHℓ.Defined.Endfamily_prod.

--- Miscellaneous\fields.html ---
fieldsLibrary fieldsRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.theory.apartness.RequireExportHoTT.Classes.theory.rings.Generalizable VariablesFf.Sectionfield_properties.Context`{IsFieldF}.Definitionrecip'(x:F) (apx:x≶ 0) :F:= //(x;apx).(* Add Ring F : (stdlib_ring_theory F). *)Lemmarecip_inverse'(x:F) (Px:x≶ 0) :x// (x;Px) = 1.Proof.apply(recip_inverse(x;Px)).Qed.Lemmareciperse_alt(x:F)Px:x// (x;Px) = 1.Proof.rewrite<-(recip_inverse(x;Px)).trivial.Qed.Lemmarecip_proper_altxyPxPy:x=y-> // (x;Px) = // (y;Py).Proof.introE.applyap.applySigma.path_sigmawithE.applypath_ishprop.Qed.Lemmarecip_properxyPy:x// (y;Py) = 1 ->x=y.Proof.introseqxy.rewrite<- (mult_1_ry).rewrite<-eqxy.rewrite(mult_assocyx(//(y;Py))).rewrite(mult_commyx).rewrite<- (mult_assocxy(//(y;Py))).rewrite(recip_inverse(y;Py)).rewrite(mult_1_rx).reflexivity.Qed.Lemmarecip_irrelevantxPx1Px2: // (x;Px1) = // (x;Px2).Proof.applyrecip_proper_alt.reflexivity.Qed.Lemmaapart_0_proper{xy} :x≶ 0 ->x=y->y≶ 0.Proof.intros?E.rewrite<-E.trivial.Qed.Global Instance:IsStrongInjective(-).Proof.repeat(split;tryapply_);introsxyE.-apply(strong_extensionality(+x+y)).rewritesimple_associativity,left_inverse,plus_0_l.rewrite(commutativity(f:=plus)xy),simple_associativity,left_inverse,plus_0_l.applysymmetry;trivial.-apply(strong_extensionality(+ -x+ -y)).rewritesimple_associativity,right_inverse,plus_0_l.rewrite(commutativity(f:=plus) (-x) (-y)),simple_associativity,right_inverse,plus_0_l.applysymmetry;trivial.Qed.Global Instance:IsStrongInjective(//).Proof.repeat(split;tryapply_);introsxyE.-apply(strong_extensionality(x.1 *.)).rewriterecip_inverse, (commutativity(f:=mult)).apply(strong_extensionality(y.1 *.)).rewritesimple_associativity,recip_inverse.rewritemult_1_l,mult_1_r.applysymmetry;trivial.-apply(strong_extensionality(.* //x)).rewriterecip_inverse, (commutativity(f:=mult)).apply(strong_extensionality(.* //y)).rewrite<-simple_associativity,recip_inverse.rewritemult_1_l,mult_1_r.applysymmetry;trivial.Qed.Global Instance:forallz,StrongLeftCancellation(+)z.Proof.introszxyE.apply(strong_extensionality(+ -z)).do2rewrite(commutativity(f:=plus)z_),<-simple_associativity,right_inverse,plus_0_r.trivial.Qed.Global Instance:forallz,StrongRightCancellation(+)z.Proof.intros.apply(strong_right_cancel_from_left(+)).Qed.Global Instance:forallz,PropHolds(z≶ 0) ->StrongLeftCancellation(.*.)z.Proof.introszEzxyE.redinEz.rewrite!(commutativityz).apply(strong_extensionality(.* // (z;(Ez: (≶0)z)))).rewrite<-!simple_associativity, !reciperse_alt.rewrite!mult_1_r;trivial.Qed.Global Instance:forallz,PropHolds(z≶ 0) ->StrongRightCancellation(.*.)z.Proof.intros.apply(strong_right_cancel_from_left(.*.)).Qed.Lemmamult_apart_zero_lxy:x*y≶ 0 ->x≶ 0.Proof.intros.apply(strong_extensionality(.*y)).rewritemult_0_l.trivial.Qed.Lemmamult_apart_zero_rxy:x*y≶ 0 ->y≶ 0.Proof.intros.apply(strong_extensionality(x*.)).rewritemult_0_r.trivial.Qed.Instancemult_apart_zeroxy:PropHolds(x≶ 0) ->PropHolds(y≶ 0) ->PropHolds(x*y≶ 0).Proof.introsExEy.apply(strong_extensionality(.* // (y;(Ey: (≶0)y)))).rewrite<-simple_associativity,reciperse_alt,mult_1_r,mult_0_l.trivial.Qed.Instance:NoZeroDivisorsF.Proof.introsx[x_nonzero[y[y_nonzeroE]]].assert(~ ~aparty0)asEy.-introsE';applyy_nonzero,tight_apart,E'.-applyEy.introy_apartzero.applyx_nonzero.rewrite<- (mult_1_rx).rewrite<- (reciperse_altyy_apartzero).rewritesimple_associativity,E.applymult_0_l.Qed.Global Instance:IsIntegralDomainF:= {}.Global Instanceapart_0_sig_apart_0:forall(x:ApartZeroF),PropHolds(x.1 ≶ 0).Proof.intros[??];trivial.Qed.Instancerecip_apart_zerox:PropHolds(//x≶ 0).Proof.red.applymult_apart_zero_rwith(x.1).rewriterecip_inverse.solve_propholds.Qed.Lemmafield_div_0_lxy:x= 0 ->x//y= 0.Proof.introsE.rewriteE.applyleft_absorb.Qed.Lemmafield_div_diagxy:x=y.1 ->x//y= 1.Proof.introsE.rewriteE.applyrecip_inverse.Qed.Lemmaequal_quotients(ac:F)bd:a*d.1 =c*b.1 <->a//b=c//d.Proof.split;introE.-rewrite<-(mult_1_l(a//b)),<- (recip_inversed),(commutativity(f:=mult)d.1 (//d)),<-simple_associativity,(simple_associativityd.1),(commutativity(f:=mult)d.1a),E,<-simple_associativity,simple_associativity,recip_inverse,mult_1_r.applycommutativity.-rewrite<-(mult_1_r(a*d.1)),<- (recip_inverseb),<-simple_associativity,(commutativity(f:=mult)b.1 (//b)),(simple_associativityd.1),(commutativity(f:=mult)d.1),!simple_associativity,E,<-(simple_associativityc),(commutativity(f:=mult) (//d)),recip_inverse,mult_1_r.reflexivity.Qed.Lemmarecip_distr_alt(xy:F)PxPyPxy:// (x*y;Pxy) = // (x;Px) * // (y;Py).Proof.apply(left_cancellation_ne_0(.*.) (x*y)).-applyapart_ne;trivial.-transitivity((x// (x;Px)) *  (y// (y;Py))).+rewrite3!reciperse_alt,mult_1_r.reflexivity.+rewrite<-simple_associativity,<-simple_associativity.applyap.rewritesimple_associativity.rewrite(commutativity(f:=mult)_y).rewrite<-simple_associativity.reflexivity.Qed.Lemmaapart_negate(x:F) (Px:x≶ 0) : (-x) ≶ 0.Proof.(* Have: x <> 0 *)(* Want to show: -x <> 0 *)(* Since x=x+0 <> 0=x-x, have x<>x or 0<>-x *)assert(ap:x+ 0 ≶x-x).{rewrite(plus_0_rx).rewrite(plus_negate_rx).assumption.}refine(Trunc_rec_(field_plus_extFx0x(-x)ap)).intros[apxx|ap0x].-destruct(apart_nexxapxx);reflexivity.-symmetry;assumption.Qed.Definitionnegate_apart:ApartZeroF->ApartZeroF.Proof.intros[xPx].exists(-x).exact((apart_negatexPx)).Defined.Lemmarecip_negate(x:F) (Px:x≶ 0) : (-//(x;Px))=//(negate_apart(x;Px)).Proof.apply(left_cancellation(.*.)x).rewrite<-negate_mult_distr_r.rewritereciperse_alt.applyflip_negate.rewritenegate_mult_distr_l.refine(_^).applyreciperse_alt.Qed.Lemmarecip_apart(x:F) (Px:x≶ 0) : // (x;Px) ≶ 0.Proof.apply(strong_extensionality(x*.) (// (x;Px)) 0).rewrite(recip_inverse(x;Px)).rewritemult_0_r.solve_propholds.Qed.Definitionrecip_on_apart(x:ApartZeroF) :ApartZeroF.Proof.exists(//x).applyrecip_apart.Defined.Global Instancerecip_involutive:Involutiverecip_on_apart.Proof.intros[xapx0].applypath_sigma_hprop.unfoldrecip_on_apart.cbn.apply(left_cancellation(.*.) (// (x;apx0))).rewrite(recip_inverse'(// (x;apx0)) (recip_apartxapx0)).rewritemult_comm.rewrite(recip_inverse(x;apx0)).reflexivity.Qed.Endfield_properties.(* Due to bug 2528 *)#[export]HintExtern8 (PropHolds(//_≶ 0)) =>eapply@recip_apart_zero:typeclass_instances.#[export]HintExtern8 (PropHolds(_*_≶ 0)) =>eapply@mult_apart_zero:typeclass_instances.Sectionmorphisms.Context`{IsFieldF1} `{IsFieldF2} `{!IsSemiRingStrongPreserving(f:F1->F2)}.(*   Add Ring F1 : (stdlib_ring_theory F1). *)Lemmastrong_injective_preserves_0: (forallx,x≶ 0 ->fx≶ 0) ->IsStrongInjectivef.Proof.introsE1.split;tryapply_.introsxyE2.apply(strong_extensionality(+ -fy)).rewriteplus_negate_r, <-preserves_minus.applyE1.apply(strong_extensionality(+y)).rewrite<-simple_associativity,left_inverse,plus_0_l,plus_0_r.trivial.Qed.(* We have the following for morphisms to non-trivial strong rings as well.However, since we do not have an interface for strong rings, we ignore it. *)Global Instance:IsStrongInjectivef.Proof.applystrong_injective_preserves_0.introsxEx.applymult_apart_zero_lwith(f(//exist(≶0)xEx)).rewrite<-rings.preserves_mult.rewritereciperse_alt.rewrite(rings.preserves_1(f:=f)).solve_propholds.Qed.Lemmapreserves_recipxPxPfx:f(// (x;Px)) = // (fx;Pfx).Proof.apply(left_cancellation_ne_0(.*.) (fx)).-applyapart_ne;trivial.-rewrite<-rings.preserves_mult.rewrite!reciperse_alt.applypreserves_1.Qed.Endmorphisms.

--- Miscellaneous\field_of_fractions.html ---
field_of_fractionsLibrary field_of_fractionsRequireImportHoTT.HIT.quotient.RequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.theory.dec_fields.ModuleFrac.Sectioncontents.UniverseUR.Context`{Funext} `{Univalence} (R:Type@{UR})`{IsIntegralDomainR} `{DecidablePathsR}.RecordFrac@{} :Type:=frac{num:R;den:R;den_ne_0:PropHolds(den<> 0) }.(* We used to havedenandden_nonzerobundled,which did work relatively nicely with Program, but theextra messyness in proofs etc turned out not to be worth it. *)LemmaFrac_ishset':IsHSetFrac.Proof.assert(E:sig(funn:R=>sig(fund:R=>d<> 0 )) <~>Frac).-issig.-apply(istrunc_equiv_istrunc_E).Qed.Global InstanceFrac_ishset@{} :IsHSetFrac:=ltac:(first[exactFrac_ishset'@{URUlargeSet}|exactFrac_ishset'@{}]).Local Existing Instanceden_ne_0.Global InstanceFrac_inject@{} :CastRFrac.Proof.introsx.apply(fracx1_).Defined.Global InstanceFrac_0@{} :ZeroFrac:= ('0 :Frac).Global InstanceFrac_1@{} :OneFrac:= ('1 :Frac).Instancepl@{} :PlusFrac.Proof.introsqr;refine(frac(numq*denr+numr*denq) (denq*denr)_).Defined.Definitionequiv@{} :=funxy=>numx*deny=numy*denx.Global Instanceequiv_equiv_rel@{} :EquivRelequiv.Proof.split.-introsx.hnf.reflexivity.-introsxy.unfoldequiv.applysymmetry.-introsxyz.unfoldequiv.introsE1E2.apply(mult_left_cancel(deny)).+solve_propholds.+rewrite!mult_assoc, !(mult_comm(deny)).rewriteE1, <-E2.rewrite<-!mult_assoc.rewrite(mult_comm(denx)).reflexivity.Qed.Global Instanceequiv_dec@{} :forallxy:Frac,Decidable(equivxy):=funxy=>decide_rel(=) (numx*deny) (numy*denx).Lemmapl_respect@{} :forallq1q2,equivq1q2->forallr1r2,equivr1r2->equiv(q1+r1) (q2+r2).Proof.unfoldequiv;introsq1q2Eqr1r2Er.simpl.rewriteplus_mult_distr_r.rewrite<-(associativity(numq1) (denr1)).rewrite(associativity(denr1)), (mult_comm(denr1)), <-(associativity(denq2)).rewrite(associativity(numq1)),Eq.rewrite(mult_comm(denq2)), <-(associativity(numr1)), (associativity(denq1)).rewrite(mult_comm(denq1)), <-(associativity(denr2)), (associativity(numr1)).rewriteEr.rewrite(mult_comm(denr1)), <-(associativity(numq2)), (associativity(denq1)).rewrite(mult_comm(denq1)), <-(associativity(denr2)), (associativity(numq2)).rewrite<-(associativity(numr2)), (associativity(denr1)),(mult_comm_(denq2)).rewrite(mult_comm(denr1)), (associativity(numr2)).applysymmetry;applyplus_mult_distr_r.Qed.Lemmapl_comm@{} :forallqr,equiv(plqr) (plrq).Proof.introsqr;unfoldequiv;simpl.rewrite(mult_comm(denr)),plus_comm.reflexivity.Qed.Lemmapl_assoc@{} :forallqrt,equiv(plq(plrt)) (pl(plqr)t).Proof.intros;unfoldequiv;simpl.applyap011;[|applysymmetry,associativity].rewriteplus_mult_distr_r.rewrite(plus_mult_distr_r__(dent)).rewriteplus_assoc.applyap011;[applyap011|].-applyassociativity.-rewrite<-(associativity(numr)), <-(associativity(numr) (denq)).rewrite(mult_comm(dent)).reflexivity.-rewrite(mult_comm(denq));applysymmetry,associativity.Qed.Instanceml@{} :MultFrac.Proof.introsqr;refine(frac(numq*numr) (denq*denr)_).Defined.Lemmaml_respect@{} :forallq1q2,equivq1q2->forallr1r2,equivr1r2->equiv(q1*r1) (q2*r2).Proof.unfoldequiv;introsq1q2Eqr1r2Er.simpl.rewrite<-(associativity(numq1)), (associativity(numr1)).rewrite(mult_comm(numr1)), <-(associativity(denq2)), (associativity(numq1)).rewriteEq,Er.rewrite<-(associativity(numq2)), (associativity(denq1)), (mult_comm(denq1)).rewrite<-(simple_associativity(numr2)), <-(simple_associativity(numq2)).reflexivity.Qed.Instanceneg@{} :NegateFrac.Proof.introsq;refine(frac(-numq) (denq)_).Defined.Lemmaneg_respect@{} :forallqr,equivqr->equiv(-q) (-r).Proof.unfoldequiv;simpl;introsqrE.rewrite<-2!negate_mult_distr_l.rewriteE;reflexivity.Qed.Lemmanonzero_num@{}x: ~ (equivx0) <->numx<> 0.Proof.split;introsEF;applyE.-red.rewriteF.simpl.rewrite2!mult_0_l.reflexivity.-redinF;simplinF.rewritemult_1_r,mult_0_linF.trivial.Qed.Lemmapl_0_l@{}x:equiv(0 +x)x.Proof.red;simpl.rewritemult_1_r,mult_0_l,mult_1_l,plus_0_l.reflexivity.Qed.Lemmapl_0_r@{}x:equiv(x+ 0)x.Proof.red;simpl.rewrite2!mult_1_r,mult_0_l,plus_0_r.reflexivity.Qed.Lemmapl_neg_l@{}x:equiv(-x+x) 0.Proof.red;simpl.rewritemult_1_r,mult_0_l.rewrite<-plus_mult_distr_r.rewriteplus_negate_l.applymult_0_l.Qed.Lemmaml_assoc@{}qrt:equiv(mlq(mlrt)) (ml(mlqr)t).Proof.red;simpl.rewrite(associativity(numq)), (associativity(denq)).reflexivity.Qed.Instancedec_rec@{} :DecRecipFrac:=funx=>matchdecide_rel(=) (numx) 0with|inl_=> 0|inrP=>frac(denx) (numx)Pend.Lemmadec_recip_respect@{} :forallqr,equivqr->equiv(/q) (/r).Proof.unfoldequiv,dec_recip,dec_rec;introsqrE;simpl.destruct(decide_relpaths(numq) 0)as[E1|E1],(decide_relpaths(numr) 0)as[E2|E2];simpl.-trivial.-rewriteE1inE;rewritemult_0_linE.destructE2.apply(right_cancellation_ne_0mult(denq));trysolve_propholds.rewritemult_0_l;applysymmetry,E.-rewriteE2inE;rewritemult_0_linE.destructE1.apply(right_cancellation_ne_0mult(denr));trysolve_propholds.rewritemult_0_l;trivial.-rewrite(mult_comm(denq)), (mult_comm(denr)).applysymmetry,E.Qed.Endcontents.ArgumentsFracR{Rzero} :rename.Argumentsfrac{RRzero}___:rename.Argumentsnum{RRzero}_:rename.Argumentsden{RRzero}_:rename.Argumentsden_ne_0{RRzero}__:rename.Argumentsequiv{R__}__.Sectionmorphisms.Context{R1} `{IsIntegralDomainR1} `{DecidablePathsR1}.Context{R2} `{IsIntegralDomainR2} `{DecidablePathsR2}.Context`(f:R1->R2) `{!IsSemiRingPreservingf} `{!IsInjectivef}.Definitionlift(x:FracR1) :FracR2.Proof.apply(frac(f(numx)) (f(denx))).applyisinjective_ne_0.apply(den_ne_0x).Defined.Lemmalift_respects:forallqr,equivqr->equiv(liftq) (liftr).Proof.unfoldequiv;simpl;introsqrE.rewrite<-2!preserves_mult.applyap,E.Qed.Endmorphisms.EndFrac.ImportFrac.ModuleFracField.Sectioncontents.(* NB: we need a separate IsHSet instanceso we don't need to depend on everything to define F. *)UniverseUR.Context`{Funext} `{Univalence} {R:Type@{UR} } `{IsHSetR} `{IsIntegralDomainR}`{DecidablePathsR}.Local Existing Instanceden_ne_0.(* Add Ring R: (stdlib_ring_theory R). *)DefinitionF@{} :=quotientequiv.Global Instanceclass@{} :Cast(FracR)F:=class_of_.(* injection from R *)Global Instanceinject@{} :CastRF:=Composeclass(Frac_inject_).Definitionpath@{} {xy} :equivxy-> 'x= 'y:=related_classes_eq_.DefinitionF_rect@{i} (P:F->Type@{i}) {sP:forallx,IsHSet(Px)}(dclass:forallx:FracR,P('x))(dequiv:forallxyE, (pathE) # (dclassx) = (dclassy)):forallq,Pq:=quotient_indequivPdclassdequiv.DefinitionF_computeP{sP}dclassdequivx: @F_rectPsPdclassdequiv('x) =dclassx:= 1.DefinitionF_compute_pathP{sP}dclassdequivqr(E:equivqr):apD(@F_rectPsPdclassdequiv) (pathE) =dequivqrE:=quotient_ind_compute_path________.DefinitionF_ind@{i} (P:F->Type@{i}) {sP:forallx,IsHProp(Px)}(dclass:forallx:FracR,P('x)) :forallx,Px.Proof.apply(@F_rectP(fun_=>istrunc_hprop)dclass).intros;applypath_ishprop.Qed.DefinitionF_ind2@{ij} (P:F->F->Type@{i}) {sP:forallxy,IsHProp(Pxy)}(dclass:forallxy:FracR,P('x) ('y)) :forallxy,Pxy.Proof.apply(@F_ind(funx=>forally,_)).-intros;applyistrunc_forall@{URij}.-introsx.apply(F_ind_);introsy.applydclass.Qed.DefinitionF_ind3@{ij} (P:F->F->F->Type@{i}){sP:forallxyz,IsHProp(Pxyz)}(dclass:forallxyz:FracR,P('x) ('y) ('z)):forallxyz,Pxyz.Proof.apply(@F_ind(funx=>forallyz,_)).-intros;applyistrunc_forall@{URjj}.-introsx.apply(F_ind2@{ij}_).auto.Qed.DefinitionF_rec@{i} {T:Type@{i} } {sT:IsHSetT}:forall(dclass:FracR->T)(dequiv:forallxy,equivxy->dclassx=dclassy),F->T:=quotient_recequiv.DefinitionF_rec_computeTsTdclassdequivx: @F_recTsTdclassdequiv('x) =dclassx:= 1.DefinitionF_rec2@{ij} {T:Type@{i} } {sT:IsHSetT}:forall(dclass:FracR->FracR->T)(dequiv:forallx1x2,equivx1x2->forally1y2,equivy1y2->dclassx1y1=dclassx2y2),F->F->T:= @quotient_rec2@{URURURji}_____(Build_HSet_).DefinitionF_rec2_compute{TsT}dclassdequivxy: @F_rec2TsTdclassdequiv('x) ('y) =dclassxy:= 1.(* Relations, operations and constants *)Global InstanceF0@{} :ZeroF:= ('0 :F).Global InstanceF1@{} :OneF:= ('1 :F).Global InstanceFplus@{} :PlusF.Proof.refine(F_rec2(funxy=> ' (Frac.pl_xy))_).intros.applypath.applyFrac.pl_respect;trivial.Defined.DefinitionFplus_compute@{}qr: ('q) + ('r) = ' (Frac.pl_qr):= 1.Global InstanceFneg@{} :NegateF.Proof.refine(F_rec(funx=> ' (Frac.neg_x))_).intros;applypath;eapplyFrac.neg_respect;tryapply_.trivial.Defined.DefinitionFneg_compute@{}q: - ('q) = ' (Frac.neg_q) := 1.Global InstanceFmult@{} :MultF.Proof.refine(F_rec2(funxy=> ' (Frac.ml_xy))_).intros.applypath.applyFrac.ml_respect;trivial.Defined.DefinitionFmult_compute@{}qr: ('q) * ('r) = ' (Frac.ml_qr):= 1.InstanceFmult_comm@{} :CommutativeFplus.Proof.hnf.apply(F_ind2_).intros;applypath,Frac.pl_comm.Qed.InstanceF_ring@{} :IsCRingF.Proof.repeatsplit;first[changesg_opwithmult;changemon_unitwith1|changesg_opwithplus;changemon_unitwith0].-apply_.-hnf.apply(F_ind3_).intros;applypath.applyFrac.pl_assoc.-hnf.apply(F_ind_).intros;applypath,Frac.pl_0_l.-hnf.apply(F_ind_).intros;applypath,Frac.pl_0_r.-hnf.apply(F_ind_).intros;applypath,Frac.pl_neg_l.-hnf;intros.rewrite(commutativity(f:=plus)).revertx;apply(F_ind_).intros;applypath,Frac.pl_neg_l.-apply_.-apply_.-hnf;apply(F_ind3_).intros;applypath,Frac.ml_assoc.-hnf.apply(F_ind_).intros;applypath.red;simpl.rewrite2!mult_1_l.reflexivity.-hnf.apply(F_ind_).intros;applypath.red;simpl.rewrite2!mult_1_r.reflexivity.-hnf;apply(F_ind2_).intros;applypath.red;simpl.rewrite(mult_comm(numy)), (mult_comm(deny)).reflexivity.-hnf.apply(F_ind3_).introsabc;applypath.red;simpl.rewrite<-!(mult_assoc(numa)).rewrite<-plus_mult_distr_l.rewrite<-(mult_assoc(numa)).applyap.rewrite(mult_comm(dena) (denc)), (mult_comm(dena) (denb)).rewrite(mult_assoc(numb)), (mult_assoc(numc)).rewrite<-plus_mult_distr_r.rewrite<-(mult_assoc_(dena) (dena*_)).applyap.rewrite(mult_comm(denb)), <-mult_assoc.applyap.rewrite(mult_comm(dena)).applyassociativity.Qed.Global InstanceFdec_rec@{} :DecRecipF.Proof.refine(F_rec(funx=> ' (Frac.dec_rec_x))_).intros.applypath.applyFrac.dec_recip_respect;trivial.Defined.Lemmaclasses_eq_related@{} :forallqr, 'q= 'r->equivqr.Proof.applyclasses_eq_related@{URURUlargeURUlarge};apply_.Qed.Lemmaclass_neq@{} :forallqr, ~ (equivqr) -> 'q<> 'r.Proof.introsqrE1E2;applyE1;applyclasses_eq_related,E2.Qed.Lemmaclasses_neq_related@{} :forallqr, 'q<> 'r-> ~ (equivqr).Proof.introsqrE1E2;applyE1,path,E2.Qed.Lemmadec_recip_0@{} : / 0 = 0.Proof.unfolddec_recip.simpl.unfoldFrac.dec_rec;simpl.destruct(decide_relpaths0 0)as[_|E].-reflexivity.-destructE;reflexivity.Qed.Lemmadec_recip_nonzero_aux@{} :forallq, 'q<> 0 ->numq<> 0.Proof.introsqE;applyclasses_neq_relatedinE.applyFrac.nonzero_numinE.trivial.Qed.Lemmadec_recip_nonzero@{} :forallq(E: 'q<> 0),/ ('q) = ' (frac(denq) (numq) (dec_recip_nonzero_auxqE)).Proof.intros.applypath.red;simpl.unfoldFrac.dec_rec.applyclasses_neq_related,Frac.nonzero_numinE.destruct(decide_relpaths(numq) 0)as[E'|?];[destructE;applyE'|].simpl.reflexivity.Qed.Global InstanceF_field@{} :IsDecFieldF.Proof.split;tryapply_.-red.applyclass_neq.unfoldequiv;simpl.rewrite2!mult_1_r.solve_propholds.-applydec_recip_0.-apply(F_ind(funx=>_->_)).introsxE.rewrite(dec_recip_nonzero_E).applypath;red;simpl.rewritemult_1_r,mult_1_l.applymult_comm.Qed.Lemmadec_class@{} :forallqr,Decidable(classq=classr).Proof.introsqr.destruct(dec(equivqr))as[E|E].-left.applypath,E.-right.introsE'.applyE.apply(classes_eq_related__E').Defined.Global InstanceF_dec@{} :DecidablePathsF.Proof.hnf.apply(F_ind2_).applydec_class.Qed.Lemmamult_num_den@{}q:'q= ('numq) / 'denq.Proof.applypath.red.simpl.rewritemult_1_l.unfoldFrac.dec_rec.simpl.destruct(decide_relpaths(denq) 0)as[E|E];simpl.-destruct(den_ne_0qE).-rewritemult_1_r.reflexivity.Qed.Lemmarecip_den_num@{}q:/ 'q= ('denq) / 'numq.Proof.applypath;red;simpl.unfoldFrac.dec_rec;simpl.destruct(decide_relpaths(numq) 0)as[E|E];simpl.-rewrite(mult_0_r(Azero:=Azero)), 2!mult_0_l.reflexivity.-rewritemult_1_l,mult_1_r.reflexivity.Qed.(* A final word about inject *)Global Instanceinject_sr_morphism@{} :IsSemiRingPreserving(castRF).Proof.repeat(split;tryapply_).-introsxy.applypath.change((x+y) * (1 * 1) = (x* 1 +y* 1) * 1).rewrite!mult_1_r.reflexivity.-introsxy.applypath.change((x*y) * (1 * 1) =x*y* 1).rewrite!mult_1_r.reflexivity.Qed.Global Instanceinject_injective@{} :IsInjective(castRF).Proof.repeat(split;tryapply_).introsxyE.applyclasses_eq_relatedinE.redinE.simplinE.rewrite2!mult_1_rinE;trivial.Qed.Endcontents.ArgumentsFR{___}.ModuleLift.Sectionmorphisms.UniverseUR1UR2.Context`{Funext} `{Univalence}.Context{R1:Type@{UR1} } `{IsIntegralDomainR1} `{DecidablePathsR1}.Context{R2:Type@{UR2} } `{IsIntegralDomainR2} `{DecidablePathsR2}.Context`(f:R1->R2) `{!IsSemiRingPreservingf} `{!IsInjectivef}.Definitionlift@{} :FR1->FR2.Proof.apply(F_rec(funx=>class(Frac.liftfx))).intros;applypath,Frac.lift_respects;trivial.Defined.Global Instancelift_sr_morphism@{i} :IsSemiRingPreservinglift.Proof.(* This takes a few seconds. *)split;split;red.-apply(F_ind2@{UR1UR2i}_).intros;simpl.apply@path.(* very slow or doesn't terminate without the @ but fast with it *)red;simpl.repeat(rewrite<-(preserves_mult(f:=f)) ||rewrite<-(preserves_plus(f:=f))).reflexivity.-simpl.applypath.red;simpl.rewrite(preserves_0(f:=f)).rewrite2!mult_0_l.reflexivity.-apply(F_ind2@{UR1UR2i}_).intros;simpl.apply@path.red;simpl.rewrite<-!(preserves_mult(f:=f)).reflexivity.-simpl.applypath.red;simpl.applycommutativity.Qed.Global Instancelift_injective@{i} :IsInjectivelift.Proof.red.apply(F_ind2@{UR1ii} (fun__=>_->_)).introsxyE.simplinE.applyclasses_eq_relatedinE.redinE;simplinE.applypath.red.apply(injectivef).rewrite2!(preserves_mult(f:=f)).applyE.Qed.Endmorphisms.EndLift.EndFracField.

--- Miscellaneous\Fin.html ---
FinLibrary FinRequireImportBasics.RequireImportTypes.RequireImportHSet.RequireImportSpaces.Nat.Core.RequireImportEquiv.PathSplit.By setting this, usingsimple_inductioninstead ofinduction, and specifying universe variables in a couple of places, we can avoid all universe variables in this file.  Several results are confirmed to use no universe variables with an @{} annotation.LocalSetUniverseMinimizationToSet.Local OpenScopepath_scope.Local OpenScopenat_scope.Finite setsCanonical finite setsA *finite set* is a type that is merely equivalent to the canonical finite set determined by some natural number.  There are many equivalent ways to define the canonical finite sets, such as{k:nat&k<n}; we instead choose a recursive one.FixpointFin(n:nat) :Type0:=matchnwith| 0 =>Empty|Sn=>Finn+Unitend.Fixpointfin_to_nat{n} :Finn->nat:=matchnwith| 0 =>Empty_rec|Sn'=>funk=>matchkwith|inlk'=>fin_to_natk'|inrtt=>n'endend.Global Instancedecidable_fin(n:nat):Decidable(Finn).Proof.destructnas[|n];tryexact_.exact(inl(inrtt)).Defined.Global Instancedecidablepaths_fin@{} (n:nat):DecidablePaths(Finn).Proof.simple_inductionnnIHn;simpl;exact_.Defined.Global Instancecontr_fin1:Contr(Fin1).Proof.refine(contr_equiv'Unit(sum_empty_lUnit)^-1).Defined.Definitionfin_empty(n:nat) (f:Finn->Empty) :n= 0.Proof.destructn; [reflexivity| ].elim(f(inrtt)).Defined.The zeroth element of a non-empty finite set is the left most element. It also happens to be the biggest by termsize.Fixpointfin_zero{n:nat} :Finn.+1 :=matchnwith|O=>inrtt|S_=>inlfin_zeroend.Where `fin_zero` computes the first element of Fin (S n), `fin_last` computes the last.Definitionfin_last{n:nat} :Fin(Sn) :=inrtt.Injection Fin n -> Fin n.+1 mapping the kth element to the kth element.Definitionfin_incl{n:nat} (k:Finn) :Fin(Sn) :=inlk.There is an injection from Fin n -> Fin n.+1 that maps the kth element to the (k+1)th element.Fixpointfsucc{n:nat} :Finn->Finn.+1 :=matchnwith|O=>Empty_rec|Sn'=>funi:Fin(Sn') =>matchiwith|inli'=>inl(fsucci')|inrtt=>inrttendend.This injection is an injection/embeddingLemmaisembedding_fsucc@{} {n:nat} :IsEmbedding(@fsuccn).Proof.applyisembedding_isinj_hset.simple_inductionnnIHn.-introi.elimi.-intros[] [];introp.+f_ap.applyIHn.eapplypath_sum_inl.exactp.+destructu.elim(inl_ne_inr__p).+destructu.elim(inr_ne_inl__p).+destructu,u0;reflexivity.Defined.Lemmapath_fin_fsucc_incl{n:nat} :forallk:Finn,fsucc(fin_inclk) =fin_incl(fsucck).Proof.trivial.Defined.Definitionpath_nat_fin_incl{n:nat} (k:Finn):fin_to_nat(fin_inclk) =fin_to_natk:= 1.Lemmapath_nat_fsucc@{} {n:nat} :forallk:Finn,fin_to_nat(fsucck) =S(fin_to_natk).Proof.simple_inductionnnIHn.-intros[].-intros[k'|[]].+rewritepath_fin_fsucc_incl,path_nat_fin_incl.applyIHn.+reflexivity.Defined.Lemmapath_nat_fin_zero@{} {n} :fin_to_nat(@fin_zeron) = 0.Proof.simple_inductionnnIHn.-reflexivity.-trivial.Defined.Definitionpath_nat_fin_last{n} :fin_to_nat(@fin_lastn) =n:= 1.Transposition equivalencesTo prove some basic facts about canonical finite sets, we need some standard automorphisms of them.  Here we define some transpositions and prove that they in fact do the desired things.Swap the last two elements.Definitionfin_transpose_last_two(n:nat):Finn.+2 <~>Finn.+2:= ((equiv_sum_assoc___)^-1)oE(1 +E(equiv_sum_symm__))oE(equiv_sum_assoc___).Argumentsfin_transpose_last_two:simplnomatch.Definitionfin_transpose_last_two_last(n:nat):fin_transpose_last_twon(inrtt) = (inl(inrtt)):= 1.Definitionfin_transpose_last_two_nextlast(n:nat):fin_transpose_last_twon(inl(inrtt)) = (inrtt):= 1.Definitionfin_transpose_last_two_rest(n:nat) (k:Finn):fin_transpose_last_twon(inl(inlk)) = (inl(inlk)):= 1.Swap the last element withk.Fixpointfin_transpose_last_with(n:nat) (k:Finn.+1):Finn.+1 <~>Finn.+1.Proof.destructkas[k|].-destructnas[|n].+elimk.+destructkas[k|].*refine((fin_transpose_last_twon)oE_oE(fin_transpose_last_twon)).refine((fin_transpose_last_withn(inlk)) +E1).*applyfin_transpose_last_two.-exact(equiv_idmap_).Defined.Argumentsfin_transpose_last_with:simplnomatch.Definitionfin_transpose_last_with_last@{} (n:nat) (k:Finn.+1):fin_transpose_last_withnk(inrtt) =k.Proof.destructkas[k|].-simple_inductionnnIHn;introk;simpl.+elimk.+destructkas[k|].*simpl.rewriteIHn;reflexivity.*simpl.applyap,ap,path_contr.-We have to destructnsince fixpoints don't reduce unless their argument is a constructor.destructn;simpl.all:applyap,path_contr.Qed.Definitionfin_transpose_last_with_with@{} (n:nat) (k:Finn.+1):fin_transpose_last_withnkk=inrtt.Proof.destructkas[k|].-simple_inductionnnIHn;introk;simpl.+elimk.+destructkas[|k];simpl.*rewriteIHn;reflexivity.*applyap,path_contr.-destructn;simpl.all:applyap,path_contr.Qed.Definitionfin_transpose_last_with_rest@{} (n:nat)(k:Finn.+1) (l:Finn)(notk:k<>inll):fin_transpose_last_withnk(inll) = (inll).Proof.destructkas[k|].-simple_inductionnnIHn;introsklnotk;simpl.1:elimk.destructkas[k|];simpl.{destructlas[l|];simpl.-rewriteIHn.+reflexivity.+exact(funp=>notk(apinlp)).-reflexivity. }{destructlas[l|];simpl.-reflexivity.-elim(notk(apinl(apinr(path_unit__)))). }-destructn;reflexivity.Defined.Definitionfin_transpose_last_with_last_other(n:nat) (k:Finn.+1):fin_transpose_last_withn(inrtt)k=k.Proof.destructn;reflexivity.Defined.Definitionfin_transpose_last_with_invol(n:nat) (k:Finn.+1):fin_transpose_last_withnkofin_transpose_last_withnk==idmap.Proof.introsl.destructlas[l|[]].-destructkas[k|[]].{destruct(dec_pathskl)as[p|p].-rewritep.rewritefin_transpose_last_with_with.applyfin_transpose_last_with_last.-rewritefin_transpose_last_with_rest;tryapplyfin_transpose_last_with_rest;exact(funq=>p(path_sum_inl_q)). }+rewritefin_transpose_last_with_last_other.applyfin_transpose_last_with_last_other.-rewritefin_transpose_last_with_last.applyfin_transpose_last_with_with.Defined.Equivalences between canonical finite setsTo give an equivalenceFinn.+1<~>Finm.+1is equivalent to giving an element ofFinm.+1(the image of the last element) together with an equivalenceFinn<~>Finm.  More specifically, any such equivalence can be decomposed uniquely as a last-element transposition followed by an equivalence fixing the last element.Here is the uncurried map that constructs an equivalenceFinn.+1<~>Finm.+1.Definitionfin_equiv(nm:nat)(k:Finm.+1) (e:Finn<~>Finm):Finn.+1 <~>Finm.+1:= (fin_transpose_last_withmk)oE(e+E1).Here is the curried version that we will prove to be an equivalence.Definitionfin_equiv'(nm:nat): ((Finm.+1) * (Finn<~>Finm)) -> (Finn.+1 <~>Finm.+1):=funke=>fin_equivnm(fstke) (sndke).We construct its inverse and the two homotopies first as versions using homotopies without funext (similar toExtendableAlong), then apply funext at the end.Definitionfin_equiv_hfiber@{} (nm:nat) (e:Finn.+1 <~>Finm.+1): {kf: (Finm.+1) * (Finn<~>Finm) &fin_equiv'nmkf==e}.Proof.simpline.refine(equiv_sigma_prod__).recall(e(inrtt))asyeqn:p.assert(p':= (moveL_equiv_V__p)^).existsy.destructyas[y|[]].+simplerefine(equiv_unfunctor_sum_l@{SetSetSetSetSetSet}(fin_transpose_last_withm(inly)oEe)__;_).{introsa.ev_equiv.assert(q:inly<>e(inla))byexact(funz=>inl_ne_inr__(equiv_inje(z^ @p^))).set(z:=e(inla))in*.destructzas[z|[]].-rewritefin_transpose_last_with_rest;tryexacttt;tryassumption.-rewritefin_transpose_last_with_last;exacttt. }{intros[].ev_equiv.rewritep.rewritefin_transpose_last_with_with;exacttt. }introsx.unfoldfst,snd;ev_equiv.simpl.destructxas[x|[]];simpl.*rewriteunfunctor_sum_l_beta.applyfin_transpose_last_with_invol.*refine(fin_transpose_last_with_last__@p^).+simplerefine(equiv_unfunctor_sum_l@{SetSetSetSetSetSet}e__;_).{introsa.destruct(is_inl_or_is_inr(e(inla)))as[l|r].-exactl.-assert(q:=inr_un_inr(e(inla))r).applymoveR_equiv_Vinq.assert(s:=q^ @ap(e^-1oinr) (path_unit__) @p').elim(inl_ne_inr__s). }{intros[];exact(p^ #tt). }introsx.unfoldfst,snd;ev_equiv.simpl.destructxas[a|[]].*rewritefin_transpose_last_with_last_other.applyunfunctor_sum_l_beta.*simpl.rewritefin_transpose_last_with_last.symmetry;applyp.Qed.Definitionfin_equiv_inv(nm:nat) (e:Finn.+1 <~>Finm.+1): (Finm.+1) * (Finn<~>Finm):= (fin_equiv_hfibernme).1.Definitionfin_equiv_issect(nm:nat) (e:Finn.+1 <~>Finm.+1):fin_equiv'nm(fin_equiv_invnme) ==e:= (fin_equiv_hfibernme).2.Definitionfin_equiv_inj_fst(nm:nat)(kl:Finm.+1) (ef:Finn<~>Finm): (fin_equivnmke==fin_equivnmlf) -> (k=l).Proof.introsp.refine(_@p(inrtt) @_);simpl;rewritefin_transpose_last_with_last;reflexivity.Qed.Definitionfin_equiv_inj_snd(nm:nat)(kl:Finm.+1) (ef:Finn<~>Finm): (fin_equivnmke==fin_equivnmlf) -> (e==f).Proof.introsp.introsx.assert(q:=p(inrtt));simplinq.rewrite!fin_transpose_last_with_lastinq.rewrite<-qinp;clearql.exact(path_sum_inl_(equiv_inj(fin_transpose_last_withmk) (p(inlx)))).Qed.Now it's time for funext.Global Instanceisequiv_fin_equiv`{Funext} (nm:nat):IsEquiv(fin_equiv'nm).Proof.refine(isequiv_pathsplit0_);split.-introse;exists(fin_equiv_invnme).applypath_equiv,path_arrow,fin_equiv_issect.-intros[ke] [lf];simpl.refine(_,fun__=>tt).introsp;refine(_;path_ishprop__).apply(apequiv_fun)inp.applyap10inp.applypath_prod'.+refine(fin_equiv_inj_fstnmklefp).+applypath_equiv,path_arrow.refine(fin_equiv_inj_sndnmklefp).Defined.Definitionequiv_fin_equiv`{Funext} (nm:nat): ((Finm.+1) * (Finn<~>Finm)) <~> (Finn.+1 <~>Finm.+1):=Build_Equiv__(fin_equiv'nm)_.In particular, this implies that if two canonical finite sets are equivalent, then their cardinalities are equal.Definitionnat_eq_fin_equiv(nm:nat): (Finn<~>Finm) -> (n=m).Proof.revertm;simple_inductionnnIHn;introm;simple_inductionmmIHm;introse.-exactidpath.-elim(e^-1 (inrtt)).-elim(e(inrtt)).-refine(apS(IHnm_)).exact(snd(fin_equiv_invnme)).Defined.Initial segments ofnatDefinitionnat_fin(n:nat) (k:Finn) :nat.Proof.simple_inductionnnnf;introk.-contradiction.-destructkas[k|_].+exact(nfk).+exactn.Defined.Definitionnat_fin_inl(n:nat) (k:Finn):nat_finn.+1 (inlk) =nat_finnk:= 1.Definitionnat_fin_compl(n:nat) (k:Finn) :nat.Proof.simple_inductionnnnfc;introk.-contradiction.-destructkas[k|_].+exact(nfck).+1.+exact0.Defined.Definitionnat_fin_compl_complnk: (nat_finnk+nat_fin_complnk).+1 =n.Proof.simple_inductionnnIHn;introk.-contradiction.-destructkas[k|?];simpl.+rewritenat_add_comm.specialize(IHnk).rewritenat_add_comminIHn.exact(apSIHn).+rewritenat_add_comm;reflexivity.Qed.fsucc_modis the successor function mod nDefinitionfsucc_mod@{} {n:nat} :Finn->Finn.Proof.destructn.1:exactidmap.intros[x|].-exact(fsuccx).-exactfin_zero.Defined.fsucc allows us to convert a natural number into an element of a finite set. This can be thought of as the modulo map.Fixpointfin_nat{n:nat} (m:nat) :Finn.+1:=matchmwith| 0 =>fin_zero|Sm=>fsucc_mod(fin_natm)end.The 1-dimensional version of Sperner's lemma says that given any finite sequence of decidable hProps, where the sequence starts with true and ends with false, we can find a point in the sequence where the sequence changes from true to false. This is like a discrete intermediate value theorem.Fixpointsperners_lemma_1d{n} :forall(f:Fin(n.+2) ->Type){dprop:foralli,Decidable(fi)}(left_true:ffin_zero)(right_false: ~ffin_last),{k:Finn.+1 &f(fin_inclk) /\ ~f(fsucck)}.Proof.intros???.destructnas[|n].-existsfin_zero.split;assumption.-destruct(dec(f(fin_inclfin_last)))as[prev_true|prev_false].+existsfin_last.split;assumption.+destruct(sperners_lemma_1d_(fofin_incl)_left_trueprev_false)as[k'[fleftfright]].exists(fin_inclk').split;assumption.Defined.

--- Miscellaneous\FinInduction.html ---
FinInductionLibrary FinInductionRequireImportHoTT.BasicsHoTT.TypesHoTT.Universes.HSetHoTT.Spaces.Nat.CoreHoTT.Spaces.Finite.FinNatHoTT.Spaces.Finite.Fin.Local OpenScopenat_scope.Definitionfin_ind(P:foralln:nat,Finn->Type)(z:foralln:nat,Pn.+1fin_zero)(s:forall(n:nat) (k:Finn),Pnk->Pn.+1 (fsucck)){n:nat} (k:Finn):Pnk.Proof.refine(transport(Pn) (path_fin_to_finnat_to_fink)_).refine(finnat_ind(funnu=>Pn(finnat_to_finu))___).-intro.applyz.-introsn'uc.refine((path_finnat_to_fin_succ_)^ #_).byapplys.Defined.Lemmafin_ind_beta_zero(P:foralln:nat,Finn->Type)(z:foralln:nat,Pn.+1fin_zero)(s:forall(n:nat) (k:Finn),Pnk->Pn.+1 (fsucck)) (n:nat):fin_indPzsfin_zero=zn.Proof.unfoldfin_ind.generalize(path_fin_to_finnat_to_fin(@fin_zeron)).induction(path_fin_to_finnat_fin_zeron)^.introp.destruct(hset_path21p).lhsnrapplytransport_1.nrapplyfinnat_ind_beta_zero.Defined.Lemmafin_ind_beta_fsucc(P:foralln:nat,Finn->Type)(z:foralln:nat,Pn.+1fin_zero)(s:forall(n:nat) (k:Finn),Pnk->Pn.+1 (fsucck)){n:nat} (k:Finn):fin_indPzs(fsucck) =snk(fin_indPzsk).Proof.unfoldfin_ind.generalize(path_fin_to_finnat_to_fin(fsucck)).induction(path_fin_to_finnat_fsucck)^.introp.refine(ap(transport(Pn.+1)p) (finnat_ind_beta_succ____) @_).generalizedependentp.induction(path_fin_to_finnat_to_fink).induction(path_fin_to_finnat_to_fink)^.introp.induction(hset_path2p(path_finnat_to_fin_succ(fin_to_finnatk))).applytransport_pV.Defined.Definitionfin_rec(B:nat->Type): (foralln:nat,Bn.+1) -> (forall(n:nat),Finn->Bn->Bn.+1) ->forall{n:nat},Finn->Bn:=fin_ind(funn_=>Bn).Lemmafin_rec_beta_zero(B:nat->Type)(z:foralln:nat,Bn.+1)(s:forall(n:nat) (k:Finn),Bn->Bn.+1) (n:nat):fin_recBzsfin_zero=zn.Proof.apply(fin_ind_beta_zero(funn_=>Bn)).Defined.Lemmafin_rec_beta_fsucc(B:nat->Type)(z:foralln:nat,Bn.+1)(s:forall(n:nat) (k:Finn),Bn->Bn.+1){n:nat} (k:Finn):fin_recBzs(fsucck) =snk(fin_recBzsk).Proof.apply(fin_ind_beta_fsucc(funn_=>Bn)).Defined.

--- Miscellaneous\Finite.html ---
FiniteLibrary FiniteRequireImportBasics.RequireImportTypes.RequireImportHSet.RequireImportSpaces.Nat.CoreSpaces.Nat.Factorial.RequireImportHFiber.RequireImportFactorization.RequireImportTruncations.RequireImportColimits.Quotient.RequireImportProjective.RequireImportFin.Local OpenScopepath_scope.Local OpenScopenat_scope.Definition of general finite setsClassFinite(X:Type) :={fcard:nat;merely_equiv_fin:merely(X<~>Finfcard) }.ArgumentsfcardX{_}.Argumentsmerely_equiv_finX{_}.Definitionissig_finiteX: {n:nat&merely(X<~>Finn) } <~>FiniteX.Proof.issig.Defined.Note that the sigma over cardinalities is not truncated.  Nevertheless, because canonical finite sets of different cardinalities are not isomorphic, being finite is still an hprop.  (Thus, we could have truncated the sigma and gotten an equivalent definition, but it would be less convenient to reason about.)Global Instanceishprop_finiteX:IsHProp(FiniteX).Proof.refine(istrunc_equiv_istrunc_(issig_finiteX)).applyishprop_sigma_disjoint;introsnmHnHm.strip_truncations.refine(nat_eq_fin_equivnm(HmoEHn^-1)).Defined.Preservation of finiteness by equivalencesDefinitionfinite_equivX{Y} (e:X->Y) `{IsEquivXYe}:FiniteX->FiniteY.Proof.intros?.refine(Build_FiniteY(fcardX)_).assert(f:=merely_equiv_finX);strip_truncations.applytr.exact(equiv_composefe^-1).Defined.Definitionfinite_equiv'X{Y} (e:X<~>Y):FiniteX->FiniteY:=finite_equivXe.Corollaryfinite_equiv_equivXY: (X<~>Y) -> (FiniteX<~>FiniteY).Proof.intros?;applyequiv_iff_hprop;applyfinite_equiv';[assumption|symmetry;assumption].Defined.Definitionfcard_equiv{XY} (e:X->Y) `{IsEquivXYe}`{FiniteX} `{FiniteY}:fcardX=fcardY.Proof.transitivity(@fcardY(finite_equivXe_)).-reflexivity.-exact(ap(@fcardY) (path_ishprop__)).Defined.Definitionfcard_equiv'{XY} (e:X<~>Y)`{FiniteX} `{FiniteY}:fcardX=fcardY:=fcard_equive.Simple examples of finite setsCanonical finite sets are finiteGlobal Instancefinite_finn:Finite(Finn):=Build_Finite_n(tr(equiv_idmap_)).This includes the empty set.Global Instancefinite_empty:FiniteEmpty:=finite_fin0.The unit type is finite, since it's equivalent toFin1.Global Instancefinite_unit:FiniteUnit.Proof.refine(finite_equiv'(Fin1)__);simpl.applysum_empty_l.Defined.Thus, any contractible type is finite.Global Instancefinite_contrX`{ContrX} :FiniteX:=finite_equivUnitequiv_contr_unit^-1_.Any decidable hprop is finite, since it must be equivalent toEmptyorUnit.Definitionfinite_decidable_hpropX`{IsHPropX} `{DecidableX}:FiniteX.Proof.destruct(decX)as[x|nx].-assert(ContrX)byexact(contr_inhabited_hpropXx).exact_.-refine(finite_equivEmptynx^-1_).Defined.#[export]HintImmediatefinite_decidable_hprop:typeclass_instances.It follows that the propositional truncation of any finite set is finite.Global Instancefinite_merelyX{fX:FiniteX}:Finite(merelyX).Proof.As in decidable_finite_hprop, we case on cardinality first to avoid needing funext.destructfXas[[|n]e];refine(finite_decidable_hprop_).-right.introsx;strip_truncations;exact(ex).-left.strip_truncations;exact(tr(e^-1 (inrtt))).Defined.Finite sets are closed under path-spaces.Global Instancefinite_paths{X} `{FiniteX} (xy:X):Finite(x=y).Proof.If we assumeFunext, then typeclass inference produces this automatically, sinceXhas decidable equality and (hence) is a set, sox=yis a decidable hprop.  But we can also deduce it without funext, sinceFiniteis an hprop even without funext.assert(e:=merely_equiv_finX).strip_truncations.refine(finite_equiv_(ape)^-1_).applyfinite_decidable_hprop;exact_.Defined.Finite sets are also closed under successors.Global Instancefinite_succX`{FiniteX} :Finite(X+Unit).Proof.refine(Build_Finite_(fcardX).+1_).poseproof(merely_equiv_finX).strip_truncations;applytr.refine(_+E1);assumption.Defined.Definitionfcard_succX`{FiniteX}:fcard(X+Unit) = (fcardX).+1:= 1.DecidabilityLike canonical finite sets, finite sets have decidable equality.Global Instancedecidablepaths_finite`{Funext}X`{FiniteX}:DecidablePathsX.Proof.assert(e:=merely_equiv_finX).strip_truncations.refine(decidablepaths_equiv_e^-1_).Defined.However, contrary to what you might expect, we cannot assert that "every finite set is decidable"!  That would be claiming a *uniform* way to select an element from every nonempty finite set, which contradicts univalence.One thing we can prove is that any finite hprop is decidable.Global Instancedecidable_finite_hpropX`{IsHPropX} {fX:FiniteX}:DecidableX.Proof.To avoid having to useFunext, we case on the cardinality ofXbefore stripping the truncation from its equivalence toFinn; if we did things in the other order then we'd have to know thatDecidableXis an hprop, which requires funext.destructfXas[[|n]e].-right;introsx.strip_truncations;exact(ex).-left.strip_truncations;exact(e^-1 (inrtt)).Defined.It follows that ifXis finite, then its propositional truncation is decidable.Global Instancedecidable_merely_finiteX{fX:FiniteX}:Decidable(merelyX).Proof.exact_.Defined.From this, it follows that any finite set is *merely* decidable.Definitionmerely_decidable_finiteX`{FiniteX}:merely(DecidableX).Proof.applyO_decidable;exact_.Defined.Induction over finite setsMost concrete applications of this don't actually require univalence, but the general version does.  For this reason the general statement is less useful (and less used in the sequel) than it might be.Definitionfinite_ind_hprop`{Univalence}(P:forallX,FiniteX->Type)`{forallX(fX:FiniteX),IsHProp(PX_)}(f0:PEmpty_)(fs:forallX(fX:FiniteX),PX_->P(X+Unit)%type_)(X:Type) `{FiniteX}:PX_.Proof.assert(e:=merely_equiv_finX).strip_truncations.assert(p:=transportDFiniteP(path_universee^-1)_).refine(transport(PX) (path_ishprop__) (p_)).generalize(fcardX);introsn.inductionnas[|nIH].-exactf0.-refine(transport(P(Finn.+1)) (path_ishprop__) (fs__IH)).Defined.The finite axiom of choice, and projectivityDefinitionfinite_choice{X} `{FiniteX} :HasChoiceX.Proof.introsPoPf;clearoP.assert(e:=merely_equiv_finX).strip_truncations.set(P':=Poe^-1).assert(f':= (funx=>f(e^-1x)) :forallx,merely(P'x)).refine(Trunc_functor(X:=forallx:Fin(fcardX),P'x) (-1)__).-introsgx;exact(eissectex#g(ex)).-clearbodyP';clearfPe.generalizedependent(fcardX);introsnPf.inductionnas[|nIH].+exact(tr(Empty_indP)).+specialize(IH(Poinl) (foinl)).assert(e:=f(inrtt)).strip_truncations.exact(tr(sum_indPIH(Unit_inde))).Defined.Corollaryisprojective_fin_n(n:nat) :IsProjective(Finn).Proof.apply(iff_isoprojective_hasochoice_(Finn)).rapplyfinite_choice.Defined.Constructions on finite setsFinite sets are closed under sums, products, function spaces, and equivalence spaces.  There are multiple choices we could make regarding how to prove these facts.  Since we know what the cardinalities ought to be in all cases (since we know how to add, multiply, exponentiate, and take factorials of natural numbers), we could specify those off the bat, and then reduce to the case of canonical finite sets.  However, it's more amusing to instead prove finiteness of these constructions by "finite-set induction", and then *deduce* that their cardinalities are given by the corresponding operations on natural numbers (because they satisfy the same recurrences).Binary sumsGlobal Instancefinite_sumXY`{FiniteX} `{FiniteY}:Finite(X+Y).Proof.assert(e:=merely_equiv_finY).strip_truncations.refine(finite_equiv_(functor_sumidmape^-1)_).generalize(fcardY);introsn.inductionnas[|nIH].-refine(finite_equiv_(sum_empty_rX)^-1_).-refine(finite_equiv_(equiv_sum_assocX_Unit)_).Defined.Note that the cardinality functionfcardactually computes.  The same will be true of all the other proofs in this section, though we don't always verify it.Goalfcard(Fin3 +Fin4) = 7.reflexivity.Abort.Definitionfcard_sumXY`{FiniteX} `{FiniteY}:fcard(X+Y) = (fcardX+fcardY).Proof.refine(_@nat_add_comm__).assert(e:=merely_equiv_finY).strip_truncations.refine(fcard_equiv'(1 +Ee) @_).refine(_@ap(funy=> (y+fcardX)) (fcard_equive^-1)).generalize(fcardY);introsn.inductionnas[|nIH].-refine(fcard_equiv(sum_empty_rX)^-1).-refine(fcard_equiv(equiv_sum_assoc___)^-1 @_).exact(apSIH).Defined.Binary productsGlobal Instancefinite_prodXY`{FiniteX} `{FiniteY}:Finite(X*Y).Proof.assert(e:=merely_equiv_finY).strip_truncations.refine(finite_equiv_(functor_prodidmape^-1)_).generalize(fcardY);introsn.inductionnas[|nIH].-refine(finite_equiv_(prod_empty_rX)^-1_).-refine(finite_equiv_(sum_distrib_lX_Unit)^-1 (finite_sum__)).refine(finite_equiv_(prod_unit_rX)^-1_).Defined.Definitionfcard_prodXY`{FiniteX} `{FiniteY}:fcard(X*Y) =fcardX*fcardY.Proof.assert(e:=merely_equiv_finX).strip_truncations.refine(fcard_equiv'(e*E1) @_).refine(_@ap(funx=>x*fcardY) (fcard_equive^-1)).generalize(fcardX);introsn.inductionnas[|nIH].-refine(fcard_equiv(prod_empty_lY)).-refine(fcard_equiv(sum_distrib_rY(Finn)Unit) @_).refine(fcard_sum__@_).simpl.refine(_@nat_add_comm__).refine(ap011nat_add__).+applyIH.+applyfcard_equiv',prod_unit_l.Defined.Function typesFinite sets are closed under function types, and even dependent function types.Global Instancefinite_forall`{Funext} {X} (Y:X->Type)`{FiniteX} `{forallx,Finite(Yx)}:Finite(forallx:X,Yx).Proof.assert(e:=merely_equiv_finX).strip_truncations.simplerefine(finite_equiv'_(equiv_functor_forall'(P:=funx=>Y(e^-1x))e_)_);tryexact_.{introsx;refine(equiv_transport_(eissectex)). }set(Y':=Yoe^-1);change(Finite(forallx,Y'x)).assert(forallx,Finite(Y'x))byexact_;clearbodyY';cleare.generalizedependent(fcardX);introsnY'?.inductionnas[|nIH].-exact_.-refine(finite_equiv_(equiv_sum_indY')_).applyfinite_prod.+applyIH;exact_.+refine(finite_equiv_(@Unit_ind(funu=>Y'(inru)))_).refine(isequiv_unit_ind(Y'oinr)).Defined.#[local]HintExtern4 =>progress(cbvbetaiota) :typeclass_instances.Definitionfcard_arrow`{Funext}XY`{FiniteX} `{FiniteY}:fcard(X->Y) =nat_pow(fcardY) (fcardX).Proof.assert(e:=merely_equiv_finX).strip_truncations.refine(fcard_equiv(functor_arroweidmap)^-1 @_).refine(_@ap(funx=>nat_pow(fcardY)x) (fcard_equive)).generalize(fcardX);introsn.inductionnas[|nIH].-reflexivity.-refine(fcard_equiv(equiv_sum_ind(fun(_:Finn.+1) =>Y))^-1 @_).refine(fcard_prod__@_).lhsnrapplynat_mul_comm.apply(ap011nat_mul).+refine(fcard_equiv(@Unit_ind(fun(_:Unit) =>Y))^-1).+assumption.Defined.fcardstill computes, despite the funext:Goalforallfs:Funext,fcard(Fin3 ->Fin4) = 64.reflexivity.Abort.Automorphism types (i.e. symmetric groups)Global Instancefinite_aut`{Funext}X`{FiniteX}:Finite(X<~>X).Proof.assert(e:=merely_equiv_finX).strip_truncations.refine(finite_equiv_(equiv_functor_equive^-1e^-1)_).generalize(fcardX);introsn.inductionnas[|nIH].-exact_.-refine(finite_equiv_(equiv_fin_equivnn)_).Defined.Definitionfcard_aut`{Funext}X`{FiniteX}:fcard(X<~>X) =factorial(fcardX).Proof.assert(e:=merely_equiv_finX).strip_truncations.refine(fcard_equiv(equiv_functor_equive^-1e^-1)^-1 @_).generalize(fcardX);introsn.inductionnas[|nIH].-reflexivity.-refine(fcard_equiv(equiv_fin_equivnn)^-1 @_).refine(fcard_prod__@_).applyap011.+reflexivity.+assumption.Defined.fcardstill computes:Goalforallfs:Funext,fcard(Fin4 <~>Fin4) = 24.reflexivity.Abort.Finite sums of natural numbersPerhaps slightly less obviously, finite sets are also closed under sigmas.Global Instancefinite_sigma{X} (Y:X->Type)`{FiniteX} `{forallx,Finite(Yx)}:Finite{x:X&Yx}.Proof.assert(e:=merely_equiv_finX).strip_truncations.refine(finite_equiv'_(equiv_functor_sigma(equiv_inversee)(funx(y:Y(e^-1x)) =>y))_).Unfortunately, becausecomposeis currently beta-expanded,set(Y':=Yoe^-1)doesn't change the goal.set(Y':=funx=>Y(e^-1x)).assert(forallx,Finite(Y'x))byexact_;clearbodyY';cleare.generalizedependent(fcardX);introsnY'?.inductionnas[|nIH].-refine(finite_equivEmptypr1^-1_).-refine(finite_equiv_(equiv_sigma_sum(Finn)UnitY')^-1_).applyfinite_sum.+applyIH;exact_.+refine(finite_equiv_(equiv_contr_sigma_)^-1_).Defined.Amusingly, this automatically gives us a way to add up a family of natural numbers indexed by any finite set.  (We could of course also define such an operation directly, probably usingmerely_ind_hset.)Definitionfinadd{X} `{FiniteX} (f:X->nat) :nat:=fcard{x:X&Fin(fx) }.Definitionfcard_sigma{X} (Y:X->Type)`{FiniteX} `{forallx,Finite(Yx)}:fcard{x:X&Yx} =finadd(funx=>fcard(Yx)).Proof.set(f:=funx=>fcard(Yx)).set(g:=funx=>merely_equiv_fin(Yx) :merely(Yx<~>Fin(fx))).applyfinite_choiceing; [|exact_].strip_truncations.unfoldfinadd.refine(fcard_equiv'(equiv_functor_sigma_idg)).Defined.The sum of a finite constant family is the product by its cardinality.Definitionfinadd_constX`{FiniteX}n:finadd(funx:X=>n) =fcardX*n.Proof.transitivity(fcard(X*Finn)).-exact(fcard_equiv'(equiv_sigma_prod0X(Finn))).-exact(fcard_prodX(Finn)).Defined.Closure under sigmas and paths also implies closure under hfibers.Definitionfinite_hfiber{XY} (f:X->Y) (y:Y)`{FiniteX} `{FiniteY}:Finite(hfiberfy).Proof.exact_.Defined.Therefore, the cardinality of the domain of a map between finite sets is the sum of the cardinalities of its hfibers.Definitionfcard_domain{XY} (f:X->Y) `{FiniteX} `{FiniteY}:fcardX=finadd(funy=>fcard(hfiberfy)).Proof.refine(_@fcard_sigma(hfiberf)).refine(fcard_equiv'(equiv_fibration_replacementf)).Defined.In particular, the image of a map between finite sets is finite.Definitionfinite_image{XY} `{FiniteX} `{FiniteY} (f:X->Y):Finite(himagef).Proof.exact_.Defined.Finite products of natural numbersSimilarly, closure of finite sets underforallautomatically gives us a way to multiply a family of natural numbers indexed by any finite set.  Of course, if we defined this explicitly, it wouldn't need funext.Definitionfinmult`{Funext} {X} `{FiniteX} (f:X->nat) :nat:=fcard(forallx:X,Fin(fx)).Definitionfcard_forall`{Funext} {X} (Y:X->Type)`{FiniteX} `{forallx,Finite(Yx)}:fcard(forallx:X,Yx) =finmult(funx=>fcard(Yx)).Proof.set(f:=funx=>fcard(Yx)).set(g:=funx=>merely_equiv_fin(Yx) :merely(Yx<~>Fin(fx))).applyfinite_choiceing; [|exact_].strip_truncations.unfoldfinmult.refine(fcard_equiv'(equiv_functor_forall'(equiv_idmapX)g)).Defined.The product of a finite constant family is the exponential by its cardinality.Definitionfinmult_const`{Funext}X`{FiniteX}n:finmult(funx:X=>n) =nat_pown(fcardX).Proof.refine(fcard_arrowX(Finn)).Defined.Finite subsetsClosure under sigmas implies that a detachable subset of a finite set is finite.Global Instancefinite_detachable_subset{X} `{FiniteX} (P:X->Type)`{forallx,IsHProp(Px)} `{forallx,Decidable(Px)}:Finite{x:X&Px}.Proof.exact_.Defined.Conversely, if a subset of a finite set is finite, then it is detachable.  We show first that an embedding between finite subsets has detachable image.Definitiondetachable_image_finite{XY} `{FiniteX} `{FiniteY} (f:X->Y) `{IsEmbeddingf}:forally,Decidable(hfiberfy).Proof.introsy.assert(ff:Finite(hfiberfy))byexact_.destructffas[[|n]e].-right;introsu;strip_truncations;exact(eu).-left;strip_truncations;exact(e^-1 (inrtt)).Defined.Definitiondetachable_finite_subset{X} `{FiniteX}(P:X->Type) `{forallx,IsHProp(Px)}{Pf:Finite({x:X&Px})}:forallx,Decidable(Px).Proof.introsx.nrefine(decidable_equiv'_(hfiber_fibrationxP)^-1%equiv_).nrefine(detachable_image_finitepr1x).1,2:exact_.apply(mapinO_pr1(Tr(-1))).Why doesn't Coq find this?Defined.QuotientsThe quotient of a finite set by a detachable equivalence relation is finite.SectionDecidableQuotients.Context`{Univalence} {X} `{FiniteX}(R:RelationX) `{is_mere_relationXR}`{Reflexive_R} `{Transitive_R} `{Symmetric_R}{Rd:forallxy,Decidable(Rxy)}.Global Instancefinite_quotient:Finite(QuotientR).Proof.assert(e:=merely_equiv_finX).strip_truncations.pose(R'xy:=R(e^-1x) (e^-1y)).assert(is_mere_relation_R')byexact_.assert(ReflexiveR')by(intros?;unfoldR';applyreflexivity).assert(SymmetricR')by(intros? ?;unfoldR';applysymmetry).assert(TransitiveR')by(intros? ? ?;unfoldR';applytransitivity).assert(R'd:forallxy,Decidable(R'xy))by(intros? ?;unfoldR';applyRd).srefine(finite_equiv'_(equiv_quotient_functorR'Re^-1_)_).1:bytry(intros;split).clearbodyR';cleare.generalizedependent(fcardX);introsn;inductionnas[|nIH];introsR'? ? ? ? ?.-refine(finite_equivEmpty_^-1_).refine(Quotient_recR'_Empty_rec(funx__=>matchxwithend)).-pose(R''xy:=R'(inlx) (inly)).assert(is_mere_relation_R'')byexact_.assert(ReflexiveR'')by(intros?;unfoldR'';applyreflexivity).assert(SymmetricR'')by(intros? ?;unfoldR'';applysymmetry).assert(TransitiveR'')by(intros? ? ?;unfoldR'';applytransitivity).assert(forallxy,Decidable(R''xy))by(intros? ?;unfoldR'';applyR'd).assert(inlresp:= (funxy=>idmap):forallxy,R''xy->R'(inlx) (inly)).destruct(dec(merely{x:Finn&R'(inlx) (inrtt)}))as[p|np].{strip_truncations.destructpas[xr].refine(finite_equiv'(QuotientR'')__).refine(Build_Equiv__(Quotient_functorR''R'inlinlresp)_).applyisequiv_surj_emb.-applyBuildIsSurjection.refine(Quotient_ind_hpropR'__).intros[y|[]];applytr.+exists(class_ofR''y);reflexivity.+exists(class_ofR''x);simpl.applyqglue,r.-applyisembedding_isinj_hset;introsu.refine(Quotient_ind_hpropR''__);introsv.revertu;refine(Quotient_ind_hpropR''__);introsu.simpl;introsq.applyqglue;unfoldR''.exact(related_quotient_pathsR'(inlu) (inlv)q). }{refine(finite_equiv'(QuotientR''+Unit)__).refine(Build_Equiv__(sum_ind(fun_=>QuotientR')(Quotient_functorR''R'inlinlresp)(fun_=>class_ofR'(inrtt)))_).applyisequiv_surj_emb.-applyBuildIsSurjection.refine(Quotient_ind_hpropR'__).intros[y|[]];applytr.+exists(inl(class_ofR''y));reflexivity.+exists(inrtt);reflexivity.-applyisembedding_isinj_hset;introsu.refine(sum_ind___).+refine(Quotient_ind_hpropR''__);introsv.revertu;refine(sum_ind___).*refine(Quotient_ind_hpropR''__);introsu.simpl;introsq.applyap,qglue;unfoldR''.exact(related_quotient_pathsR'(inlu) (inlv)q).*intros[];simpl.introsq.applyrelated_quotient_pathsinq;tryexact_.applysymmetryinq.elim(np(tr(v;q))).+intros[];simpl.destructuas[u|[]];simpl.*revertu;refine(Quotient_ind_hpropR''__);introsu;simpl.introsq.applyrelated_quotient_pathsinq;tryexact_.elim(np(tr(u;q))).*intros;reflexivity. }Defined.Therefore, the cardinality ofXis the sum of the cardinalities of its equivalence classes.Definitionfcard_quotient:fcardX=finadd(funz:QuotientR=>fcard{x:X&in_classRzx}).Proof.refine(fcard_domain(class_ofR) @_).applyap,path_arrow;introsz;revertz.refine(Quotient_ind_hprop___);introsx;simpl.applyfcard_equiv';unfoldhfiber.refine(equiv_functor_sigma_id_);introsy;simpl.symmetry.refine(path_quotientRyxoE_).applyequiv_iff_hprop;applysymmetry.Defined.EndDecidableQuotients.InjectionsAn injection between finite sets induces an inequality between their cardinalities.Definitionleq_inj_finite{XY} {fX:FiniteX} {fY:FiniteY}(f:X->Y) (i:IsEmbeddingf):fcardX<=fcardY.Proof.assert(MapIn(Tr(-1))f)byexact_.cleari.destructfXas[ne];simpl.destructfYas[me'];simpl.strip_truncations.pose(g:=e'ofoe^-1).assert(MapIn(Tr(-1))g)by(unfoldg;exact_).clearbodyg.clearee'.generalizedependentm.inductionnas[|nIHn].1:exact_.introsmg?.assert(i:IsInjectiveg)by(applyisinj_embedding;exact_).destructmas[|m].{elim(g(inrtt)). }pose(h:= (fin_transpose_last_withm(g(inrtt)))^-1og).assert(MapIn(Tr(-1))h)by(unfoldh;exact_).assert(Ha:foralla:Finn,is_inl(h(inla))).{introsa.remember(g(inla))asbeqn:p.destructbas[b|[]].-assert(q:g(inla) <> (g(inrtt))).{introsr.exact(inl_ne_inr__(i__r)). }rewritepinq;applysymmetric_neqinq.assert(r:h(inla) =inlb).{unfoldh;applymoveR_equiv_V;symmetry.refine(fin_transpose_last_with_restm(g(inrtt))bq@p^). }rewriter;exacttt.-assert(q:h(inla) =g(inrtt)).{unfoldh;applymoveR_equiv_V;symmetry.refine(_@p^);applyfin_transpose_last_with_with. }rewriteq.destruct(is_inl_or_is_inr(g(inrtt)))as[l|r];tryassumption.assert(s:=inr_un_inr_r).reverts;generalize(un_inr(g(inrtt))r);intros[]s.elim(inl_ne_inr__(i__(p@s))). }assert(Hb:forallb:Unit,is_inr(h(inrb))).{intros[].assert(q:h(inrtt) =inrtt).{unfoldh;applymoveR_equiv_V;symmetry.applyfin_transpose_last_with_last. }rewriteq;exacttt. }applyleq_succ.exact(IHnm(unfunctor_sum_lhHa)(mapinO_unfunctor_sum_l(Tr(-1))hHaHb)).Qed.SurjectionsA surjection between finite sets induces an inequality between their cardinalities.Definitiongeq_surj_finite{XY} {fX:FiniteX} {fY:FiniteY}(f:X->Y) (i:IsSurjectionf):fcardX>=fcardY.Proof.destructfXas[ne],fYas[me'];simpl.assert(k:=isprojective_fin_nm).strip_truncations.pose(g:=e'ofoe^-1).assert(k':IsSurjectiong)byexact_.clearbodyg;clearif.assert(j:=k(Finn)_(Finm)_idmapgk').strip_truncations.simpl;destructjas[sis_section].changenwith(fcard(Finn)).changemwith(fcard(Finm)).apply(leq_inj_finites).applyisembedding_isinj_hset, (isinj_sectionis_section).Defined.EnumerationsA function fromnatto a finite set must repeat itself eventually.SectionEnumeration.Context`{Funext} {X} `{Finite@{_Set_}X} (e:nat->X).Leter(n:nat) :Finn->X:=funk=>e(nat_finnk).Lemmafinite_enumeration_stage(n:nat):IsEmbedding(ern)+ {n:nat& {k:nat&en=e(n+k).+1 }}.Proof.inductionnas[|n[IH|IH]].-left.introsx.applyhprop_inhabited_contr;intros[[]_].-destruct(detachable_image_finite(ern) (ern.+1 (inrtt)))as[[kp]|ne].+right.exists(nat_finnk).exists(nat_fin_complnk).rewritenat_fin_compl_compl.exactp.+left.introsx.applyhprop_allpath.introskl.applypath_sigma_hprop.destructkas[[k|[]]p],las[[l|[]]q];simpl.*applyisinj_embeddinginIH.applyap.applyIH.unfolderinp,q.simplinp,q.exact(p@q^).*refine(Empty_rec(ne_)).existsk.exact(p@q^).*refine(Empty_rec(ne_)).existsl.exact(q@p^).*reflexivity.-right;exactIH.Defined.Definitionfinite_enumeration_repeats: {n:nat& {k:nat&en=e(n+k).+1 }}.Proof.destruct(finite_enumeration_stage(fcardX).+1)as[p|?].-assert(q:=leq_inj_finite(er(fcardX).+1)p);simplinq.elim(lt_irrefl_q).-assumption.Defined.EndEnumeration.

--- Miscellaneous\FiniteSum.html ---
FiniteSumLibrary FiniteSumRequireImportBasics.OvertureBasics.Tactics.RequireImportSpaces.Nat.CoreSpaces.Int.RequireExportClasses.interfaces.canonical_names(Zero,zero,Plus).RequireExportClasses.interfaces.abstract_algebra(IsAbGroup(..),abgroup_group,abgroup_commutative).RequireImportAbelianGroup.Local OpenScopemc_scope.Local OpenScopemc_add_scope.Finite SumsIndexed finite sum of abelian group elements.Definitionab_sum{A:AbGroup} (n:nat) (f:forallk, (k<n)%nat->A) :A.Proof.inductionnas[|nIHn].-exactzero.-refine(fn_+IHn_).introskHk.exact(fk_).Defined.If the function is constant in the range of a finite sum then the sum is equal to the constant timesn. This is a group power in the underlying group.Definitionab_sum_const{A:AbGroup} (n:nat) (a:A)(f:forallk, (k<n)%nat->A) (p:forallkHk,fkHk=a):ab_sumnf=ab_mulna.Proof.inductionnas[|nIHn]inf,p|- *.-reflexivity.-rhs_Vnrapply(ap@{Set_}_(int_nat_succn)).rhsnrapplygrp_pow_succ.simpl.f_ap.applyIHn.intros.applyp.Defined.If the function is zero in the range of a finite sum then the sum is zero.Definitionab_sum_zero{A:AbGroup} (n:nat)(f:forallk, (k<n)%nat->A) (p:forallkHk,fkHk= 0):ab_sumnf= 0.Proof.lhsnrapply(ab_sum_const_0fp).applygrp_pow_unit.Defined.Finite sums distribute over addition.Definitionab_sum_plus{A:AbGroup} (n:nat) (fg:forallk, (k<n)%nat->A):ab_sumn(funkHk=>fkHk+gkHk)=ab_sumn(funkHk=>fkHk) +ab_sumn(funkHk=>gkHk).Proof.inductionnas[|nIHn].1:byrewritegrp_unit_l.simpl.rewrite<- !grp_assoc;f_ap.rewriteIHn,ab_comm, <-grp_assoc;f_ap.byrewriteab_comm.Defined.Double finite sums commute.Definitionab_sum_sum{A:AbGroup} (mn:nat)(f:forallij, (i<m)%nat-> (j<n)%nat->A):ab_summ(funiHi=>ab_sumn(funjHj=>fijHiHj))=ab_sumn(funjHj=>ab_summ(funiHi=>fijHiHj)).Proof.inductionnas[|nIHn]inm,f|- *.1:bynrapplyab_sum_zero.lhsnrapplyab_sum_plus;cbn;f_ap.Defined.Finite sums are equal if the functions are equal in the range.Definitionpath_ab_sum{A:AbGroup} {n:nat} {fg:forallk, (k<n)%nat->A}(p:forallkHk,fkHk=gkHk):ab_sumnf=ab_sumng.Proof.inductionnas[|nIHn].1:reflexivity.cbn;f_ap.byapplyIHn.Defined.

--- Miscellaneous\FinNat.html ---
FinNatLibrary FinNatRequireImportBasics.OvertureBasics.TacticsBasics.TruncBasics.PathGroupoidsBasics.EquivalencesBasics.DecidableBasics.Classes.RequireImportTypes.EmptyTypes.SigmaTypes.SumTypes.ProdTypes.Equiv.RequireImportSpaces.Nat.Core.RequireImportFinite.Fin.Local OpenScopenat_scope.SetUniverseMinimizationToSet.DefinitionFinNat@{} (n:nat) :Type0:= {x:nat|x<n}.Definitionzero_finnat@{} (n:nat) :FinNatn.+1:= (0;_: 0 <n.+1).Definitionsucc_finnat@{} {n:nat} (u:FinNatn) :FinNatn.+1:= (u.1.+1;leq_succu.2).Definitionpath_succ_finnat{n:nat} (x:nat) (h:x.+1 <n.+1):succ_finnat(x;leq_pred'h) = (x.+1;h).Proof.byapplypath_sigma_hprop.Defined.Definitionlast_finnat@{} (n:nat) :FinNatn.+1:=exist(funx=>x<n.+1)n(leq_refln.+1).Definitionincl_finnat@{} {n:nat} (u:FinNatn) :FinNatn.+1:= (u.1;leq_transu.2 (leq_succ_r(leq_refln))).Definitionfinnat_ind@{u} (P:foralln:nat,FinNatn->Type@{u})(z:foralln:nat,Pn.+1 (zero_finnatn))(s:forall(n:nat) (u:FinNatn),Pnu->Pn.+1 (succ_finnatu)){n:nat} (u:FinNatn):Pnu.Proof.simple_inductionnnIHn;introu.-elim(not_lt_zero_ru.1u.2).-destructuas[xh].destructxas[|x].+nrefine(transport(Pn.+1)_(z_)).byapplypath_sigma_hprop.+refine(transport(Pn.+1) (path_succ_finnat__)_).applys.applyIHn.Defined.Definitionfinnat_ind_beta_zero@{u} (P:foralln:nat,FinNatn->Type@{u})(z:foralln:nat,Pn.+1 (zero_finnatn))(s:forall(n:nat) (u:FinNatn),Pnu->Pn.+1 (succ_finnatu))(n:nat):finnat_indPzs(zero_finnatn) =zn.Proof.snrapply(transport2_(q:=idpath@{Set})).rapplypath_ishprop.Defined.Definitionfinnat_ind_beta_succ@{u} (P:foralln:nat,FinNatn->Type@{u})(z:foralln:nat,Pn.+1 (zero_finnatn))(s:forall(n:nat) (u:FinNatn),Pnu->Pn.+1 (succ_finnatu)){n:nat} (u:FinNatn):finnat_indPzs(succ_finnatu) =snu(finnat_indPzsu).Proof.destructuas[u1u2];simpl;unfoldpath_succ_finnat.destruct(path_ishpropu2(leq_pred'(leq_succu2))).refine(transport2_(q:=idpath@{Set})__).rapplypath_ishprop.Defined.Definitionis_bounded_fin_to_nat@{} {n} (k:Finn):fin_to_natk<n.Proof.inductionnas[|nIHn].-elimk.-destructkas[k| []];exact_.Defined.Definitionfin_to_finnat{n} (k:Finn) :FinNatn:= (fin_to_natk;is_bounded_fin_to_natk).Fixpointfinnat_to_fin@{} {n:nat} :FinNatn->Finn:=matchnwith| 0 =>funu=>Empty_rec(not_lt_zero_r_u.2)|n.+1 =>funu=>matchuwith| (0;_) =>fin_zero| (x.+1;h) =>fsucc(finnat_to_fin(x;leq_pred'h))endend.Definitionpath_fin_to_finnat_fsucc@{} {n:nat} (k:Finn):fin_to_finnat(fsucck) =succ_finnat(fin_to_finnatk).Proof.applypath_sigma_hprop.applypath_nat_fsucc.Defined.Definitionpath_fin_to_finnat_fin_zero@{} (n:nat):fin_to_finnat(@fin_zeron) =zero_finnatn.Proof.applypath_sigma_hprop.applypath_nat_fin_zero.Defined.Definitionpath_finnat_to_fin_succ@{} {n:nat} (u:FinNatn):finnat_to_fin(succ_finnatu) =fsucc(finnat_to_finu).Proof.cbn.do2f_ap.byapplypath_sigma_hprop.Defined.Definitionpath_finnat_to_fin_incl@{} {n:nat} (u:FinNatn):finnat_to_fin(incl_finnatu) =fin_incl(finnat_to_finu).Proof.revertnu.snrapplyfinnat_ind.1:reflexivity.introsnu;cbnbeta;introsp.lhsnrapply(path_finnat_to_fin_succ(incl_finnatu)).lhsnrapply(apfsuccp).exact(apfin_incl(path_finnat_to_fin_succ_))^.Defined.Definitionpath_finnat_to_fin_last@{} (n:nat):finnat_to_fin(last_finnatn) =fin_last.Proof.inductionnas[|nIHn].-reflexivity.-exact(apfsuccIHn).Defined.Definitionpath_finnat_to_fin_to_finnat@{} {n:nat} (u:FinNatn):fin_to_finnat(finnat_to_finu) =u.Proof.inductionnas[|nIHn].-elim(not_lt_zero_r_u.2).-destructuas[xh].applypath_sigma_hprop.destructxas[|x].+exact(appr1(path_fin_to_finnat_fin_zeron)).+refine((path_fin_to_finnat_fsucc_)..1 @_).exact(apS(IHn(x;leq_pred'h))..1).Defined.Definitionpath_fin_to_finnat_to_fin@{} {n:nat} (k:Finn):finnat_to_fin(fin_to_finnatk) =k.Proof.inductionnas[|nIHn].-elimk.-destructkas[k| []].+specialize(IHnk).refine(path_finnat_to_fin_incl(fin_to_finnatk) @_).exact(apfin_inclIHn).+applypath_finnat_to_fin_last.Defined.Definitionequiv_fin_finnat@{} (n:nat) :Finn<~>FinNatn:=equiv_adjointifyfin_to_finnatfinnat_to_finpath_finnat_to_fin_to_finnatpath_fin_to_finnat_to_fin.

--- Miscellaneous\FinSeq.html ---
FinSeqLibrary FinSeqRequireImportHoTT.BasicsHoTT.TypesHoTT.Universes.HSetHoTT.Spaces.Finite.FinHoTT.Spaces.Finite.FinInductionHoTT.Spaces.Nat.Core.Local OpenScopenat_scope.Finite-dimensional sequence. It is often referred to as vector,
    but we call it finite sequenceFinSeqto avoid confusion with
    vector from linear algebra.Note that the induction principlefinseq_DefinitionFinSeq@{u} (n:nat) (A:Type@{u}) :Type@{u} :=Finn->A.The empty finite sequence.Definitionfsnil{A:Type} :FinSeq0A:=Empty_rec.Definitionpath_fsnil`{Funext} {A:Type} (v:FinSeq0A) :fsnil=v.Proof.applypath_contr.Defined.Add an element in the end of a finite sequence,fscons'andfscons.Definitionfscons'{A:Type} (n:nat) (a:A) (v:FinSeq(nat_predn)A):FinSeqnA:=funi=>fin_rec(funn=>FinSeq(nat_predn)A->A)(fun__=>a) (funn'i_v=>vi)iv.Definitionfscons{A:Type} {n:nat} :A->FinSeqnA->FinSeqn.+1A:=fscons'n.+1.Take the first element of a non-empty finite sequence,fshead'andfshead.Definitionfshead'{A} (n:nat) : 0 <n->FinSeqnA->A:=matchnwith| 0 =>funN_=>Empty_rec(not_lt_zero_r_N)|n'.+1 =>fun_v=>vfin_zeroend.Definitionfshead{A} {n:nat} :FinSeqn.+1A->A:=fshead'n.+1_.Definitionfshead'_beta_fscons'{A}n(N:n> 0) (a:A) (v:FinSeq(nat_predn)A):fshead'nN(fscons'nav) =a.Proof.destructn; [elim(lt_irrefl_N)|].exact(apD10(fin_rec_beta_zero____)v).Defined.Definitionfshead_beta_fscons{A} {n} (a:A) (v:FinSeqnA):fshead(fsconsav) =a.Proof.applyfshead'_beta_fscons'.Defined.If the sequence is non-empty, then remove the first element.Definitionfstail'{A} (n:nat) :FinSeqnA->FinSeq(nat_predn)A:=matchnwith| 0 =>fun_=>Empty_rec|n'.+1 =>funvi=>v(fsucci)end.Remove the first element from a non-empty sequence.Definitionfstail{A} {n:nat} :FinSeqn.+1A->FinSeqnA:=fstail'n.+1.Definitionfstail'_beta_fscons'{A}n(a:A) (v:FinSeq(nat_predn)A):fstail'n(fscons'nav) ==v.Proof.introi.destructn; [elimi|].exact(apD10(fin_rec_beta_fsucc____)v).Defined.Definitionfstail_beta_fscons`{Funext} {A} {n} (a:A) (v:FinSeqnA):fstail(fsconsav) =v.Proof.funexti.applyfstail'_beta_fscons'.Defined.A non-empty finite sequence is equal tofsconsof head and tail,path_expand_fscons'andpath_expand_fscons.Lemmapath_expand_fscons'{A:Type} (n:nat)(i:Finn) (N:n> 0) (v:FinSeqnA):fscons'n(fshead'nNv) (fstail'nv)i=vi.Proof.inductioniusingfin_ind.-applyfshead_beta_fscons.-apply(fstail'_beta_fscons'n.+1 (fsheadv) (fstailv)).Defined.Lemmapath_expand_fscons`{Funext} {A} {n} (v:FinSeqn.+1A):fscons(fsheadv) (fstailv) =v.Proof.funexti.applypath_expand_fscons'.Defined.The followingpath_fscons'andpath_fsconsgives a way to construct
    a path betweenfsconsfinite sequences. They cooperate nicely withpath_expand_fscons'andpath_expand_fscons.Definitionpath_fscons'{A}n{a1a2:A} {v1v2:FinSeq(nat_predn)A}(p:a1=a2) (q:foralli,v1i=v2i) (i:Finn):fscons'na1v1i=fscons'na2v2i.Proof.inductioniusingfin_ind.-exact(fshead_beta_fscons__@p@ (fshead_beta_fscons__)^).-refine(_@ (fstail'_beta_fscons'n.+1a2v2i)^).exact(fstail'_beta_fscons'n.+1a1v1i@qi).Defined.Definitionpath_fscons'_beta{A} (n:nat)(a:A) (v:FinSeq(nat_predn)A) (i:Finn):path_fscons'n(idpatha) (funj=>idpath(vj))i=idpath.Proof.inductioniusingfin_ind;unfoldpath_fscons'.-rewritefin_ind_beta_zero.refine(ap(funp=>p@_) (concat_p1_) @_).applyconcat_pV.-rewritefin_ind_beta_fsucc.refine(ap(funp=>p@_) (concat_p1_) @_).applyconcat_pV.Qed.Definitionpath_fscons`{Funext} {A} {n} {a1a2:A} (p:a1=a2){v1v2:FinSeqnA} (q:v1=v2):fsconsa1v1=fsconsa2v2.Proof.funexti.applypath_fscons'.-assumption.-introj.exact(apD10qj).Defined.Lemmapath_fscons_beta`{Funext} {A} {n} (a:A) (v:FinSeqnA):path_fscons(idpatha) (idpathv) =idpath.Proof.refine(ap(path_forall__)_@eta_path_forall___).funexti.exact(path_fscons'_betan.+1avi).Defined.The lemmaspath_expand_fscons_fscons'andpath_expand_fscons_fsconsidentifypath_expand_fscons'withpath_fscons'andpath_expand_fsconswithpath_fscons.Lemmapath_expand_fscons_fscons'{A:Type} (n:nat)(N:n> 0) (a:A) (v:FinSeq(nat_predn)A) (i:Finn):path_expand_fscons'niN(fscons'nav) =path_fscons'n(fshead'_beta_fscons'nNav) (fstail'_beta_fscons'nav)i.Proof.inductioniusingfin_ind;unfoldpath_fscons',path_expand_fscons'.-do2rewritefin_ind_beta_zero.refine(_@concat_p_pp___).refine(_@ (ap(funp=>_@p) (concat_pV_))^).exact(concat_p1_)^.-do2rewritefin_ind_beta_fsucc.refine(_@concat_p_pp___).refine(_@ (ap(funp=>_@p) (concat_pV_))^).exact(concat_p1_)^.Qed.Lemmapath_expand_fscons_fscons`{Funext}{A:Type} {n:nat} (a:A) (v:FinSeqnA):path_expand_fscons(fsconsav) =path_fscons(fshead_beta_fsconsav) (fstail_beta_fsconsav).Proof.refine(ap(path_forall__)_).funexti.pose(p:=eisretrapD10(fstail'_beta_fscons'n.+1av)).refine(_@ (ap(funf=>_fi)p)^).exact(path_expand_fscons_fscons'n.+1_avi).Defined.The induction principle for finite sequence,finseq_ind.
    Note that it uses funext and does not compute.Lemmafinseq_ind`{Funext} {A:Type} (P:foralln,FinSeqnA->Type)(z:P0fsnil) (s:forallna(v:FinSeqnA),Pnv->Pn.+1 (fsconsav)){n:nat} (v:FinSeqnA):Pnv.Proof.inductionn.-exact(transport(P0) (path_fsnilv)z).-refine(transport(Pn.+1) (path_expand_fsconsv)_).applys.applyIHn.Defined.Lemmafinseq_ind_beta_fsnil`{Funext} {A:Type}(P:foralln,FinSeqnA->Type) (z:P0fsnil)(s:forall(n:nat) (a:A) (v:FinSeqnA),Pnv->Pn.+1 (fsconsav)):finseq_indPzsfsnil=z.Proof.exact(ap(funx=>_xz) (hset_path21 (path_fsnilfsnil)))^.Defined.Lemmafinseq_ind_beta_fscons`{Funext} {A:Type}(P:foralln,FinSeqnA->Type) (z:P0fsnil)(s:forall(n:nat) (a:A) (v:FinSeqnA),Pnv->Pn.+1 (fsconsav)){n:nat} (a:A) (v:FinSeqnA):finseq_indPzs(fsconsav) =snav(finseq_indPzsv).Proof.simpl.induction(path_expand_fscons_fsconsav)^.set(p1:=fshead_beta_fsconsav).set(p2:=fstail_beta_fsconsav).inductionp1,p2.exact(ap(funp=>transport_p_) (path_fscons_beta__)).Defined.

--- Miscellaneous\Flattening.html ---
FlatteningLibrary FlatteningThe flattening lemma.RequireImportHoTT.Basics.RequireImportTypes.PathsTypes.ForallTypes.SigmaTypes.ArrowTypes.Universe.Local OpenScopepath_scope.RequireImportHoTT.Colimits.Coeq.The base HITWis just a homotopy coequalizerCoeq.TODO: Make the names in this file more usable, move it intoCoeq.v, and use it to derive corresponding flattening lemmas forpushout, etc.Now we define the flattened HIT which will be equivalent to the total space of a fibration overW.ModuleExportFlattenedHIT.Private InductiveWtil(AB:Type) (fg:B->A)(C:A->Type) (D:forallb,C(fb) <~>C(gb)):Type:=|cct:foralla,Ca->WtilABfgCD.Argumentscct{ABfgCD}ac.Axiomppt:forall{ABfgCD} (b:B) (y:C(fb)),@cctABfgCD(fb)y=cct(gb) (Dby).DefinitionWtil_ind{ABfgCD} (Q:WtilABfgCD->Type)(cct':forallax,Q(cctax))(ppt':forallby, (pptby) # (cct'(fb)y) =cct'(gb) (Dby)):forallw,Qw:=funw=>matchwwithcctax=>fun_=>cct'axendppt'.AxiomWtil_ind_beta_ppt:forall{ABfgCD} (Q:WtilABfgCD->Type)(cct':forallax,Q(cctax))(ppt':forallby, (pptby) # (cct'(fb)y) =cct'(gb) (Dby))(b:B) (y:C(fb)),apD(Wtil_indQcct'ppt') (pptby) =ppt'by.EndFlattenedHIT.DefinitionWtil_rec{ABfgC} {D:forallb,C(fb) <~>C(gb)}(Q:Type) (cct':foralla(x:Ca),Q)(ppt':forallb(y:C(fb)),cct'(fb)y=cct'(gb) (Dby)):WtilABfgCD->Q:=Wtil_ind(fun_=>Q)cct'(funby=>transport_const__@ppt'by).DefinitionWtil_rec_beta_ppt{ABfgC} {D:forallb,C(fb) <~>C(gb)}(Q:Type) (cct':foralla(x:Ca),Q)(ppt':forall(b:B) (y:C(fb)),cct'(fb)y=cct'(gb) (Dby))(b:B) (y:C(fb)):ap(@Wtil_recABfgCDQcct'ppt') (pptby) =ppt'by.Proof.unfoldWtil_rec.eapply(cancelL(transport_const(ppt(C:=C)by)_)).refine((apD_const(@Wtil_indABfgCD(fun_=>Q)cct'_) (pptby))^ @_).refine(Wtil_ind_beta_ppt(fun_=>Q)____).Defined.Now we define the fibration over it that we will be considering the total space of.SectionAssumeAxioms.Context`{Univalence}.Context{BA:Type} {fg:B->A}.Context{C:A->Type} {D:forallb,C(fb) <~>C(gb)}.LetW':=Coeqfg.LetP:W'->Type:=Coeq_recTypeC(funb=>path_universe(Db)).Now we give the total space the same structure asWtil.LetsWtil:= {w:W'&Pw}.Letscct(a:A) (x:Ca) :sWtil:= (existP(coeqa)x).Letsppt(b:B) (y:C(fb)) :scct(fb)y=scct(gb) (Dby):=path_sigma'P(cglueb)(transport_path_universe'P(cglueb) (Db)(Coeq_rec_beta_cglueTypeC(funb0=>path_universe(Db0))b)y).Here is the dependent eliminatorDefinitionsWtil_ind(Q:sWtil->Type)(scct':forallax,Q(scctax))(sppt':forallby, (spptby) # (scct'(fb)y) =scct'(gb) (Dby)):forallw,Qw.Proof.applysig_ind.refine(Coeq_ind(funw=>forallx:Pw,Q(w;x))(funax=>scct'ax)_).introsb.apply(dpath_forallP(funab=>Q(a;b))__(cglueb)(scct'(fb)) (scct'(gb))).introsy.set(q:=transport_path_universe'P(cglueb) (Db)(Coeq_rec_beta_cglueTypeC(funb0:B=>path_universe(Db0))b)y).rewritetransportD_is_transport.refine(_@apD(scct'(gb))q^).refine(moveL_transport_V(funx=>Q(scct(gb)x))q___).rewritetransport_compose, <-transport_pp.refine(_@sppt'by).applyap10,ap.refine(whiskerL_(ap_existP(coeq(gb))__q) @_).exact((path_sigma_p1_1p'___)^).Defined.The eliminator computes on the point constructor.DefinitionsWtil_ind_beta_cct(Q:sWtil->Type)(scct':forallax,Q(scctax))(sppt':forallby, (spptby) # (scct'(fb)y) =scct'(gb) (Dby))(a:A) (x:Ca):sWtil_indQscct'sppt'(scctax) =scct'ax:= 1.This would be its propositional computation rule on the path constructor...Definition sWtil_ind_beta_ppt (Q : sWtil -> Type)
  (scct' : forall a x, Q (scct a x))
  (sppt' : forall b y, (sppt b y) # (scct' (f b) y) = scct' (g b) (D b y))
  (b:B) (y:C (f b))
  : apD (sWtil_ind Q scct' sppt') (sppt b y) = sppt' b y.
Proof.
  unfold sWtil_ind.
  (** ... but it's a doozy! *)
Abort.Fortunately, it turns out to be enough to have the computation rule for the *non-dependent* eliminator!We could define that in terms of the dependent one, as usual...Definition sWtil_rec (P : Type)
  (scct' : forall a (x : C a), P)
  (sppt' : forall b (y : C (f b)), scct' (f b) y = scct' (g b) (D b y))
  : sWtil -> P
  := sWtil_ind (fun _ => P) scct' (fun b y => transport_const _ _ @ sppt' b y)....but if we define it diindly, then it's easier to reason about.DefinitionsWtil_rec(Q:Type)(scct':foralla(x:Ca),Q)(sppt':forallb(y:C(fb)),scct'(fb)y=scct'(gb) (Dby)):sWtil->Q.Proof.applysig_ind.refine(Coeq_ind(funw=>Pw->Q) (funax=>scct'ax)_).introsb.refine(dpath_arrowP(fun_=>Q)____).introsy.refine(transport_const__@_).refine(sppt'b_@ap__).refine((transport_path_universe'P(cglueb) (Db)__)^).exact(Coeq_rec_beta_cglue____).Defined.OpenScopelong_path_scope.DefinitionsWtil_rec_beta_ppt(Q:Type)(scct':foralla(x:Ca),Q)(sppt':forallb(y:C(fb)),scct'(fb)y=scct'(gb) (Dby))(b:B) (y:C(fb)):ap(sWtil_recQscct'sppt') (spptby) =sppt'by.Proof.unfoldsWtil_rec,sppt.refine(@ap_sig_rec_path_sigmaW'PQ__(cglueb)____@_);simpl.rewrite(@Coeq_ind_beta_cglueBAfg).rewrite(ap10_dpath_arrowP(fun_=>Q) (cglueb)___y).repeatrewriteconcat_p_pp.Now everything cancels!rewriteap_V,concat_pV_p,concat_pV_p,concat_pV_p,concat_Vp.byapplyconcat_1p.Qed.CloseScopelong_path_scope.Woot!Definitionequiv_flattening:WtilABfgCD<~>sWtil.Proof.The maps back and forth are obtained easily from the non-dependent eliminators.refine(equiv_adjointify(Wtil_rec_scctsppt)(sWtil_rec_cctppt)__).The two homotopies are completely symmetrical, using the *dependent* eliminators, but only the computation rules for the non-dependent ones.-refine(sWtil_ind_(funax=> 1)_).introsby.applydpath_path_FFlr.rewriteconcat_1p,concat_p1.rewritesWtil_rec_beta_ppt.bysymmetry;apply(@Wtil_rec_beta_pptABfgCD).-refine(Wtil_ind_(funax=> 1)_).introsby.applydpath_path_FFlr.rewriteconcat_1p,concat_p1.rewriteWtil_rec_beta_ppt.bysymmetry;applysWtil_rec_beta_ppt.Defined.EndAssumeAxioms.

--- Miscellaneous\Forall.html ---
ForallLibrary ForallRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.Indexed product of categoriesGlobal Instanceisgraph_forall(A:Type) (B:A->Type)`{foralla,IsGraph(Ba)}:IsGraph(foralla,Ba).Proof.srapplyBuild_IsGraph.introsxy;exact(forall(a:A),xa$->ya).Defined.Global Instanceis01cat_forall(A:Type) (B:A->Type)`{foralla,IsGraph(Ba)} `{foralla,Is01Cat(Ba)}:Is01Cat(foralla,Ba).Proof.srapplyBuild_Is01Cat.+introsxa;exact(Id(xa)).+introsxyzfga;exact(fa$oga).Defined.Global Instanceis0gpd_forall(A:Type) (B:A->Type)(* Apparently when there's aforallthere, Coq can't automatically add theIs01Catinstance from theIs0Gpdinstance. *)`{foralla,IsGraph(Ba)} `{foralla,Is01Cat(Ba)} `{foralla,Is0Gpd(Ba)}:Is0Gpd(foralla,Ba).Proof.constructor.introsfgpa;exact((pa)^$).Defined.Global Instanceis2graph_forall(A:Type) (B:A->Type)`{foralla,IsGraph(Ba)} `{foralla,Is2Graph(Ba)}:Is2Graph(foralla,Ba).Proof.introsxy;srapplyBuild_IsGraph.introsfg;exact(foralla,fa$->ga).Defined.Global Instanceis1cat_forall(A:Type) (B:A->Type)`{foralla,IsGraph(Ba)} `{foralla,Is01Cat(Ba)}`{foralla,Is2Graph(Ba)} `{foralla,Is1Cat(Ba)}:Is1Cat(foralla,Ba).Proof.srapplyBuild_Is1Cat.+introsxyzh;srapplyBuild_Is0Functor.introsfgpa.exact(ha$@Lpa).+introsxyzh;srapplyBuild_Is0Functor.introsfgpa.exact(pa$@Rha).+introswxyzfgha;applycat_assoc.+introswxyzfgha;applycat_assoc_opp.+introsxyfa;applycat_idl.+introsxyfa;applycat_idr.Defined.

--- Miscellaneous\Fracture.html ---
FractureLibrary FractureRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensionsLimits.Pullback.RequireImportModalityLexOpenClosedNullification.Local OpenScopepath_scope.The lex-modal fracture theoremThe fracture theorem for two modalitiesO1andO2and a typeA, when it holds, states that the naturality squareA   -->   O1 A
 |          |
 |          |
 V          V
O2 A --> O2 (O1 A)is a pullback.  This says in a certain precise sense thatAcan be recovered from itsO1- andO2-reflections together with some information about how they fit together.  If we think ofO1andO2as subuniverses or subtoposes, then the fracture theorem says that their "union", or more precisely their *gluing*, is the whole universe.We will prove the fracture theorem holds under the assumptions thatO2is lex, and thatO1-connected types areO2-modal.  Note that like lex-ness, the latter is also a "large" hypothesis.  But also as with lex-ness, rather than hypothesize it polymorphically with a module type, we just hypothesize it in the obvious way and allow the polymophism of the resulting theorem to be computed automatically.  This actually gives more precise information: the fracture theorem for a particular typeAonly depends on this hypothesis for typesBlying in the same universe asA.  (In fact, as we will see, it only needs the special cases of the fibers oftoO1A, but in examples it seems no harder to verify the general case.)It may sometimes happen that in addition, the "intersection" ofO1andO2is trivial.  This is naturally expressed in the context of the fracture theorem by saying thatO2-modal types areO1-connected, i.e. the converse of the second hypothesis of our fracture theorem.  When this also holds, we can show that the universeTypecan actually be reconstructed, up to equivalence, from the universes ofO1- andO2-modal types and theO2-reflection from the first to the second, using the "Artin gluing construction" from topos theory.The fracture theoremSectionFractureTheorem.Context(O1O2:Modality).Definitionfracture_square(A:Type):O_functorO2(toO1A)otoO2A==toO2(O1A)otoO1A:=to_O_naturalO2(toO1A).Here are the hypotheses of the fracture theoremContext`{LexO2}.DefinitionGluable:Type:=forall(A:Type),IsConnectedO1A->InO2A.Context(ino2_isconnectedo1:Gluable).The fracture theorem.Definitionispullback_fracture_squareA:IsPullback(fracture_squareA).Proof.applyispullback_symm.nrefine(ispullback_connmap_mapino_commsqO2_).1-3:exact_.2:rapplymapinO_between_inO.introsx;refine(ino2_isconnectedo1__).Defined.The fracture gluing theoremWe now also assume the converse of the second hyopthesisDefinitionDisjoint:Type:=forall(A:Type),InO2A->IsConnectedO1A.Context(isconnectedo1_ino2:Disjoint).This implies that the universe decomposes into anO1-part, anO2-part, and a gluing map.  We define these pieces separately in order to make the maps transparent but the homotopies opaque.Definitionfracture_glue_uncurried: {B:Type_O1& {C:Type_O2&C->O2B}} ->Type:=funBCf=>PullbackBCf.2.2 (toO2BCf.1).Definitionfracture_glue(BC:Type) `{HB:InO1B} `{HC:InO2C} (f:C->O2B):Type:=fracture_glue_uncurried((B;HB);((C;HC);f)).Definitionfracture_unglue:Type-> {B:Type_O1& {C:Type_O2&C->O2B}}:=funA=> ((O1A;O_inOA) ; ((O2A;O_inOA) ;O_functorO2(toO1A))).Definitionfracture_unglue_isretr`{Univalence}(BCf: {B:Type_O1& {C:Type_O2&C->O2B}}):fracture_unglue(fracture_glue_uncurriedBCf) =BCf.Proof.destructBCfas[B[Cf]].The first two components of our path will be applications of univalence.  We begin by observing that maps we will use are equivalences.assert(IsEquiv(O_rec((toO2B)^*'f))).{applyisequiv_O_rec_O_inverts.applyO_inverts_conn_map,conn_map_pullback'.introsob;applyisconnectedo1_ino2.rapplymapinO_between_inO. }assert(IsEquiv(O_rec(f^* (toO2B)))).{applyisequiv_O_rec_O_inverts.applyO_inverts_conn_map,conn_map_pullback;exact_. }Now we start building the path.simplerefine(path_sigma'___).{applypath_TypeO;unfold".1", ".2".refine(path_universe(O_rec((toO2B)^*'f))). }refine(transport_sigma'__@_);unfold".1", ".2".simplerefine(path_sigma'___).{applypath_TypeO;unfold".1", ".2".refine(path_universe(O_rec(f^* (toO2B)))). }It remains to identify the induced function with the givenf.  We begin with some boilerplate.applypath_arrow;introsc.refine(transport_arrow_toconst___@_).refine(transport_arrow_fromconst(C:=funX:Type_O1=>O2X)___@_).refine(transport_composeO2(TypeO_pr1O1)__@_).refine(transport_composeidmapO2__@_).Now we have to compute through the action ofapandtransporton paths in sigmas and the universe.  In applying these it helps to specify a couple of intermediate steps explicitly.transitivity(transportidmap(apO2(path_universe(O_rec((toO2B)^*'f))))(O_functorO2(toO1(Pullbackf(toO2B)))((O_rec(f^* (toO2B)))^-1c)));[applyap11;repeatapplyap|transitivity(O_functorO2(O_rec((toO2B)^*'f))(O_functorO2(toO1(Pullbackf(toO2B)))((O_rec(f^* (toO2B)))^-1c))) ].+refine(pr1_path_sigma_uncurried_@eisretrpr1_).+refine(transport_composeidmap(TypeO_pr1O2)(path_TypeOO2(O2(Pullbackf(toO2B));_)C_)^c@_).refine(ap(funp=>transportidmappc) (ap_V__) @_).refine(ap(funp=>transportidmapp^c)(pr1_path_sigma_uncurried_@eisretrpr1_) @_).refine(transport_path_universe_V__).+refine(ap(funp=>transportidmapp_)(ap_O_path_universeO2_) @_).refine(transport_path_universe__).Now we're down to the real point.+refine((O_functor_composeO2___)^ @_).refine(O_functor_homotopyO2__(O_rec_beta_)_@_).revertc;equiv_intro(O_rec(f^* (toO2B)))x.refine(ap_(eissect__) @_).revertx;applyO_indpaths;introsx.refine(to_O_naturalO2_x@_).refine(_@apf(O_rec_beta__)^).destructxas[a[bq]];exact(q^).Qed.Definitionfracture_unglue_issect`{Univalence} (A:Type):fracture_glue_uncurried(fracture_unglueA) =A.Proof.applypath_universe_uncurried,equiv_inverse.exact(Build_Equiv__(pullback_corec(fracture_squareA))(ispullback_fracture_squareA)).Qed.Definitionisequiv_fracture_unglue`{Univalence}:IsEquivfracture_unglue:=isequiv_adjointifyfracture_ungluefracture_glue_uncurriedfracture_unglue_isretrfracture_unglue_issect.Definitionequiv_fracture_unglue`{Univalence}:Type<~> {B:Type_O1& {C:Type_O2&C->O2B}}:=Build_Equiv__fracture_unglueisequiv_fracture_unglue.EndFractureTheorem.The propositional fracture theoremAn easy example of the lex-modal fracture theorem is supplied by the open and closed modalities for an hpropU.Definitiongluable_open_closed`{Funext} (U:HProp):Gluable(OpU) (ClU).Proof.introsA.change(Contr(U->A) -> (U->ContrA));intros?u.apply(Build_Contr_(center(U->A)u));introsa.exact(ap10(path_contr_(fun_=>a))u).Defined.Definitiondisjoint_open_closed`{Funext} (U:HProp):Disjoint(OpU) (ClU).Proof.introsA.change((U->ContrA) ->Contr(U->A));introsuc.apply(Build_Contr_(funu=>leti:=ucuincenterA)).introsf;applypath_arrow;introsu.pose(ucu);applypath_contr.Defined.We can also prove the same thing without funext if we use the nullification versions of these modalities.Definitiongluable_open_closed'(U:HProp):Gluable(Op'U) (Cl'U).Proof.introsA?u;simplin*.poseproof(contr_inhabited_hpropUu).assert(ContrA).{simplerefine(contr_equiv(Op'UA)_).-refine(O_recidmap).intros[];simpl.applyooextendable_equiv.refine(equiv_isequiv(@equiv_contr_contrUUnit__)).-refine(isequiv_adjointify_(to(Op'U)A)__).+introsa;applyO_rec_beta.+applyO_indpaths;cbn.reflexivity. }applyooextendable_contr;exact_.Defined.Definitiondisjoint_open_closed'(U:HProp):Disjoint(Op'U) (Cl'U).Proof.introsAAn.applyisconnected_from_elim;introsCCnf.simplerefine(@local_rec_CCntt_tt;_);simpl.-introsu.exact(f(@local_rec_AAnuEmpty_rectt)).-introsa;simpl.refine(@local_indpaths_CCntt(fun_=>fa)__tt);introsu;simplin*.refine(_@ (@local_rec_beta_CCntt_u)^).applyap.exact(@local_indpaths_AAnu(fun_=>a)_(Empty_ind_)tt).Defined.

--- Miscellaneous\FreeAbelianGroup.html ---
FreeAbelianGroupLibrary FreeAbelianGroupRequireImportBasics.OvertureBasics.TacticsBasics.Equivalences.RequireImportTypes.SigmaTypes.ForallTypes.Paths.RequireImportWildCat.CoreWildCat.EquivGpdWildCat.Universe.RequireImportAlgebra.AbGroups.AbelianGroupAlgebra.AbGroups.Abelianization.RequireImportAlgebra.Groups.FreeGroup.RequireImportSpaces.List.Core.Free Abelian GroupsDefinitionFactorsThroughFreeAbGroup(S:Type) (F_S:AbGroup)(i:S->F_S) (A:AbGroup) (g:S->A) :Type:= {f:F_S$->A&foi==g}.Universal property of a free abelian group on a set (type).ClassIsFreeAbGroupOn(S:Type) (F_S:AbGroup) (i:S->F_S):=contr_isfreeabgroupon:forall(A:AbGroup) (g:S->A),Contr(FactorsThroughFreeAbGroupSF_SiAg).Global Existing Instancecontr_isfreeabgroupon.A abelian group is free if there exists a generating type on which it is a free group (a basis).ClassIsFreeAbGroup(F_S:AbGroup):=isfreegroup: {S:_& {i:_&IsFreeAbGroupOnSF_Si}}.Global Instanceisfreeabgroup_isfreeabgroupon(S:Type) (F_S:AbGroup) (i:S->F_S){H:IsFreeAbGroupOnSF_Si}:IsFreeAbGroupF_S:= (S;i;H).The abelianization of the free group on a set is the free abelian group.DefinitionFreeAbGroup(S:Type) :AbGroup:=abel(FreeGroupS).ArgumentsFreeAbGroupS:simplnever.Definitionfreeabgroup_in{S:Type} :S->FreeAbGroupS:=abel_unitofreegroup_in.DefinitionFreeAbGroup_rec{S:Type} {A:AbGroup} (f:S->A):FreeAbGroupS$->A:=grp_homo_abel_rec(FreeGroup_rec__f).DefinitionFreeAbGroup_rec_beta_in{S:Type} {A:AbGroup} (f:S->A):FreeAbGroup_recfofreeabgroup_in==f:=fun_=>idpath.DefinitionFreeAbGroup_ind_homotopy{X:Type} {A:AbGroup}{ff':FreeAbGroupX$->A}(p:forallx,f(freeabgroup_inx) =f'(freeabgroup_inx)):f$==f'.Proof.snrapplyabel_ind_homotopy.snrapplyFreeGroup_ind_homotopy.snrapplyp.Defined.The abelianization of a free group on a set is a free abelian group on that set.Global Instanceisfreeabgroupon_isabelianization_isfreegroup`{Funext}{S:Type} {G:Group} {A:AbGroup} (f:S->G) (g:G$->A){H1:IsAbelianizationAg} {H2:IsFreeGroupOnSGf}:IsFreeAbGroupOnSA(gof).Proof.unfoldIsFreeAbGroupOn.introsBh.specialize(H2Bh).revertH2.unfoldFactorsThroughFreeGroup,FactorsThroughFreeAbGroup.snrapplycontr_equiv'.symmetry.exact(equiv_functor_sigma_pb(equiv_group_precomp_isabelianizationgB)).Defined.As a special case, the free abelian group is a free abelian group.Global Instanceisfreeabgroup_freeabgroup`{Funext} (S:Type):IsFreeAbGroup(FreeAbGroupS).Proof.existsS,freeabgroup_in.srapplyisfreeabgroupon_isabelianization_isfreegroup.Defined.Functoriality follows from the functoriality ofabelandFreeGroup.Global Instanceis0functor_freeabgroup:Is0FunctorFreeAbGroup:=_.Global Instanceis1functor_freeabgroup:Is1FunctorFreeAbGroup:=_.

--- Miscellaneous\FreeGroup.html ---
FreeGroupLibrary FreeGroupRequireImportBasicsTypesGroupSubgroupWildCat.CoreWildCat.UniverseColimits.CoeqTruncations.CoreTruncations.SeparatedTruncSpaces.List.CoreSpaces.List.Theory.Local OpenScopemc_scope.Local OpenScopemc_mult_scope.IsFreeGroupis defined in Group.v. In this file we construct free groups and and prove properties about them.We construct the free group on a typeAas a higher inductive type. This construction is due to Kraus-Altenkirch 2018 arXiv:1805.02069. Their construction is actually more general, but we set-truncate it to suit our needs which is the free group as a set. This is a very simple HIT in a similar manner to the abelianization HIT used in Algebra.AbGroup.Abelianization.SectionReduction.Universeu.Context(A:Type@{u}).Local OpenScopelist_scope.We define words (with inverses) on A to be lists of marked elements of ALocal DefinitionWords:Type@{u} :=list(A+A).Given a marked element of A we can change its markLocal Definitionchange_sign:A+A->A+A:=equiv_sum_symmAA.We introduce a local notation forchange_sign. It is only defined in this section however.Local Notation"a ^" := (change_signa).Changing sign is an involutionLocal Definitionchange_sign_inva:a^^ =a.Proof.bydestructa.Defined.Now we wish to define the free group on A as the following HIT:HIT N(A) : hSet
     | eta : Words -> N(A)
     | tau (x : Words) (a : A + A) (y : Words)
         : eta (x ++a++a^++ y) = eta (x ++ y).Since we cannot write our HITs directly like this (without resorting to private inductive types), we will construct this HIT out of HITs we know. In fact, we can define N(A) as a coequalizer.Local Definitionmap1:Words* (A+A) *Words->Words.Proof.intros[[xa]y].exact(x++ [a] ++ [a^] ++y).Defined.Argumentsmap1_/.Local Definitionmap2:Words* (A+A) *Words->Words.Proof.intros[[xa]y].exact(x++y).Defined.Argumentsmap2_/.Now we can define the underlying type of the free group as the 0-truncated coequalizer of these two mapsDefinitionfreegroup_type:Type:=Tr0 (Coeqmap1map2).This is the point constructorDefinitionfreegroup_eta:Words->freegroup_type:=trocoeq.This is the path constructorDefinitionfreegroup_tau(x:Words) (a:A+A) (y:Words):freegroup_eta(x++ [a] ++ [a^] ++y) =freegroup_eta(x++y).Proof.applypath_Tr,tr.exact((cglue(x,a,y))).Defined.The group operationGlobal Instancesgop_freegroup:SgOpfreegroup_type.Proof.introsxy.strip_truncations.revertx;snrapplyCoeq_rec.{introsx;reverty.snrapplyCoeq_rec.{introsy.exact(freegroup_eta(x++y)). }intros[[ya]z];simpl.change(freegroup_eta(x++y++ ([a] ++ [a^] ++z))=freegroup_eta(x++y++z)).rhsnrapplyap.2:nrapplyapp_assoc.lhsnrapplyap.1:nrapplyapp_assoc.nrapply(freegroup_tau_a). }intros[[cb]d].reverty.srapplyCoeq_ind_hprop.introa.change(freegroup_eta((c++ [b] ++ [b^] ++d) ++a)=freegroup_eta((c++d) ++a)).lhs_Vnrapplyap.1:nrapplyapp_assoc.lhs_Vnrapply(ap(funx=>freegroup_eta(c++x))).1:nrapplyapp_assoc.lhs_Vnrapply(ap(funx=>freegroup_eta(c++_++x))).1:nrapplyapp_assoc.rhs_Vnrapplyap.2:nrapplyapp_assoc.nrapplyfreegroup_tau.Defined.The unit of the free group is the empty wordGlobal Instancemonunit_freegroup_type:MonUnitfreegroup_type:=freegroup_etanil.We can change the sign of all the elements in a word and reverse the order. This will be the inversion in the groupDefinitionword_change_sign(x:Words) :Words:=reverse(list_mapchange_signx).Changing the sign changes the order of word concatenationDefinitionword_change_sign_ww(xy:Words):word_change_sign(x++y) =word_change_signy++word_change_signx.Proof.unfoldword_change_sign.lhsnrapply(apreverse).1:nrapplylist_map_app.nrapplyreverse_app.Defined.This is also involutiveLemmaword_change_sign_invx:word_change_sign(word_change_signx) =x.Proof.unfoldword_change_sign.lhs_Vnrapplylist_map_reverse.lhsnrapplyap.1:nrapplyreverse_reverse.lhs_Vnrapplylist_map_compose.snrapplylist_map_id.introsa?.applychange_sign_inv.Defined.Changing the sign gives us left inversesLemmaword_concat_Vwx:freegroup_eta(word_change_signx++x) =mon_unit.Proof.inductionx.1:reflexivity.lhsnrapply(ap(funx=>freegroup_eta(x++_))).1:nrapplyreverse_cons.change(freegroup_eta((word_change_signx++ [a^]) ++ [a] ++x)=mon_unit).lhs_Vnrapplyap.1:nrapplyapp_assoc.set(a':=a^).rewrite<- (change_sign_inva).lhsnrapplyfreegroup_tau.applyIHx.Defined.And since changing the sign is involutive we get right inverses from left inversesLemmaword_concat_wVx:freegroup_eta(x++word_change_signx) =mon_unit.Proof.set(x':=word_change_signx).rewrite<- (word_change_sign_invx).change(freegroup_eta(word_change_signx'++x') =mon_unit).applyword_concat_Vw.Defined.Negation is defined by changing the order of a word that appears in eta. Most of the work here is checking that it is agreeable with the path constructor.Global Instancenegate_freegroup_type:Negatefreegroup_type.Proof.introx.strip_truncations.revertx;srapplyCoeq_rec.{introx.applyfreegroup_eta.exact(word_change_signx). }intros[[ba]c].unfoldmap1,map2.lhsnrapplyap.{lhsnrapplyword_change_sign_ww.nrapply(ap(funx=>x++_)).lhsnrapplyword_change_sign_ww.nrapply(ap(funx=>x++_)).lhsnrapplyword_change_sign_ww.nrapply(ap(funx=>_++x)).nrapply(word_change_sign_inv[a]). }lhs_Vnrapplyap.1:rhs_Vnrapplyapp_assoc.1:nrapplyapp_assoc.rhsnrapplyap.2:nrapplyword_change_sign_ww.nrapplyfreegroup_tau.Defined.Now we can start to prove the group laws. Since these are hprops we can ignore what happens with the path constructor.Our operation is associativeGlobal Instanceassociative_freegroup_type:Associativesg_op.Proof.introsxyz.strip_truncations.revertx;srapplyCoeq_ind_hprop;introx.reverty;srapplyCoeq_ind_hprop;introy.revertz;srapplyCoeq_ind_hprop;introz.nrapply(ap(trocoeq)).nrapplyapp_assoc.Defined.Left identityGlobal Instanceleftidentity_freegroup_type:LeftIdentitysg_opmon_unit.Proof.rapplyTrunc_ind.srapplyCoeq_ind_hprop;introsx.reflexivity.Defined.Right identityGlobal Instancerightidentity_freegroup_type:RightIdentitysg_opmon_unit.Proof.rapplyTrunc_ind.srapplyCoeq_ind_hprop;introsx.apply(aptr),ap.nrapplyapp_nil.Defined.Left inverseGlobal Instanceleftinverse_freegroup_type:LeftInversesg_opnegatemon_unit.Proof.rapplyTrunc_ind.srapplyCoeq_ind_hprop;introx.applyword_concat_Vw.Defined.Right inverseGlobal Instancerightinverse_freegroup_type:RightInversesg_opnegatemon_unit.Proof.rapplyTrunc_ind.srapplyCoeq_ind_hprop;introx.applyword_concat_wV.Defined.Finally we have defined the free group onADefinitionFreeGroup:Group.Proof.snrapply(Build_Groupfreegroup_type);repeatsplit;exact_.Defined.Definitionword_rec(G:Group) (s:A->G) :A+A->G.Proof.intros[x|x].-exact(sx).-exact(-sx).Defined.When we have a list of words we can recursively define a group element. The obvious choice would be to mapnilto the identity andx::xstox*words_recxs. This has the disadvantage that a single generating element gets mapped tox*1instead ofx. To fix this issue, we mapnilto the identity, the singleton to the element we want, and do the rest recursively.Definitionwords_rec(G:Group) (s:A->G) :Words->G.Proof.introxs.inductionxsas[|x[|yxs]IHxs].-exactmon_unit.-exact(word_recGsx).-exact(word_recGsx*IHxs).Defined.Definitionwords_rec_cons(G:Group) (s:A->G) (x:A+A) (xs:Words):words_recGs(x::xs)%list=word_recGsx*words_recGsxs.Proof.inductionxsinx|- *.-symmetry;nrapplygrp_unit_r.-reflexivity.Defined.Lemmawords_rec_pp(G:Group) (s:A->G)  (xy:Words):words_recGs(x++y) =words_recGsx*words_recGsy.Proof.inductionxas[|xxsIHxs]iny|- *.-symmetry;nrapplygrp_unit_l.-change((?x:: ?xs) ++y)with(x::xs++y).lhsnrapplywords_rec_cons.lhsnrapplyap.1:nrapplyIHxs.lhsnrapplygrp_assoc.nrapply(ap(.*_)).symmetry.applywords_rec_cons.Defined.Lemmawords_rec_coh(G:Group) (s:A->G) (a:A+A) (bc:Words):words_recGs(map1(b,a,c)) =words_recGs(map2(b,a,c)).Proof.unfoldmap1,map2.rhsnrapply(words_rec_ppGs).lhsnrapplywords_rec_pp.nrapply(ap(_*.)).lhsnrapplywords_rec_pp.lhsnrapplyap.1:nrapplywords_rec_pp.lhsnrapplygrp_assoc.rhs_Vnrapplygrp_unit_l.nrapply(ap(.*_)).destructa;simpl.-nrapplygrp_inv_r.-nrapplygrp_inv_l.Defined.Given a groupGwe can construct a group homomorphismFreeGroupA->Gif we have a mapA->G.DefinitionFreeGroup_rec(G:Group) (s:A->G):GroupHomomorphismFreeGroupG.Proof.snrapplyBuild_GroupHomomorphism.{rapplyTrunc_rec.srapplyCoeq_rec.1:applywords_rec,s.intros[[ba]c].applywords_rec_coh. }introsxy;strip_truncations.revertx;srapplyCoeq_ind_hprop;introx.reverty;srapplyCoeq_ind_hprop;introy.simpl.applywords_rec_pp.Defined.Definitionfreegroup_in:A->FreeGroup:=freegroup_etao(funx=> [x])oinl.DefinitionFreeGroup_rec_beta{G:Group} (f:A->G):FreeGroup_rec_fofreegroup_in==f:=fun_=>idpath.Coercionfreegroup_in:A>->group_type.DefinitionFreeGroup_ind_hprop'(P:FreeGroup->Type)`{forallx,IsHProp(Px)}(H1:forallw,P(freegroup_etaw)):forallx,Px.Proof.rapplyTrunc_ind.srapplyCoeq_ind_hprop.exactH1.Defined.DefinitionFreeGroup_ind_hprop(P:FreeGroup->Type)`{forallx,IsHProp(Px)}(H1:Pmon_unit)(Hin:forallx,P(freegroup_inx))(Hop:forallxy,Px->Py->P(-x*y)):forallx,Px.Proof.rapplyFreeGroup_ind_hprop'.introsw.inductionwas[|awIHw].-exactH1.-destructaas[a|a].+change(P((freegroup_ina) *freegroup_etaw)).rewrite<- (grp_inv_inva).applyHop.*rewrite<-grp_unit_r.byapplyHop.*assumption.+change(P(-(freegroup_ina) *freegroup_etaw)).byapplyHop.Defined.DefinitionFreeGroup_ind_homotopy{G:Group} {ff':FreeGroup$->G}(H:forallx,f(freegroup_inx) =f'(freegroup_inx)):f$==f'.Proof.rapplyFreeGroup_ind_hprop.-exact(concat(grp_homo_unitf) (grp_homo_unitf')^).-exactH.-introsxypq.refine(grp_homo_op_agreeff'_q).lhsnrapplygrp_homo_inv.rhsnrapplygrp_homo_inv.exact(ap_p).Defined.Now we need to prove that the free group satisifes the unviersal property of the free group.  TODO: remove funext from here and universal property of free groupGlobal Instanceisfreegroupon_freegroup`{Funext}:IsFreeGroupOnAFreeGroupfreegroup_in.Proof.introsGf.snrapplyBuild_Contr.{srefine(_;_);simpl.1:applyFreeGroup_rec,f.introx;reflexivity. }intros[gh].nrapplypath_sigma_hprop; [exact_|].simpl.applyequiv_path_grouphomomorphism.symmetry.snrapplyFreeGroup_ind_homotopy.exacth.Defined.Typeclass search can already find this but we leave it here as a definition for reference.Definitionisfreegroup_freegroup`{Funext} :IsFreeGroupFreeGroup:=_.EndReduction.Argumentsfreegroup_eta{A}.Argumentsfreegroup_in{A}.Properties of free groups(* Given a function on the generators, there is an induced group homomorphism from the free group. *)Definitionisfreegroupon_rec{S:Type} {F_S:Group}{i:S->F_S} `{IsFreeGroupOnSF_Si}{G:Group} (f:S->G) :F_S$->G:= (center(FactorsThroughFreeGroupSF_SiGf)).1.(* The propositional computation rule for the recursor. *)Definitionisfreegroupon_rec_beta{S:Type} {F_S:Group} {i:S->F_S} `{IsFreeGroupOnSF_Si}{G:Group} (f:S->G):isfreegroupon_recfoi==f:= (center(FactorsThroughFreeGroupSF_SiGf)).2.(* Two homomorphisms from a free group are equal if they agree on the generators. *)Definitionpath_homomorphism_from_free_group{S:Type}{F_S:Group} {i:S->F_S} `{IsFreeGroupOnSF_Si}{G:Group} (fg:F_S$->G) (K:foi==goi):f=g.Proof.(* By assumption, the typeFactorsThroughFreeGroupSF_SiG(goi)of factorizations ofgoithroughiis contractible.  Therefore the two elements we have are equal.  Therefore, their first components are equal. *)exact(path_contr(f;K) (g;funx=>idpath))..1.Defined.Global Instanceisequiv_isfreegroupon_rec`{Funext} {S:Type}{F_S:Group} {i:S->F_S} `{IsFreeGroupOnSF_Si} {G:Group}:IsEquiv(@isfreegroupon_recSF_Si_G).Proof.apply(isequiv_adjointifyisfreegroupon_rec(funf=>foi)).-introf.applypath_homomorphism_from_free_group.applyisfreegroupon_rec_beta.-introf.(* here we needFunext: *)applypath_arrow,isfreegroupon_rec_beta.Defined.The universal property of a free group.Definitionequiv_isfreegroupon_rec`{Funext} {GF:Group} {A:Type}{i:A->F} `{IsFreeGroupOnAFi}: (A->G) <~> (F$->G) :=Build_Equiv__isfreegroupon_rec_.The above theorem is true regardless of the implementation of free groups. This lets us state the more specific theorem about the canonical free groups. This can be read asFreeGroupis left adjoint to the forgetful functorgroup_type.Definitionequiv_freegroup_rec`{Funext} (G:Group) (A:Type): (A->G) <~> (FreeGroupA$->G):=equiv_isfreegroupon_rec.Global Instanceishprop_isfreegroupon`{Funext} (F:Group) (A:Type) (i:A->F):IsHProp(IsFreeGroupOnAFi).Proof.unfoldIsFreeGroupOn.applyistrunc_forall.Defined.Both ways of stating the universal property are equivalent.Definitionequiv_isfreegroupon_isequiv_precomp`{Funext}(F:Group) (A:Type) (i:A->F):IsFreeGroupOnAFi<~>forallG,IsEquiv(funf:F$->G=>foi).Proof.srapplyequiv_iff_hprop.1:intros? ?;exact(equiv_isequiv(equiv_isfreegroupon_rec)^-1).introskGg.specialize(kG).snrapplycontr_equiv'.1:exact(hfiber(funfx=>grp_homo_mapf(ix))g).{rapplyequiv_functor_sigma_id.introy;symmetry.applyequiv_path_forall. }exact_.Defined.Subgroups of free groups(* We say that a groupGis generated by a subtypeXif the natural map from the subgroup generated byXtoGis a surjection.  One could equivalently sayIsEquiv(subgroup_incl(subgroup_generatedX)),forallg,subgroup_generatedXg, orsubgroup_generatedX=maximal_subgroup, but the definition using surjectivity is convenient later. *)Definitionisgeneratedby(G:Group) (X:G->Type):=IsSurjection(subgroup_incl(subgroup_generatedX)).SectionFreeGroupGenerated.(* In this Section, we prove that the free groupF_Son a typeSis generated in the above sense by the image ofS.  We conclude that the inclusion map is an equivalence, and that the free group is isomorphic as a group to the subgroup. We show that the inclusion is a surjection by showing that it is split epi in the category of groups. *)Context{S:Type} {F_S:Group} {i:S->F_S} `{IsFreeGroupOnSF_Si}.(* We define a group homomorphism fromF_Sto the subgroupGgenerated bySby sending a generatorsto "itself".  This map will be a section of the inclusion map. *)Local Definitionto_subgroup_generated:F_S$->subgroup_generated(hfiberi).Proof.applyisfreegroupon_rec.intros.snrapplysubgroup_generated_gen_incl.-exact(is).-exact(s;idpath).Defined.(* We record the computation rule thatto_subgroup_generatedsatisfies. *)Local Definitionto_subgroup_generated_beta(s:S):to_subgroup_generated(is) =subgroup_generated_gen_incl(is) (s;idpath):=isfreegroupon_rec_beta__.(* It follows thatto_subgroup_generatedis a section of the inclusion map fromGtoF_S. *)Local Definitionis_retraction: (subgroup_incl_) $oto_subgroup_generated=grp_homo_id.Proof.applypath_homomorphism_from_free_group;cbn.intros.exact(appr1(to_subgroup_generated_betas)).Defined.(* It follows that the inclusion map is a surjection, i.e., thatF_Sis generated by the image ofS. *)Definitionisgenerated_isfreegroupon:isgeneratedbyF_S(hfiberi).Proof.snrapplyissurj_retr.-applyto_subgroup_generated.-applyap10;cbn.exact(apgrp_homo_mapis_retraction).Defined.(* Therefore, the inclusion map is an equivalence, since it is known to be an embedding. *)Definitionisequiv_subgroup_incl_freegroupon:IsEquiv(subgroup_incl(subgroup_generated(hfiberi))).Proof.applyisequiv_surj_emb.-applyisgenerated_isfreegroupon.-exact_.Defined.(* Therefore, the subgroup is isomorphic to the free group. *)Definitioniso_subgroup_incl_freegroupon:GroupIsomorphism(subgroup_generated(hfiberi))F_S.Proof.nrapplyBuild_GroupIsomorphism.applyisequiv_subgroup_incl_freegroupon.Defined.EndFreeGroupGenerated.FunctorialityGlobal Instanceis0functor_freegroup:Is0FunctorFreeGroup.Proof.snrapplyBuild_Is0Functor.introsXYf.snrapplyFreeGroup_rec.exact(freegroup_inof).Defined.Global Instanceis1functor_freegroup:Is1FunctorFreeGroup.Proof.snrapplyBuild_Is1Functor.-introsXYfgp.snrapplyFreeGroup_ind_homotopy.introsx.exact(apfreegroup_in(px)).-introsX.bysnrapplyFreeGroup_ind_homotopy.-introsXYZfg.bysnrapplyFreeGroup_ind_homotopy.Defined.

--- Miscellaneous\FreeInt.html ---
FreeIntLibrary FreeIntRequireImportBasicsTypesWildCat.CoreTruncations.CoreSpaces.IntAbelianGroupAbHomCentralizerAbProjectiveGroups.FreeGroupAbGroups.Z.The free group on one generatorWe can define the integers as the free group on one generator, which we denoteZ1below. Results from Centralizer.v and Groups.FreeGroup let us show thatZ1is abelian.We defineZ1as the free group with a single generator.DefinitionZ1:=FreeGroupUnit.DefinitionZ1_gen:Z1:=freegroup_intt.(* The generator *)The recursion principle ofZ1and its computation rule.DefinitionZ1_rec{G:Group} (g:G) :Z1$->G:=FreeGroup_recUnitG(unit_nameg).DefinitionZ1_rec_beta{G:Group} (g:G) :Z1_recgZ1_gen=g:=FreeGroup_rec_beta___.The free groupZ1on one generator is isomorphic to the subgroup ofZ1generated by the generator.  And such cyclic subgroups are known to be commutative, bycommutative_cyclic_subgroup.Global InstanceZ1_commutative`{Funext} :Commutative(@group_sgopZ1):=commutative_iso_commutativeiso_subgroup_incl_freegroupon.(* TODO:Funextis used inisfreegroupon_freegroup, but there is a comment there saying that it can be removed.  If that is done, can remove it from many results in this file. A different proof of this result, directly using the construction of the free group, could probably also avoidFunext. *)Definitionab_Z1`{Funext} :AbGroup:=Build_AbGroupZ1_.The universal property ofab_Z1.Lemmaequiv_Z1_hom@{uv|u<v} `{Funext} (A:AbGroup@{u}):GroupIsomorphism(ab_hom@{uv}ab_Z1@{uv}A)A.Proof.snrapplyBuild_GroupIsomorphism'.-refine(_oE(equiv_freegroup_rec@{uuuv}AUnit)^-1).symmetry.refine(Build_Equiv__(funa=>unit_namea)_).-introsfg.cbn.reflexivity.Defined.Definitionnat_to_Z1:nat->Z1:=funn=>grp_powZ1_genn.DefinitionZ1_mul_nat`{Funext} (n:nat) :ab_Z1$->ab_Z1:=Z1_rec(nat_to_Z1n).LemmaZ1_mul_nat_beta{A:AbGroup} (a:A) (n:nat):Z1_reca(nat_to_Z1n) =ab_mulna.Proof.inductionnas[|nH].1:done.exact(grp_pow_natural___).Defined.ab_Z1is projective.Global Instanceab_Z1_projective`{Funext}:IsAbProjectiveab_Z1.Proof.introsABpfH1.poseproof(a:= @center_(H1(fZ1_gen))).strip_truncations.snrefine(tr(Z1_reca.1;_)).cbnbeta.applyap10.applyap.(* of the coerciongrp_homo_map*)applypath_homomorphism_from_free_group.simpl.intros[].exacta.2.Defined.The map sending the generator to1:Int.DefinitionZ1_to_Z`{Funext} :ab_Z1$->abgroup_Z:=Z1_rec(G:=abgroup_Z) 1%int.TODO:  Prove thatZ1_to_Zis a group isomorphism.

--- Miscellaneous\FreeIntQuotient.html ---
FreeIntQuotientLibrary FreeIntQuotientRequireImportHoTT.BasicsHoTT.Types.RequireImportSpaces.IntSpaces.Circle.RequireImportColimits.CoeqHIT.FlatteningTruncations.CoreTruncations.Connectedness.Local OpenScopepath_scope.Quotients by free actions ofIntWe will show that ifIntacts freely on a set, then the set-quotient of that action can be defined without a 0-truncation, giving it a universal property for mapping into all types.SectionFreeIntAction.Context`{Univalence}.Context(R:Type) `{IsHSetR}.A free action byIntis the same as a single autoequivalencef(the action of1) whose iterates are all pointwise distinct.Context(f:R<~>R)(f_free:forall(r:R) (nm:Int),(int_iterfnr=int_iterfmr) -> (n=m)).We can then define the quotient to be the coequalizer offand the identity map.  This gives it the desired universal property for all types; it remains to show that this definition gives a set.LetRmodZ:=Coeqfidmap.Together,Randfdefine a fibration overCircle.  By the flattening lemma, its total space is equivalent to the quotient.Global Instanceisset_RmodZ:IsHSetRmodZ.Proof.nrefine(istrunc_equiv_istrunc{z:Circle&Circle_recTypeR(path_universef)z}(_oE(@equiv_flattening_UnitUnitidmapidmap(fun_=>R) (fun_=>f))^-1oE_));tryexact_.-unshelverapplyequiv_adjointify.+simplerefine(Wtil_rec___).*introsur;exact(coeqr).*introsur;cbn.exact((cgluer)^).+simplerefine(Coeq_rec___).*exact(ccttt).*introsr;exact((pptttr)^).+refine(Coeq_ind_(funa=> 1)_);cbn;introsb.rewritetransport_paths_FlFr,concat_p1,ap_idmap.applymoveR_Vp;rewriteconcat_p1.rewriteap_compose.rewrite(Coeq_rec_beta_cglue(WtilUnitUnitidmapidmap(unit_nameR) (unit_namef))(ccttt) (funr=> (pptttr)^)b).rewriteap_V;symmetry.refine(inverse2(Wtil_rec_beta_pptRmodZ(unit_name(funr=>coeqr))(unit_name(funr=> (cgluer)^))ttb) @inv_V_).+simplerefine(Wtil_ind___);cbn.{intros[] ?;reflexivity. }intros[]r;cbn.rewritetransport_paths_FlFr,concat_p1,ap_idmap.applymoveR_Vp;rewriteconcat_p1.rewriteap_compose.refine(_@ap(ap_) (Wtil_rec_beta_pptRmodZ(unit_name(funr=>coeqr))(unit_name(funr=> (cgluer)^))ttr)^).rewriteap_V.rewrite(Coeq_rec_beta_cglue(WtilUnitUnitidmapidmap(unit_nameR) (unit_namef))(ccttt) (funr0:R=> (pptttr0)^)r).symmetry;applyinv_V.-applyequiv_functor_sigma_id;introsx.applyequiv_path.revertx;refine(Circle_ind_1_);cbn.rewritetransport_paths_FlFr,concat_p1.applymoveR_Vp;rewriteconcat_p1.rewriteCircle_rec_beta_loop.unfoldloop.exact(Coeq_rec_beta_cglue____).-applyistrunc_S.introsxuyv.nrefine(istrunc_equiv_istrunc(n:= -1)_(equiv_path_sigma_xuyv)).destructxuas[xu],yvas[yv];cbn.applyhprop_allpath.intros[pr] [qs].set(P:=Circle_recTypeR(path_universef))in*.assert(forallz,IsHSet(Pz)).{simplerefine(Circle_ind___);cbnbeta.-exact_.-applypath_ishprop. }applypath_sigma_hprop;cbn.assert(t:=r@s^);clearrs.assert(xb:=merely_path_is0connectedCirclebasex).assert(yb:=merely_path_is0connectedCirclebasey).strip_truncations.destructxb,yb.revertpqt.equiv_intro(equiv_loopCircle_int^-1)n.equiv_intro(equiv_loopCircle_int^-1)m.substP.rewrite!Circle_action_is_iter.introsp.applyap.exact(f_freeunmp).Qed.TODO: Prove that thisRmodZis equivalent to the set-quotient ofRby a suitably defined equivalence relation.EndFreeIntAction.

--- Miscellaneous\FreeProduct.html ---
FreeProductLibrary FreeProductRequireImportBasicsTypes.RequireImportCubical.DPath.RequireImportSpaces.List.CoreSpaces.List.Theory.RequireImportColimits.Pushout.RequireImportTruncations.CoreTruncations.SeparatedTrunc.RequireImportAlgebra.Groups.Group.RequireImportWildCat.Local OpenScopelist_scope.Local OpenScopemc_scope.Local OpenScopemc_mult_scope.In this file we define the amalgamated free product of a span of group homomorphisms as a HIT.We wish to define the amalgamated free product of a span of group homomorphisms f : G -> H, g : G -> K as the following HIT:HIT M(f,g)
   | amal_eta : list (H + K) -> M(f,g)
   | mu_H : forall (x y : list (H + K)) (h1 h2 : H),
      amal_eta (x ++inlh1,inlh2++ y) = amal_eta (x ++inl(h1*h2)++ y)
   | mu_K : forall (x y : list (H + K)) (k1 k2 : K),
      amal_eta (x ++inrk1,inrk2++ y) = amal_eta (x ++inr(k1*k2)++ y)
   | tau : forall (x y : list (H + K)) (z : G),
      amal_eta (x ++inl(fz)++ y) = amal_eta (x ++inr(gz)++ y)
   | omega_H : forall (x y : list (H + K)),
      amal_eta (x ++inlmon_unit++ y) = amal_eta (x ++ y)
   | omega_K : forall (x y : list (H + K)),
      amal_eta (x ++inrmon_unit++ y) = amal_eta (x ++ y).We will build this HIT up sucessively out of coequalizers.We will call Mamal_typeand prefix all the constructors withamal_(for amalgmated free product).SectionFreeProduct.Context(GHK:Group)(f:GroupHomomorphismGH) (g:GroupHomomorphismGK).Local DefinitionWords:Type:=list(H+K).Local Fixpointword_inverse(x:Words) :Words.Proof.destructxas[|xxs].1:exactnil.destructxas[h|k].+exact((word_inversexs) ++ [inl(-h)]).+exact((word_inversexs) ++ [inr(-k)]).Defined.Inversion changes order of concatenation.Local Definitionword_inverse_ww(xy:Words):word_inverse(x++y) =word_inversey++word_inversex.Proof.inductionxas[|xxs].1:symmetry;applyapp_nil.simpl.destructx;rhsnrapplyapp_assoc;f_ap.Defined.There are five source types for the path constructors. We will construct this HIT as the colimit of five forks going intoWords. We can bundle up this colimit as a single coequalizer.Source types of path constructorsLocal Definitionpc1:Type:=Words*H*H*Words.Local Definitionpc2:Type:=Words*K*K*Words.Local Definitionpc3:Type:=Words*G*Words.Local Definitionpc4:Type:=Words*Words.Local Definitionpc5:Type:=Words*Words.End points of the first path constructorLocal Definitionm1:pc1->Words.Proof.intros[[[xh1]h2]y].exact(x++ (inlh1:: [inlh2]) ++y).Defined.Local Definitionm1':pc1->Words.Proof.intros[[[xh1]h2]y].exact(x++ [inl(h1*h2)] ++y).Defined.End points of the second path constructLocal Definitionm2:pc2->Words.Proof.intros[[[xk1]k2]y].exact(x++ (inrk1:: [inrk2]) ++y).Defined.Local Definitionm2':pc2->Words.Proof.intros[[[xk1]k2]y].exact(x++ [inr(k1*k2)] ++y).Defined.End points of the third path constructorLocal Definitionm3:pc3->Words.Proof.intros[[xz]y].exact(x++ [inl(fz)] ++y).Defined.Local Definitionm3':pc3->Words.Proof.intros[[xz]y].exact(x++ [inr(gz)] ++y).Defined.End points of the fourth path constructorLocal Definitionm4:pc4->Words.Proof.intros[xy].exact(x++ [inlmon_unit] ++y).Defined.Local Definitionm4':pc4->Words.Proof.intros[xy].exact(x++y).Defined.End points of the fifth path constructorLocal Definitionm5:pc5->Words.Proof.intros[xy].exact(x++ [inrmon_unit] ++y).Defined.Local Definitionm5':pc5->Words.Proof.intros[xy].exact(x++y).Defined.We can then define maps going into words consisting of the corresponding endpoints of the path constructors.Local Definitionmap1:pc1+pc2+pc3+pc4+pc5->Words.Proof.intros[[[[x|x]|x]|x]|x].+exact(m1x).+exact(m2x).+exact(m3x).+exact(m4x).+exact(m5x).Defined.Local Definitionmap2:pc1+pc2+pc3+pc4+pc5->Words.Proof.intros[[[[x|x]|x]|x]|x].+exact(m1'x).+exact(m2'x).+exact(m3'x).+exact(m4'x).+exact(m5'x).Defined.Finally we can define our type as the 0-truncation of the coequalizer of these mapsDefinitionamal_type:Type:=Tr0 (Coeqmap1map2).We can define the constructorsDefinitionamal_eta:Words->amal_type:=trocoeq.Definitionamal_mu_H(xy:Words) (h1h2:H):amal_eta(x++ (cons(inlh1) [inlh2]) ++y) =amal_eta(x++ [inl(h1*h2)] ++y).Proof.unfoldamal_eta.applypath_Tr,tr.exact(cglue(inl(inl(inl(inl(x,h1,h2,y)))))).Defined.Definitionamal_mu_K(xy:Words) (k1k2:K):amal_eta(x++ (cons(inrk1) [inrk2]) ++y) =amal_eta(x++ [inr(k1*k2)] ++y).Proof.unfoldamal_eta.applypath_Tr,tr.exact(cglue(inl(inl(inl(inr(x,k1,k2,y)))))).Defined.Definitionamal_tau(xy:Words) (z:G):amal_eta(x++ [inl(fz)] ++y) =amal_eta(x++ [inr(gz)] ++y).Proof.unfoldamal_eta.applypath_Tr,tr.exact(cglue(inl(inl(inr(x,z,y))))).Defined.Definitionamal_omega_H(xy:Words):amal_eta(x++ [inlmon_unit] ++y) =amal_eta(x++y).Proof.unfoldamal_eta.applypath_Tr,tr.exact(cglue(inl(inr(x,y)))).Defined.Definitionamal_omega_K(xy:Words):amal_eta(x++ [inrmon_unit] ++y) =amal_eta(x++y).Proof.unfoldamal_eta.applypath_Tr,tr.exact(cglue(inr(x,y))).Defined.Now we can derive the dependent eliminatorDefinitionamal_type_ind(P:amal_type->Type) `{forallx,IsHSet(Px)}(e:forallw,P(amal_etaw))(mh:forall(xy:Words) (h1h2:H),DPathP(amal_mu_Hxyh1h2) (e(x++ (inlh1:: [inlh2]) ++y)) (e(x++ [inl(h1*h2)] ++y)))(mk:forall(xy:Words) (k1k2:K),DPathP(amal_mu_Kxyk1k2) (e(x++ (inrk1:: [inrk2]) ++y)) (e(x++ [inr(k1*k2)] ++y)))(t:forall(xy:Words) (z:G),DPathP(amal_tauxyz) (e(x++ [inl(fz)] ++y)) (e(x++ [inr(gz)] ++y)))(oh:forall(xy:Words),DPathP(amal_omega_Hxy) (e(x++ [inlmon_unit] ++y)) (e(x++y)))(ok:forall(xy:Words),DPathP(amal_omega_Kxy) (e(x++ [inrmon_unit] ++y)) (e(x++y))):forallx,Px.Proof.snrapplyTrunc_ind; [exact_|].snrapplyCoeq_ind.1:exacte.introa.destructaas[ [ [ [a|a] |a] |a] |a].+destructaas[[[xh1]h2]y].applydp_compose.exact(mhxyh1h2).+destructaas[[[xk1]k2]y].applydp_compose.exact(mkxyk1k2).+destructaas[[xz]y].applydp_compose.exact(txyz).+destructaas[xy].applydp_compose.exact(ohxy).+destructaas[xy].applydp_compose.exact(okxy).Defined.Definitionamal_type_ind_hprop(P:amal_type->Type) `{forallx,IsHProp(Px)}(e:forallw,P(amal_etaw)):forallx,Px.Proof.srapplyamal_type_ind.1:exacte.all:intros;applypath_ishprop.Defined.From which we can derive the non-dependent eliminator / recursion principleDefinitionamal_type_rec(P:Type) `{IsHSetP} (e:Words->P)(eh:forall(xy:Words) (h1h2:H),e(x++ (cons(inlh1) [inlh2]) ++y) =e(x++ [inl(h1*h2)] ++y))(ek:forall(xy:Words) (k1k2:K),e(x++ (cons(inrk1) [inrk2]) ++y) =e(x++ [inr(k1*k2)] ++y))(t:forall(xy:Words) (z:G),e(x++ [inl(fz)] ++y) =e(x++ [inr(gz)] ++y))(oh:forall(xy:Words),e(x++ [inlmon_unit] ++y) =e(x++y))(ok:forall(xy:Words),e(x++ [inrmon_unit] ++y) =e(x++y)):amal_type->P.Proof.snrapplyamal_type_ind.1:exact_.1:exacte.all:intros;applydp_const.1:applyeh.1:applyek.1:applyt.1:applyoh.applyok.Defined.Now for the group structureThe group operation is concatenation of the underlying list. Most of the work is spent showing that it respects the path constructors.Global Instancesgop_amal_type:SgOpamal_type.Proof.introsxy;revertx.srapplyamal_type_rec;introsx;reverty.{srapplyamal_type_rec;introsy.1:exact(amal_eta(x++y)).{introszh1h2.refine(apamal_eta_@_@apamal_eta_^).1,3:applyapp_assoc.rapplyamal_mu_H. }{introszk1k2.refine(apamal_eta_@_@apamal_eta_^).1,3:applyapp_assoc.rapplyamal_mu_K. }{introswz.refine(apamal_eta_@_@apamal_eta_^).1,3:applyapp_assoc.applyamal_tau. }{introsz.refine(apamal_eta_@_@apamal_eta_^).1,3:applyapp_assoc.applyamal_omega_H. }{introsz.refine(apamal_eta_@_@apamal_eta_^).1,3:applyapp_assoc.applyamal_omega_K. } }{introsryh1h2;revertr.rapplyamal_type_ind_hprop.introsz;change(amal_eta((x++ ((inlh1:: [inlh2]) ++y)) ++z)=amal_eta((x++ [inl(h1*h2)] ++y) ++z)).refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.refine(apamal_eta(ap(appx)_)^ @_@apamal_eta(ap(appx)_)).1,3:applyapp_assoc.applyamal_mu_H. }{introsryk1k2;revertr.rapplyamal_type_ind_hprop.introsz;change(amal_eta((x++ ((inrk1:: [inrk2]) ++y)) ++z)=amal_eta((x++ [inr(k1*k2)] ++y) ++z)).refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.refine(apamal_eta(ap(appx)_)^ @_@apamal_eta(ap(appx)_)).1,3:applyapp_assoc.applyamal_mu_K. }{introsryz;revertr.rapplyamal_type_ind_hprop.introsw;change(amal_eta((x++ [inl(fz)] ++y) ++w)=amal_eta((x++ [inr(gz)] ++y) ++w)).refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.refine(apamal_eta(ap(appx)_)^ @_@apamal_eta(ap(appx)_)).1,3:applyapp_assoc.applyamal_tau. }{introsrz;revertr.rapplyamal_type_ind_hprop.introsw;change(amal_eta((x++ [inlmon_unit] ++z) ++w) =amal_eta((x++z) ++w)).refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.refine(apamal_eta(ap(appx)_)^ @_).1:applyapp_assoc.applyamal_omega_H. }{introsrz;revertr.rapplyamal_type_ind_hprop.introsw;change(amal_eta((x++ [inrmon_unit] ++z) ++w) =amal_eta((x++z) ++w)).refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.refine(apamal_eta(ap(appx)_)^ @_).1:applyapp_assoc.applyamal_omega_K. }Defined.The identity element is the empty listGlobal Instancemonunit_amal_type:MonUnitamal_type.Proof.exact(amal_etanil).Defined.Global Instancenegate_amal_type:Negateamal_type.Proof.srapplyamal_type_rec.{introsw.exact(amal_eta(word_inversew)). }{hnf;introsxyh1h2.refine(apamal_eta_@_@apamal_eta_^).1,3:refine(word_inverse_ww__@ap(funs=>s++_)_).1:applyword_inverse_ww.{refine(word_inverse_ww__@_).applyap;simpl.rapply(ap(funs=> [s])).applyap.applynegate_sg_op. }simpl.refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.applyamal_mu_H. }{hnf;introsxyk1k2.refine(apamal_eta_@_@apamal_eta_^).1,3:refine(word_inverse_ww__@ap(funs=>s++_)_).1:applyword_inverse_ww.{refine(word_inverse_ww__@_).applyap;simpl.rapply(ap(funs=> [s])).applyap.applynegate_sg_op. }simpl.refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.applyamal_mu_K. }{hnf;introsxyz.refine(apamal_eta_@_@apamal_eta_^).1,3:refine(word_inverse_ww__@ap(funs=>s++_)_).1,2:cbn;refine(ap__).1,2:rapply(ap(funs=> [s])).1,2:applyap.1,2:symmetry;applygrp_homo_inv.refine(apamal_eta_^ @_@apamal_eta_).1,3:applyapp_assoc.applyamal_tau. }{hnf;introsxz.refine(apamal_eta_@_@apamal_eta_^).1,3:applyword_inverse_ww.refine(apamal_eta_@_).{refine(ap(funs=>s++_)_).applyword_inverse_ww. }refine(apamal_eta_^ @_).1:applyapp_assoc.simpl.rewritenegate_mon_unit.applyamal_omega_H. }{hnf;introsxz.refine(apamal_eta_@_@apamal_eta_^).1,3:applyword_inverse_ww.refine(apamal_eta_@_).{refine(ap(funs=>s++_)_).applyword_inverse_ww. }refine(apamal_eta_^ @_).1:applyapp_assoc.simpl.rewritenegate_mon_unit.applyamal_omega_K. }Defined.Global Instanceassociative_sgop_m:Associativesg_op.Proof.introsxy.rapplyamal_type_ind_hprop;introz;reverty.rapplyamal_type_ind_hprop;introy;revertx.rapplyamal_type_ind_hprop;introx.nrapply(apamal_eta).rapplyapp_assoc.Defined.Global Instanceleftidentity_sgop_amal_type:LeftIdentitysg_opmon_unit.Proof.rapplyamal_type_ind_hprop;introx.reflexivity.Defined.Global Instancerightidentity_sgop_amal_type:RightIdentitysg_opmon_unit.Proof.rapplyamal_type_ind_hprop;introx.nrapply(apamal_eta).nrapplyapp_nil.Defined.Lemmaamal_eta_word_concat_Vw(x:Words) :amal_eta(word_inversex++x) =mon_unit.Proof.inductionxas[|xxs].1:reflexivity.destructxas[h|k].+change(amal_eta(word_inverse([inlh] ++xs) ++ [inlh] ++xs) =mon_unit).rewriteword_inverse_ww.rewrite<-app_assoc.refine(amal_mu_H____@_).rewriteleft_inverse.rewriteamal_omega_H.applyIHxs.+change(amal_eta(word_inverse([inrk] ++xs) ++ [inrk] ++xs) =mon_unit).rewriteword_inverse_ww.rewrite<-app_assoc.refine(amal_mu_K____@_).rewriteleft_inverse.rewriteamal_omega_K.applyIHxs.Defined.Lemmaamal_eta_word_concat_wV(x:Words) :amal_eta(x++word_inversex) =mon_unit.Proof.inductionxas[|xxs].1:reflexivity.destructxas[h|k].+cbn.rewriteapp_assoc.change(amal_eta([inlh]) *amal_eta((xs++word_inversexs)) *amal_eta([inl(-h)]) =mon_unit).rewriteIHxs.rewriterightidentity_sgop_amal_type.rewrite<- (app_nil(cons__)).change(amal_eta(([inlh] ++ [inl(-h)]) ++nil) =mon_unit).rewrite<-app_assoc.change(amal_eta(nil++ [inlh] ++ [inl(-h)] ++nil) =mon_unit).refine(amal_mu_H____@_).refine(_@_).{applyap,ap.rapply(ap(funx=>x++_)).rapply(ap(funx=> [x])).applyap.applyright_inverse. }applyamal_omega_H.+cbn.rewriteapp_assoc.change(amal_eta([inrk]) *amal_eta((xs++word_inversexs)) *amal_eta([inr(-k)]) =mon_unit).rewriteIHxs.rewriterightidentity_sgop_amal_type.rewrite<- (app_nil(cons__)).change(amal_eta(([inrk] ++ [inr(-k)]) ++nil) =mon_unit).rewrite<-app_assoc.change(amal_eta(nil++ [inrk] ++ [inr(-k)] ++nil) =mon_unit).refine(amal_mu_K____@_).refine(_@_).{applyap,ap.rapply(ap(funx=>x++_)).rapply(ap(funx=> [x])).applyap.applyright_inverse. }applyamal_omega_K.Defined.Global Instanceleftinverse_sgop_amal_type:LeftInversesg_opnegatemon_unit.Proof.rapplyamal_type_ind_hprop;introx.applyamal_eta_word_concat_Vw.Defined.Global Instancerightinverse_sgop_amal_type:RightInversesg_opnegatemon_unit.Proof.rapplyamal_type_ind_hprop;introx.applyamal_eta_word_concat_wV.Defined.DefinitionAmalgamatedFreeProduct:Group.Proof.snrapply(Build_Groupamal_type);repeatsplit;exact_.Defined.Using foldr. It's important that we use foldr as foldl is near impossible to reason about.DefinitionAmalgamatedFreeProduct_rec'(X:Group)(h:GroupHomomorphismHX) (k:GroupHomomorphismKX)(p:hof==kog):AmalgamatedFreeProduct->X.Proof.srapplyamal_type_rec.{introw.refine(fold_right__w).{intros[l|r]x.+exact(hl*x).+exact(kr*x). }exactmon_unit. }{introsxyh1h2;hnf.rewrite?fold_right_app.f_ap.simpl.rewritesimple_associativity.f_ap.symmetry.exact(grp_homo_ophh1h2). }{introsxyk1k2;hnf.rewrite?fold_right_app.f_ap.simpl.rewritesimple_associativity.f_ap.symmetry.exact(grp_homo_opkk1k2). }{introsxyz;hnf.rewrite?fold_right_app.f_ap;simpl;f_ap. }{introsxy;hnf.rewrite?fold_right_app.f_ap.simpl.rewritegrp_homo_unit.rapplyleft_identity. }{introsxy;hnf.rewrite?fold_right_app.f_ap.simpl.rewritegrp_homo_unit.rapplyleft_identity. }Defined.Global Instanceissemigrouppreserving_AmalgamatedFreeProduct_rec'(X:Group) (h:GroupHomomorphismHX) (k:GroupHomomorphismKX)(p:hof==kog):IsSemiGroupPreserving(AmalgamatedFreeProduct_rec'Xhkp).Proof.introsx;srapplyamal_type_ind_hprop;introy;revertx;srapplyamal_type_ind_hprop;introx;simpl.rewritefold_right_app.set(s:= (fold_right(funX0:H+K=>matchX0with|inll=>funx0:X=>hl*x0|inrr=>funx0:X=>kr*x0end)mon_unity)).inductionxas[|ax].1:symmetry;applyleft_identity.simpl.rewriteIHx.destructa;applysimple_associativity.Qed.DefinitionAmalgamatedFreeProduct_rec(X:Group)(h:GroupHomomorphismHX) (k:GroupHomomorphismKX)(p:hof==kog):GroupHomomorphismAmalgamatedFreeProductX.Proof.snrapplyBuild_GroupHomomorphism.1:srapply(AmalgamatedFreeProduct_rec'Xhkp).exact_.Defined.Definitionamal_inl:GroupHomomorphismHAmalgamatedFreeProduct.Proof.snrapplyBuild_GroupHomomorphism.{introx.exact(amal_eta[inlx]). }introsxy.rewrite<- (app_nil[inl(x*y)]).rewrite<- (amal_mu_Hnilnilxy).rewriteapp_nil.reflexivity.Defined.Definitionamal_inr:GroupHomomorphismKAmalgamatedFreeProduct.Proof.snrapplyBuild_GroupHomomorphism.{introx.exact(amal_eta[inrx]). }introsxy.rewrite<- (app_nil[inr(x*y)]).rewrite<- (amal_mu_Knilnilxy).rewriteapp_nil.reflexivity.Defined.Theoremequiv_amalgamatedfreeproduct_rec`{Funext} (X:Group): {h:GroupHomomorphismHX& {k:GroupHomomorphismKX&hof==kog}}<~>GroupHomomorphismAmalgamatedFreeProductX.Proof.snrapplyequiv_adjointify.1:intros[h[kp]];exact(AmalgamatedFreeProduct_recXhkp).{introsr.exists(grp_homo_composeramal_inl).exists(grp_homo_composeramal_inr).introx.apply(apr).simpl.rewrite<- (app_nil[inl(fx)]).rewrite<- (app_nil[inr(gx)]).apply(amal_taunilnilx). }{introsr.applyequiv_path_grouphomomorphism.srapplyamal_type_ind_hprop.introx.inductionxas[|ax].1:symmetry;apply(grp_homo_unitr).simplin*.rewriteIHx.destructa;symmetry;rapply(grp_homo_opr(amal_eta[_]) (amal_etax)). }introhkp.simpl.rapply(equiv_ap'(equiv_sigma_prod(funhk:GroupHomomorphismHX*GroupHomomorphismKX=>fsthkof==sndhkog))__)^-1%equiv.rapplypath_sigma_hprop.destructhkpas[h[kp]].applypath_prod;cbn;applyequiv_path_grouphomomorphism;intro;simpl;rapplyright_identity.Defined.EndFreeProduct.Argumentsamal_eta{GHKfg}x.DefinitionFreeProduct(GH:Group) :Group:=AmalgamatedFreeProductgrp_trivialGH(grp_trivial_rec_) (grp_trivial_rec_).Definitionfreeproduct_inl{GH:Group} :GroupHomomorphismG(FreeProductGH):=amal_inl_____.Definitionfreeproduct_inr{GH:Group} :GroupHomomorphismH(FreeProductGH):=amal_inr_____.DefinitionFreeProduct_rec(GHK:Group)(f:GroupHomomorphismGK) (g:GroupHomomorphismHK):GroupHomomorphism(FreeProductGH)K.Proof.snrapply(AmalgamatedFreeProduct_rec______fg).intros[].refine(grp_homo_unit_@ (grp_homo_unit_)^).Defined.Definitionequiv_freeproduct_rec`{funext:Funext} (GHK:Group): (GroupHomomorphismGK) * (GroupHomomorphismHK)<~>GroupHomomorphism(FreeProductGH)K.Proof.refine(equiv_amalgamatedfreeproduct_rec_____KoE_^-1).refine(equiv_sigma_prod0__oEequiv_functor_sigma_id(fun_=>equiv_sigma_contr_)).introsf.rapplycontr_forall.intros[];applycontr_inhab_prop.applytr.refine(grp_homo_unit_@ (grp_homo_unit_)^).Defined.The freeproduct is the coproduct in the category of groups.Global Instancehasbinarycoproducts:HasBinaryCoproductsGroup.Proof.introsGH.snrapplyBuild_BinaryCoproduct.-exact(FreeProductGH).-exactfreeproduct_inl.-exactfreeproduct_inr.-exact(FreeProduct_recGH).-introsZfgx;simpl.rapplyright_identity.-introsZfgx;simpl.rapplyright_identity.-introsZfgpq.srapplyamal_type_ind_hprop;simpl.introsw.inductionwas[|gh].1:exact(grp_homo_unit_@ (grp_homo_unit_)^).change(f(amal_eta[gh] *amal_etaw) =g(amal_eta[gh] *amal_etaw)).nrapplygrp_homo_op_agree.2:applyIHw.destructghas[g'|h].+exact(pg').+exact(qh).Defined.

--- Miscellaneous\Freudenthal.html ---
FreudenthalLibrary FreudenthalRequireImportBasics.RequireImportTypes.RequireImportColimits.Pushout.RequireImportColimits.SpanPushout.RequireImportHoTT.Truncations.RequireImportHomotopy.Suspension.RequireImportHomotopy.BlakersMassey.The Freudenthal Suspension TheoremThe Freudenthal suspension theorem is a fairly trivial corollary of the Blakers-Massey theorem.  The only real work is to relate the span-pushout that we used for Blakers-Massey to the naive pushout that we used to define suspension.Local Definitionfreudenthal'`{Univalence} (n:trunc_index)(X:Type) `{IsConnectedn.+1X}:IsConnMap(n+2+n) (@meridX).Proof.snrapplycancelL_equiv_conn_map.2: {refine(equiv_ap'(B:=SPushout(fun(uv:Unit) =>X))_NorthSouth).exact(equiv_pushout(equiv_contr_sigma(fun_:Unit*Unit=>X))^-1(equiv_idmapUnit) (equiv_idmapUnit)(funx:X=>idpath) (funx:X=>idpath)). }refine(conn_map_homotopic____(blakers_masseynn(fun(uv:Unit) =>X)tttt)).introsx.refine(_@ (equiv_pushout_pglue(equiv_contr_sigma(fun_:Unit*Unit=>X))^-1(equiv_idmapUnit) (equiv_idmapUnit)(funx:X=>idpath) (funx:X=>idpath)x)^).exact((concat_p1_@concat_1p_)^).Defined.Definitionfreudenthal@{uv|u<v} :=Evalunfoldfreudenthal'in@freudenthal'@{uuuuuvuuuuu}.Global Existing Instancefreudenthal.

--- Miscellaneous\FromFunctor.html ---
FromFunctorLibrary FromFunctorFunctors to cat are pseudofunctorsRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportFunctor.Composition.CoreNaturalTransformation.Composition.CoreNaturalTransformation.Composition.Laws.RequireImportFunctor.Identity.RequireImportPseudofunctor.Core.RequireImportCat.Core.RequireImportFunctorCategory.Core.RequireImportFunctorCategory.MorphismsNaturalTransformation.Isomorphisms.RequireImportCategory.MorphismsNaturalTransformation.Paths.RequireImportBasics.PathGroupoidsBasics.Trunc.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopepath_scope.Local OpenScopemorphism_scope.Every functor to Cat is a pseudofunctorSectionof_functor.Context`{Funext}.VariableC:PreCategory.Context`{HP:forallCD,PC->PD->IsHSet(FunctorCD)}.Local Notationcat:= (@sub_pre_cat_PHP).VariableF:FunctorCcat.Definitionpath_functor_helperAB(F1F2:FunctorAB) (pf1pf2:F1=F2):PA->PB->pf1=pf2:=funPAPB=> @path_ishprop_(@HPABPAPBF1F2)__.Local Hint Extern0 (P?x.1) =>exactx.2 :core.Local Tactic Notation"transitivity_idtoiso"open_constr(hyp) :=lazymatchgoalwith| [ |- ?f(Category.Morphisms.idtoiso?C_) =_] =>etransitivity(f(Category.Morphisms.idtoisoChyp));[do2refine(ap__);(* https://coq.inria.fr/bugs/show_bug.cgi?id=3626 *)applypath_functor_helper;simpl;trivial|path_natural_transformation]end.Local Ltacpseudofunctor_t:=intros;unfoldnatural_transformation_of_natural_isomorphism;rewrite?idtoiso_whisker_r, ?idtoiso_whisker_l;repeat(letC:=matchgoalwith|- @paths(@NaturalTransformation?C?D?F?G)__=>constr:((C->D)%category)endinfirst[eapply(@iso_moveL_pVC)|eapply(@iso_moveL_VpC)|eapply(@iso_moveL_pMC)|eapply(@iso_moveL_MpC) ];simpl);rewrite?idtoiso_inv;simpl;change@NaturalTransformation.Composition.Core.composewith(funCDFGH=>Category.Core.compose(C:=C->D) (s:=F) (d:=G) (d':=H));cbvbeta;rewrite?idtoiso_comp;first[transitivity_idtoiso(Functor.Composition.Laws.left_identity_)|transitivity_idtoiso((Functor.Composition.Laws.left_identity_)^)|transitivity_idtoiso(Functor.Composition.Laws.right_identity_)|transitivity_idtoiso((Functor.Composition.Laws.right_identity_)^)|transitivity_idtoiso(Functor.Composition.Laws.associativity___)|transitivity_idtoiso((Functor.Composition.Laws.associativity___)^) ];rewriteeta_idtoiso;simpl;rewrite?ap_V, ?Functor.Composition.Laws.left_identity_fst, ?Functor.Composition.Laws.right_identity_fst, ?Functor.Composition.Laws.associativity_fst;tryreflexivity.(* The following helpers were generated with<<intros.repeat match goal with||-context[idtoiso?C(?f?x)]=> generalize (f x); intro||-context[MorphismOf?F?f]=> generalize dependent (MorphismOf F f); repeat (let x := fresh "x" in intro x)||-context[ObjectOf?F?f]=> generalize dependent (ObjectOf F f); repeat (let x := fresh "x" in intro x)end.simpl in *.unfold SubPreCatCat.simpl in *.clear.destruct_head_hnf @sig.simpl in *.repeat match goal with|H:_|-_=> revert Hend.intros H P.>> *)Lemmapseudofunctor_of_functor__composition_of{x0x1x2x:PreCategory}{x7x11:Functorx0x1}{x12:x7=x11}{x6:Functorx0x2} {x9:Functorx2x1}{x14:x11= (x9ox6)%functor}{x4:Functorx0x} {x5:Functorxx1}{x8:x7= (x5ox4)%functor} {x10:Functorxx2}{x13:x6= (x10ox4)%functor} {x15:x5= (x9ox10)%functor}(H0':Px0) (H1':Px1) (H2':Px2) (H':Px): ((associator_1x9x10x4)o((idtoiso(x->x1)x15:morphism___)oRx4o(idtoiso(x0->x1)x8:morphism___)))%natural_transformation= (x9oL(idtoiso(x0->x2)x13:morphism___)o((idtoiso(x0->x1)x14:morphism___)o(idtoiso(x0->x1)x12:morphism___)))%natural_transformation.Proof.clearF.symmetry;simpl;pseudofunctor_t.Qed.Lemmapseudofunctor_of_functor__left_identity_of{x0x:PreCategory}{x2:Functorxx} {x3:x2= 1%functor}{x4x5:Functorx0x} {x6:x4=x5} {x7:x4= (x2ox5)%functor}(H0':Px0) (H':Px): ((Category.Morphisms.idtoiso(x->x)x3:morphism___)oRx5o(Category.Morphisms.idtoiso(x0->x)x7:morphism___))%natural_transformation= ((NaturalTransformation.Composition.Laws.left_identity_natural_transformation_2x5)o(Category.Morphisms.idtoiso(x0->x)x6:morphism___))%natural_transformation.Proof.clearF.simpl;pseudofunctor_t.Qed.Lemmapseudofunctor_of_functor__right_identity_of{x0x:PreCategory}{x4:Functorx0x0} {x5:x4= 1%functor}{x2x3:Functorx0x} {x6:x2=x3} {x7:x2= (x3ox4)%functor}(H0':Px0) (H':Px): (x3oL(Category.Morphisms.idtoiso(x0->x0)x5:morphism___)o(Category.Morphisms.idtoiso(x0->x)x7:morphism___))%natural_transformation= ((NaturalTransformation.Composition.Laws.right_identity_natural_transformation_2x3)o(Category.Morphisms.idtoiso(x0->x)x6:morphism___))%natural_transformation.Proof.clearF.simpl;pseudofunctor_t.Qed.Definitionpseudofunctor_of_functor:PseudofunctorC:=Build_PseudofunctorC(funx=>pr1(Fx))(funsdm=>F_1m)(funsdd'm0m1=>Category.Morphisms.idtoiso(_->_) (composition_ofF___m1m0))(funx=>Category.Morphisms.idtoiso(_->_) (identity_ofFx))(funwxyz___=>pseudofunctor_of_functor__composition_of(Fw).2 (Fz).2 (Fy).2 (Fx).2)(funxy_=>pseudofunctor_of_functor__left_identity_of(Fx).2 (Fy).2)(funxy_=>pseudofunctor_of_functor__right_identity_of(Fx).2 (Fy).2).Endof_functor.DefinitionFunctorToCat`{Funext} {C} `{HP:forallCD,PC->PD->IsHSet(FunctorCD)}:=FunctorC(@sub_pre_cat_PHP).IdentityCoercionfunctor_to_cat_id:FunctorToCat>->Functor.Definitionpseudofunctor_of_functor_to_cat`(F: @FunctorToCatHCPHP):= @pseudofunctor_of_functor_CPHPF.

--- Miscellaneous\Full.html ---
FullLibrary FullFull SubcategoriesWe reuse the generalizion given by ∑-precategories; a full subcategory has a sigma type as its objects.RequireImportCategory.Sigma.OnObjects.Notationfull:=sig_obj.Notation"{ x : A | P }" := (fullA(funx=>P)) :category_scope.

--- Miscellaneous\FunctorCat.html ---
FunctorCatLibrary FunctorCatRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.RequireImportWildCat.Opposite.RequireImportWildCat.Equiv.RequireImportWildCat.Induced.RequireImportWildCat.NatTrans.Wild functor categoriesCategories of 0-coherent 1-functorsRecordFun01(AB:Type) `{IsGraphA} `{IsGraphB} := {fun01_F:A->B;fun01_is0functor:Is0Functorfun01_F;}.Coercionfun01_F:Fun01>->Funclass.Global Existing Instancefun01_is0functor.ArgumentsBuild_Fun01AB{isgraph_Aisgraph_B}F{fun01_is0functor} :rename.Definitionissig_Fun01(AB:Type) `{IsGraphA} `{IsGraphB}:_<~>Fun01AB:=ltac:(issig).(* Note that even ifAandBare fully coherent oo-categories, the objects of our "functor category" are not fully coherent.  Thus we cannot in general expect this "functor category" to itself be fully coherent.  However, it is at least a 0-coherent 1-category, as long asBis a 1-coherent 1-category. *)Global Instanceisgraph_fun01(AB:Type) `{IsGraphA} `{Is1CatB} :IsGraph(Fun01AB).Proof.srapplyBuild_IsGraph.intros[F?] [G?].exact(NatTransFG).Defined.Global Instanceis01cat_fun01(AB:Type) `{IsGraphA} `{Is1CatB} :Is01Cat(Fun01AB).Proof.srapplyBuild_Is01Cat.-intros[F?];cbn.exact(nattrans_idF).-introsFGKgammaalpha;cbnin*.exact(nattrans_compgammaalpha).Defined.Global Instanceis2graph_fun01(AB:Type) `{IsGraphA,Is1CatB}:Is2Graph(Fun01AB).Proof.intros[F?] [G?];applyBuild_IsGraph.intros[alpha?] [gamma?].exact(foralla,alphaa$==gammaa).Defined.In fact, in this case it is automatically also a 0-coherent 2-category and a 1-coherent 1-category, with a totally incoherent notion of 2-cell between 1-coherent natural transformations.Global Instanceis1cat_fun01(AB:Type) `{IsGraphA} `{Is1CatB} :Is1Cat(Fun01AB).Proof.srapplyBuild_Is1Cat.-intros[F?] [G?];srapplyBuild_Is01Cat.+intros[alpha?]a;cbn.reflexivity.+intros[alpha?] [gamma?] [phi?]numua.exact(mua$@nua).-intros[F?] [G?];srapplyBuild_Is0Gpd.intros[alpha?] [gamma?]mua.exact((mua)^$).-intros[F?] [G?] [K?] [alpha?].srapplyBuild_Is0Functor.intros[phi?] [mu?]fa.exact(alphaa$@Lfa).-intros[F?] [G?] [K?] [alpha?].srapplyBuild_Is0Functor.intros[phi?] [mu?]fa.exact(fa$@Ralphaa).-intros[F?] [G?] [K?] [L?] [alpha?] [gamma?] [phi?]a;cbn.srapplycat_assoc.-intros[F?] [G?] [K?] [L?] [alpha?] [gamma?] [phi?]a;cbn.srapplycat_assoc_opp.-intros[F?] [G?] [alpha?]a;cbn.srapplycat_idl.-intros[F?] [G?] [alpha?]a;cbn.srapplycat_idr.Defined.It also inherits a notion of equivalence, namely a natural transformation that is a pointwise equivalence.  Note that this is not a "fully coherent" notion of equivalence, since the functors and transformations are not themselves fully coherent.Global Instancehasequivs_fun01(AB:Type) `{Is01CatA} `{HasEquivsB}:HasEquivs(Fun01AB).Proof.srapplyBuild_HasEquivs.1:introsFG;exact(NatEquivFG).all:introsFGalpha;cbnin*.-exact(foralla,CatIsEquiv(alphaa)).-exactalpha.-introsa;exact_.-applyBuild_NatEquiv'.-cbn;intros;applycate_buildequiv_fun.-exact(natequiv_inversealpha).-intros;applycate_issect.-intros;applycate_isretr.-intros[gamma?]rsa;cbnin*.refine(catie_adjointify(alphaa) (gammaa) (ra) (sa)).Defined.Bundled opposite functorsDefinitionfun01_op(AB:Type) `{IsGraphA} `{IsGraphB}:Fun01AB->Fun01A^opB^op.Proof.introsF.rapply(Build_Fun01A^opB^opF).Defined.Categories of 1-coherent 1-functorsRecordFun11(AB:Type) `{Is1CatA} `{Is1CatB} :={fun11_fun:A->B;is0functor_fun11:Is0Functorfun11_fun;is1functor_fun11:Is1Functorfun11_fun}.Coercionfun11_fun:Fun11>->Funclass.Global Existing Instanceis0functor_fun11.Global Existing Instanceis1functor_fun11.ArgumentsBuild_Fun11AB{isgraph_Ais2graph_Ais01cat_Ais1cat_Aisgraph_Bis2graph_Bis01cat_Bis1cat_B}F{is0functor_fun11is1functor_fun11} :rename.Coercionfun01_fun11{AB:Type} `{Is1CatA} `{Is1CatB}(F:Fun11AB):Fun01AB.Proof.existsF;exact_.Defined.Global Instanceisgraph_fun11{AB:Type} `{Is1CatA} `{Is1CatB}:IsGraph(Fun11AB):=isgraph_inducedfun01_fun11.Global Instanceis01cat_fun11{AB:Type} `{Is1CatA} `{Is1CatB}:Is01Cat(Fun11AB):=is01cat_inducedfun01_fun11.Global Instanceis2graph_fun11{AB:Type} `{Is1CatA,Is1CatB}:Is2Graph(Fun11AB):=is2graph_inducedfun01_fun11.Global Instanceis1cat_fun11{AB:Type} `{Is1CatA} `{Is1CatB}:Is1Cat(Fun11AB):=is1cat_inducedfun01_fun11.Global Instancehasequivs_fun11{AB:Type} `{Is1CatA} `{HasEquivsB}:HasEquivs(Fun11AB):=hasequivs_inducedfun01_fun11.Identity functorsDefinitionfun01_id{A} `{IsGraphA} :Fun01AA:=Build_Fun01AAidmap.Definitionfun11_id{A} `{Is1CatA} :Fun11AA:=Build_Fun11__idmap.Composition of functorsDefinitionfun01_compose{ABC} `{IsGraphA,IsGraphB,IsGraphC}:Fun01BC->Fun01AB->Fun01AC:=funGF=>Build_Fun01__(GoF).Definitionfun01_postcomp{ABC}`{IsGraphA,Is1CatB,Is1CatC} (F:Fun11BC):Fun01AB->Fun01AC:=fun01_compose(A:=A)F.Warning:Fneeds to be a 1-functor for this to be a 0-functor.Global Instanceis0functor_fun01_postcomp{ABC}`{IsGraphA,Is1CatB,Is1CatC} (F:Fun11BC):Is0Functor(fun01_postcomp(A:=A)F).Proof.applyBuild_Is0Functor.introsabf.rapplynattrans_postwhisker.exactf.Defined.Global Instanceis1functor_fun01_postcomp{ABC}`{IsGraphA,Is1CatB,Is1CatC} (F:Fun11BC):Is1Functor(fun01_postcomp(A:=A)F).Proof.applyBuild_Is1Functor.-introsabfgpx.rapplyfmap2.rapplyp.-introsfx.rapplyfmap_id.-introsabcfgx.rapplyfmap_comp.Defined.Definitionfun11_fun01_postcomp{ABC}`{IsGraphA,Is1CatB,Is1CatC} (F:Fun11BC):Fun11(Fun01AB) (Fun01AC):=Build_Fun11__(fun01_postcompF).Definitionfun11_compose{ABC} `{Is1CatA,Is1CatB,Is1CatC}:Fun11BC->Fun11AB->Fun11AC.Proof.introsFG.nrapplyBuild_Fun11.rapply(is1functor_composeGF).Defined.

--- Miscellaneous\FunctorCategory.html ---
FunctorCategoryLibrary FunctorCategoryFunctor categorySince there are only notations inFunctorCategory.Notations, we can just export those.RequireExportFunctorCategory.Notations.DefinitionRequireFunctorCategory.Core.Morphisms in a functor categoryRequireFunctorCategory.Morphisms.Functoriality of(_→_)RequireFunctorCategory.Functorial.Opposite functor(C→D)→(Cᵒᵖ→Dᵒᵖ)ᵒᵖRequireFunctorCategory.Dual.IncludeFunctorCategory.Core.IncludeFunctorCategory.Morphisms.IncludeFunctorCategory.Functorial.IncludeFunctorCategory.Dual.We don't want to make utf-8 notations the default, so we don't export them.

--- Miscellaneous\Functorial.html ---
FunctorialLibrary FunctorialFunctoriality of composition of natural transformationsRequireImportCategory.CoreFunctor.Core.RequireImportFunctorCategory.CoreFunctor.Composition.CoreNaturalTransformation.Composition.CoreNaturalTransformation.Composition.Laws.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.Sectionfunctorial_composition.Context`{Funext}.VariablesCDE:PreCategory.Local OpenScopenatural_transformation_scope.whiskering on the left is a functorDefinitionwhiskerL_functor(F: (D->E)%category): ((C->D) -> (C->E))%category:=Build_Functor(C->D) (C->E)(funG=>FoG)%functor(fun__T=>FoLT)(fun_____=>composition_of_whisker_l___)(fun_=>whisker_l_right_identity__).whiskering on the right is a functorDefinitionwhiskerR_functor(G: (C->D)%category): ((D->E) -> (C->E))%category:=Build_Functor(D->E) (C->E)(funF=>FoG)%functor(fun__T=>ToRG)(fun_____=>composition_of_whisker_r___)(fun_=>whisker_r_left_identity__).Endfunctorial_composition.

--- Miscellaneous\Functorish.html ---
FunctorishLibrary FunctorishRequireImportHoTT.BasicsTypes.Universe.Local OpenScopepath_scope.SectionFunctorish.Context`{Univalence}.(* We do not need composition to be preserved. *)ClassFunctorish(F:Type->Type) := {fmap{AB} (f:A->B) :FA->FB;fmap_idmap(A:Type) :fmap(idmap:A->A) =idmap}.Global ArgumentsfmapF{FF} {AB}f_:rename.Global Argumentsfmap_idmapF{FFA} :rename.Context(F:Type->Type).Context{FF:FunctorishF}.Propositionisequiv_fmap{AB} (f:A->B) `{IsEquiv__f}:IsEquiv(fmapFf).Proof.refine(equiv_induction(funA'e=>IsEquiv(fmapFe))__(Build_Equiv__f_)).refine(transport_(fmap_idmapF)^_);tryapplyisequiv_idmap.(* This line may not be needed in a new enough coq. *)Defined.Propositionfmap_agrees_with_univalence{AB} (f:A->B) `{IsEquiv__f}:fmapFf=equiv_path__(apF(path_universef)).Proof.refine(equiv_induction(funA'e=>fmapFe=equiv_path__(apF(path_universee)))__(Build_Equiv__f_)).transitivity(idmap:FA->FA).-applyfmap_idmap.-change(equiv_idmapA)with(equiv_pathAA1).rewrite(@eta_path_universe_AA1).exact1.Defined.EndFunctorish.

--- Miscellaneous\Functors.html ---
FunctorsLibrary FunctorsFunctors betweenset_catandprop_catRequireSetCategory.Functors.SetProp.IncludeSetCategory.Functors.SetProp.

--- Miscellaneous\FundamentalPreGroupoidCategory.html ---
FundamentalPreGroupoidCategoryLibrary FundamentalPreGroupoidCategoryFundamental PregroupoidsRequireImportCategory.Core.RequireImportHoTT.Truncations.Core.RequireImportHoTT.Basics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopepath_scope.Local OpenScopecategory_scope.Quoting the HoTT Book:Example. ForanytypeX, there is a precategory withXas
    its type of objects and withhom(x,y):∥x=y∥₀. The
    composition operation∥y=z∥₀→∥x=y∥₀→∥x=z∥₀is defined
    by induction on truncation from concatenation(y=z)→(x=y)→(x=z). We call this the fundamental pregroupoid ofX.We don't want access to all of the internals of a groupoid category at top level.ModuleFundamentalPreGroupoidCategoryInternals.Sectionfundamental_pregroupoid_category.VariableX:Type.Local Notationobject:=X(onlyparsing).Local Notationmorphismsd:= (Trunc0 (s=d:>X)) (onlyparsing).Definitioncomposesdd'(m:morphismdd') (m':morphismsd):morphismsd'.Proof.revertm';applyTrunc_rec;introm'.revertm;applyTrunc_rec;introm.applytr.exact(m'@m).Defined.Definitionidentityx:morphismxx:=tr(reflexivity_).Global Argumentscompose[sdd']mm'/ .Global Argumentsidentityx/ .Endfundamental_pregroupoid_category.EndFundamentalPreGroupoidCategoryInternals.Categorification of the fundamental pregroupoid of a typeDefinitionfundamental_pregroupoid_category(X:Type) :PreCategory.Proof.refine(@Build_PreCategoryX_(@FundamentalPreGroupoidCategoryInternals.identityX)(@FundamentalPreGroupoidCategoryInternals.composeX)____);simpl;intros;abstract(repeatmatchgoalwith| [m:Trunc__|-_]=>revertm;applyTrunc_ind;[intro;matchgoalwith| [ |-IsHSet(?a= ?b:> ?T) ]=>generalizeab;intros;letH:=freshinassert(H:forallxy:T,IsHProp(x=y))end;typeclasseseauto|intro]end;simpl;applyap;first[applyconcat_p_pp|applyconcat_1p|applyconcat_p1]).Defined.

--- Miscellaneous\Funext.html ---
FunextLibrary FunextRequireImportBasics.Overture.To assume the Funext axiom outright, import this file. (Doing this instead of simply positing Funext directly avoids creating multiple witnesses for the axiom in different developments.)Axiomfunext_axiom:Funext.Global Existing Instancefunext_axiom.

--- Miscellaneous\FunextVarieties.html ---
FunextVarietiesLibrary FunextVarietiesVarieties of function extensionalityRequireImportHoTT.BasicsHoTT.Types.RequireImportMetatheory.Core.Local OpenScopepath_scope.In the Overture, we defined function extensionality to be the assertion that the mapapD10is an equivalence.   We now prove that this follows from a couple of weaker-looking forms of function extensionality.  We do require eta conversion, which Coq 8.4+ has judgmentally.This proof is originally due to Voevodsky; it has since been simplified by Peter Lumsdaine and Michael Shulman.Naive funext is the simple assertion that pointwise equal functions are equal.  The domain and codomain could live in different universes; the third universe argument is essentially the max ofiandj(and similarly for all subsequent axioms).DefinitionNaiveFunext:=forall(A:Type@{i}) (P:A->Type@{j}) (fg:forallx,Px),(forallx,fx=gx) -> (f=g).Naive non-dependent funext is the same, but only for non-dependent functions.DefinitionNaiveNondepFunext:=forall(AB:Type) (fg:A->B),(forallx,fx=gx) -> (f=g).Weak funext says that a product of contractible types is contractible.DefinitionWeakFunext:=forall(A:Type) (P:A->Type),(forallx,Contr(Px)) ->Contr(forallx,Px).The obvious implications are
   Funext -> NaiveFunext -> WeakFunext and NaiveFunext -> NaiveNondepFunext.
   None of these do anything fiddly with the universes either.DefinitionFunext_implies_NaiveFunext@{ijmax}:Funext_type@{ijmax} ->NaiveFunext@{ijmax}.Proof.introsfeAPfgh.unfoldFunext_typein*.exact((@apD10APfg)^-1h).Defined.DefinitionNaiveFunext_implies_WeakFunext@{ijmax}:NaiveFunext@{ijmax} ->WeakFunext@{ijmax}.Proof.introsnfAPPc.apply(Build_Contr_(funx=>center(Px))).introsf;applynf;introsx.applycontr.Defined.DefinitionNaiveFunext_implies_NaiveNondepFunext@{ijmax}:NaiveFunext@{ijmax} ->NaiveNondepFunext@{ijmax}:=funnfABfg=>nfA(fun_=>B)fg.The non-obvious directions are that WeakFunext implies Funext and that NaiveNondepFunext implies WeakFunext (and hence all four are logically equivalent).Weak funext implies FunextTo show that WeakFunext implies Funext, the point is that under weak funext, the space of "pointwise homotopies" has the same universal property as the space of paths.SectionHomotopies.Context(wf:WeakFunext).Context{A:Type} {B:A->Type}.Context(f:forallx,Bx).(* Recall thatf==gis the type of pointwise paths (or "homotopies") fromftog. *)Letidhtpy:f==f:=funx=>idpath(fx).Weak funext implies that the "based homotopy space" of the Pi-type is contractible, just like the based path space.  Use priority 1, so we don't overrideContrUnit.Global Instancecontr_basedhtpy:Contr{g:forallx,Bx&f==g} | 1.Proof.unfoldWeakFunextinwf.(* Allow typeclass inference to find it *)apply(Build_Contr_(f;idhtpy)).intros[gh].(* The trick is to show that the type{g:forallx,Bx&f==g}is a retract offorallx,{y:Bx&fx=y}, which is contractible due to J and weak funext.  Here are the retraction and its section. *)pose(r:=funk=>exist(fung=>f==g)(funx=> (kx).1) (funx=> (kx).2)).pose(s:=fun(g:forallx,Bx) (h:f==g)x=> (gx;hx)).(* Because of judgemental eta-conversion, the retraction is actually definitional, so we can just replace the goal. *)change(r(funx=> (fx;idpath(fx))) =r(sgh)).applyap;srapplypath_contr.Defined.This enables us to prove that pointwise homotopies have the same elimination rule as the identity type.Context(Q:forallg(h:f==g),Type).Context(d:Qfidhtpy).Definitionhtpy_indgh:Qgh:= @transport_(fungh=>Qgh.1gh.2) (f;idhtpy) (g;h)(@path_contr____)d.The computation rule, of course, is only propositional.Definitionhtpy_ind_beta:htpy_indfidhtpy=d:=transport(funp: (f;idhtpy) = (f;idhtpy) =>transport(fungh=>Qgh.1gh.2)pd=d)(@path2_contr____(path_contr(f;idhtpy) (f;idhtpy)) (idpath_))^(idpath_).EndHomotopies.Now the proof is fairly easy; we can just use the same induction principle on both sides.  This proof also preserves all the universes.TheoremWeakFunext_implies_Funext@{ijmax}:WeakFunext@{ijmax} ->Funext_type@{ijmax}.Proof.introswf;hnf;introsABfg.refine(isequiv_adjointify(@apD10ABfg)(htpy_indwff(fung'_=>f=g')idpathg)__).-revertg;refine(htpy_indwf___).refine(ap_(htpy_ind_betawf___)).-introsh;destructh.refine(htpy_ind_betawf___).Defined.DefinitionNaiveFunext_implies_Funext:NaiveFunext->Funext_type:=WeakFunext_implies_FunextoNaiveFunext_implies_WeakFunext.Naive non-dependent funext implies weak funextFirst we show that naive non-dependent funext suffices to show that postcomposition with an equivalence is an equivalence.Definitionequiv_postcompose_from_NaiveNondepFunext(nf:NaiveNondepFunext) {ABC:Type} (f:B<~>C): (A->B) <~> (A->C):=Build_Equiv__(fun(g:A->B) =>fog)(isequiv_adjointify(fun(g:A->B) =>fog)(funh=>f^-1oh)(funh=>nf____(funx=>eisretrf(hx)))(fung=>nf____(funy=>eissectf(gy)))).Now, if eachPxis contractible, the projectionpr1:{x:X&Px}->Xis an equivalence (this requires no funext).  Thus, postcomposition with it is also an equivalence, and hence the fiber of postcomposition overidmapXis contractible.  But this fiber is "the type of sections ofpr1" and hence equivalent toforallx:X,Px.  The latter equivalence requires full funext to prove, but without any funext we can show thatforallx:X,Pxis a *retract* of the type of sections, hence also contractible.TheoremNaiveNondepFunext_implies_WeakFunext:NaiveNondepFunext->WeakFunext.Proof.introsnfXPH.pose(T:= (hfiber(equiv_postcompose_from_NaiveNondepFunextnf(equiv_pr1P))idmap)).exact(@contr_retractT__(funfpx=>transportP(ap10fp.2x) (fp.1x).2)(funf=> ((funx=> (x;fx)) ; 1)) (funf=> 1)).Defined.Therefore, naive nondependent funext also implies full funext.  Interestingly, this requires the universe of the assumption codomain to be not just that of the conclusion codomain, but the max of that universe with the domain universe (which is unchanged).DefinitionNaiveNondepFunext_implies_Funext@{ijmax}:NaiveNondepFunext@{imaxmax} ->Funext_type@{ijmax}:=WeakFunext_implies_FunextoNaiveNondepFunext_implies_WeakFunext.Functional extensionality is downward closedIf universeU_iis functionally extensional, then so are universesU_i'fori'≤i.LemmaFunext_downward_closed@{ijmaxi'j'max'|i<=max,j<=max,i'<=max',j'<=max',i'<=i,j'<=j}`{H:Funext_type@{ijmax}} :Funext_type@{i'j'max'}.Proof.hnfin*.(* Here we make use of cumulativity. *)exact(funAP=>HAP).Defined.

--- Miscellaneous\GCH.html ---
GCHLibrary GCHFromHoTTRequireImportTruncTypeabstract_algebra.FromHoTTRequireImportUniverses.Smallness.FromHoTTRequireImportSpaces.Nat.CoreSpaces.Card.Local OpenScopetype.Local OpenScopehprop_scope.Formulation of GCH(* GCH states that for any infinite set X with Y between X and P(X) either Y embeds into X or P(X) embeds into Y. *)DefinitionGCH:=forallXY:HSet,infiniteX->InjectsIntoXY->InjectsIntoY(X->HProp) ->InjectsIntoYX+InjectsInto(X->HProp)Y.GCH is a propositionLemmaCantor_inj{PR:PropResizing} {FE:Funext}X:~Injection(X->HProp)X.Proof.intros[iHI].pose(pn:=Build_HProp(smalltype(forallq,iq=n-> ~qn))).enough(Hp:p(ip) <-> ~p(ip)).{applyHp;applyHp;introsH;byapplyHp. }unfoldpat1.split.-introsH.applyequiv_smalltypeinH.applyH.reflexivity.-introsH.applyequiv_smalltype.introsq-> %HI.applyH.Qed.(* The concluding disjunction of GCH is excluse since otherwise we'd obtain an injection of P(X) into X. *)Lemmahprop_GCH{PR:PropResizing} {FE:Funext} :IsHPropGCH.Proof.repeat(nrapplyistrunc_forall;intros).applyhprop_allpath.intros[H|H] [H'|H'].-enough(H=H')as->;trivial.applypath_ishprop.-applyEmpty_rec.eapplymerely_destruct;tryeapply(Cantor_inja);trivial.byapplyInjectsInto_transwitha0.-applyEmpty_rec.eapplymerely_destruct;tryeapply(Cantor_inja);trivial.byapplyInjectsInto_transwitha0.-enough(H=H')as->;trivial.applypath_ishprop.Qed.GCH implies LEMSectionLEM.VariableX:HSet.VariableP:HProp.Context{PR:PropResizing}.Context{FE:Funext}.Definitionhpaths(xy:X) :=Build_HProp(pathsxy).Definitionsing(p:X->HProp) :=existsx,p=hpathsx.Letsings:={p:X->HProp|singp\/ (P+ ~P) }.(* The main idea is that for a given set X and proposition P, the set sings fits between X and P(X).Then CH for X implies that either sings embeds into X (which can be refuted constructively),or that P(X) embeds into sings, from which we can extract a proof of P + ~P. *)LemmaCantor_sing(i: (X->HProp) -> (X->HProp)) :IsInjectivei->existsp, ~sing(ip).Proof.introsHI.pose(pn:=Build_HProp(smalltype(forallq,iq=hpathsn-> ~qn))).existsp.intros[nHN].enough(Hp:pn<-> ~pn).{applyHp;applyHp;introsH;byapplyHp. }unfoldpat1.split.-introsH.applyequiv_smalltypeinH.applyH,HN.-introsH.applyequiv_smalltype.introsqHQ.rewrite<-HNinHQ.byapplyHIinHQas->.Qed.Lemmainjective_proj1{Z} (r:Z->HProp) :IsInjective(@proj1Zr).Proof.intros[pHp] [qHq];cbn.intros->.unshelveeapplypath_sigma;cbn.-reflexivity.-cbn.applypath_ishprop.Qed.Lemmainject_sings:(P+ ~P) ->Injection(X->HProp)sings.Proof.introsHP.unshelveeexists.-introsp.existsp.applytr.byright.-introspq.introsH.changepwith((exist(funr=>singr\/ (P+ ~P))p(tr(inrHP))).1).rewriteH.cbn.reflexivity.Qed.TheoremCH_LEM:(InjectionXsings->Injectionsings(X->HProp) -> ~ (InjectionsingsX) ->InjectsInto(X->HProp)sings)->P\/ ~P.Proof.introsch.eapplymerely_destruct;tryapplych.-unshelveeexists.+introsx.exists(hpathsx).applytr.left.existsx.reflexivity.+introsxy.introsH%pr1_path.cbninH.change(hpathsxy).byrewriteH.-exists(@proj1__).byapplyinjective_proj1.-introsH.assert(HP': ~ ~ (P+ ~P)).{introsHP.applyHP.right.introsp.applyHP.byleft. }applyHP'.introsHP%inject_sings.clearHP'.applyCantor_injwithX.byeapply(Injection_trans___HP).-intros[iHi].destruct(Cantor_sing(funp=> @proj1__(ip)))as[pHP].+introsxyH%injective_proj1.byapplyHi.+destruct(ip)as[qHq];cbnin*.eapplymerely_destruct;tryapplyHq.intros[H|H]; [destruct(HPH)|byapplytr].Qed.EndLEM.(* We can instantiate the previous lemma with nat to obtain GCH -> LEM. *)TheoremGCH_LEM{PR:PropResizing} {UA:Univalence} :GCH-> (forallP:HProp,P\/ ~P).Proof.introsgchP.eapply(CH_LEM(Build_HSetnat));tryexact_.introsH1H2H3.pose(sings:= {p:nat->HProp|sing(Build_HSetnat)p\/ (P+ ~P) }).destruct(gch(Build_HSetnat) (Build_HSetsings))as[H|H].-cbn.existsidmap.applyisinj_idmap.-applytr.applyH1.-applytr.applyH2.-applyEmpty_rec.eapplymerely_destruct;tryapplyH.applyH3.-applyH.Qed.

--- Miscellaneous\GCHtoAC.html ---
GCHtoACLibrary GCHtoACFromHoTTRequireImportTruncTypeExcludedMiddleabstract_algebra.FromHoTTRequireImportUniverses.Smallness.FromHoTTRequireImportSpaces.Nat.CoreSpaces.Card.FromHoTTRequireImportEquiv.BiInv.FromHoTTRequireImportHIT.unique_choice.FromHoTT.SetsRequireImportOrdinalsHartogsPowersGCHAC.OpenScopetype.CloseScopetrunc_scope.(* The proof of Sierpinski's results that GCH implies AC given in this file consists of two ingredients:1. Adding powers of infinite sets does not increase the cardinality (path_infinite_power).2. A variant of Cantor's theorem saying that P(X) <= (X + Y) implies P(X) <= Y for large X (Cantor_injects_injects).Those are used to obtain that cardinality-controlled functions are well-behaved in the presence of GCH (Sierpinski), from which we obtain by instantiation with the Hartogs number that every set embeds into an ordinal, which is enough to conclude GCH -> AC (GCH_AC) since the well-ordering theorem implies AC (WO_AC). *)Constructive equivalences(* For the first ingredient, we establish a bunch of paths and conclude the desired result by equational reasoning. *)SectionPreparation.Context{UA:Univalence}.Lemmapath_sum_prodXYZ:(X->Z) * (Y->Z) = ((X+Y) ->Z).Proof.applypath_universe_uncurried.applyequiv_sum_distributive.Qed.Lemmapath_sum_assocXYZ:X+ (Y+Z) =X+Y+Z.Proof.symmetry.applypath_universe_uncurried.applyequiv_sum_assoc.Qed.Lemmapath_sum_boolX:X+X=Bool*X.Proof.applypath_universe_uncurried.srapplyequiv_adjointify.-exact(funx=>matchxwithinlx=> (true,x) |inrx=> (false,x)end).-exact(funx=>matchxwith(true,x) =>inlx| (false,x) =>inrxend).-intros[[]];reflexivity.-intros[];reflexivity.Qed.Lemmapath_unit_nat:Unit+nat=nat.Proof.applypath_universe_uncurried.srapplyequiv_adjointify.-exact(funx=>matchxwithinl_=>O|inrn=>Snend).-exact(funn=>matchnwithO=>inltt|Sn=>inrnend).-byintros[].-byintros[[]|n].Qed.Lemmapath_unit_funX:X= (Unit->X).Proof.applypath_universe_uncurried.applyequiv_unit_rec.Qed.Equivalences relying on LEMContext{EM:ExcludedMiddle}.Lemmapath_bool_prop:HProp=Bool.Proof.applypath_universe_uncurried.srapplyequiv_adjointify.-exact(funP=>ifLEMP_thentrueelsefalse).-exact(funb:Bool=>ifbthenmerelyUnitelsemerelyEmpty).-intros[];destructLEMas[H|H];auto.+destruct(H(trtt)).+apply(@merely_destructEmpty);trydone.exact_.-introsP.destructLEMas[H|H];applyequiv_path_iff_hprop.+split;auto.intros_.applytr.exacttt.+split;trydone.introsHE.apply(@merely_destructEmpty);trydone.exact_.Qed.Lemmapath_bool_subsingleton:(Unit->HProp) =Bool.Proof.rewrite<-path_unit_fun.applypath_bool_prop.Qed.Lemmapath_pred_sumX(p:X->HProp) :X=sigp+sig(funx=> ~px).Proof.applypath_universe_uncurried.srapplyequiv_adjointify.-introsx.destruct(LEM(px)_)as[H|H]; [left|right];byexistsx.-intros[[x_]|[x_]];exactx.-cbn.intros[[xHx]|[xHx]];destructLEMas[H|H];trycontradiction.+enough(H=Hx)as->byreflexivity.applypath_ishprop.+enough(H=Hx)as->byreflexivity.applypath_forall.byintrosHP.-cbn.introsx.bydestructLEM.Qed.Definitionran{XY:Type} (f:X->Y) :=funy=>hexists(funx=>fx=y).Lemmapath_ran{X} {Y:HSet} (f:X->Y) :IsInjectivef->sig(ranf) =X.Proof.introsHf.applypath_universe_uncurried.srapplyequiv_adjointify.-intros[yH].destruct(iota(funx=>fx=y)_)as[xHx];tryexactx.split;tryapplyH.introsxx'.cbn.introsHyHy'.rewrite<-Hy'inHy.byapplyHf.-introsx.exists(fx).applytr.existsx.reflexivity.-cbn.introsx.destructiotaas[x'H].byapplyHf.-cbn.intros[yx].applypath_sigma_hprop.cbn.destructiotaas[x'Hx].applyHx.Qed.Equivalences on infinite setsLemmapath_infinite_unit(X:HSet) :infiniteX->Unit+X=X.Proof.intros[fHf].rewrite(@path_pred_sumX(ranf)).rewrite(path_ran_Hf).rewritepath_sum_assoc.rewritepath_unit_nat.reflexivity.Qed.Factpath_infinite_power(X:HSet) :infiniteX-> (X->HProp) + (X->HProp) = (X->HProp).Proof.introsH.rewritepath_sum_bool.rewrite<-path_bool_subsingleton.rewritepath_sum_prod.byrewritepath_infinite_unit.Qed.Variants of Cantors's theorem(* For the second ingredient, we give a preliminary version (Cantor_path_inject) to see the idea, as well as a stronger refinement (Cantor_injects_injects) which is then a mere reformulation. *)Context{PR:PropResizing}.LemmaCantorX(f:X->X->Type) :{p|forallx,fx<>p}.Proof.exists(funx=> ~fxx).introsxH.enough(Hx:fxx<-> ~fxx).-applyHx;applyHx;introsH';byapplyHx.-pattern(fx)at1.rewriteH.reflexivity.Qed.LemmahCantor{X} (f:X->X->HProp) :{p|forallx,fx<>p}.Proof.exists(funx=>Build_HProp(fxx->Empty)).introsxH.enough(Hx:fxx<-> ~fxx).-applyHx;applyHx;introsH';byapplyHx.-pattern(fx)at1.rewriteH.reflexivity.Qed.Definitionclean_sum{XYZ} (f:X->Y+Z) :(forallxy,fx<>inly) ->forallx, {z|inrz=fx}.Proof.introsHf.enough(H:forallxa,a=fx-> {z:Z&inrz=fx}).-introsx.byapply(Hx(fx)).-introsxaHxa.specialize(Hfx).destruct(fx)as[y|z].+applyEmpty_rect.byapply(Hfy).+byexistsz.Qed.FactCantor_path_injection{XY} :(X->HProp) = (X+Y) -> (X+X) =X->Injection(X->HProp)Y.Proof.introsH1H2.assert(H:X+Y= (X->HProp) * (X->HProp)).-byrewrite<-H1,path_sum_prod,H2.-applyequiv_pathinHas[f[gHfgHgf_]].pose(f'x:=fst(f(inlx))).destruct(hCantorf')as[pHp].pose(g'q:=g(p,q)).assert(H':forallqx,g'q<>inlx).+introsqxH.apply(Hpx).unfoldf'.rewrite<-H.unfoldg'.byrewriteHfg.+exists(funx=>proj1(clean_sum_H'x)).introsqq'H.assert(Hqq':g'q=g'q').*destructclean_sumas[z<-].destructclean_sumas[z'<-].cbninH.byrewriteH.*unfoldg'inHqq'.change(snd(p,q) =snd(p,q')).rewrite<- (Hfg(p,q)), <- (Hfg(p,q')).byrewriteHqq'.Qed.(* Version just requiring propositional injections *)LemmaCantor_relX(R:X-> (X->HProp) ->HProp) :(forallxpp',Rxp->Rxp'->merely(p=p')) -> {p|forallx, ~Rxp}.Proof.introsHR.pose(pcx:=Build_HProp(smalltype(forallp:X->HProp,Rxp-> ~px))).existspc.introsxH.enough(Hpc:pcx<-> ~pcx). 2:split.{applyHpc;applyHpc;introsH';byapplyHpc. }-introsHx.applyequiv_smalltypeinHx.byapplyHx.-introsHx.applyequiv_smalltype.introspHp.eapplymerely_destruct;tryapply(HR___HpH).byintros->.Qed.LemmaInjectsInto_power_morphXY:InjectsIntoXY->InjectsInto(X->HProp) (Y->HProp).Proof.introsHF.eapplymerely_destruct;tryapplyHF.intros[fHf].applytr.exists(funp=>funy=>hexists(funx=>px/\y=fx)).introspqH.applypath_forall.introsx.applyequiv_path_iff_hprop.split;introsHx.-assert(Hp: (funy:Y=>hexists(funx:X=>px* (y=fx))) (fx)). {applytr.existsx.split;trivial. }pattern(fx)inHp.rewriteHinHp.eapplymerely_destruct;tryapplyHp.byintros[x'[Hq<- %Hf]].-assert(Hq: (funy:Y=>hexists(funx:X=>qx* (y=fx))) (fx)). {applytr.existsx.split;trivial. }pattern(fx)inHq.rewrite<-HinHq.eapplymerely_destruct;tryapplyHq.byintros[x'[Hp<- %Hf]].Qed.FactCantor_injects_injects{XY:HSet} :InjectsInto(X->HProp) (X+Y) ->InjectsInto(X+X)X->InjectsInto(X->HProp)Y.Proof.introsH1H2.assert(HF:InjectsInto((X->HProp) * (X->HProp)) (X+Y)).-eapplyInjectsInto_trans;tryapplyH1.eapplyInjectsInto_trans;tryapplyInjectsInto_power_morph,H2.rewritepath_sum_prod.applytr.reflexivity.-eapplymerely_destruct;tryapplyHF.intros[fHf].pose(Rxp:=hexists(funq=>f(p,q) =inlx)).destruct(@Cantor_rel_R)as[pHp].{introsxpp'H3H4.eapplymerely_destruct;tryapplyH3.intros[qHq].eapplymerely_destruct;tryapplyH4.intros[q'Hq'].applytr.changepwith(fst(p,q)).rewrite(Hf(p,q) (p',q'));trivial.byrewriteHq,Hq'. }pose(f'q:=f(p,q)).assert(H':forallqx,f'q<>inlx).+introsqxH.apply(Hpx).applytr.existsq.applyH.+applytr.exists(funx=>proj1(clean_sum_H'x)).introsqq'H.assert(Hqq':f'q=f'q').*destructclean_sumas[z<-].destructclean_sumas[z'<-].cbninH.byrewriteH.*applyHfinHqq'.changeqwith(snd(p,q)).byrewriteHqq'.Qed.EndPreparation.Sierpinski's TheoremSectionSierpinski.Context{UA:Univalence}.Context{EM:ExcludedMiddle}.Context{PR:PropResizing}.DefinitionpowfixX:=foralln, (power_iteratedXn+power_iteratedXn) = (power_iteratedXn).VariableHN:HSet->HSet.HypothesisHN_ninject:forallX, ~InjectsInto(HNX)X.VariableHN_bound:nat.HypothesisHN_inject:forallX,InjectsInto(HNX) (power_iteratedXHN_bound).(* This section then concludes the intermediate result that abstractly, any function HN behaving like the Hartogs number is tamed in the presence of GCH.  Morally we show that X <= HN(X) for all X, we just ensure that X is large enough by considering P(N + X). *)LemmaInjectsInto_sumXYX'Y':InjectsIntoXX'->InjectsIntoYY'->InjectsInto(X+Y) (X'+Y').Proof.introsH1H2.eapplymerely_destruct;tryapplyH1.intros[fHf].eapplymerely_destruct;tryapplyH2.intros[gHg].applytr.exists(funz=>matchzwithinlx=>inl(fx) |inry=>inr(gy)end).intros[x|y] [x'|y']H.-applyap.applyHf.applypath_sum_inlwithY'.applyH.-byapplyinl_ne_inrinH.-byapplyinr_ne_inlinH.-applyap.applyHg.applypath_sum_inrwithX'.applyH.Qed.(* The main proof is by induction on the cardinality bound for HN.  As the Hartogs number is bounded by P^3(X), we'd actually just need finitely many instances of GCH. *)LemmaSierpinski_step(X:HSet)n:GCH->infiniteX->powfixX->InjectsInto(HNX) (power_iteratedXn) ->InjectsIntoX(HNX).Proof.introsgchH1H2Hi.inductionn.-byapplyHN_ninjectinHi.-destruct(gch(Build_HSet(power_iteratedXn)) (Build_HSet(power_iteratedXn+HNX)))as[H|H].+byapplyinfinite_power_iterated.+applytr.existsinl.introsxx'.applypath_sum_inl.+eapplyInjectsInto_trans.*applyInjectsInto_sum;tryapplyHi.applytr,Injection_power.exact_.*cbn.specialize(H2(Sn)).cbninH2.rewriteH2.applytr,Injection_refl.+applyIHn.eapplyInjectsInto_trans;tryapplyH.applytr.existsinr.introsxy.applypath_sum_inr.+applyInjectsInto_transwith(power_iteratedX(Sn));tryapplytr,Injection_power_iterated.cbn.apply(Cantor_injects_injectsH).rewrite(H2n).applytr,Injection_refl.Qed.TheoremGCH_injects'(X:HSet) :GCH->infiniteX->InjectsIntoX(HN(Build_HSet(X->HProp))).Proof.introsgchHX.eapplyInjectsInto_trans;tryapplytr,Injection_power;tryapplyX.apply(@Sierpinski_step(Build_HSet(X->HProp))HN_boundgch).-applyinfinite_injectwithX;trivial.applyInjection_power.applyX.-introsn.cbn.rewrite!power_iterated_shift.eapplypath_infinite_power.cbn.byapplyinfinite_power_iterated.-applyHN_inject.Qed.TheoremGCH_injects(X:HSet) :GCH->InjectsIntoX(HN(Build_HSet(Build_HSet(nat+X) ->HProp))).Proof.introsgch.eapplyInjectsInto_transwith(nat+X).-applytr.existsinr.introsxy.applypath_sum_inr.-applyGCH_injects';trivial.existsinl.introsxy.applypath_sum_inl.Qed.EndSierpinski.(* Main result: GCH implies AC *)TheoremGCH_AC{UA:Univalence} {PR:PropResizing} {LEM:ExcludedMiddle} :GCH->Choice_type.Proof.introsgch.applyWO_AC.introsX.applytr.exists(hartogs_number(Build_HSet(Build_HSet(nat+X) ->HProp))).unshelveeapply(@GCH_injectsUALEMPRhartogs_number_3_Xgch).-introsY.introsH.eapplymerely_destruct;tryapplyH.applyhartogs_number_no_injection.-introsY.applytr.applyhartogs_number_injection.Qed.(* Note that the assumption of LEM is actually not necessary due to GCH_LEM. *)

--- Miscellaneous\Graph.html ---
GraphLibrary GraphRequireImportBasics.Overture.GraphsAGraphis a typegraph0of points together with a typegraph1of arrows between each points.RecordGraph:= {graph0:Type;graph1:graph0->graph0->Type;}.Coerciongraph0:Graph>->Sortclass.Coerciongraph1:Graph>->Funclass.

--- Miscellaneous\GraphQuotient.html ---
GraphQuotientLibrary GraphQuotientRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoidsBasics.Equivalences.RequireImportTypes.UniverseTypes.PathsTypes.ArrowTypes.SigmaCubical.DPath.Quotient of a graphDefinitionThe quotient of a graph is one of the simplest HITs that can be found in HoTT. It consists of a base type and a relation on it, and for every witness of a relation between two points of the type, a path.We use graph quotients to build up all our other non-recursive HITs. Their simplicity means that we can easily prove results about them and generalise them to other HITs.LocalUnsetEliminationSchemes.ModuleExportGraphQuotient.SectionGraphQuotient.Universesiju.Constrainti<=u,j<=u.Context{A:Type@{i}}.Private InductiveGraphQuotient(R:A->A->Type@{j}) :Type@{u} :=|gq:A->GraphQuotientR.Argumentsgq{R}a.Context{R:A->A->Type@{j}}.Axiomgqglue:forall{ab:A},Rab->paths(@gqRa) (gqb).DefinitionGraphQuotient_ind(P:GraphQuotientR->Type@{k})(gq':foralla,P(gqa))(gqglue':forallab(s:Rab),gqglues#gq'a=gq'b):forallx,Px:=funx=>matchxwith|gqa=>fun_=>gq'aendgqglue'.Above we did a match with output type a function, and then outside of the match we provided the argumentgqglue'.  If we instead end with|gqa=>gq'aend., the definition will not depend ongqglue', which would be incorrect.  This is the idiom referred to in ../../test/bugs/github1758.v and github1759.v.AxiomGraphQuotient_ind_beta_gqglue:forall(P:GraphQuotientR->Type@{k})(gq':foralla,P(gqa))(gqglue':forallab(s:Rab),gqglues#gq'a=gq'b)(ab:A) (s:Rab),apD(GraphQuotient_indPgq'gqglue') (gqglues) =gqglue'abs.EndGraphQuotient.EndGraphQuotient.Argumentsgq{AR}a.DefinitionGraphQuotient_rec{ARP} (c:A->P) (g:forallab,Rab->ca=cb):GraphQuotientR->P.Proof.srapplyGraphQuotient_ind.1:exactc.introsabs.refine(transport_const__@gabs).Defined.DefinitionGraphQuotient_rec_beta_gqglue{ARP}(c:A->P) (g:forallab,Rab->ca=cb)(ab:A) (s:Rab):ap(GraphQuotient_reccg) (gqglues) =gabs.Proof.unfoldGraphQuotient_rec.refine(cancelL____).refine((apD_const__)^ @_).rapplyGraphQuotient_ind_beta_gqglue.Defined.The flattening lemmaUnivalence tells us that type families over a colimit correspond to cartesian families over the indexing diagram.  The flattening lemma gives an explicit description of the family over a colimit that corresponds to a given cartesian family, again using univalence.  Together, these are known as descent, a fundamental result in higher topos theory which has many implications.SectionFlattening.Context`{Univalence} {A:Type} {R:A->A->Type}.We consider a type family overAwhich is "equifibrant" or "cartesian": the fibers are equivalent when the base points are related byR.Context(F:A->Type) (e:forallxy,Rxy->Fx<~>Fy).By univalence, the equivalences give equalities, which means thatFinduces a map on the quotient.DefinitionDGraphQuotient:GraphQuotientR->Type:=GraphQuotient_recF(funxys=>path_universe(exys)).The transport ofDGraphQuotientalonggqglueequals the equivalenceeapplied to the original point. This lemma is required a few times in the following proofs.Definitiontransport_DGraphQuotient{xy} (s:Rxy) (a:Fx):transportDGraphQuotient(gqglues)a=exysa.Proof.lhsnrapplytransport_idmap_ap.lhsnrapply(transport2idmap).1:applyGraphQuotient_rec_beta_gqglue.rapplytransport_path_universe.Defined.The familyDGraphQuotientwe have defined overGraphQuotientRhas a total space which we will describe as aGraphQuotientofsigFby an appropriate relation.We mimic the constructors ofGraphQuotientfor the total space. Here is the point constructor.Definitionflatten_gq{x} :Fx->sigDGraphQuotient.Proof.introsp.exact(gqx;p).Defined.And here is the path constructor.Definitionflatten_gqglue{xy} (s:Rxy) (a:Fx):flatten_gqa=flatten_gq(exysa).Proof.snrapplypath_sigma'.-byapplygqglue.-applytransport_DGraphQuotient.Defined.This lemma is the same astransport_DGraphQuotientbut adapted instead forDPath. The use ofDPathwill be apparent there.Lemmaequiv_dp_dgraphquotient(xy:A) (s:Rxy) (a:Fx) (b:Fy):DPathDGraphQuotient(gqglues)ab<~> (exysa=b).Proof.refine(equiv_concat_l_^_).applytransport_DGraphQuotient.Defined.We can also prove an induction principle forsigDGraphQuotient. We won't show that it satisfies the relevant computation rules as these will not be needed. Instead we will prove the non-dependent eliminator directly so that we can better reason about it. In order to get through the path algebra here, we have opted to use dependent paths. This makes the reasoning slightly easier, but it should not matter too much.Definitionflatten_ind{Q:sigDGraphQuotient->Type}(Qgq:foralla(x:Fa),Q(flatten_gqx))(Qgqglue:forallab(s:Rab) (x:Fa),flatten_gqgluesx#Qgq_x=Qgq_(e___x)):forallx,Qx.Proof.applysig_ind.snrapplyGraphQuotient_ind.1:exactQgq.introsabs.applydp_forall.introsxy.srapply(equiv_ind(equiv_dp_dgraphquotientabsxy)^-1).introsq.destructq.refine(transport2___@Qgqglueabsx).refine(ap(path_sigma_uncurriedDGraphQuotient__)_).snrapplypath_sigma.1:reflexivity.lhsnrapplyconcat_p1.applyinv_V.Defined.Rather than useflatten_indto defineflatten_recwe reprove this simple case. This means we can later reason about it and derive the computation rules easily. The full computation rule forflatten_indtakes some work to derive and is not actually needed.Definitionflatten_rec{Q:Type} (Qgq:foralla,Fa->Q)(Qgqglue:forallab(s:Rab) (x:Fa),Qgqax=Qgqb(e__sx)):sigDGraphQuotient->Q.Proof.applysig_rec.snrapplyGraphQuotient_ind.1:exactQgq.introsabs.nrapplydpath_arrow.introsy.lhsnrapplytransport_const.lhsnrapply(Qgqglueabs).f_ap;symmetry.applytransport_DGraphQuotient.Defined.The non-dependent eliminator computes as expected on our "path constructor".Definitionflatten_rec_beta_gqglue{Q:Type} (Qgq:foralla,Fa->Q)(Qgqglue:forallab(r:Rab) (x:Fa),Qgqax=Qgqb(e__rx))(ab:A) (s:Rab) (x:Fa):ap(flatten_recQgqQgqglue) (flatten_gqgluesx) =Qgqglueabsx.Proof.lhsnrapplyap_sig_rec_path_sigma;cbn.lhsnrapply(ap(funx=>x@_)).{nrapplyap.nrapply(ap01(funx=>ap10x_)).nrapplyGraphQuotient_ind_beta_gqglue. }applymoveR_pM.applymoveL_pM.do3lhsnrapplyconcat_pp_p.applymoveR_Vp.lhsrefine(1 @@ (1 @@ (_@@ 1))).1:nrapply(ap10_dpath_arrowDGraphQuotient(fun_=>Q) (gqglues)).lhsrefine(1 @@ (1 @@_)).{lhsnrapplyconcat_pp_p.nrapplyconcat_pp_p. }lhsnrapply(1 @@concat_V_pp__).lhsnrapplyconcat_V_pp.lhsnrapplyconcat_pp_p.f_ap.lhsnrapplyconcat_pp_p.applymoveR_Mp.rhsnrapplyconcat_Vp.applymoveR_pV.rhsnrapplyconcat_1p.nrapplyap_V.Defined.Now that we've shown thatsigDGraphQuotientacts like aGraphQuotientofsigFby an appropriate relation, we can use this to prove the flattening lemma. The maps back and forth are very easy so this could almost be a formal consequence of the induction principle.Lemmaequiv_gq_flatten:sigDGraphQuotient<~>GraphQuotient(funab=> {r:Ra.1b.1 &e__ra.2 =b.2}).Proof.snrapplyequiv_adjointify.-snrapplyflatten_rec.+exact(funax=>gq(a;x)).+introsabrx.applygqglue.existsr.reflexivity.-snrapplyGraphQuotient_rec.+exact(fun'(a;x) => (gqa;x)).+intros[ax] [by] [rp].simplinp,r.destructp.applyflatten_gqglue.-snrapplyGraphQuotient_ind.1:reflexivity.intros[ax] [by] [rp].simplinp,r.destructp.simpl.lhsnrapplytransport_paths_FFlr.rewriteGraphQuotient_rec_beta_gqglue.refine((_@@ 1) @concat_Vp_).lhsnrapplyconcat_p1.applyinverse2.nrapplyflatten_rec_beta_gqglue.-snrapplyflatten_ind.1:reflexivity.introsabrx.nrapply(transport_paths_FFlr'(g:=GraphQuotient_rec__));applyequiv_p1_1q.rewriteflatten_rec_beta_gqglue.exact(GraphQuotient_rec_beta_gqglue__(a;x) (b;eabrx) (r; 1)).Defined.EndFlattening.Functoriality of graph quotientsLemmafunctor_gq{AB:Type} (f:A->B){R:A->A->Type} {S:B->B->Type} (e:forallab,Rab->S(fa) (fb)):GraphQuotientR->GraphQuotientS.Proof.snrapplyGraphQuotient_rec.1:exact(funx=>gq(fx)).introsabr.applygqglue.applye.exactr.Defined.Lemmafunctor_gq_idmap{A:Type} {R:A->A->Type}:functor_gq(A:=A) (B:=A) (S:=R)idmap(funabr=>r) ==idmap.Proof.snrapplyGraphQuotient_ind.1:reflexivity.introsabr.nrapply(transport_paths_FlFr'(gqgluer)).applyequiv_p1_1q.rhsnrapplyap_idmap.nrapplyGraphQuotient_rec_beta_gqglue.Defined.Lemmafunctor_gq_compose{ABC:Type} (f:A->B) (g:B->C){R:A->A->Type} {S:B->B->Type} {T:C->C->Type}(e:forallab,Rab->S(fa) (fb)) (e':forallab,Sab->T(ga) (gb)):functor_gqge'o(functor_gqfe) ==functor_gq(gof) (funabr=>e'__(e__r)).Proof.snrapplyGraphQuotient_ind.1:reflexivity.introsabs.nrapply(transport_paths_FlFr'(gqglues)).applyequiv_p1_1q.lhsnrapply(ap_compose(functor_gqfe) (functor_gqge') (gqglues)).lhsnrapplyap.1:applyGraphQuotient_rec_beta_gqglue.lhsnrapplyGraphQuotient_rec_beta_gqglue.exact(GraphQuotient_rec_beta_gqglue____s)^.Defined.Lemmafunctor2_gq{AB:Type} (ff':A->B){R:A->A->Type} {S:B->B->Type}(e:forallab,Rab->S(fa) (fb)) (e':forallab,Rab->S(f'a) (f'b))(p:f==f')(q:forallabr,transport011S(pa) (pb) (eabr) =e'abr):functor_gqfe==functor_gqf'e'.Proof.snrapplyGraphQuotient_ind.-simpl;intro.applyap.applyp.-introsabs.nrapply(transport_paths_FlFr'(gqglues)).rhsnrefine(1 @@_).2:applyGraphQuotient_rec_beta_gqglue.lhsnrefine(_@@ 1).1:applyGraphQuotient_rec_beta_gqglue.applymoveL_Mp.symmetry.destruct(qabs).lhsnrapply(ap_transport011__(funs_=>gqglue)).rhsnrapplyconcat_p_pp.nrapplytransport011_paths.Defined.Equivalence of graph quotientsGlobal Instanceisequiv_functor_gq{AB:Type} (f:A->B) `{IsEquiv__f}{R:A->A->Type} {S:B->B->Type} (e:forallab,Rab->S(fa) (fb))`{forallab,IsEquiv(eab)}:IsEquiv(functor_gqfe).Proof.srapplyisequiv_adjointify.-nrapply(functor_gqf^-1).introsabs.apply(e__)^-1.exact(transport011S(eisretrfa)^ (eisretrfb)^s).-introsx.lhsnrapplyfunctor_gq_compose.rhs_Vnrapplyfunctor_gq_idmap.snrapplyfunctor2_gq;cbnbeta.1:applyeisretr.introsabs.rewrite(eisretr(e(f^-1a) (f^-1b))).lhs_Vnrapplytransport011_pp.byrewrite2concat_Vp.-introsx.lhsnrapplyfunctor_gq_compose.rhs_Vnrapplyfunctor_gq_idmap.snrapplyfunctor2_gq;cbnbeta.1:applyeissect.introsabr.rewrite2eisadj.rewrite<- 2ap_V.rewrite<- (transport011_composeS).rewrite<- (ap_transport011(Q:=funxy=>S(fx) (fy)) (eissectfa)^ (eissectfb)^e).rewrite(eissect(e(f^-1 (fa)) (f^-1 (fb)))).lhs_Vnrapplytransport011_pp.byrewrite2concat_Vp.Defined.Definitionequiv_functor_gq{AB:Type} (f:A<~>B)(R:A->A->Type) (S:B->B->Type) (e:forallab,Rab<~>S(fa) (fb)):GraphQuotientR<~>GraphQuotientS:=Build_Equiv__(functor_gqfe)_.

--- Miscellaneous\Group.html ---
GroupLibrary GroupRequireImportBasicsTypesHPropHFiberHSet.RequireImportPathAny.RequireImport(notations)Classes.interfaces.canonical_names.RequireExport(hints)Classes.interfaces.abstract_algebra.RequireExport(hints)Classes.interfaces.canonical_names.We only export the parts of these that will be most useful to users of this file.RequireExportClasses.interfaces.canonical_names(SgOp,sg_op,One,one,MonUnit,mon_unit,LeftIdentity,left_identity,RightIdentity,right_identity,Negate,negate,Associative,simple_associativity,associativity,LeftInverse,left_inverse,RightInverse,right_inverse,Commutative,commutativity).Exportcanonical_names.BinOpNotations.RequireExportClasses.interfaces.abstract_algebra(IsGroup(..),group_monoid,negate_l,negate_r,IsSemiGroup(..),sg_set,sg_ass,IsMonoid(..),monoid_left_id,monoid_right_id,monoid_semigroup,IsMonoidPreserving(..),monmor_unitmor,monmor_sgmor,IsSemiGroupPreserving,preserves_sg_op,IsUnitPreserving,preserves_mon_unit).RequireExportClasses.theory.groups.RequireImportPointed.Core.RequireImportWildCat.RequireImportSpaces.Nat.CoreSpaces.Int.RequireImportTruncations.Core.LocalSetPolymorphicInductiveCumulativity.Generalizable VariablesGHABCfg.Declare Scopegroup_scope.GroupsA group is an abstraction of several common situations in mathematics. For example, consider the symmetries of an object.  Two symmetries can be combined; there is a symmetry that does nothing; and any symmetry can be reversed. Such situations arise in geometry, algebra and, importantly for us, homotopy theory.Local OpenScopepointed_scope.Local OpenScopemc_mult_scope.Local OpenScopewc_iso_scope.Definition of a GroupA group consists of a type, an operation on that type, a unit and an inverse that satisfy the group axioms inIsGroup.RecordGroup:= {group_type:>Type;group_sgop::SgOpgroup_type;group_unit::MonUnitgroup_type;group_inverse::Negategroup_type;group_isgroup::IsGroupgroup_type;}.Argumentsgroup_sgop{_}.Argumentsgroup_unit{_}.Argumentsgroup_inverse{_}.Argumentsgroup_isgroup{_}.We should never need to unfold the proof that something is a group.Global Opaquegroup_isgroup.Definitionissig_group:_<~>Group:=ltac:(issig).Proof automationMany times in group theoretic proofs we want some form of automation for obvious identities. Here we implement such a behavior.We create a database of hints for the group theory libraryCreate HintDbgroup_db.Our group laws can be proven easily with tactics such asrapplyassociativity. However this requires a typeclass search on more general algebraic structures. Therefore we explicitly list many groups laws here so that coq can use them. We also create hints for each law in our groups database.SectionGroupLaws.Context{G:Group} (xyz:G).Definitiongrp_assoc:=associativityxyz.Definitiongrp_unit_l:=left_identityx.Definitiongrp_unit_r:=right_identityx.Definitiongrp_inv_l:=left_inversex.Definitiongrp_inv_r:=right_inversex.EndGroupLaws.#[export]HintImmediategrp_assoc:group_db.#[export]HintImmediategrp_unit_l:group_db.#[export]HintImmediategrp_unit_r:group_db.#[export]HintImmediategrp_inv_l:group_db.#[export]HintImmediategrp_inv_r:group_db.Given path types in a product we may want to decompose.#[export]HintExtern5 (@paths(_*_)__) => (applypath_prod) :group_db.Given path types in a sigma type of a hprop family (i.e. a subset) we may want to decompose.#[export]HintExtern6 (@paths(sig_)__) => (rapplypath_sigma_hprop) :group_db.We also declare a tactic (notation) for automatically solving group laws  TODO: improve this tactic so that it also rewrites and is able to solve basic group lemmas.Tactic Notation"grp_auto" :=hnf;intros;eautowithgroup_db.Some basic properties of groupsGroups are pointed sets with point the identity.Global Instanceispointed_group(G:Group):IsPointedG:= @mon_unitG_.Definitionptype_group:Group->pType:=funG=> [G,_].Coercionptype_group:Group>->pType.An element acting like the identity is unique.Definitionidentity_unique{A:Type} {Aop:SgOpA}(xy:A) {p:LeftIdentityAopx} {q:RightIdentityAopy}:x=y:= (qx)^ @py.Definitionidentity_unique'{A:Type} {Aop:SgOpA}(xy:A) {p:LeftIdentityAopx} {q:RightIdentityAopy}:y=x:= (identity_uniquexy)^.An element acting like an inverse is unique.Definitioninverse_unique`{IsMonoidA}(axy:A) {p:x*a=mon_unit} {q:a*y=mon_unit}:x=y.Proof.refine((right_identityx)^ @ap_q^ @_).refine(associativity___@_).refine(ap(funx=>x*y)p@_).applyleft_identity.Defined.Group homomorphismsGroup homomorphisms are maps between groups that preserve the group operation. They allow us to compare groups and map their structure to one another. This is useful for determining if two groups are really the same, in which case we say they are "isomorphic".A group homomorphism consists of a map between groups and a proof that the map preserves the group operation.RecordGroupHomomorphism(GH:Group) :=Build_GroupHomomorphism{grp_homo_map:>group_typeG->group_typeH;issemigrouppreserving_grp_homo::IsSemiGroupPreservinggrp_homo_map;}.Argumentsgrp_homo_map{GH}.ArgumentsBuild_GroupHomomorphism{GH}__.Argumentsissemigrouppreserving_grp_homo{GH}f_:rename.Basic properties of group homomorphismsGroup homomorphisms preserve group operations. This is an alias forissemigrouppreserving_grp_homowith the identity written explicitly.Definitiongrp_homo_op:forall{GH:Group} (f:GroupHomomorphismGH) (xy:G),f(x*y) =fx*fy:= @issemigrouppreserving_grp_homo.#[export]HintImmediategrp_homo_op:group_db.Group homomorphisms are unit preserving.Global Instanceisunitpreserving_grp_homo{GH:Group}(f:GroupHomomorphismGH):IsUnitPreservingf.Proof.unfoldIsUnitPreserving.apply(group_cancelL(fmon_unit)).rhsnrapplygrp_unit_r.rhs_Vrapply(ap_(monoid_left_id_mon_unit)).symmetry.nrapplyissemigrouppreserving_grp_homo.Defined.Group homomorphisms preserve identities. This is an alias for the previous statement.Definitiongrp_homo_unit:forall{GH:Group} (f:GroupHomomorphismGH),fmon_unit=mon_unit:= @isunitpreserving_grp_homo.#[export]HintImmediategrp_homo_unit:group_db.Therefore, group homomorphisms are monoid homomorphisms.Global Instanceismonoidpreserving_grp_homo{GH:Group}(f:GroupHomomorphismGH):IsMonoidPreservingf:= {}.Group homomorphisms are pointed maps.Definitionpmap_GroupHomomorphism{GH:Group} (f:GroupHomomorphismGH) :G->*H:=Build_pMapGHf(isunitpreserving_grp_homof).Coercionpmap_GroupHomomorphism:GroupHomomorphism>->pForall.Definitionissig_GroupHomomorphism(GH:Group) :_<~>GroupHomomorphismGH:=ltac:(issig).Function extensionality for group homomorphisms.Definitionequiv_path_grouphomomorphism{F:Funext} {GH:Group}{gh:GroupHomomorphismGH} :g==h<~>g=h.Proof.refine((equiv_ap(issig_GroupHomomorphismGH)^-1__)^-1oE_).refine(equiv_path_sigma_hprop__oE_).applyequiv_path_forall.Defined.Group homomorphisms are sets, in the presence of funext.Global Instanceishset_grouphomomorphism{F:Funext} {GH:Group}:IsHSet(GroupHomomorphismGH).Proof.applyistrunc_S.introsfg;apply(istrunc_equiv_istrunc_equiv_path_grouphomomorphism).Defined.Group homomorphisms preserve inverses.Definitiongrp_homo_inv{GH} (f:GroupHomomorphismGH):forallx,f(-x) = -(fx).Proof.introx.apply(inverse_unique(fx)).+refine(_@grp_homo_unitf).refine((grp_homo_opf(-x)x)^ @_).applyap.applygrp_inv_l.+applygrp_inv_r.Defined.#[export]HintImmediategrp_homo_inv:group_db.The identity map is a group homomorphism.Definitiongrp_homo_id{G:Group} :GroupHomomorphismGG:=Build_GroupHomomorphismidmap_.The composition of the underlying functions of two group homomorphisms is also a group homomorphism.Definitiongrp_homo_compose{GHK:Group}:GroupHomomorphismHK->GroupHomomorphismGH->GroupHomomorphismGK.Proof.introsfg.srapply(Build_GroupHomomorphism(fog)).Defined.Group IsomorphismsGroup isomorphsims are group homomorphisms whose underlying map happens to be an equivalence. They allow us to consider two groups to be the "same". They can be inverted and composed just like equivalences.An isomorphism of groups is defined as group homomorphism that is an equivalence.RecordGroupIsomorphism(GH:Group) :=Build_GroupIsomorphism{grp_iso_homo:>GroupHomomorphismGH;isequiv_group_iso::IsEquivgrp_iso_homo;}.We can build an isomorphism from an operation-preserving equivalence.DefinitionBuild_GroupIsomorphism'{GH:Group}(f:G<~>H) (h:IsSemiGroupPreservingf):GroupIsomorphismGH.Proof.srapplyBuild_GroupIsomorphism.1:srapplyBuild_GroupHomomorphism.exact_.Defined.Definitionissig_GroupIsomorphism(GH:Group):_<~>GroupIsomorphismGH:=ltac:(issig).The underlying equivalence of a group isomorphism.Definitionequiv_groupisomorphism{GH:Group}:GroupIsomorphismGH->G<~>H:=funf=>Build_EquivGHf_.Coercionequiv_groupisomorphism:GroupIsomorphism>->Equiv.The underlying pointed equivalence of a group isomorphism.Definitionpequiv_groupisomorphism{AB:Group}:GroupIsomorphismAB-> (A<~>*B):=funf=>Build_pEquiv__f_.Coercionpequiv_groupisomorphism:GroupIsomorphism>->pEquiv.Funext for group isomorphisms.Definitionequiv_path_groupisomorphism`{F:Funext} {GH:Group}(fg:GroupIsomorphismGH):f==g<~>f=g.Proof.refine((equiv_ap(issig_GroupIsomorphismGH)^-1__)^-1oE_).refine(equiv_path_sigma_hprop__oE_).applyequiv_path_grouphomomorphism.Defined.Group isomorphisms form a set.Definitionishset_groupisomorphism`{F:Funext} {GH:Group}:IsHSet(GroupIsomorphismGH).Proof.applyistrunc_S.introsfg;apply(istrunc_equiv_istrunc_(equiv_path_groupisomorphism__)).Defined.The identity map is an equivalence and therefore a group isomorphism.Definitiongrp_iso_id{G:Group} :GroupIsomorphismGG:=Build_GroupIsomorphism__grp_homo_id_.Group isomorphisms can be composed by composing the underlying group homomorphism.Definitiongrp_iso_compose{GHK:Group}(g:GroupIsomorphismHK) (f:GroupIsomorphismGH):GroupIsomorphismGK:=Build_GroupIsomorphism__(grp_homo_composegf)_.Group isomorphisms can be inverted. The inverse map of the underlying equivalence also preserves the group operation and unit.Definitiongrp_iso_inverse{GH:Group}:GroupIsomorphismGH->GroupIsomorphismHG.Proof.intros[fe].srapplyBuild_GroupIsomorphism.-srapply(Build_GroupHomomorphismf^-1).-exact_.Defined.Group isomorphism is a reflexive relation.Global Instancereflexive_groupisomorphism:ReflexiveGroupIsomorphism:=funG=>grp_iso_id.Group isomorphism is a symmetric relation.Global Instancesymmetric_groupisomorphism:SymmetricGroupIsomorphism:=funGH=>grp_iso_inverse.Group isomorphism is a transitive relation.Global Instancetransitive_groupisomorphism:TransitiveGroupIsomorphism:=funGHKfg=>grp_iso_composegf.Under univalence, equality of groups is equivalent to isomorphism of groups. This is the structure identity principle for groups.Definitionequiv_path_group'{U:Univalence} {GH:Group}:GroupIsomorphismGH<~>G=H.Proof.equiv_via{f:G<~>H&IsSemiGroupPreservingf}.1:make_equiv.revertGH;apply(equiv_path_issig_contrissig_group).-intros[G[? [? [? ?]]]].exists1%equiv.exact_.-intros[G[op[unit[negax]]]];cbn.contr_sigsigG(equiv_idmapG).srefine(Build_Contr_((_;(_;(_;_)));_)_);cbn.1:assumption.1:exact_.intros[[op'[unit'[neg'ax']]]eq].applypath_sigma_hprop;cbn.refine(@ap__(funx: {oun:{oo:SgOpG& {u:MonUnitG&NegateG}}& @IsGroupGoun.1oun.2.1oun.2.2}=> (x.1.1 ;x.1.2.1 ;x.1.2.2 ;x.2))((op;unit;neg);ax) ((op';unit';neg');ax')_).applypath_sigma_hprop;cbn.srefine(path_sigma'___).1:funextxy;applyeq.rewritetransport_const.pose(f:=Build_GroupHomomorphism(G:=Build_GroupGopunitnegax)(H:=Build_GroupGop'unit'neg'ax')idmapeq).srefine(path_sigma'___).1:exact(grp_homo_unitf).lhsnrapplytransport_const.funextx.exact(grp_homo_invfx).Defined.A version with nicer universe variables.Definitionequiv_path_group@{uv|u<v} {U:Univalence} {GH:Group@{u}}:GroupIsomorphismGH<~> (paths@{v}GH):=equiv_path_group'.Simple group equivalencesLeft multiplication is an equivalence.Global Instanceisequiv_group_left_op{G:Group}:forall(x:G),IsEquiv(x*.).Proof.introx.srapplyisequiv_adjointify.1:exact(-x*.).all:introy.all:refine(grp_assoc___@_@grp_unit_ly).all:refine(ap(funx=>x*y)_).1:applygrp_inv_r.applygrp_inv_l.Defined.Right multiplication is an equivalence.Global Instanceisequiv_group_right_op(G:Group):forall(x:G),IsEquiv(funy=>y*x).Proof.introx.srapplyisequiv_adjointify.1:exact(funy=>y* -x).all:introy.all:refine((grp_assoc___)^ @_@grp_unit_ry).all:refine(ap(y*.)_).1:applygrp_inv_l.applygrp_inv_r.Defined.The operation inverting group elements is an equivalence. Note that, since the order of the operation will change after inversion, this isn't a group homomorphism.Global Instanceisequiv_group_inverse{G:Group}:IsEquiv((-) :G->G).Proof.srapplyisequiv_adjointify.1:apply(-).all:intro;applynegate_involutive.Defined.Reasoning with equations in groups.SectionGroupEquations.Context{G:Group} (xyz:G).Inverses are involutive.Definitiongrp_inv_inv: --x=x:=negate_involutivex.Inverses distribute over the group operation.Definitiongrp_inv_op: - (x*y) = -y* -x:=negate_sg_opxy.The inverse of the unit is the unit.Definitiongrp_inv_unit: -mon_unit=mon_unit:=negate_mon_unit(G:=G).EndGroupEquations.Cancelation lemmasGroup elements can be cancelled both on the left and the right.Definitiongrp_cancelL{G:Group} {xy:G}z:x=y<~>z*x=z*y:=equiv_ap(funx=>z*x)__.Definitiongrp_cancelR{G:Group} {xy:G}z:x=y<~>x*z=y*z:=equiv_ap(funx=>x*z)__.Group movement lemmasSectionGroupMovement.Since left/right multiplication is an equivalence, we can use lemmas about moving equivalences around to prove group movement lemmas.Context{G:Group} {xyz:G}.Moving group elementsDefinitiongrp_moveL_gM:x* -z=y<~>x=y*z:=equiv_moveL_equiv_M(f:=funt=>t*z)__.Definitiongrp_moveL_Mg: -y*x=z<~>x=y*z:=equiv_moveL_equiv_M(f:=funt=>y*t)__.Definitiongrp_moveR_gM:x=z* -y<~>x*y=z:=equiv_moveR_equiv_M(f:=funt=>t*y)__.Definitiongrp_moveR_Mg:y= -x*z<~>x*y=z:=equiv_moveR_equiv_M(f:=funt=>x*t)__.Moving inverses.These are the inverses of the previous but are included here for completenessDefinitiongrp_moveR_gV:x=y*z<~>x* -z=y:=equiv_moveR_equiv_V(f:=funt=>t*z)__.Definitiongrp_moveR_Vg:x=y*z<~> -y*x=z:=equiv_moveR_equiv_V(f:=funt=>y*t)__.Definitiongrp_moveL_gV:x*y=z<~>x=z* -y:=equiv_moveL_equiv_V(f:=funt=>t*y)__.Definitiongrp_moveL_Vg:x*y=z<~>y= -x*z:=equiv_moveL_equiv_V(f:=funt=>x*t)__.We close the section here so the previous lemmas generalise their assumptions.EndGroupMovement.SectionGroupMovement.Context{G:Group} {xyz:G}.Moving elements equal to unit.Definitiongrp_moveL_1M:x* -y=mon_unit<~>x=y:=equiv_concat_r(grp_unit_l_)_oEgrp_moveL_gM.Definitiongrp_moveL_1V:x*y=mon_unit<~>x= -y:=equiv_concat_r(grp_unit_l_)_oEgrp_moveL_gV.Definitiongrp_moveL_M1: -y*x=mon_unit<~>x=y:=equiv_concat_r(grp_unit_r_)_oEgrp_moveL_Mg.Definitiongrp_moveR_1M:mon_unit=y* (-x) <~>x=y:= (equiv_concat_l(grp_unit_l_)_)^-1%equivoEgrp_moveR_gM.Definitiongrp_moveR_M1:mon_unit= -x*y<~>x=y:= (equiv_concat_l(grp_unit_r_)_)^-1%equivoEgrp_moveR_Mg.Cancelling elements equal to unit.Definitiongrp_cancelL1:x=mon_unit<~>z*x=z:= (equiv_concat_r(grp_unit_r_)_oEgrp_cancelLz).Definitiongrp_cancelR1:x=mon_unit<~>x*z=z:= (equiv_concat_r(grp_unit_l_)_)oEgrp_cancelRz.EndGroupMovement.CommutationIfgcommutes withh, thengcommutes with the inverse-h.Definitiongrp_commutes_inv{G:Group} (gh:G) (p:g*h=h*g):g* (-h) = (-h) *g.Proof.applygrp_moveR_gV.rhs_Vapplysimple_associativity.byapplygrp_moveL_Vg.Defined.Ifgcommutes withhandh', thengcommutes with their producth*h'.Definitiongrp_commutes_op{G:Group} (ghh':G)(p:g*h=h*g) (p':g*h'=h'*g):g* (h*h') = (h*h') *g.Proof.lhsapplysimple_associativity.lhsnrapply(ap(.*h')p).lhs_Vapplysimple_associativity.lhsnrapply(ap(h*.)p').byapplysimple_associativity.Defined.Power operationFor a giveng:Gwe can define the functionInt->Gsending an integer to that power ofg.Definitiongrp_pow{G:Group} (g:G) (n:Int) :G:=int_iter(g*.)nmon_unit.Any homomorphism respectsgrp_pow. In other words,fung=>grp_powgnis natural.Lemmagrp_pow_natural{GH:Group} (f:GroupHomomorphismGH) (n:Int) (g:G):f(grp_powgn) =grp_pow(fg)n.Proof.lhssnrapply(int_iter_commute_map_((fg) *.)).1:nrapplygrp_homo_op.apply(ap(int_iter_n)),grp_homo_unit.Defined.All powers of the unit are the unit.Definitiongrp_pow_unit{G:Group} (n:Int):grp_pow(G:=G)mon_unitn=mon_unit.Proof.snrapply(int_iter_invariantn_(fung=>g=mon_unit));cbn.1, 2:applypaths_ind_r.-applygrp_unit_r.-lhsnrapplygrp_unit_r.applygrp_inv_unit.-reflexivity.Defined.Note that powers don't preserve the group operation as it is not commutative. This does hold in an abelian group so such a result will appear later.The next two results tell us howgrp_powunfolds.Definitiongrp_pow_succ{G:Group} (n:Int) (g:G):grp_powg(n.+1)%int=g*grp_powgn:=int_iter_succ_l___.Definitiongrp_pow_pred{G:Group} (n:Int) (g:G):grp_powg(n.-1)%int= (-g) *grp_powgn:=int_iter_pred_l___.grp_powsatisfies an additive law of exponents.Definitiongrp_pow_add{G:Group} (mn:Int) (g:G):grp_powg(n+m)%int=grp_powgn*grp_powgm.Proof.lhsnrapplyint_iter_add.inductionn;cbn.1:exact(grp_unit_l_)^.1:rewriteint_iter_succ_l,grp_pow_succ.2:rewriteint_iter_pred_l,grp_pow_pred;cbn.1,2 :rhs_Vsrapplyassociativity;applyap,IHn.Defined.grp_powcommutes negative exponents to powers of the inverseDefinitiongrp_pow_neg{G:Group} (n:Int) (g:G):grp_powg(int_negn) =grp_pow(-g)n.Proof.lhsnrapplyint_iter_neg.cbn;unfoldgrp_pow.(* These agree, except for the proofs thatsg_op(-g)is an equivalence. *)applyint_iter_agree.Defined.Using a negative power ingrp_powis the same as first using a positive power and then inverting the result.Definitiongrp_pow_neg_inv{G:Group} (m:Int) (g:G) :grp_powg(-m)%int= -grp_powgm.Proof.applygrp_moveL_1V.lhs_Vnrapplygrp_pow_add.byrewriteint_add_neg_l.Defined.Combining the two previous results gives that a power of an inverse is the inverse of the power.Definitiongrp_pow_neg_inv'{G:Group} (n:Int) (g:G) :grp_pow(-g)n= -grp_powgn.Proof.lhs_Vnrapplygrp_pow_neg.applygrp_pow_neg_inv.Defined.grp_powsatisfies a multiplicative law of exponents.Definitiongrp_pow_int_mul{G:Group} (mn:Int) (g:G):grp_powg(m*n)%int=grp_pow(grp_powgm)n.Proof.inductionn.-simpl.byrewriteint_mul_0_r.-rewriteint_mul_succ_r.rewritegrp_pow_add.rewritegrp_pow_succ.applygrp_cancelL,IHn.-rewriteint_mul_pred_r.rewritegrp_pow_add.rewritegrp_pow_neg_inv.rewritegrp_pow_pred.applygrp_cancelL,IHn.Defined.Ifhcommutes withg, thenhcommutes withgrp_powgn.Definitiongrp_pow_commutes{G:Group} (n:Int) (gh:G)(p:h*g=g*h):h* (grp_powgn) = (grp_powgn) *h.Proof.inductionn.-exact(grp_unit_r_@ (grp_unit_l_)^).-rewritegrp_pow_succ.nrapplygrp_commutes_op;assumption.-rewritegrp_pow_pred.nrapplygrp_commutes_op.2:assumption.applygrp_commutes_inv,p.Defined.grp_powgncommutes withg.Definitiongrp_pow_commutes'{G:Group} (n:Int) (g:G):g*grp_powgn=grp_powgn*g.Proof.byapplygrp_pow_commutes.Defined.Ifgandhcommute, thengrp_pow(g*h)n= (grp_pow g n) * (grp_pow h n)].Definitiongrp_pow_mul{G:Group} (n:Int) (gh:G)(c:g*h=h*g):grp_pow(g*h)n= (grp_powgn) * (grp_powhn).Proof.inductionn.-simpl.symmetry;nrapplygrp_unit_r.-rewrite3grp_pow_succ.rewriteIHn.rewrite2grp_assoc.applygrp_cancelR.rewrite<- 2grp_assoc.applygrp_cancelL.applygrp_pow_commutes.exactc^.-simpl.rewrite3grp_pow_pred.rewriteIHn.rewrite2grp_assoc.applygrp_cancelR.rewritec.rewritegrp_inv_op.rewrite<- 2grp_assoc.applygrp_cancelL.applygrp_pow_commutes.symmetry;applygrp_commutes_inv,c.Defined.The category of GroupsGroups together with homomorphisms form a 1-category whose equivalences are the group isomorphisms.Global Instanceisgraph_group:IsGraphGroup:=Build_IsGraphGroupGroupHomomorphism.Global Instanceis01cat_group:Is01CatGroup:=Build_Is01CatGroup_(@grp_homo_id) (@grp_homo_compose).Helper notation so that the wildcat instances can easily be inferred.Local Notationgrp_homo_map'AB:= (@grp_homo_mapAB:_-> (group_typeA$->_)).Global Instanceis2graph_group:Is2GraphGroup:=funAB=>isgraph_induced(grp_homo_map'AB).Global Instanceisgraph_grouphomomorphism{AB:Group} :IsGraph(A$->B):=isgraph_induced(grp_homo_map'AB).Global Instanceis01cat_grouphomomorphism{AB:Group} :Is01Cat(A$->B):=is01cat_induced(grp_homo_map'AB).Global Instanceis0gpd_grouphomomorphism{AB:Group}:Is0Gpd(A$->B):=is0gpd_induced(grp_homo_map'AB).Global Instanceis0functor_postcomp_grouphomomorphism{ABC:Group} (h:B$->C):Is0Functor(@cat_postcompGroup__ABCh).Proof.applyBuild_Is0Functor.introsfgpa;exact(aph(pa)).Defined.Global Instanceis0functor_precomp_grouphomomorphism{ABC:Group} (h:A$->B):Is0Functor(@cat_precompGroup__ABCh).Proof.applyBuild_Is0Functor.intros[f?] [g?]pa;exact(p(ha)).Defined.Group forms a 1CatGlobal Instanceis1cat_group:Is1CatGroup.Proof.byrapplyBuild_Is1Cat.Defined.UnderFunext, the category of groups has morphism extensionality.Global Instancehasmorext_group`{Funext} :HasMorExtGroup.Proof.srapplyBuild_HasMorExt.introsABfg;cbnin*.snrapply@isequiv_homotopic.1:exact(equiv_path_grouphomomorphism^-1%equiv).1:exact_.intros[];reflexivity.Defined.Group isomorphisms become equivalences in the category of groups.Global Instancehasequivs_group:HasEquivsGroup.Proof.unshelveeconstructor.+exactGroupIsomorphism.+exact(funGHf=>IsEquivf).+introsGHf;exactf.+exactBuild_GroupIsomorphism.+introsGH;exactgrp_iso_inverse.+cbn;exact_.+reflexivity.+intros????;applyeissect.+intros????;applyeisretr.+introsGHfgpq.exact(isequiv_adjointifyfgpq).Defined.Global Instanceis1cat_strong`{Funext} :Is1Cat_StrongGroup.Proof.rapplyBuild_Is1Cat_Strong.all:intros;applyequiv_path_grouphomomorphism;intro;reflexivity.Defined.Thegroup_typemap is a 1-functor.Global Instanceis0functor_type_group:Is0Functorgroup_type.Proof.applyBuild_Is0Functor.rapply@grp_homo_map.Defined.Global Instanceis1functor_type_group:Is1Functorgroup_type.Proof.byapplyBuild_Is1Functor.Defined.Theptype_groupmap is a 1-functor.Global Instanceis0functor_ptype_group:Is0Functorptype_group.Proof.applyBuild_Is0Functor.rapply@pmap_GroupHomomorphism.Defined.Global Instanceis1functor_ptype_group:Is1Functorptype_group.Proof.applyBuild_Is1Functor;intros;byapplyphomotopy_homotopy_hset.Defined.Given a group elementa0:Aoverb:B, multiplication byaestablishes an equivalence between the kernel and the fiber overb.Lemmaequiv_grp_hfiber{AB:Group} (f:GroupHomomorphismAB) (b:B):forall(a0:hfiberfb),hfiberfb<~>hfiberfmon_unit.Proof.intros[a0p].refine(equiv_transport(hfiberf) (right_inverseb)oE_).snrapplyBuild_Equiv.{srapply(functor_hfiber(h:=funt=>t* -a0) (k:=funt=>t* -b)).introa;cbn;symmetry.refine(_@ap(funx=>fa* (-x))p).exact(grp_homo_opf__@ap(funx=>fa*x) (grp_homo_invfa0)). }srapplyisequiv_functor_hfiber.Defined.The trivial groupDefinitiongrp_trivial:Group.Proof.refine(Build_GroupUnit(fun__=>tt)tt(fun_=>tt)_).repeatsplit;tryexact_;byintros[].Defined.Map out of trivial group.Definitiongrp_trivial_rec(G:Group) :GroupHomomorphismgrp_trivialG.Proof.snrapplyBuild_GroupHomomorphism.1:exact(fun_=>group_unit).intros??;symmetry;applygrp_unit_l.Defined.Map into trivial group.Definitiongrp_trivial_corec(G:Group) :GroupHomomorphismGgrp_trivial.Proof.snrapplyBuild_GroupHomomorphism.1:exact(fun_=>tt).intros??;symmetry;exact(grp_unit_l_).Defined.Group is a pointed category.Global Instanceispointedcat_group:IsPointedCatGroup.Proof.snrapplyBuild_IsPointedCat.-exactgrp_trivial.-introG.exists(grp_trivial_recG).introsg[];cbn.exact(grp_homo_unitg)^.-introG.exists(grp_trivial_corecG).introsgx;cbn.applypath_unit.Defined.Definitiongrp_homo_const{GH:Group} :GroupHomomorphismGH:=zero_morphism.The direct product of groupsThe cartesian product of the underlying sets of two groups has a natural group structure. We call this the direct product of groups.Definitiongrp_prod:Group->Group->Group.Proof.introsGH.srapply(Build_Group(G*H)).Operation{intros[g1h1] [g2h2].exact(g1*g2,h1*h2). }Unit1:exact(mon_unit,mon_unit).Inverse{intros[gh].exact(-g, -h). }repeatsplit.1:exact_.all:grp_auto.Defined.Maps into the direct product can be built by mapping separately into each factor.Propositiongrp_prod_corec{GHK:Group} (f:K$->G) (g:K$->H):K$-> (grp_prodGH).Proof.snrapplyBuild_GroupHomomorphism.-exact(funx:K=> (fx,gx)).-introsxy.applypath_prod';applygrp_homo_op.Defined.grp_prod_corecsatisfies a definitional naturality property.Definitiongrp_prod_corec_natural{XYAB:Group}(f:X$->Y) (g0:Y$->A) (g1:Y$->B):grp_prod_corecg0g1$of$==grp_prod_corec(g0$of) (g1$of):=fun_=>idpath.The left factor injects into the direct product.Definitiongrp_prod_inl{HK:Group}:H$-> (grp_prodHK):=grp_prod_corecgrp_homo_idgrp_homo_const.The left injection is an embedding.Global Instanceisembedding_grp_prod_inl{HK:Group}:IsEmbedding(@grp_prod_inlHK).Proof.applyisembedding_isinj_hset.introsh0h1p;cbninp.exact(fst((equiv_path_prod__)^-1p)).Defined.The right factor injects into the direct product.Definitiongrp_prod_inr{HK:Group}:K$-> (grp_prodHK):=grp_prod_corecgrp_homo_constgrp_homo_id.The right injection is an embedding.Global Instanceisembedding_grp_prod_inr{HK:Group}:IsEmbedding(@grp_prod_inrHK).Proof.applyisembedding_isinj_hset.introsk0k1q;cbninq.exact(snd((equiv_path_prod__)^-1q)).Defined.Given two pairs of isomorphic groups, their pairwise direct products are isomorphic.Definitiongrp_iso_prod{ABCD:Group}:A≅B->C≅D-> (grp_prodAC) ≅ (grp_prodBD).Proof.introsfg.srapplyBuild_GroupIsomorphism'.1:srapply(equiv_functor_prod(f:=f) (g:=g)).simpl.unfoldfunctor_prod.introsxy.applypath_prod.1,2:applygrp_homo_op.Defined.The first projection of the direct product.Definitiongrp_prod_pr1{GH:Group}:GroupHomomorphism(grp_prodGH)G.Proof.snrapplyBuild_GroupHomomorphism.1:exactfst.intros? ?;reflexivity.Defined.The first projection is a surjection.Global Instanceissurj_grp_prod_pr1{GH:Group}:IsSurjection(@grp_prod_pr1GH):=issurj_retrgrp_prod_inl(fun_=>idpath).The second projection of the direct product.Definitiongrp_prod_pr2{GH:Group}:GroupHomomorphism(grp_prodGH)H.Proof.snrapplyBuild_GroupHomomorphism.1:exactsnd.intros? ?;reflexivity.Defined.Pairs in direct products can be decomposedDefinitiongrp_prod_decompose{GH:Group} (g:G) (h:H): (g,h) = ((g,group_unit) :grp_prodGH) * (group_unit,h).Proof.snrapplypath_prod;symmetry.-snrapplygrp_unit_r.-snrapplygrp_unit_l.Defined.The second projection is a surjection.Global Instanceissurj_grp_prod_pr2{GH:Group}:IsSurjection(@grp_prod_pr2GH):=issurj_retrgrp_prod_inr(fun_=>idpath).Groupis a category with binary products given by the direct product.Global Instancehasbinaryproducts_group:HasBinaryProductsGroup.Proof.introsGH.snrapplyBuild_BinaryProduct.-exact(grp_prodGH).-exactgrp_prod_pr1.-exactgrp_prod_pr2.-introsK.exactgrp_prod_corec.-introsKfg.exact(Id_).-introsKfg.exact(Id_).-introsKfgpqa.exact(path_prod'(pa) (qa)).Defined.Properties of maps to and from the trivial groupGlobal Instanceisinitial_grp_trivial:IsInitialgrp_trivial.Proof.introG.exists(grp_trivial_rec_).introsg[].apply(grp_homo_unitg)^.Defined.Global Instancecontr_grp_homo_trivial_source`{Funext}G:Contr(GroupHomomorphismgrp_trivialG).Proof.snrapplyBuild_Contr.1:exact(grp_trivial_rec_).introsg.rapplyequiv_path_grouphomomorphism.intros[].symmetry.rapplygrp_homo_unit.Defined.Global Instanceisterminal_grp_trivial:IsTerminalgrp_trivial.Proof.introG.exists(grp_trivial_corec_).introsgx.applypath_contr.Defined.Global Instancecontr_grp_homo_trivial_target`{Funext}G:Contr(GroupHomomorphismGgrp_trivial).Proof.snrapplyBuild_Contr.1:exact(pr1(isterminal_grp_trivial_)).introsg.rapplyequiv_path_grouphomomorphism.introsx.applypath_contr.Defined.Global Instanceishprop_grp_iso_trivial`{Funext} (G:Group):IsHProp(G≅grp_trivial).Proof.applyequiv_hprop_allpath.introsfg.applyequiv_path_groupisomorphism;intro;applypath_ishprop.Defined.Free groupsDefinitionFactorsThroughFreeGroup(S:Type) (F_S:Group)(i:S->F_S) (A:Group) (g:S->A) :Type:= {f:F_S$->A&foi==g}.Universal property of a free group on a set (type).ClassIsFreeGroupOn(S:Type) (F_S:Group) (i:S->F_S):=contr_isfreegroupon:forall(A:Group) (g:S->A),Contr(FactorsThroughFreeGroupSF_SiAg).Global Existing Instancecontr_isfreegroupon.A group is free if there exists a generating type on which it is a free group.ClassIsFreeGroup(F_S:Group):=isfreegroup: {S:_& {i:_&IsFreeGroupOnSF_Si}}.Global Instanceisfreegroup_isfreegroupon(S:Type) (F_S:Group) (i:S->F_S){H:IsFreeGroupOnSF_Si}:IsFreeGroupF_S:= (S;i;H).Further properties of group homomorphisms.Characterisation of injective group homomorphisms.Lemmaisembedding_grouphomomorphism{AB:Group} (f:A$->B): (foralla,fa=group_unit->a=group_unit) <->IsEmbeddingf.Proof.split.-introshb.applyhprop_allpath.intros[a0p0] [a1p1].srapplypath_sigma_hprop;simpl.applygrp_moveL_1M.applyh.rewritegrp_homo_op,grp_homo_inv.rewritep0,p1.applyright_inverse.-introsEap.rapply(isinj_embeddingf).exact(p@ (grp_homo_unitf)^).Defined.Commutativity can be transferred across isomorphisms.Definitioncommutative_iso_commutative{GH:Group}{C:Commutative(@group_sgopG)} (f:GroupIsomorphismGH):Commutative(@group_sgopH).Proof.unfoldCommutative.rapply(equiv_indf);introg1.rapply(equiv_indf);introg2.refine((preserves_sg_op__)^ @_@ (preserves_sg_op__)).refine(apf_).applyC.Defined.If two group homomorphisms agree on two elements, then they agree on their product.Definitiongrp_homo_op_agree{GG'H:Group} (f:G$->H) (f':G'$->H){xy:G} {x'y':G'} (p:fx=f'x') (q:fy=f'y'):f(x*y) =f'(x'*y').Proof.lhsnrapplygrp_homo_op.rhsnrapplygrp_homo_op.exact(ap011_pq).Defined.The group movement lemmas can be extended to when there is a homomorphism involved.  For now, we only include these two.Definitiongrp_homo_moveL_1V{AB:Group} (f:GroupHomomorphismAB) (xy:A):f(x*y) =group_unit<~> (fx= -fy):=grp_moveL_1VoEequiv_concat_l(grp_homo_opfxy)^_.Definitiongrp_homo_moveL_1M{AB:Group} (f:GroupHomomorphismAB) (xy:A):f(x* -y) =group_unit<~> (fx=fy).Proof.refine(grp_moveL_1MoEequiv_concat_l_^_).lhsnrapplygrp_homo_op.applyap,grp_homo_inv.Defined.

--- Miscellaneous\GroupCoeq.html ---
GroupCoeqLibrary GroupCoeqRequireImportBasicsTypes.RequireImportWildCat.Core.RequireImportTruncations.Core.RequireImportAlgebra.Groups.Group.RequireImportColimits.Coeq.RequireImportAlgebra.Groups.FreeProduct.Local OpenScopemc_scope.Local OpenScopemc_mult_scope.Coequalizers of group homomorphismsDefinitionGroupCoeq{AB:Group} (fg:A$->B) :Group.Proof.rapply(AmalgamatedFreeProduct(FreeProductAA)AB).1,2:applyFreeProduct_rec.+exactgrp_homo_id.+exactgrp_homo_id.+exactf.+exactg.Defined.Definitionequiv_groupcoeq_rec`{Funext} {ABC:Group} (fg:GroupHomomorphismAB): {h:B$->C&hof==hog} <~> (GroupCoeqfg$->C).Proof.refine(equiv_amalgamatedfreeproduct_rec______oE_).refine(equiv_sigma_symm_oE_).applyequiv_functor_sigma_id.introsh.snrapplyequiv_adjointify.{introsp.exists(grp_homo_composehf).hnf;introx.refine(p_@_).revertx.rapplyTrunc_ind.srapplyCoeq_ind_hprop.introsw.hnf.inductionw.1:applyap,grp_homo_unit.simpl.destructaas[a|a].1,2:refine(ap_(grp_homo_op___) @_).1,2:nrapplygrp_homo_op_agree;trivial.symmetry.applyp. }{intros[kp]x.assert(q1:=p(freeproduct_inlx)).assert(q2:=p(freeproduct_inrx)).simplinq1,q2.rewrite2right_identityinq1,q2.refine(q1^ @q2). }{hnf.intros[kp].applypath_sigma_hprop.simpl.applyequiv_path_grouphomomorphism.introy.pose(q1:=p(freeproduct_inly)).simplinq1.rewrite2right_identityinq1.exactq1^. }hnf;intros;applypath_ishprop.Defined.

--- Miscellaneous\GroupoidCategory.html ---
GroupoidCategoryLibrary GroupoidCategoryGroupoidsDefinitionRequireGroupoidCategory.Core.Morphisms in a groupoidRequireGroupoidCategory.Morphisms.Propositional self-dualityRequireGroupoidCategory.Dual.IncludeGroupoidCategory.Core.IncludeGroupoidCategory.Core.GroupoidCategoryInternals.IncludeGroupoidCategory.Morphisms.IncludeGroupoidCategory.Dual.

--- Miscellaneous\GrpPullback.html ---
GrpPullbackLibrary GrpPullbackRequireImportBasicsTypesLimits.PullbackCubical.PathSquare.RequireImportAlgebra.Groups.Group.RequireImportWildCat.Core.Pullbacks of groups are formalized by equipping the set-pullback with the desired group structure. The universal property in the category of groups is proved by saying that the corecursion principle (grp_pullback_corec) is an equivalence.Local OpenScopemc_scope.Local OpenScopemc_mult_scope.SectionGrpPullback.(* Variables are named to correspond with Limits.Pullback. *)Context{ABC:Group} (f:B$->A) (g:C$->A).Local Instancegrp_pullback_sgop:SgOp(Pullbackfg).Proof.intros[b[cp]] [d[eq]].refine(b*d;c*e;_).exact(grp_homo_op_agree__pq).Defined.Local Instancegrp_pullback_sgop_associative:Associativegrp_pullback_sgop.Proof.intros[x1[x2p]] [y1[y2q]] [z1[z2u]].applyequiv_path_pullback;simpl.refine(associativity___;associativity___;_).applyequiv_sq_path.applypath_ishprop.Defined.Local Instancegrp_pullback_issemigroup:IsSemiGroup(Pullbackfg) := {}.Local Instancegrp_pullback_mon_unit:MonUnit(Pullbackfg):= (1; 1;grp_homo_unitf@ (grp_homo_unitg)^).Local Instancegrp_pullback_leftidentity:LeftIdentitygrp_pullback_sgopgrp_pullback_mon_unit.Proof.intros[b[cp]];simpl.applyequiv_path_pullback;simpl.refine(left_identity_;left_identity_;_).applyequiv_sq_path.applypath_ishprop.Defined.Local Instancegrp_pullback_rightidentity:RightIdentitygrp_pullback_sgopgrp_pullback_mon_unit.Proof.intros[b[cp]];simpl.applyequiv_path_pullback;simpl.refine(right_identity_;right_identity_;_).applyequiv_sq_path.applypath_ishprop.Defined.Local Instanceismonoid_grp_pullback:IsMonoid(Pullbackfg) := {}.Local Instancegrp_pullback_negate:Negate(Pullbackfg).Proof.intros[b[cp]].refine(-b; -c;grp_homo_invfb@_@ (grp_homo_invgc)^).exact(ap(funa=> -a)p).Defined.Local Instancegrp_pullback_leftinverse:LeftInversegrp_pullback_sgopgrp_pullback_negategrp_pullback_mon_unit.Proof.unfoldLeftInverse.intros[b[cp]].unfoldgrp_pullback_sgop;simpl.applyequiv_path_pullback;simpl.refine(left_inverse_;left_inverse_;_).applyequiv_sq_path.applypath_ishprop.Defined.Local Instancegrp_pullback_rightinverse:RightInversegrp_pullback_sgopgrp_pullback_negategrp_pullback_mon_unit.Proof.intros[b[cp]].unfoldgrp_pullback_sgop;simpl.applyequiv_path_pullback;simpl.refine(right_inverse_;right_inverse_;_).applyequiv_sq_path.applypath_ishprop.Defined.Global Instanceisgroup_grp_pullback:IsGroup(Pullbackfg) := {}.Definitiongrp_pullback:Group:=Build_Group(Pullbackfg)____.Definitiongrp_pullback_pr1:grp_pullback$->B.Proof.snrapplyBuild_GroupHomomorphism.-applypullback_pr1.-introsxy.reflexivity.Defined.Definitiongrp_pullback_pr2:grp_pullback$->C.Proof.snrapplyBuild_GroupHomomorphism.-applypullback_pr2.-introsxy.reflexivity.Defined.Propositiongrp_pullback_corec{X:Group}(b:X$->B) (c:X$->C)(p:fob==goc):X$->grp_pullback.Proof.snrapplyBuild_GroupHomomorphism.-exact(funx=> (bx;cx;px)).-introsxy.srapplypath_sigma.+simpl.apply(grp_homo_opb).+unfoldpr2.refine(transport_sigma'__@_).unfoldpr1.applypath_sigma_hprop.simpl.apply(grp_homo_opc).Defined.Corollarygrp_pullback_corec'(X:Group): {b:X$->B& {c:X$->C&fob==goc}}-> (X$->grp_pullback).Proof.intros[b[cp]];exact(grp_pullback_corecbcp).Defined.EndGrpPullback.Definitionfunctor_grp_pullback{AA'BB'CC':Group}(f:B$->A) (f':B'$->A')(g:C$->A) (g':C'$->A')(alpha:A$->A') (beta:B$->B') (gamma:C$->C')(h:f'obeta==alphaof)(k:alphaog==g'ogamma):grp_pullbackfg$->grp_pullbackf'g'.Proof.srapplygrp_pullback_corec.-exact(beta$ogrp_pullback_pr1fg).-exact(gamma$ogrp_pullback_pr2fg).-introx;cbn.refine(h_@apalpha_@k_).applypullback_commsq.Defined.Definitionequiv_functor_grp_pullback{AA'BB'CC':Group}(f:B$->A) (f':B'$->A')(g:C$->A) (g':C'$->A')(alpha:GroupIsomorphismAA')(beta:GroupIsomorphismBB')(gamma:GroupIsomorphismCC')(h:f'obeta==alphaof)(k:alphaog==g'ogamma):GroupIsomorphism(grp_pullbackfg) (grp_pullbackf'g').Proof.srapplyBuild_GroupIsomorphism.1:exact(functor_grp_pullbackff'gg'___hk).srapplyisequiv_adjointify.{srapply(functor_grp_pullbackf'fg'g).1-3:rapplygrp_iso_inverse;assumption.+rapply(equiv_indbeta);introb.refine(apf(eissect__) @_).apply(equiv_ap'alpha__)^-1.exact((hb)^ @ (eisretr__)^).+rapply(equiv_indgamma);introc.refine(_@apg(eissect__)^).apply(equiv_ap'alpha__)^-1.exact(eisretr__@ (kc)^). }all:introx;applyequiv_path_pullback_hset;split;cbn.1-2:applyeisretr.1-2:applyeissect.Defined.Pulling back along someg:Y$->Zand theng':Y'$->Yis the same as pulling back alongg$og'.Definitionequiv_grp_pullback_compose_r{XZYY':Group} (f:X$->Z) (g':Y'$->Y) (g:Y$->Z):GroupIsomorphism(grp_pullback(grp_pullback_pr2fg)g') (grp_pullbackf(g$og')).Proof.srapplyBuild_GroupIsomorphism.-srapplygrp_pullback_corec.+exact(grp_pullback_pr1__$ogrp_pullback_pr1__).+applygrp_pullback_pr2.+introx;cbn.exact(pullback_commsq___@apg(pullback_commsq___)).-srapplyisequiv_adjointify.+srapplygrp_pullback_corec.*srapplyfunctor_grp_pullback.1,2:exactgrp_homo_id.1:exactg'.all:reflexivity.*applygrp_pullback_pr2.*reflexivity.+introx;cbn.bysrapplyequiv_path_pullback_hset.+intros[[x[yz0]] [y'z1]];srapplyequiv_path_pullback_hset;split;cbn.2:reflexivity.srapplyequiv_path_pullback_hset;split;cbn.1:reflexivity.exactz1^.Defined.SectionIsEquivGrpPullbackCorec.(* New section with Funext at the start of the Context. *)Context`{Funext} {ABC:Group} (f:B$->A) (g:C$->A).Lemmagrp_pullback_corec_pr1{X:Group}(b:X$->B) (c:X$->C)(p:fob==goc):grp_pullback_pr1fg$ogrp_pullback_corecfgbcp=b.Proof.applyequiv_path_grouphomomorphism;reflexivity.Defined.Lemmagrp_pullback_corec_pr2{X:Group}(b:X$->B) (c:X$->C)(p:fob==goc):grp_pullback_pr2fg$ogrp_pullback_corecfgbcp=c.Proof.applyequiv_path_grouphomomorphism;reflexivity.Defined.Theoremisequiv_grp_pullback_corec(X:Group):IsEquiv(grp_pullback_corec'fgX).Proof.snrapplyisequiv_adjointify.-introphi.refine(grp_pullback_pr1fg$ophi;grp_pullback_pr2fg$ophi;_).introx;exact(pullback_commsqfg(phix)).-introphi.applyequiv_path_grouphomomorphism;reflexivity.-introbcp;simpl.srapplypath_sigma.+simpl.applygrp_pullback_corec_pr1.+refine(transport_sigma'__@_).applypath_sigma_hprop;simplpr1.simpl.applygrp_pullback_corec_pr2.Defined.EndIsEquivGrpPullbackCorec.

--- Miscellaneous\Hartogs.html ---
HartogsLibrary HartogsFromHoTTRequireImportTruncTypeExcludedMiddleModalities.ReflectiveSubuniverseabstract_algebraHSet.FromHoTTRequireImportUniverses.Smallness.FromHoTTRequireImportSpaces.Card.FromHoTT.SetsRequireImportOrdinalsPowers.CloseScopetrunc_scope.This file contains a construction of the Hartogs number.We begin with some results about changing the universe of a power set using propositional resizing.Definitionpower_inj`{PropResizing} {C:Type@{i}} (p:C->HProp@{j}):C->HProp@{k}.Proof.exact(funa=>Build_HProp(smalltype@{kj} (pa))).Defined.Lemmainjective_power_inj`{PropResizing} {ua:Univalence} (C:Type@{i}):IsInjective(@power_inj_C).Proof.introspp'.unfoldpower_inj.introsq.applypath_forall.introsa.applypath_iff_hprop;introsHa.-eapplyequiv_smalltype.change((funa=>Build_HProp(smalltype(p'a)))a).rewrite<-q.applyequiv_smalltype.applyHa.-eapplyequiv_smalltype.change((funa=>Build_HProp(smalltype(pa)))a).rewriteq.applyequiv_smalltype.applyHa.Qed.(* TODO: Could factor this as something keeping theHPropuniverse the same, followed bypower_inj. *)Definitionpower_morph`{PropResizing} {ua:Univalence} {CB:Type@{i}} (f:C->B): (C->HProp) -> (B->HProp).Proof.introspb.exact(Build_HProp(smalltype(foralla,fa=b->pa))).Defined.Definitioninjective_power_morph`{PropResizing} {ua:Univalence} {CB:Type@{i}} (f:C->B):IsInjectivef->IsInjective(@power_morph__CBf).Proof.introsHfpp'q.applypath_forall.introsa.applypath_iff_hprop;introsHa.-enough(Hp:power_morphfp(fa)).+rewriteqinHp.applyequiv_smalltypeinHp.applyHp.reflexivity.+applyequiv_smalltype.introsa'-> %Hf.applyHa.-enough(Hp:power_morphfp'(fa)).+rewrite<-qinHp.applyequiv_smalltypeinHp.applyHp.reflexivity.+applyequiv_smalltype.introsa'-> %Hf.applyHa.Qed.We'll also need this result.Lemmale_Cardinal_lt_Ordinal`{PropResizing} `{Univalence} (BC:Ordinal):B<C->cardB≤cardC.Proof.introsB_C.applytr.cbn.rewrite(bound_propertyB_C).existsout.applyisinjective_simulation.applyis_simulation_out.Qed.Hartogs numberSectionHartogs_Number.Declare ScopeHartogs.OpenScopeHartogs.Notation"'𝒫'" :=power_type(atlevel30) :Hartogs.Local Coercionsubtype_as_type'{X} (Y: 𝒫X) := {x:X&Yx}.UniverseA.Context{univalence:Univalence}{prop_resizing:PropResizing}{lem:ExcludedMiddle}(A:HSet@{A}).(* The Hartogs number ofAconsists of all ordinals that embed intoA. Note that this construction necessarily increases the universe level. *)FailCheck{B:Ordinal@{A_} |cardB<=cardA} :Type@{A}.Definitionhartogs_number':Ordinal.Proof.set(carrier:= {B:Ordinal@{A_} &cardB<=cardA}).set(relation:=fun(BC:carrier) =>B.1 <C.1).existscarrierrelation.snrapply(isordinal_simulationpr1).1-4:exact_.-applyisinj_embedding, (mapinO_pr1(Tr(-1))).(* Faster thanexact_.*)-constructor.+introsaa'a_a'.exacta_a'.+intros[Bsmall_B]CC_B;cbnin*.applytr.unshelveeexists(C;_);cbn;auto.revertsmall_B.srapplyTrunc_rec.intros[fisinjective_f].applytr.destructC_Bas[b->].exists(fun'(x;x_b) =>fx);cbn.intros[xx_b] [yy_b]fx_fy.applypath_sigma_hprop;cbn.apply(isinjective_fxy).exactfx_fy.Defined.Definitionproper_subtype_inclusion(UV: 𝒫A):= (foralla,Ua->Va) /\merely(existsa:A,Va/\ ~(Ua)).Infix"⊊" :=proper_subtype_inclusion(atlevel50) :Hartogs.Notation"(⊊)" :=proper_subtype_inclusion:Hartogs.(* The hartogs number ofAembeds into the threefold power set ofA.  This preliminary injection also increases the universe level though. *)Lemmahartogs_number'_injection:existsf:hartogs_number'-> (𝒫 (𝒫 (𝒫A))),IsInjectivef.Proof.transparentassert(ϕ: (forallX: 𝒫 (𝒫A),LtX)). {introsX.introsx1x2.exact(x1.1 ⊊x2.1).}unshelveeexists.-intros[B_].introsX.exact(merely(Isomorphism(X:Type;ϕX)B)).-intros[BB_A] [CC_A]H0.applypath_sigma_hprop;cbn.revertB_A.rapplyTrunc_rec.intros[finjective_f].applyequiv_path_Ordinal.assert{X: 𝒫 (𝒫A) &Isomorphism(X:Type;ϕX)B}as[Xiso]. {assert(H2:forallX: 𝒫A,IsHProp{b:B&foralla,Xa<->existsb',b'<b/\a=fb'}). {introsX.applyhprop_allpath;intros[b1Hb1] [b2Hb2].snrapplypath_sigma_hprop;cbn.-introsb.snrapplyistrunc_forall.introsa.snrapplyistrunc_prod. 2:exact_.snrapplyistrunc_arrow.rapplyishprop_sigma_disjoint.introsb1'b2'[_->] [_p].apply(injective_f).exactp.-applyextensionality.introsb'.split.+introsb'_b1.specialize(Hb1(fb')).applysndinHb1.specialize(Hb1(b'; (b'_b1,idpath))).applyHb2inHb1.destructHb1as(? &H2&H3).applyinjectiveinH3. 2:assumption.destructH3.exactH2.+introsb'_b2.specialize(Hb2(fb')).applysndinHb2.specialize(Hb2(b'; (b'_b2,idpath))).applyHb1inHb2.destructHb2as(? &H2&H3).applyinjectiveinH3. 2:assumption.destructH3.exactH2.}exists(funX: 𝒫A=>Build_HProp{b:B&foralla,Xa<->existsb',b'<b/\a=fb'}). {unfoldsubtype_as_type'.unshelveeexists.-srapplyequiv_adjointify.+intros[X[b_]].exactb.+introsb.unshelveeexists(funa=>Build_HProp(existsb',b'<b/\a=fb')).1:exact_.{applyhprop_allpath.intros[b1[b1_bp]] [b2[b2_bq]].applypath_sigma_hprop;cbn.apply(injectivef).destructp,q.reflexivity.}existsb.introsb'.cbn.reflexivity.+cbn.reflexivity.+cbn.intros[X[bHb]].applypath_sigma_hprop.cbn.applypath_forall;introsa.applypath_iff_hprop;applyHb.-cbn.intros[X1[b1H'1]] [X2[b2H'2]].unfoldϕ,proper_subtype_inclusion.cbn.split.+introsH3.refine(Trunc_rec_(trichotomy_ordinalb1b2)).intros[b1_b2|H4].*exactb1_b2.*revertH4.rapplyTrunc_rec.intros[b1_b2|b2_b1].--applyEmpty_rec.destructH3as[_H3].revertH3.rapplyTrunc_rec.intros[a[X2anot_X1a]].applynot_X1a.applyH'1.rewriteb1_b2.applyH'2.exactX2a.--applyEmpty_rec.destructH3as[_H3].revertH3.rapplyTrunc_rec.intros[a[X2anot_X1a]].applynot_X1a.applyH'1.applyH'2inX2a.destructX2aas[b'[b'_b2a_fb']].existsb'.split.++transitivityb2;assumption.++assumption.+introsb1_b2.split.*introsaX1a.applyH'2.applyH'1inX1a.destructX1aas[b'[b'_b1a_fb']].existsb'.split.--transitivityb1;assumption.--assumption.*applytr.exists(fb1).split.--applyH'2.existsb1;auto.--introsX1_fb1.applyH'1inX1_fb1.destructX1_fb1as[b'[b'_b1fb1_fb']].apply(injectivef)infb1_fb'.destructfb1_fb'.applyirreflexivityinb'_b1. 2:exact_.assumption.}}assert(IsOrdinalX(ϕX))byexact(isordinal_simulationiso.1).applyapD10inH0.specialize(H0X).cbninH0.refine(transitive_Isomorphism_(X:Type;ϕX)___). {applyisomorphism_inverse.assumption.}enough(merely(Isomorphism(X:Type;ϕX)C)). {revertX1.nrapplyTrunc_rec. {exact(ishprop_Isomorphism(Build_OrdinalX(ϕX)_)C).}auto.}rewrite<-H0.applytr.exactiso.Qed.Using hprop resizing, the threefold power set can be pushed to the same universe level asA.Definitionuni_fix(X: 𝒫 (𝒫 (𝒫A))) : ((𝒫 (𝒫 (𝒫A))) :Type@{A}).Proof.revertX.nrapplypower_morph.nrapplypower_morph.nrapplypower_inj.Defined.Lemmainjective_uni_fix:IsInjectiveuni_fix.Proof.introsXY.unfolduni_fix.introsH%injective_power_morph;trivial.introsPQ.introsH'%injective_power_morph;trivial.introspq.applyinjective_power_inj.Qed.(* We can therefore resize the Hartogs number of A to the same universe level as A. *)Definitionhartogs_number_carrier:Type@{A}:= {X: 𝒫 (𝒫 (𝒫A)) |smalltype(merely(existsa,uni_fix(hartogs_number'_injection.1a) =X))}.Lemmahartogs_equiv:hartogs_number_carrier<~>hartogs_number'.Proof.applyequiv_inverse.unshelveeexists.-introsa.exists(uni_fix(hartogs_number'_injection.1a)).applyequiv_smalltype,tr.existsa.reflexivity.-snrapplyisequiv_surj_emb.+applyBuildIsSurjection.intros[XHX].eapplymerely_destruct.*eapplyequiv_smalltype,HX.*intros[a<-].cbn.applytr.existsa.cbn.applyap.applypath_ishprop.+applyisembedding_isinj_hset.introsab.introsH%pr1_path.cbninH.specialize(injective_uni_fix(hartogs_number'_injection.1a) (hartogs_number'_injection.1b)).introsH'.applyH'inH.byapplyhartogs_number'_injection.2.Qed.Definitionhartogs_number:Ordinal@{A_}:=resize_ordinalhartogs_number'hartogs_number_carrierhartogs_equiv.(* This final definition by satisfies the expected cardinality properties. *)Lemmahartogs_number_injection:existsf:hartogs_number-> 𝒫 (𝒫 (𝒫A)),IsInjectivef.Proof.cbn.existsproj1.intros[XHX] [YHY].cbn.intros->.applyap.applypath_ishprop.Qed.Lemmahartogs_number_no_injection: ~ (existsf:hartogs_number->A,IsInjectivef).Proof.cbn.intros[fHf].cbninf.assert(HN:cardhartogs_number<=cardA). {applytr.byexistsf. }transparentassert(HNO:hartogs_number'). {existshartogs_number.applyHN. }apply(ordinal_initialhartogs_number'HNO).eapply(transitive_Isomorphismhartogs_number'hartogs_number).-applyisomorphism_inverse.unfoldhartogs_number.exact(resize_ordinal_isohartogs_number'hartogs_number_carrierhartogs_equiv).-assert(Isomorphismhartogs_number↓hartogs_number)byapplyisomorphism_to_initial_segment.eapplytransitive_Isomorphism. 1:exactX.unshelveeexists.+srapplyequiv_adjointify.*intros[aHa%equiv_smalltype].unshelveeexists.--existsa.transitivity(cardhartogs_number).++nrapplyle_Cardinal_lt_Ordinal;applyHa.++applyHN.--applyequiv_smalltype.cbn.exactHa.*intros[[aHa]H%equiv_smalltype].existsa.applyequiv_smalltype.applyH.*introa.applypath_sigma_hprop.applypath_sigma_hprop.reflexivity.*introa.applypath_sigma_hprop.reflexivity.+reflexivity.Defined.EndHartogs_Number.

--- Miscellaneous\Hexadecimal.html ---
HexadecimalLibrary Hexadecimal(************************************************************************)(*         *   The Coq Proof Assistant / The Coq Development Team       *)(*  v      *         Copyright INRIA, CNRS and contributors             *)(* <O___,, * (see version control and CREDITS file for authors & dates) *)(*   \VV/  **************************************************************)(*    //   *    This file is distributed under the terms of the         *)(*         *     GNU Lesser General Public License Version 2.1          *)(*         *     (see LICENSE file for the text of the license)         *)(************************************************************************)(************************************************************************)(* This file has been modified for use in the HoTT library              *)(************************************************************************)RequireImportBasics.OvertureBasics.Numerals.Decimal.Hexadecimal numbersThese numbers coded in base 16 will be used for parsing and printing
    other Coq numeral datatypes in an human-readable way.
    See theNumeralNotationcommand.
    We represent numbers in base 16 as lists of hexadecimal digits,
    in big-endian order (most significant digit comes first).Unsigned integers are just lists of digits.
    For instance, sixteen is (D1 (D0 Nil))Inductiveuint:Type0:=|Nil|D0(_:uint)|D1(_:uint)|D2(_:uint)|D3(_:uint)|D4(_:uint)|D5(_:uint)|D6(_:uint)|D7(_:uint)|D8(_:uint)|D9(_:uint)|Da(_:uint)|Db(_:uint)|Dc(_:uint)|Dd(_:uint)|De(_:uint)|Df(_:uint).Nilis the number terminator. Taken alone, it behaves as zero,
    but rather useD0Nilinstead, since this form will be denoted
    as0, whileNilwill be printed asNil.Notationzero:= (D0Nil).For signed integers, we use two constructorsPosandNeg.Variantint:Type0:=Pos(d:uint) |Neg(d:uint).For decimal numbers, we use two constructorsHexadecimalandHexadecimalExp, depending on whether or not they are given with an
    exponent (e.g., 0x1.a2p+01).iis the integral part whilefis
    the fractional part (beware that leading zeroes do matter).Varianthexadecimal:Type0:=|Hexadecimal(i:int) (f:uint)|HexadecimalExp(i:int) (f:uint) (e:Decimal.int).Declare Scopehex_uint_scope.DelimitScopehex_uint_scopewithhuint.Bind Scopehex_uint_scopewithuint.Declare Scopehex_int_scope.DelimitScopehex_int_scopewithhint.Bind Scopehex_int_scopewithint.Registeruintasnum.hexadecimal_uint.type.Registerintasnum.hexadecimal_int.type.Registerhexadecimalasnum.hexadecimal.type.Fixpointnb_digitsd:=matchdwith|Nil=>O|D0d|D1d|D2d|D3d|D4d|D5d|D6d|D7d|D8d|D9d|Dad|Dbd|Dcd|Ddd|Ded|Dfd=>S(nb_digitsd)end.This representation favors simplicity over canonicity.
    For normalizing numbers, we need to remove head zero digits,
    and choose our canonical representation of 0 (hereD0Nilfor unsigned numbers andPos(D0Nil)for signed numbers).nzheadremoves all head zero digitsFixpointnzheadd:=matchdwith|D0d=>nzheadd|_=>dend.unorm: normalization of unsigned integersDefinitionunormd:=matchnzheaddwith|Nil=>zero|d=>dend.norm: normalization of signed integersDefinitionnormd:=matchdwith|Posd=>Pos(unormd)|Negd=>matchnzheaddwith|Nil=>Poszero|d=>Negdendend.A few easy operations. For more advanced computations, use the conversions
    with other Coq numeral datatypes (e.g. Z) and the operations on them.Definitionopp(d:int) :=matchdwith|Posd=>Negd|Negd=>Posdend.For conversions with binary numbers, it is easier to operate
    on little-endian numbers.Fixpointrevapp(dd':uint) :=matchdwith|Nil=>d'|D0d=>revappd(D0d')|D1d=>revappd(D1d')|D2d=>revappd(D2d')|D3d=>revappd(D3d')|D4d=>revappd(D4d')|D5d=>revappd(D5d')|D6d=>revappd(D6d')|D7d=>revappd(D7d')|D8d=>revappd(D8d')|D9d=>revappd(D9d')|Dad=>revappd(Dad')|Dbd=>revappd(Dbd')|Dcd=>revappd(Dcd')|Ddd=>revappd(Ddd')|Ded=>revappd(Ded')|Dfd=>revappd(Dfd')end.Definitionrevd:=revappdNil.Definitionappdd':=revapp(revd)d'.Definitionapp_intd1d2:=matchd1withPosd1=>Pos(appd1d2) |Negd1=>Neg(appd1d2)end.nztailremoves all trailing zero digits and return both the
    result and the number of removed digits.Definitionnztaild:=letfixauxd_rev:=matchd_revwith|D0d_rev=>let(r,n) :=auxd_revinpairr(Sn)|_=>paird_revOendinlet(r,n) :=aux(revd)inpair(revr)n.Definitionnztail_intd:=matchdwith|Posd=>let(r,n) :=nztaildinpair(Posr)n|Negd=>let(r,n) :=nztaildinpair(Negr)nend.ModuleLittle.Successor of little-endian numbersFixpointsuccd:=matchdwith|Nil=>D1Nil|D0d=>D1d|D1d=>D2d|D2d=>D3d|D3d=>D4d|D4d=>D5d|D5d=>D6d|D6d=>D7d|D7d=>D8d|D8d=>D9d|D9d=>Dad|Dad=>Dbd|Dbd=>Dcd|Dcd=>Ddd|Ddd=>Ded|Ded=>Dfd|Dfd=>D0(succd)end.Doubling little-endian numbersFixpointdoubled:=matchdwith|Nil=>Nil|D0d=>D0(doubled)|D1d=>D2(doubled)|D2d=>D4(doubled)|D3d=>D6(doubled)|D4d=>D8(doubled)|D5d=>Da(doubled)|D6d=>Dc(doubled)|D7d=>De(doubled)|D8d=>D0(succ_doubled)|D9d=>D2(succ_doubled)|Dad=>D4(succ_doubled)|Dbd=>D6(succ_doubled)|Dcd=>D8(succ_doubled)|Ddd=>Da(succ_doubled)|Ded=>Dc(succ_doubled)|Dfd=>De(succ_doubled)endwithsucc_doubled:=matchdwith|Nil=>D1Nil|D0d=>D1(doubled)|D1d=>D3(doubled)|D2d=>D5(doubled)|D3d=>D7(doubled)|D4d=>D9(doubled)|D5d=>Db(doubled)|D6d=>Dd(doubled)|D7d=>Df(doubled)|D8d=>D1(succ_doubled)|D9d=>D3(succ_doubled)|Dad=>D5(succ_doubled)|Dbd=>D7(succ_doubled)|Dcd=>D9(succ_doubled)|Ddd=>Db(succ_doubled)|Ded=>Dd(succ_doubled)|Dfd=>Df(succ_doubled)end.EndLittle.

--- Miscellaneous\HFiber.html ---
HFiberLibrary HFiberRequireImportBasicsTypesDiagrams.CommutativeSquaresHSet.Local OpenScopeequiv_scope.Local OpenScopepath_scope.Basic facts about fibrations(* ** Homotopy fibers *)Paths in homotopy fibers can be constructed usingpath_sigmaandtransport_paths_Fl.Definitionequiv_path_hfiber{AB:Type} {f:A->B} {y:B}(x1x2:hfiberfy): {q:x1.1 =x2.1 &x1.2 =apfq@x2.2 } <~> (x1=x2).Proof.refine(equiv_path_sigma___oE_).applyequiv_functor_sigma_id.introsp;simpl.refine(_oEequiv_moveR_Vp___).exact(equiv_concat_l(transport_paths_Fl__)_).Defined.Definitionpath_hfiber_uncurried{AB:Type} {f:A->B} {y:B}{x1x2:hfiberfy}: {q:x1.1 =x2.1 &x1.2 =apfq@x2.2 } -> (x1=x2):=equiv_path_hfiberx1x2.Definitionpath_hfiber{AB:Type} {f:A->B} {y:B}{x1x2:hfiberfy} (q:x1.1 =x2.1) (r:x1.2 =apfq@x2.2):x1=x2:=path_hfiber_uncurried(q;r).If we rearrange this a bit, then it characterizes the fibers ofap.Definitionhfiber_ap{AB:Type} {f:A->B} {x1x2:A}(p:fx1=fx2):hfiber(apf)p<~> ((x1;p) = (x2; 1) :>hfiberf(fx2)).Proof.refine(equiv_path_hfiber(x1;p) (x2;1%path)oE_).unfoldhfiber;simpl.applyequiv_functor_sigma_id;introsq.refine(_oEequiv_path_inverse__).exact(equiv_concat_r(concat_p1_)^_).Defined.Homotopic maps have equivalent fibers.Definitionequiv_hfiber_homotopic{AB:Type} (fg:A->B) (h:f==g) (b:B):hfiberfb<~>hfibergb.Proof.refine(Build_Equiv__(funfx=> (fx.1 ; (hfx.1)^ @fx.2))_).refine(isequiv_adjointify_(fungx=> (gx.1 ; (hgx.1) @gx.2))__);intros[ap];simpl;applyap.-applyconcat_V_pp.-applyconcat_p_Vp.Defined.Commutative squares induce maps between fibers.Definitionfunctor_hfiber{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh) (b:B):hfiberfb->hfiberg(kb).Proof.snrapply@functor_sigma.-exacth.-introsae;exact((pa)^ @apke).Defined.This doesn't need to be defined as an instance, since typeclass search can already find it, but we state it here for the reader's benefit.Definitionisequiv_functor_hfiber{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}`{IsEquivACh} `{IsEquivBDk}(p:kof==goh) (b:B):IsEquiv(functor_hfiberpb) :=_.Definitionequiv_functor_hfiber{ABCD}{f:A->B} {g:C->D} {h:A<~>C} {k:B<~>D}(p:kof==goh) (b:B):hfiberfb<~>hfiberg(kb):=Build_Equiv__(functor_hfiberpb)_.A version of functor_hfiber which is functorial in both the function and the pointDefinitionfunctor_hfiber2{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh) {b:B} {b':D} (q:kb=b'):hfiberfb->hfibergb'.Proof.srapplyfunctor_sigma.-exacth.-introsae.exact((pa)^ @apke@q).Defined.Global Instanceisequiv_functor_hfiber2{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}`{IsEquivACh} `{IsEquivBDk}(p:kof==goh) {b:B} {b':D} (q:kb=b'):IsEquiv(functor_hfiber2pq).Proof.refine(isequiv_functor_sigma(f:=h));introsa.refine(isequiv_compose(f:=fune=> (pa)^ @apke) (g:=fune'=>e'@q)).Defined.Definitionequiv_functor_hfiber2{ABCD}{f:A->B} {g:C->D} {h:A<~>C} {k:B<~>D}(p:kof==goh) {b:B} {b':D} (q:kb=b'):hfiberfb<~>hfibergb':=Build_Equiv__(functor_hfiber2pq)_.Definitionfunctor_hfiber_compose{ABCXYZ:Type} {k:A->B} {l:B->C}{f:A->X} {g:B->Y} {h:C->Z} {i:X->Y} {j:Y->Z}(H:iof==gok) (K:jog==hol):forallx,functor_hfiber(comm_square_comp'HK)x== (functor_hfiberK(ix))o(functor_hfiberHx:hfiberfx->_).Proof.introsx[yp].destructp.apply(path_sigma'_idpath).refine(concat_p1_@_).refine(inv_pp__@ap__).refine((ap_V__)^ @ap__^).applyconcat_p1.Defined.The 3x3 lemma for fibrationsDefinitionhfiber_functor_hfiber{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh) (b:B) (c:C) (q:gc=kb):hfiber(functor_hfiberpb) (c;q)<~>hfiber(functor_hfiber(funx=> (px)^)c) (b;q^).Proof.rapply(equiv_functor_sigma_id_oE_oE(equiv_functor_sigma_id_)^-1).1,3:intros;rapplyequiv_path_sigma.refine(equiv_sigma_assoc__oE_oE(equiv_sigma_assoc__)^-1).applyequiv_functor_sigma_id;introsa;cbn.refine(equiv_sigma_symm_oE_).do2 (applyequiv_functor_sigma_id;intro).refine((equiv_apinverse__)^-1oE_).refine(equiv_concat_r(inv_Vq)^_oE_).applyequiv_concat_l.abstract(rewrite!transport_paths_Fl, !inv_pp, !inv_V,concat_pp_p;reflexivity).Defined.Replacing a map with a fibrationDefinitionequiv_fibration_replacement{BC} (f:C->B):C<~> {y:B&hfiberfy}.Proof.snrefine(Build_Equiv___(Build_IsEquivC{y:B& {x:C&fx=y}}(func=> (fc; (c;idpath)))(func=>c.2.1)_(func=>idpath)_)).-intros[? [? []]];reflexivity.-reflexivity.Defined.Definitionhfiber_fibration{X} (x:X) (P:X->Type):Px<~> @hfiber(sigP)Xpr1x.Proof.snrefine(Build_Equiv___(Build_IsEquiv(Px) {z:sigP&z.1 =x}(funPx=> ((x;Px);idpath))(funPx=>transportPPx.2Px.1.2)_(funPx=>idpath)_)).-intros[[] []];reflexivity.-reflexivity.Defined.Exercise 4.4: The unstable octahedral axiom.SectionUnstableOctahedral.Context(n:trunc_index) {ABC:Type} (f:A->B) (g:B->C).Definitionhfiber_compose_map(c:C):hfiber(gof)c->hfibergc:=funx=> (fx.1 ;x.2).Definitionhfiber_hfiber_compose_map(b:B):hfiber(hfiber_compose_map(gb)) (b;1) <~>hfiberfb.Proof.unfoldhfiber,hfiber_compose_map.Once we "destruct" the equality in a sigma type, the rest is just shuffling of data and path induction.refine(_oEequiv_functor_sigma_id(funx=> (equiv_path_sigma___)^-1));cbn.make_equiv_contr_basedpaths.Defined.Definitionhfiber_compose(c:C):hfiber(gof)c<~> {w:hfibergc&hfiberfw.1 }.Proof.make_equiv_contr_basedpaths.Defined.Global Instanceistruncmap_compose`{!IsTruncMapng} `{!IsTruncMapnf}:IsTruncMapn(gof).Proof.introsc.exact(istrunc_isequiv_istrunc_(hfiber_composec)^-1).Defined.EndUnstableOctahedral.We characterize the fibers offunctor_forall, but only in the special case where the base map isidmap. This doesn't depend on anything else in this file, but can't be put in Types/Forall.v, because it requires results from Types/Sigma.v.Definitionhfiber_functor_forall_id`{Funext} {A:Type} {PQ:A->Type}(h:foralla,Pa->Qa) (g:foralla,Qa):hfiber(functor_forall_idh)g<~> (foralla,hfiber(ha) (ga)).Proof.unfoldhfiber,functor_forall_id,functor_forall.nrefine(equiv_sig_coind__oE_).applyequiv_functor_sigma_id;introf.applyequiv_apD10.Defined.Fibers of constant functionsDefinitionhfiber_constA{B} (yy':B):hfiber(fun_:A=>y)y'<~>A* (y=y'):=equiv_sigma_prod0A(y=y').Global Instanceistruncmap_constn{AB} `{!IsTruncnA}(y:B) `{!forally',IsTruncn(y=y')}:IsTruncMapn(fun_:A=>y):=funy'=>_.IsTruncMapn.+1f<->IsTruncMapn(apf)Global Instanceistruncmap_ap{AB}n(f:A->B) `{!IsTruncMapn.+1f}:forallxy,IsTruncMapn(@ap__fxy):=funxx'y=>istrunc_equiv_istrunc_(hfiber_apy)^-1.Definitionistruncmap_from_ap{AB}n(f:A->B) `{!forallxy,IsTruncMapn(@ap__fxy)}:IsTruncMapn.+1f.Proof.introy;applyistrunc_S.intros[ap] [bq];destructq;exact(istrunc_equiv_istrunc_(hfiber_app)).Defined.Definitionequiv_istruncmap_ap`{Funext} {AB}n(f:A->B):IsTruncMapn.+1f<~> (forallxy,IsTruncMapn(@ap__fxy)):=equiv_iff_hprop(@istruncmap_ap__nf) (@istruncmap_from_ap__nf).Global Instanceisequiv_ap_isembedding{AB} (f:A->B) `{!IsEmbeddingf}:forallxy,IsEquiv(@ap__fxy).Proof.introsxy.applyisequiv_contr_map,_.Defined.Definitionequiv_ap_isembedding{AB} (f:A->B) `{!IsEmbeddingf} (xy:A): (x=y) <~> (fx=fy):=Build_Equiv__(apf)_.Definitionisembedding_isequiv_ap{AB} (f:A->B) `{!forallxy,IsEquiv(@ap__fxy)}:IsEmbeddingf.Proof.rapplyistruncmap_from_ap.Defined.Definitionequiv_isequiv_ap_isembedding`{Funext} {AB} (f:A->B):IsEmbeddingf<~> (forallxy,IsEquiv(@ap__fxy)).Proof.exact(equiv_iff_hprop(@isequiv_ap_isembedding__f) (@isembedding_isequiv_ap__f)).Defined.It follows fromisembedding_isequiv_apandisequiv_ap_equiv_funthatequiv_funis an embedding.Global Instanceisembedding_equiv_fun`{Funext} {AB:Type}:IsEmbedding(@equiv_funAB).Proof.rapplyisembedding_isequiv_ap.Defined.Lemmaap_isinj_embedding_beta{XY:Type} (f:X->Y) {I:IsEmbeddingf} {x0x1:X}:forall(p:fx0=fx1),apf(isinj_embeddingfIx0x1p) =p.Proof.equiv_intro(equiv_ap_isembeddingfx0x1)q.inductionq.cbn.exact(ap_(isinj_embedding_betaf)).Defined.

--- Miscellaneous\Hom.html ---
HomLibrary HomHom-Set AdjunctionsRequireImportCategory.CoreFunctor.Core.RequireImportAdjoint.UnitCounit.RequireImportFunctor.Dual.RequireImportFunctor.Prod.Core.RequireImportHomFunctor.RequireImportFunctor.Composition.Core.RequireImportFunctorCategory.Morphisms.RequireImportFunctor.Identity.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.Local OpenScopecategory_scope.Local OpenScopefunctor_scope.Local OpenScopenatural_transformation_scope.SectionAdjunction.Context`{Funext}.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.Quoting the MIT 18.705 Lecture Notes:LetCandDbe categories,F:C→DandG:D→Cfunctors. We call(F,G)an adjoint pair,Fthe left adjoint
     ofG, andGthe right adjoint ofFif, for each objectA:Cand objectA':D, there is a natural bijectionHom_D(FA)A'≅Hom_CA(GA')Here natural means that mapsB→AandA'→B'induce a
     commutative diagram:Hom_D (F A) A' ≅ Hom_C A (G A')
             |                 |
             |                 |
             |                 |
             |                 |
             V                 V
       Hom_D (F B) B' ≅ Hom_C B (G B')We want tosimplout the notation machineryLocal OpaqueNaturalIsomorphism.LetAdjunction_Type:=Evalsimplinhom_functorDo(F^op, 1) <~=~>hom_functorCo(1,G).(*Let Adjunction_Type := Eval simpl in HomFunctor D ⟨ F ⟨ 1 ⟩ , 1 ⟩ ≅ HomFunctor C ⟨ 1 , G ⟨ 1 ⟩ ⟩.*)(*Set Printing All.Print Adjunction_Type.*)Just putting inAdjunction_TypebreaksAMateOfRecordAdjunctionHom:={mate_of: @NaturalIsomorphismH(Category.Prod.prod(Category.Dual.oppositeC)D)(@Core.set_catH)(@compose(Category.Prod.prod(Category.Dual.oppositeC)D)(Category.Prod.prod(Category.Dual.oppositeD)D)(@Core.set_catH) (@hom_functorHD)(@pair(Category.Dual.oppositeC)(Category.Dual.oppositeD)DD(@oppositeCDF) (identityD)))(@compose(Category.Prod.prod(Category.Dual.oppositeC)D)(Category.Prod.prod(Category.Dual.oppositeC)C)(@Core.set_catH) (@hom_functorHC)(@pair(Category.Dual.oppositeC)(Category.Dual.oppositeC)DC(identity(Category.Dual.oppositeC))G))}.EndAdjunction.Coercionmate_of:AdjunctionHom>->NaturalIsomorphism.Bind Scopeadjunction_scopewithAdjunctionHom.Argumentsmate_of{_} [C%_categoryD%_categoryF%_functorG%_functor]_%_adjunction.

--- Miscellaneous\HomCoercions.html ---
HomCoercionsLibrary HomCoercionsCoercions between hom-set adjunctions and unit+counit adjunctionsRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportAdjoint.UnitCounitAdjoint.UnitCounitCoercionsAdjoint.Hom.RequireImportCategory.Morphisms.RequireImportFunctor.Composition.Core.RequireImportFunctorCategory.Morphisms.RequireImportFunctor.Identity.RequireImportSetCategory.Morphisms.RequireImportBasics.TruncTypes.SigmaHoTT.TacticsEquivalences.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopepath_scope.Local OpenScopemorphism_scope.Local OpenScopecategory_scope.Local OpenScopefunctor_scope.Local OpenScopenatural_transformation_scope.unit+UMP from hom-set adjunctionSectionAdjunctionEquivalences.Context`{Funext}.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.Local OpenScopemorphism_scope.We need to jump through some hoops withsimplfor speedSectionadjunction_naturality.VariableA:AdjunctionHomFG.Sectionnat1.Contextcdd'(f:morphismD(Fc)d)(g:morphismDdd').Letadjunction_naturalityT:=EvalsimplinG_1goA(c,d)f=A(c,d') (gof).Lemmaadjunction_naturality:adjunction_naturalityT.Proof.poseproof(ap10(commutesA(c,d) (c,d') (1%morphism,g))^f)asH';simplin*.rewrite?identity_of, ?left_identity, ?right_identityinH'.exactH'.Qed.Endnat1.Sectionnat2.Contextcc'd(f:morphismD(Fc')d)(g:morphismCcc').Letadjunction_naturalityT':=EvalsimplinA(c',d)fog=A(c,d) (foF_1g).Lemmaadjunction_naturality':adjunction_naturalityT'.Proof.poseproof(ap10(commutesA(c',d) (c,d) (g, 1%morphism))^f)asH';simplin*.rewrite?identity_of, ?left_identity, ?right_identityinH'.exactH'.Qed.Endnat2.Endadjunction_naturality.Quoting from Awodey's "Category Theory":Proposition 9.4. Given categories and functors,F:C↔D:Gthe following conditions are equivalent:1.Fis left adjoint toG; that is, there is a natural
        transformationη:1_C→G∘Fthat has the UMP of the unit:For anyc:C,d:Dandf:c->Gdthere exists a
        uniqueg:Fc→dsuch thatf=Gg∘ηc.2. For anyc:Candd:Dthere is an isomorphism,ϕ:Hom_D(Fc,d)≅Hom_C(c,Gd)that is natural in bothcandd.Moreover, the two conditions are related by the formulasϕg=Gg∘ηcηc=ϕ(1_{Fc})Lemmaadjunction_unit__of__adjunction_hom_helper(A:AdjunctionHomFG)(c:C) (d:D) (f:morphismCc(Gd)):IsHProp{g:morphismD(Fc)d&G_1goA(c,Fc) 1 =f}.Proof.applyhprop_allpath.intros[g0H0] [g1H1];applypath_sigma_hprop;simpl.destructH1.rewrite!adjunction_naturalityinH0.rewrite!right_identityinH0.change(idmapg0=idmapg1).rewrite<- (ap10(@left_inverse___(A(c,d))_)).simplrewriteH0.letk:=constr:(ap10(@left_inverse___(A(c,d))_))insimplrewritek.(* https://coq.inria.fr/bugs/show_bug.cgi?id=3773 and https://coq.inria.fr/bugs/show_bug.cgi?id=3772 (probably) *)reflexivity.Qed.Lemmaadjunction_unit__of__adjunction_hom__mate_of__commutes(A:AdjunctionHomFG) (sd:C) (m:morphismCsd):A(d,Fd) 1om=G_1(F_1m)oA(s,Fs) 1.Proof.simpl;rewriteadjunction_naturality',adjunction_naturality.rewrite?left_identity, ?right_identity.reflexivity.Qed.Definitionadjunction_unit__of__adjunction_hom(A:AdjunctionHomFG):AdjunctionUnitFG.Proof.exists(Build_NaturalTransformation1 (GoF)(func=>A(c,Fc) 1)(adjunction_unit__of__adjunction_hom__mate_of__commutesA)).simplin*.introscdf.applycontr_inhabited_hprop.-applyadjunction_unit__of__adjunction_hom_helper.-exact((A(c,d))^-1%morphismf;((adjunction_naturalityA_____)@ (ap(A(c,d)) (right_identity____))@ (ap10(@right_inverse___(A(c,d))_)f))%path).Defined.EndAdjunctionEquivalences.Sectionisequiv.We want to be able to use this without needingFunext.  So, first, we prove that the types of hom-sets are equivalent.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.Local OpenScopemorphism_scope.VariableT:AdjunctionUnitFG.Lemmaequiv_hom_set_adjunction(c:C) (d:D):morphismCc(Gd) <~>morphismD(Fc)d.Proof.refine(equiv_adjointify(funf=> (@center_(T.2__f)).1)(fung=>G_1goT.1c)__);intro.-matchgoalwith| [ |- @pr1?A?P?x= ?y]=>change(x.1 = (existPyidpath).1)end.apply(appr1).applycontr.-matchgoalwith| [ |-context[?x.1] ]=>applyx.2end.Defined.Endisequiv.hom-set adjunction from unit+ump adjunctionSectionAdjunctionEquivalences'.Context`{Funext}.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.Local OpenScopemorphism_scope.Lemmaadjunction_hom__of__adjunction_unit__commutes(T:AdjunctionUnitFG)scsddcdd(mc:morphismCdcsc) (md:morphismDsddd): (funx:morphismD(Fsc)sd=>G_1(mdoxoF_1mc)oT.1dc) =(funx:morphismD(Fsc)sd=>G_1mdo(G_1xoT.1sc)omc).Proof.applypath_forall;intro.rewrite!composition_of, !associativity.simplrewrite(commutesT.1).reflexivity.Qed.Definitionadjunction_hom__of__adjunction_unit(T:AdjunctionUnitFG):AdjunctionHomFG.Proof.constructor.(eexists(Build_NaturalTransformation____)).apply(@isisomorphism_natural_transformation_);simpl.exact(funcd=>@isiso_isequiv____(equiv_isequiv(equiv_hom_set_adjunctionT(fstcd) (sndcd))^-1)).Unshelve.simpl.intros.exact(adjunction_hom__of__adjunction_unit__commutesT______).Defined.EndAdjunctionEquivalences'.DefinitionAdjunctionUnitWithFunext`{Funext}CDFG:= @AdjunctionUnitCDFG.DefinitionAdjunctionCounitWithFunext`{Funext}CDFG:= @AdjunctionCounitCDFG.DefinitionAdjunctionUnitCounitWithFunext`{Funext}CDFG:= @AdjunctionUnitCounitCDFG.IdentityCoercionAdjunctionUnit_Funext:AdjunctionUnitWithFunext>->AdjunctionUnit.IdentityCoercionAdjunctionCounit_Funext:AdjunctionCounitWithFunext>->AdjunctionCounit.IdentityCoercionAdjunctionUnitCounit_Funext:AdjunctionUnitCounitWithFunext>->AdjunctionUnitCounit.Definitionadjunction_hom__of__adjunction_unit_Funext`{Funext}CDFG(A:AdjunctionUnitWithFunext__):AdjunctionHom__:= @adjunction_hom__of__adjunction_unit_CDFGA.DefinitionAdjunctionHomOfAdjunctionCounit_Funext`{Funext}CDFG(A:AdjunctionCounitWithFunext__):AdjunctionHom__:= @adjunction_hom__of__adjunction_unit_CDFG(adjunction_unit_counit__of__adjunction_counitA).Definitionadjunction_hom__of__adjunction_unitCounit_Funext`{Funext}CDFG(A:AdjunctionUnitCounitWithFunext__):AdjunctionHom__:= @adjunction_hom__of__adjunction_unit_CDFGA.

--- Miscellaneous\HomFunctor.html ---
HomFunctorLibrary HomFunctorHom FunctorRequireImportCategory.CoreFunctor.CoreSetCategory.CoreCategory.Dual.RequireFunctor.Prod.Core.ImportCategory.Prod.CategoryProdNotationsFunctor.Prod.Core.FunctorProdCoreNotations.RequireImportBasics.Trunc.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.Definition ofhom:Cᵒᵖ×C→Setas a functorSectionhom_functor.Context`{Funext}.VariableC:PreCategory.Local Notationobj_ofc'c:=(Build_HSet(morphismC(fst(c'c:object(C^op*C)))(snd(c'c:object(C^op*C))))).Lethom_functor_morphism_ofs'sd'd(hf:morphism(C^op*C)s'sd'd):morphismset_cat(obj_ofs's) (obj_ofd'd):=fung=>sndhfogofsthf.Definitionhom_functor:Functor(C^op*C)set_cat.refine(Build_Functor(C^op*C)set_cat(func'c=>obj_ofc'c)hom_functor_morphism_of__);substhom_functor_morphism_of;simpl;abstract(repeat(applypath_forall||intros[] ||intro);simplin*;rewrite<- ?associativity, ?left_identity, ?right_identity;reflexivity).Defined.Endhom_functor.Sectioncovariant_contravariant.Context`{Funext}.VariableC:PreCategory.Local OpenScopefunctor_scope.Local ArgumentsFunctor.Prod.Core.induced_snd/ .Local ArgumentsFunctor.Prod.Core.induced_fst/ .Covariant hom functorhom_C(A,─):C→setDefinitioncovariant_hom_functor(A:objectC^op):=EvalsimplinFunctor.Prod.Core.induced_snd(hom_functorC)A.Contravariant hom functorhom_C(─,A):Cᵒᵖ→setDefinitioncontravariant_hom_functor(A:C):=EvalsimplinFunctor.Prod.Core.induced_fst(hom_functorC)A.Endcovariant_contravariant.

--- Miscellaneous\Homomorphism.html ---
HomomorphismLibrary HomomorphismThis file implements algebra homomorphism. We show that algebras form a wild category with homomorphisms. TheWildCatmodule provides some nice notations that we we use:A$->Bfor homomorphism,Idfor the identity homomorphism andg$offor composition.LocalUnsetEliminationSchemes.RequireExportHoTT.Algebra.Universal.AlgebraHoTT.WildCat.Core.RequireImportHoTT.Types.Local OpenScopeAlgebra_scope.Sectionis_homomorphism.Context{σ} {AB:Algebraσ} (f:forall(s:Sortσ),As->Bs).DefinitionOpPreserving{w:SymbolTypeσ}(α:OperationAw) (β:OperationBw) :Type:=foralla:DomOperationAw,f(sort_codw) (αa) =β(funi=>f(sorts_domwi) (ai)).Global Instancehprop_oppreserving`{Funext} {w:SymbolTypeσ}(α:OperationAw) (β:OperationBw):IsHProp(OpPreservingαβ).Proof.applyistrunc_forall.Qed.ClassIsHomomorphism:Type:=oppreserving_hom:forall(u:Symbolσ),OpPreservingu.#Au.#B.Global Instancehprop_is_homomorphism`{Funext}:IsHPropIsHomomorphism.Proof.applyistrunc_forall.Qed.Endis_homomorphism.RecordHomomorphism{σ} {AB:Algebraσ} :Type:=Build_Homomorphism{def_homomorphism:forall(s:Sortσ),As->Bs;is_homomorphism:IsHomomorphismdef_homomorphism}.ArgumentsHomomorphism{σ}.ArgumentsBuild_Homomorphism{σAB}def_homomorphism{is_homomorphism}.Global Coerciondef_homomorphism:Homomorphism>->Funclass.Global Existing Instanceis_homomorphism.Global Instanceisgraph_algebra(σ :Signature) :IsGraph(Algebraσ):=Build_IsGraph(Algebraσ)Homomorphism.LemmaapD10_homomorphism{σ} {AB:Algebraσ} {fg:A$->B}:f=g->foralls,fs==gs.Proof.introp.bydestructp.Defined.DefinitionSigHomomorphism{σ} (AB:Algebraσ) :Type:={def_hom:foralls,As->Bs|IsHomomorphismdef_hom}.Lemmaissig_homomorphism{σ} (AB:Algebraσ):SigHomomorphismAB<~> (A$->B).Proof.issig.Defined.Global Instancehset_homomorphism`{Funext} {σ} (AB:Algebraσ):IsHSet(A$->B).Proof.apply(istrunc_equiv_istrunc_(issig_homomorphismAB)).Qed.Lemmapath_homomorphism`{Funext} {σ} {AB:Algebraσ}(fg:A$->B) (p:def_homomorphismf=def_homomorphismg):f=g.Proof.apply(ap(issig_homomorphismAB)^-1)^-1.unfoldissig_homomorphism;cbn.applypath_sigma_hprop.exactp.Defined.The identity homomorphism.Sectionhomomorphism_id.Context{σ} (A:Algebraσ).Global Instanceis_homomorphism_id:IsHomomorphism(funs(x:As) =>x).Proof.introsua.reflexivity.Defined.Definitionhomomorphism_id:A$->A:=Build_Homomorphism(funs(x:As) =>x).Endhomomorphism_id.Argumentshomomorphism_id{σ}A%_Algebra_scope, {σ} {A}.Composition of homomorphisms.Sectionhomomorphism_compose.Context{σ} {ABC:Algebraσ}.Global Instanceis_homomorphism_compose(g:foralls,Bs->Cs) `{!IsHomomorphismg}(f:foralls,As->Bs) `{!IsHomomorphismf}:IsHomomorphism(funs=>gsofs).Proof.introsua.byrewrite<- (oppreserving_homg), (oppreserving_homf).Qed.Definitionhomomorphism_compose(g:B$->C) (f:A$->B) :A$->C:=Build_Homomorphism(funs=>gsofs).Endhomomorphism_compose.Global Instanceis01cat_algebra(σ :Signature) :Is01Cat(Algebraσ):=Build_Is01Cat(Algebraσ)_(fun_=>homomorphism_id) (fun___=>homomorphism_compose).Lemmaassoc_homomorphism_compose`{Funext} {σ}{ABCD:Algebraσ} (h:C$->D) (g:B$->C) (f:A$->B): (h$og) $of=h$o(g$of).Proof.byapplypath_homomorphism.Defined.Lemmaleft_id_homomorphism_compose`{Funext} {σ}{AB:Algebraσ} (f:A$->B):IdB$of=f.Proof.byapplypath_homomorphism.Defined.Lemmaright_id_homomorphism_compose`{Funext} {σ}{AB:Algebraσ} (f:A$->B):f$oIdA=f.Proof.byapplypath_homomorphism.Defined.Global Instanceis2graph_algebra{σ} :Is2Graph(Algebraσ):=funAB=>Build_IsGraph_(fun(fg:A$->B) =>foralls,fs==gs).Global Instanceis01cat_homomorphism{σ} (AB:Algebraσ):Is01Cat(A$->B).Proof.applyBuild_Is01Cat.-exact(funfsx=>idpath).-exact(funfghPQsx=>Qsx@Psx).Defined.Global Instanceis0gpd_homomorphism{σ} {AB:Algebraσ}:Is0Gpd(A$->B).Proof.applyBuild_Is0Gpd.introsfgPsx.exact(Psx)^.Defined.Global Instanceis0functor_postcomp_homomorphism{σ}(A:Algebraσ) {BC:Algebraσ} (h:B$->C):Is0Functor(@cat_postcomp(Algebraσ)__ABCh).Proof.applyBuild_Is0Functor.intros[f?] [g?]psx.exact(ap(hs) (psx)).Defined.Global Instanceis0functor_precomp_homomorphism{σ}{AB:Algebraσ} (h:A$->B) (C:Algebraσ):Is0Functor(@cat_precomp(Algebraσ)__ABCh).Proof.applyBuild_Is0Functor.intros[f?] [g?]psx.exact(ps(hsx)).Defined.Global Instanceis1cat_algebra(σ :Signature) :Is1Cat(Algebraσ).Proof.byrapplyBuild_Is1Cat.Defined.Global Instanceis1cat_strong_algebra`{Funext} (σ :Signature):Is1Cat_Strong(Algebraσ).Proof.rapplyBuild_Is1Cat_Strong.-intros.applyassoc_homomorphism_compose.-intros.symmetry;applyassoc_homomorphism_compose.-intros.applyleft_id_homomorphism_compose.-intros.applyright_id_homomorphism_compose.Defined.

--- Miscellaneous\HomotopyGroup.html ---
HomotopyGroupLibrary HomotopyGroupRequireImportBasicsTypesPointedHSet.RequireImportModalities.Modality.RequireImportTruncations.CoreTruncations.SeparatedTrunc.RequireImportAlgebra.AbGroups.RequireImportWildCat.Local OpenScopenat_scope.Local OpenScopepointed_scope.Local OpenScopepath_scope.The type that the nth homotopy group will have.DefinitionHomotopyGroup_type(n:nat) :Type:=matchnwith| 0 =>pType|n.+1 =>Groupend.(* Every homotopy group is, in particular, a pointed type. *)DefinitionHomotopyGroup_type_ptype(n:nat) :HomotopyGroup_typen->pType:=matchnreturnHomotopyGroup_typen->pTypewith| 0 =>funX=>X(* This works becauseptype_groupis already a coercion. *)|n.+1 =>funG=>Gend.CoercionHomotopyGroup_type_ptype:HomotopyGroup_type>->pType.We construct the wildcat structure on HomotopyGroup_type in the obvious way.Global Instanceisgraph_homotopygroup_type(n:nat):IsGraph(HomotopyGroup_typen) :=ltac:(destructn;exact_).Global Instanceis2graph_homotopygroup_type(n:nat):Is2Graph(HomotopyGroup_typen) :=ltac:(destructn;exact_).Global Instanceis01cat_homotopygroup_type(n:nat):Is01Cat(HomotopyGroup_typen) :=ltac:(destructn;exact_).Global Instanceis1cat_homotopygroup_type(n:nat):Is1Cat(HomotopyGroup_typen) :=ltac:(destructn;exact_).Global Instanceis0functor_homotopygroup_type_ptype(n:nat):Is0Functor(HomotopyGroup_type_ptypen):=ltac:(destructn;exact_).Global Instanceis1functor_homotopygroup_type_ptype(n:nat):Is1Functor(HomotopyGroup_type_ptypen):=ltac:(destructn;exact_).We first definePi1X, and use this to definePinX.
  The reason is to make it easier for Coq to see thatPi(n.+1)Xis
  definitionally equal toPi1(iterated_loopsnX)DefinitionPi1(X:pType) :Group.Proof.srapply(Build_Group(Tr0 (loopsX)));repeatsplit.Operation+introsxy.strip_truncations.exact(tr(x@y)).Unit+exact(tr1).Inverse+srapplyTrunc_rec;introx.exact(trx^).IsHSet+exact_.Associativity+introsxyz.strip_truncations.cbn;applyap.applyconcat_p_pp.Left identity+introx.strip_truncations.cbn;applyap.applyconcat_1p.Right identity+introx.strip_truncations.cbn;applyap.applyconcat_p1.Left inverse+introx.strip_truncations.apply(aptr).applyconcat_Vp.Right inverse+introx.strip_truncations.apply(aptr).applyconcat_pV.Defined.Definition of the nth homotopy groupDefinitionPi(n:nat) (X:pType) :HomotopyGroup_typen.Proof.destructn.1:exact(pTr0X).exact(Pi1(iterated_loopsnX)).Defined.Seepi_loopsbelow for an alternate unfolding.Definitionpi_succnX:Pin.+1X$<~>Pi1 (iterated_loopsnX):=grp_iso_id.ModulePiUtf8.Notation"'π'" :=Pi.EndPiUtf8.Global Instanceishset_pi{n:nat} {X:pType}:IsHSet(PinX):=ltac:(destructn;exact_).When n >= 2 we have that the nth homotopy group is an abelian group. Note that we don't actually define it as an abelian group but merely show that it is one. This would cause lots of complications with the typechecker.Global Instanceisabgroup_pi(n:nat) (X:pType):IsAbGroup(Pin.+2X).Proof.nrapplyBuild_IsAbGroup.1:exact_.introsxy.strip_truncations.cbn;apply(aptr).applyeckmann_hilton.Defined.For the same reason as above, we makePi1a functor before makingPia functor.Global Instanceis0functor_pi1:Is0FunctorPi1.Proof.applyBuild_Is0Functor.introsXYf.snrapplyBuild_GroupHomomorphism.{rapply(fmap(Tr0)).rapply(fmaploops).assumption. }Note: we don't have to be careful about which paths we choose here since we are trying to inhabit a proposition.introsxy.strip_truncations.apply(aptr);cbn.rewrite2concat_pp_p.applywhiskerL.rewrite2concat_p_pp.rewrite(concat_pp_p(apfx)).rewriteconcat_pV,concat_p1.rewriteconcat_p_pp.applywhiskerR.applyap_pp.Defined.Global Instanceis0functor_pi(n:nat) :Is0Functor(Pin):=ltac:(destructn;exact_).Definitionfmap_pi_succ{XY:pType} (f:X$->Y) (n:nat):fmap(Pin.+1)f$==fmap(Pi1) (fmap(iterated_loopsn)f).Proof.reflexivity.Defined.Global Instanceis1functor_pi1:Is1FunctorPi1.Proof.The conditions forPi1to be a 1-functor only involve equalities of maps between groups, which reduce to equalities of maps between types.  Type inference shows thatTr0oloopsis a 1-functor, and so it follows thatPi1is a 1-functor.assert(is1f:Is1Functor(Tr0oloops))byexact_.applyBuild_Is1Functor;intros;[byrapply(fmap2_(is1functor_F:=is1f))|byrapply(fmap_id_(is1functor_F:=is1f))|byrapply(fmap_comp_(is1functor_F:=is1f)) ].Defined.Global Instanceis1functor_pi(n:nat) :Is1Functor(Pin):=ltac:(destructn;exact_).Sometimes it is convenient to regardPinas landing in pointed types.  On objects, this is handled by the coercionHomotopyGroup_type_ptype, but on morphisms it doesn't seem possible to define a coercion.  So we explicitly name the composite functor.DefinitionpPi(n:nat) :pType->pType:=HomotopyGroup_type_ptypenoPin.Global Instanceis0functor_ppi(n:nat) :Is0Functor(pPin) :=_.Global Instanceis1functor_ppi(n:nat) :Is1Functor(pPin) :=_.pPiis equal to a more explicit map.  These are definitional forn=0andna successor; it would be nice to make them definitional for genericn.Definitionppi_ptr_iterated_loops(n:nat):pPin=pTr0oiterated_loopsn:=ltac:(destructn;reflexivity).Here is the associated object-wise equivalence, which is the identity map for0and successors.Definitionpequiv_ppi_ptr_iterated_loops(n:nat) (X:pType):pPinX<~>*pTr0 (iterated_loopsnX):=ltac:(destructn;exactpequiv_pmap_idmap).These equivalences are natural. Put another way, we can computefmapPiin terms of the composite functor, up to the equivalences above. Forn=0orna successor, we can omit the equivalences; forn=0, the induced maps are definitionally equal as pointed maps; forna successfor the underlying unpointed maps are definitionally equal, but the pointedness proofs are not, and this is handled byphomotopy_homotopy_hset.Definitionfmap_ppi_ptr_iterated_loops(n:nat) {XY:pType} (f:X->*Y):pequiv_ppi_ptr_iterated_loopsnYo*fmap(pPin)f==*fmap(pTr0) (fmap(iterated_loopsn)f)o*pequiv_ppi_ptr_iterated_loopsnX.Proof.destructn;unfoldpequiv_ppi_ptr_iterated_loops.1:refine(pmap_postcompose_idmap_@* (pmap_precompose_idmap_)^*).refine(pmap_postcompose_idmap_@*_@* (pmap_precompose_idmap_)^*).srapplyphomotopy_homotopy_hset;reflexivity.Defined.Pin.+1sends equivalences to group isomorphisms.Definitiongroupiso_pi_functor(n:nat) {XY:pType} (e:X<~>*Y):Pin.+1X$<~>Pin.+1Y:=emap(Pin.+1)e.The homotopy groups of a loop space are those of the space shifted.Definitionpi_loopsnX:Pin.+1X<~>*Pin(loopsX).Proof.destructn.1:reflexivity.rapply(emap(pTr0oloops)).applyunfold_iterated_loops'.Defined.Except in the lowest case, this can be expressed as an isomorphism of groups.Definitiongroupiso_pi_loopsnX:Pin.+2X$<~>Pin.+1 (loopsX).Proof.snrapply(groupiso_pi_functor0).applyunfold_iterated_loops'.Defined.Naturality ofpi_loops.Definitionfmap_pi_loops(n:nat) {XY:pType} (f:X->*Y): (pi_loopsnY)o* (fmap(Pin.+1)f)==* (fmap(pPinoloops)f)o* (pi_loopsnX).Proof.destructn;srapplyphomotopy_homotopy_hset;introsx.1:reflexivity.refine((O_functor_compose0___)^ @_@ (O_functor_compose0___)).applyO_functor_homotopy.exact(pointed_htpy(unfold_iterated_fmap_loopsn.+1f)).Defined.Homotopy groups preserve products.  This is a direct proof, but below we give a second proof whose underlying map is the natural one.Definitionpi_prod'{n:nat} (XY:pType):pPin(X*Y) <~>* (pPinX) * (pPinY).Proof.(* First we re-express this in terms of the compositepTr0oiterated_loopsn. *)refine(_o*Epequiv_ppi_ptr_iterated_loops__).refine((equiv_functor_pprod(pequiv_ppi_ptr_iterated_loops__)(pequiv_ppi_ptr_iterated_loops__))^-1*o*E_).(* For this composite, the proof is straightforward. *)refine(_o*Epequiv_ptr_functor0_).1:nrapplyiterated_loops_prod.snrapplyBuild_pEquiv';cbn.-refine(equiv_O_prod_cmp0__).-reflexivity.Defined.The pointed map from left-to-right below, coming from functoriality, is an equivalence.Definitionpi_prod{n:nat} (XY:pType):pPin(X*Y) <~>* (pPinX) * (pPinY).Proof.snrapplyBuild_pEquiv.(* This describes the natural map. *)-rapply(equiv_pprod_coind(pfam_const_) (pfam_const_));split.+exact(fmap(pPin) (@pfstXY)).+exact(fmap(pPin) (@psndXY)).(* To see that it is an equivalence, we show that it is homotopic topi_prod'. *)-snrapply(isequiv_homotopic'(pi_prod'XY)).introxy.destructn;strip_truncations.+applypath_prod;reflexivity.+applypath_prod.1,2:apply(aptr).(* Not obvious, but unfolding makes things cluttered. *)*exact(pfst_iterated_loops_prodXY(n:=n.+1)xy).*exact(psnd_iterated_loops_prodXY(n:=n.+1)xy).Defined.For positiven, this equivalence is an isomorphism of groups.Lemmagrp_iso_pi_prod{n:nat} (XY:pType):GroupIsomorphism(Pin.+1 (X*Y)) (grp_prod(Pin.+1X) (Pin.+1Y)).Proof.snrapplyBuild_GroupIsomorphism.(* The underlying map is the natural one, so it is automatically a group homomorphism. *)-applygrp_prod_corec.+exact(fmap(Pin.+1) (@pfstXY)).+exact(fmap(Pin.+1) (@psndXY)).(* This is also the underlying map ofpi_prod, so we can reuse the proof that it is an equivalence. *)-exact(equiv_isequiv(pi_prodXY(n:=n.+1))).Defined.Homotopy groups of truncationsAnn-connected map induces an equivalence on the nth homotopy group.  We first state this forpTr0oiterated_loopsn, since the proof works for generaln, and then we deduce the result forpPinafterwards.Definitionisequiv_pi_connmap'`{Univalence} (n:nat) {XY:pType} (f:X->*Y)`{!IsConnMapnf}:IsEquiv(fmap(pTr0) (fmap(iterated_loopsn)f)).Proof.rapplyO_inverts_conn_map.rapplyisconnected_iterated_fmap_loops.rewrite2trunc_index_inc'_succ.rewrite<-trunc_index_inc_agree.assumption.Defined.The same holds forpPin.Global Instanceisequiv_pi_connmap`{Univalence} (n:nat) {XY:pType} (f:X->*Y)`{!IsConnMapnf}:IsEquiv(fmap(pPin)f).Proof.(* Forn=0andna successor,fmap(pPin)fis definitionally equal to the map in the previous result as a map of types. *)destructn;rapplyisequiv_pi_connmap'.Defined.Definitionpequiv_pi_connmap`{Univalence} (n:nat) {XY:pType} (f:X->*Y)`{!IsConnMapnf}:PinX<~>*PinY:=Build_pEquiv__(fmap(pPin)f)_.For positiven, it is a group isomorphism.Definitiongrp_iso_pi_connmap`{Univalence} (n:nat) {XY:pType} (f:X->*Y)`{!IsConnMapn.+1f}:GroupIsomorphism(Pin.+1X) (Pin.+1Y):=Build_GroupIsomorphism__(fmap(Pin.+1)f) (isequiv_pi_connmapn.+1f).As a consequence, the truncation mapptr:X->pTrnXinduces an equivalence onPin.  We don't make this an instance, since it is found by typeclass search.Definitionisequiv_pi_Tr`{Univalence} (n:nat) (X:pType):IsEquiv(fmap(pPin)ptr:PinX->Pin(pTrnX)):=_.Definitionpequiv_pi_Tr`{Univalence} (n:nat) (X:pType):PinX<~>*Pin(pTrnX):=Build_pEquiv__(fmap(pPin)ptr)_.For positiven, it is a group isomorphism.Definitiongrp_iso_pi_Tr`{Univalence} (n:nat) (X:pType):GroupIsomorphism(Pin.+1X) (Pin.+1 (pTrn.+1X)):=grp_iso_pi_connmapnptr.Ann-connected map induces a surjection onn+1-fold loop spaces andPi(n+1).Definitionissurj_iterated_loops_connmap`{Univalence} (n:nat) {XY:pType} (f:X->*Y){C:IsConnMapnf}:IsSurjection(fmap(iterated_loops(n.+1))f).Proof.applyisconnected_iterated_fmap_loops.cbn.rewritetrunc_index_inc'_0n;assumption.Defined.Definitionissurj_pi_connmap`{Univalence} (n:nat) {XY:pType} (f:X->*Y){C:IsConnMapnf}:IsConnMap(Tr(-1)) (fmap(pPin.+1)f).Proof.rapplyconn_map_O_functor_strong_leq.byapplyissurj_iterated_loops_connmap.Defined.Pointed sections induce embeddings on homotopy groups.Propositionisembedding_pi_psect{n:nat} {XY:pType}(s:X->*Y) (r:Y->*X) (k:ro*s==*pmap_idmap):IsEmbedding(fmap(pPin)s).Proof.applyisembedding_isinj_hset.rapply(isinj_section(r:=fmap(pPin)r)).introx.lhs_Vrapply(fmap_comp(pPin)srx).lhsrapply(fmap2(pPin)kx).exact(fmap_id(pPin)Xx).Defined.

--- Miscellaneous\HomotopyPreCategory.html ---
HomotopyPreCategoryLibrary HomotopyPreCategoryHomotopy PreCategory of TypesRequireImportCategory.Core.RequireImportHoTT.BasicsHoTT.Truncations.Core.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopepath_scope.Local OpenScopecategory_scope.Quoting the HoTT Book:Example. There is a precategory whose type of objects isUand
    withhom(X,Y):∥X→Y∥₀, and composition defined by induction
    on truncation from ordinary composition(Y→Z)→(X→Y)→(X→Z). We call this the homotopy precategory of types.We don't want access to all of the internals of this category at top level.ModuleHomotopyPreCategoryInternals.Sectionhomotopy_precategory.Local Notationobject:=Type(onlyparsing).Local Notationmorphismsd:= (Trunc0 (s->d)) (onlyparsing).Definitioncomposesdd'(m:morphismdd') (m':morphismsd):morphismsd'.Proof.revertm';applyTrunc_rec;introm'.revertm;applyTrunc_rec;introm.applytr.exact(mom')%core.Defined.Definitionidentityx:morphismxx:=tridmap.Global Argumentscompose[sdd']mm'/ .Global Argumentsidentityx/ .Endhomotopy_precategory.EndHomotopyPreCategoryInternals.The Homotopy PreCategory of TypesDefinitionhomotopy_precategory:PreCategory.Proof.refine(@Build_PreCategoryType_(@HomotopyPreCategoryInternals.identity)(@HomotopyPreCategoryInternals.compose)____);simpl;intros;repeatmatchgoalwith| [m:Trunc__|-_]=>revertm;applyTrunc_ind;[intro;matchgoalwith| [ |-IsHSet(?a= ?b:> ?T) ]=>generalizeab;intros;letH:=freshinassert(H:forallxy:T,IsHProp(x=y))end;typeclasseseauto|intro]end;simpl;applyap;exactidpath.Defined.

--- Miscellaneous\Hopf.html ---
HopfLibrary HopfRequireImportTypesBasicsPointedTruncations.RequireImportHSpaceSuspensionExactSequenceHomotopyGroup.RequireImportWildCat.CoreWildCat.UniverseWildCat.EquivModalities.ReflectiveSubuniverseModalities.Descent.RequireImportHSetSpaces.Nat.Core.RequireImportHomotopy.JoinColimits.Pushout.Local OpenScopepointed_scope.Local OpenScopetrunc_scope.Local OpenScopemc_mult_scope.The Hopf constructionWe define the Hopf construction associated to a left-invertible H-space, and use it to prove that H-spaces satisfy a strengthened version of Freudenthal's theorem (seefreudenthal_hspacebelow).The Hopf construction associated to a left-invertible H-space (Definition 8.5.6 in the HoTT book).Definitionhopf_construction`{Univalence} (X:pType)`{IsHSpaceX} `{foralla,IsEquiv(a*.)}:pFam(psuspX).Proof.srapplyBuild_pFam.-apply(Susp_rec(Y:=Type)XX).exact(funx=>path_universe(x*.)).-simpl.exactpt.Defined.Total space of the Hopf constructionThe total space of the Hopf construction onSuspXis the join ofXwith itself. Note that we need both left and right multiplication to be equivalences. This is true whenXis a 0-connected H-space for example. (This is lemma 8.5.7 in the HoTT book).Definitionpequiv_hopf_total_join`{Univalence} (X:pType)`{IsHSpaceX} `{foralla,IsEquiv(a*.)} `{foralla,IsEquiv(.*a)}:psigma(hopf_constructionX) <~>*pjoinXX.Proof.snrapplyBuild_pEquiv'.{refine(_oEequiv_pushout_flatten(f:=const_ttX) (g:=const_ttX)(Unit_ind(pointed_typeX)) (Unit_ind(pointed_typeX))(funx=>Build_Equiv__(x*.) (H1x))).snrapplyequiv_pushout.(* The equivalence{x:X&X}<~>X*Xthat we need sends(x;y)to(y,x*y). *){cbn.refine(equiv_sigma_prod0__oE_oEequiv_sigma_symm0__).snrapplyequiv_functor_sigma_id.introsx.exact(Build_Equiv__(.*x)_). }1,2:rapply(equiv_contr_sigma(Unit_ind(pointed_typeX))).1,2:reflexivity. }reflexivity.Defined.Miscellaneous lemmas and corollaries about the Hopf constructionLemmatransport_hopf_construction`{Univalence} {X:pType}`{IsHSpaceX} `{foralla,IsEquiv(a*.)}:forallxy:X,transport(hopf_constructionX) (meridx)y=x*y.Proof.introsxy.transport_to_ap.refine(ap(funz=>transportidmapzy)_@_).1:applySusp_rec_beta_merid.applytransport_path_universe.Defined.The connecting map associated to the Hopf construction ofXis a retraction ofloop_susp_unitX(Proposition 2.19 in https://arxiv.org/abs/2301.02636v1).Propositionhopf_retraction`{Univalence} (X:pType)`{IsHSpaceX} `{foralla,IsEquiv(a*.)}:connecting_map_family(hopf_constructionX)o*loop_susp_unitX==*pmap_idmap.Proof.nrapplyhspace_phomotopy_from_homotopy.1:assumption.introx;cbn.refine(transport_pp____@_);unfolddpoint.applymoveR_transport_V.refine(transport_hopf_construction__@_@ (transport_hopf_construction__)^).exact(right_identity_@ (left_identity_)^).Defined.It follows fromhopf_retractionand Freudenthal's theorem thatloop_susp_unitinduces an equivalence onPi(2n+1)forn-connected H-spaces (with n >= 0). Note thatXis automatically left-invertible.Propositionisequiv_Pi_connected_hspace`{Univalence}{n:nat} (X:pType) `{IsConnectednX}`{IsHSpaceX}:IsEquiv(fmap(pPi(n+n).+1) (loop_susp_unitX)).Proof.nrapplyisequiv_surj_emb.-applyissurj_pi_connmap.destructn.+byapply(conn_map_loop_susp_unit(-1)).+rewrite<-trunc_index_add_nat_add.byapply(conn_map_loop_susp_unit).-pose(is0connected_isconnectedn.-2_).nrapplyisembedding_pi_psect.applyhopf_retraction.Defined.By Freudenthal,loop_susp_unitinduces an equivalence on lower homotopy groups as well, so it is a (2n+1)-equivalence.  We formalize it below withm=n-1, and allownto start at-1.  We prove it using a more general result about reflective subuniverses,OO_inverts_conn_map_factor_conn_map, but one could also use homotopy groups and the truncated Whitehead theorem.Definitionfreudenthal_hspace'`{Univalence}{m:trunc_index} (X:pType) `{IsConnectedm.+1X}`{IsHSpaceX} `{foralla,IsEquiv(a*.)}:O_inverts(Tr(m+2+m).+1) (loop_susp_unitX).Proof.set(r:=connecting_map_family(hopf_constructionX)).nrapply(OO_inverts_conn_map_factor_conn_map_(m+2+m)_r).2, 4:exact_.1:applyO_lex_leq_Tr.rapply(conn_map_homotopic_equiv_idmap(roloop_susp_unitX)).symmetry.nrapplyhopf_retraction.Defined.Note that we don't really need the assumption thatXis left-invertible in the previous result; form>=-1, it follows from connectivity.  And form=-2, the conclusion is trivial. Here we state the version form>=-1without left-invertibility.Definitionfreudenthal_hspace`{Univalence}{m:trunc_index} (X:pType) `{IsConnectedm.+2X}`{IsHSpaceX}:O_inverts(Tr(m.+1 +2+m.+1).+1) (loop_susp_unitX).Proof.pose(is0connected_isconnectedm_).exact(freudenthal_hspace'(m:=m.+1)X).Defined.Here we give a generalization of a result from Eilenberg-MacLane Spaces in Homotopy Type Theory, Dan Licata and Eric Finster.  Their version corresponds tom=-2in our version.  Their encode-decode proof was formalized in this library in EMSpace.v until this shorter and more general approach was found.Definitionlicata_finster`{Univalence}{m:trunc_index} (X:pType) `{IsConnectedm.+2X}(k:= (m.+1 +2+m.+1).+1) `{IsHSpaceX} `{IsTrunckX}:X<~>*pTrk(loops(psuspX)).Proof.refine(_o*Epequiv_ptr(n:=k)).nrefine(pequiv_O_invertsk(loop_susp_unitX)).rapplyfreudenthal_hspace.Defined.SinceloopsXis an H-space, the Hopf construction provides a mapJoin(loopsX)(loopsX)->Susp(loopsX).  We show that this map is equivalent to the fiber ofloop_susp_counitX:Susp(loopsX)->Xover the base point, up to the automorphism ofSusp(loopsX)induced by inverting loops.Definitionpequiv_pfiber_loops_susp_counit_join`{Univalence} (X:pType):pfiber(loop_susp_counitX) <~>*pjoin(loopsX) (loopsX).Proof.snrefine(pequiv_hopf_total_join(loopsX)o*E_).2:rapplyishspace_loops.2,3:exact_.snrapplyBuild_pEquiv'.{snrapplyequiv_functor_sigma'.1:exact(emappsusp(equiv_path_inverse__)).snrapplySusp_ind;hnf.1,2:reflexivity.introsp.nrapplypath_equiv.funextq.simpl.lhsrapply(transport_equiv(meridp)_q).simpl.lhsnrapplyap.{lhsnrapplytransport_paths_Fl.nrapplywhiskerR.{lhsnrapply(apinverse(ap_V__)).lhsrapplyinv_V.applySusp_rec_beta_merid. } }lhsnrapply(transport_idmap_ap_(meridp)).lhsnrapply(transport2idmap).{lhsnrapplyap_compose.lhsnrapplyap.1:applyfunctor_susp_beta_merid.applySusp_rec_beta_merid. }lhsnrapplytransport_path_universe.applyconcat_V_pp. }reflexivity.Defined.As a corollary we get 2n-connectivity ofloop_susp_counitXfor an n-connectedX.Global Instanceconn_map_loop_susp_counit`{Univalence}{n:trunc_index} (X:pType) `{IsConnectedn.+1X}:IsConnMap(n+2+n) (loop_susp_counitX).Proof.destructn.-introx;hnf;exact_.-snrapply(conn_point_elim(-1)).+exact(isconnected_pred_add'n0_).+exact_.+nrapply(isconnected_equiv'__(pequiv_pfiber_loops_susp_counit_joinX)^-1).nrapplyisconnected_join;exact_.Defined.In particular, we get the following result.  All we are really using is thatn.+2<=n+2+n, but because of the use ofisconnmap_pred_add, the proof is a bit more specific to this case.Definitionpequiv_ptr_psusp_loops`{Univalence} (X:pType) (n:nat) `{IsConnectedn.+1X}:pTrn.+2 (psusp(loopsX)) <~>*pTrn.+2X.Proof.snrapplyBuild_pEquiv.1:rapply(fmap(pTr_) (loop_susp_counit_)).nrapplyO_inverts_conn_map.nrapply(isconnmap_pred_addn.-2).rewrite2trunc_index_add_succ.rapply(conn_map_loop_susp_counitX).Defined.

--- Miscellaneous\HoTT.html ---
HoTTLibrary HoTTA convenience file that loads most of the HoTT library.
    You can use it with "Require Import HoTT" in your files.
    But please do not use it in the HoTT library itself, or
    you are likely going to create a dependency loop.RequireExportHoTT.Basics.RequireExportHoTT.Types.RequireExportHoTT.WildCat.RequireExportHoTT.Cubical.DPath.RequireExportHoTT.Cubical.PathSquare.RequireExportHoTT.Cubical.DPathSquare.RequireExportHoTT.Cubical.PathCube.RequireExportHoTT.Cubical.DPathCube.RequireExportHoTT.Pointed.RequireExportHoTT.Truncations.RequireExportHoTT.HFiber.RequireExportHoTT.Projective.RequireExportHoTT.EquivGroupoids.RequireExportHoTT.Equiv.BiInv.RequireExportHoTT.Equiv.PathSplit.RequireExportHoTT.Equiv.Relational.RequireExportHoTT.Extensions.RequireExportHoTT.Misc.RequireExportHoTT.PathAny.RequireExportHoTT.Functorish.RequireExportHoTT.Factorization.RequireExportHoTT.Constant.RequireExportHoTT.Universes.Smallness.RequireExportHoTT.Universes.TruncType.RequireExportHoTT.Universes.ObjectClassifier.RequireExportHoTT.Universes.DProp.RequireExportHoTT.Universes.HProp.RequireExportHoTT.Universes.HSet.RequireExportHoTT.Universes.Automorphisms.RequireExportHoTT.Universes.BAut.RequireExportHoTT.Universes.Rigid.RequireExportHoTT.NullHomotopy.RequireExportHoTT.Idempotents.RequireExportHoTT.ExcludedMiddle.RequireExportHoTT.BoundedSearch.RequireExportHoTT.HIT.Interval.RequireExportHoTT.HIT.Flattening.RequireExportHoTT.HIT.FreeIntQuotient.RequireExportHoTT.HIT.SetCone.RequireExportHoTT.HIT.epi.RequireExportHoTT.HIT.unique_choice.RequireExportHoTT.HIT.iso.RequireExportHoTT.HIT.quotient.RequireExportHoTT.HIT.surjective_factor.RequireExportHoTT.HIT.V.RequireExportHoTT.Diagrams.Graph.RequireExportHoTT.Diagrams.Diagram.RequireExportHoTT.Diagrams.Cone.RequireExportHoTT.Diagrams.Cocone.RequireExportHoTT.Diagrams.DDiagram.RequireExportHoTT.Diagrams.ConstantDiagram.RequireExportHoTT.Diagrams.CommutativeSquares.RequireExportHoTT.Diagrams.Sequence.RequireExportHoTT.Diagrams.Span.RequireExportHoTT.Diagrams.ParallelPair.RequireExportHoTT.Limits.Pullback.RequireExportHoTT.Limits.Equalizer.RequireExportHoTT.Limits.Limit.RequireExportHoTT.Colimits.GraphQuotient.RequireExportHoTT.Colimits.Coeq.RequireExportHoTT.Colimits.Pushout.RequireExportHoTT.Colimits.SpanPushout.RequireExportHoTT.Colimits.Quotient.RequireExportHoTT.Colimits.Quotient.Choice.RequireExportHoTT.Colimits.MappingCylinder.RequireExportHoTT.Colimits.Sequential.RequireExportHoTT.Colimits.Colimit.RequireExportHoTT.Colimits.Colimit_Pushout.RequireExportHoTT.Colimits.Colimit_Coequalizer.RequireExportHoTT.Colimits.Colimit_Flattening.RequireExportHoTT.Colimits.Colimit_Prod.RequireExportHoTT.Colimits.Colimit_Pushout_Flattening.RequireExportHoTT.Colimits.Colimit_Sigma.RequireExportHoTT.Modalities.ReflectiveSubuniverse.RequireExportHoTT.Modalities.Modality.RequireExportHoTT.Modalities.Accessible.RequireExportHoTT.Modalities.Notnot.RequireExportHoTT.Modalities.Identity.RequireExportHoTT.Modalities.Localization.RequireExportHoTT.Modalities.Nullification.RequireExportHoTT.Modalities.Descent.RequireExportHoTT.Modalities.Separated.RequireExportHoTT.Modalities.Lex.RequireExportHoTT.Modalities.Topological.RequireExportHoTT.Modalities.Open.RequireExportHoTT.Modalities.Closed.RequireExportHoTT.Modalities.Fracture.RequireExportHoTT.Modalities.Meet.RequireExportHoTT.Modalities.CoreflectiveSubuniverse.RequireExportHoTT.Spaces.Nat.RequireExportHoTT.Spaces.BinInt.RequireExportHoTT.Spaces.Pos.RequireExportHoTT.Spaces.List.Core.RequireExportHoTT.Spaces.List.Theory.RequireExportHoTT.Spaces.List.Paths.RequireExportHoTT.Spaces.Cantor.RequireExportHoTT.Spaces.Circle.RequireExportHoTT.Spaces.TwoSphere.RequireExportHoTT.Spaces.Spheres.RequireExportHoTT.Spaces.BAut.Cantor.RequireExportHoTT.Spaces.BAut.Bool.RequireExportHoTT.Spaces.BAut.Bool.IncoherentIdempotent.RequireExportHoTT.Spaces.Finite.RequireExportHoTT.Spaces.Card.RequireExportHoTT.Spaces.No.RequireExportHoTT.Spaces.Torus.Torus.RequireExportHoTT.Spaces.Torus.TorusEquivCircles.RequireExportHoTT.Spaces.Torus.TorusHomotopy.RequireExportHoTT.Algebra.ooGroup.RequireExportHoTT.Algebra.Aut.RequireExportHoTT.Algebra.ooAction.RequireExportHoTT.Algebra.AbGroups.RequireExportHoTT.Algebra.AbSES.RequireExportHoTT.Algebra.Groups.RequireExportHoTT.Algebra.Rings.RequireExportHoTT.Algebra.Universal.Algebra.RequireExportHoTT.Algebra.Universal.Congruence.RequireExportHoTT.Algebra.Universal.Homomorphism.RequireExportHoTT.Algebra.Universal.Operation.RequireExportHoTT.Algebra.Universal.TermAlgebra.RequireExportHoTT.Analysis.Locator.RequireExportHoTT.Homotopy.HomotopyGroup.RequireExportHoTT.Homotopy.PinSn.RequireExportHoTT.Homotopy.WhiteheadsPrinciple.RequireExportHoTT.Homotopy.BlakersMassey.RequireExportHoTT.Homotopy.Freudenthal.RequireExportHoTT.Homotopy.Suspension.RequireExportHoTT.Homotopy.Smash.RequireExportHoTT.Homotopy.Wedge.RequireExportHoTT.Homotopy.Join.RequireExportHoTT.Homotopy.HSpace.RequireExportHoTT.Homotopy.ClassifyingSpace.RequireExportHoTT.Homotopy.CayleyDickson.RequireExportHoTT.Homotopy.EMSpace.RequireExportHoTT.Homotopy.HSpaceS1.RequireExportHoTT.Homotopy.Bouquet.RequireExportHoTT.Homotopy.EncodeDecode.RequireExportHoTT.Homotopy.Syllepsis.RequireExportHoTT.Homotopy.Hopf.RequireExportHoTT.Spectra.Spectrum.RequireExportHoTT.Tactics.RequireExportHoTT.Tactics.BinderApply.RequireExportHoTT.Tactics.EquivalenceInduction.RequireExportHoTT.Tactics.EvalIn.RequireExportHoTT.Tactics.Nameless.RequireExportHoTT.Tactics.RewriteModuloAssociativity.RequireExportHoTT.Sets.AC.RequireExportHoTT.Sets.GCH.RequireExportHoTT.Sets.GCHtoAC.RequireExportHoTT.Sets.Hartogs.RequireExportHoTT.Sets.Ordinals.RequireExportHoTT.Sets.Powers.We donotexportUnivalenceAxiom,FunextAxiom, or any of the files inMetatheoryfrom this file.  Thus, importing this file does not prevent you from tracking usage ofUnivalenceandFunexttheorem-by-theorem in the same way that the library does.  If you want any of those files, you should import them separately.We check that UnivalenceAxiom, FunextAxiom aren't being leaked. This is so that these can be imported seperately.FailCheckHoTT.UnivalenceAxiom.univalence_axiom.FailCheckHoTT.FunextAxiom.funext_axiom.

--- Miscellaneous\HProp.html ---
HPropLibrary HPropHPropositionsRequireImportHoTT.BasicsHoTT.Types.Local OpenScopepath_scope.Generalizable VariablesAB.Alternate characterization of hprops.Theoremequiv_hprop_allpath`{Funext} (A:Type):IsHPropA<~> (forall(xy:A),x=y).Proof.rapply(equiv_iff_hprop(@path_ishpropA) (@hprop_allpathA)).applyhprop_allpath;introsfg.funextxy.pose(C:=Build_ContrAx(fx)).applypath_contr.Defined.Theoremequiv_hprop_inhabited_contr`{Funext} {A}:IsHPropA<~> (A->ContrA).Proof.apply(equiv_adjointify(@contr_inhabited_hpropA) (@hprop_inhabited_contrA)).-introic.by_extensionalityx.apply@path_contr.applycontr_istrunc.exact(icx).-introhp.applypath_ishprop.Defined.Being an hprop is also equivalent to the diagonal being an equivalence.Definitionishprop_isequiv_diag{A} `{IsEquiv__(fun(a:A) => (a,a))}:IsHPropA.Proof.applyhprop_allpath;introsxy.set(d:=fun(a:A) => (a,a))in*.transitivity(fst(d(d^-1 (x,y)))).-exact(apfst(eisretrd(x,y))^).-transitivity(snd(d(d^-1 (x,y)))).+unfoldd;reflexivity.+exact(apsnd(eisretrd(x,y))).Defined.Global Instanceisequiv_diag_ishprop{A} `{IsHPropA}:IsEquiv(fun(a:A) => (a,a)).Proof.refine(isequiv_adjointify_fst__).-intros[xy].applypath_prod;simpl.+reflexivity.+applypath_ishprop.-introsa;simpl.reflexivity.Defined.A map is an embedding as soon as its ap's have sections.Definitionisembedding_sect_ap{XY} (f:X->Y)(s:forallx1x2, (fx1=fx2) -> (x1=x2))(H:forallx1x2, (@apXYfx1x2)o(sx1x2) ==idmap):IsEmbeddingf.Proof.introsy.applyhprop_allpath.intros[x1p1] [x2p2].applypath_sigmawith(sx1x2(p1@p2^)).abstract(rewritetransport_paths_Fl;cbn;rewrite(Hx1x2(p1@p2^));rewriteinv_pp,inv_V;applyconcat_pV_p).Defined.Alternate characterizations of contractibility.Theoremequiv_contr_inhabited_hprop`{Funext} {A}:ContrA<~>A*IsHPropA.Proof.assert(f:ContrA->A*IsHPropA).-introP.split.+exact(@center_P).+apply@istrunc_succ.exactP.-assert(g:A*IsHPropA->ContrA).+intros[aP].apply(@contr_inhabited_hprop_Pa).+refine(@equiv_iff_hprop____fg).applyhprop_inhabited_contr;introp.apply@contr_prod.*exact(gp).*apply(@contr_inhabited_hprop__(sndp)).Defined.Theoremequiv_contr_inhabited_allpath`{Funext} {A}:ContrA<~>A*forall(xy:A),x=y.Proof.transitivity(A*IsHPropA).-applyequiv_contr_inhabited_hprop.-exact(1 *Eequiv_hprop_allpath_).Defined.Logical equivalence of hpropsLogical equivalence of hprops is not just logically equivalent to equivalence, it is equivalent to it.Global Instanceisequiv_equiv_iff_hprop_uncurried`{Funext} {AB} `{IsHPropA} `{IsHPropB}:IsEquiv(@equiv_iff_hprop_uncurriedA_B_) | 0.Proof.pose(@istrunc_equiv).refine(isequiv_adjointifyequiv_iff_hprop_uncurried(fune=> (@equiv_fun__e, @equiv_inv__e_))__);intro;byapplypath_ishprop.Defined.Definitionequiv_equiv_iff_hprop`{Funext} (AB:Type) `{IsHPropA} `{IsHPropB}: (A<->B) <~> (A<~>B):=Build_Equiv__(@equiv_iff_hprop_uncurriedA_B_)_.Inhabited and uninhabited hpropsIf an hprop is inhabited, then it is equivalent toUnit.Lemmaif_hprop_then_equiv_Unit(hprop:Type) `{IsHProphprop} :hprop->hprop<~>Unit.Proof.introp.applyequiv_iff_hprop.-exact(fun_=>tt).-exact(fun_=>p).Defined.If an hprop is not inhabited, then it is equivalent toEmpty.Lemmaif_not_hprop_then_equiv_Empty(hprop:Type) `{IsHProphprop} : ~hprop->hprop<~>Empty.Proof.intronp.exact(Build_Equiv__np_).Defined.Thus, a decidable hprop is either equivalent toUnitorEmpty.Definitionequiv_decidable_hprop(hprop:Type)`{IsHProphprop} `{Decidablehprop}: (hprop<~>Unit) + (hprop<~>Empty).Proof.destruct(dechprop)as[x|nx].-exact(inl(if_hprop_then_equiv_Unithpropx)).-exact(inr(if_not_hprop_then_equiv_Emptyhpropnx)).Defined.

--- Miscellaneous\hprop_lattice.html ---
hprop_latticeLibrary hprop_latticeRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Universes.TruncType.Demonstrate theHPropis a (bounded) lattice w.r.t. the logical
operations. This requires Univalence.Global Instancejoin_hor:JoinHProp:=hor.Definitionhand(XY:HProp) :HProp:=Build_HProp(X*Y).Global Instancemeet_hprop:MeetHProp:=hand.Global Instancebottom_hprop:BottomHProp:=False_hp.Global Instancetop_hprop:TopHProp:=Unit_hp.Sectioncontents.Context`{Univalence}.(* We use this notation becausehorcan accept arguments of typeType, which leads to minor confusion in the instances below *)Notationlor:= (hor:HProp->HProp->HProp).(* This tactic attempts to destruct a truncated sum (disjunction) *)Local Ltachor_intros:=letx:=freshinintrox;repeat(strip_truncations;destructxas[x|x]).Instancecommutative_hor:Commutativelor.Proof.intros??.applypath_iff_hprop;hor_intros;applytr;auto.Defined.Instancecommutative_hand:Commutativehand.Proof.intros??.applypath_hprop.applyequiv_prod_symm.Defined.Instanceassociative_hor:Associativelor.Proof.intros???.applypath_iff_hprop;hor_intros;applytr;((byauto) || (left;applytr) || (right;applytr));auto.Defined.Instanceassociative_hand:Associativehand.Proof.intros???.applypath_hprop.applyequiv_prod_assoc.Defined.Instanceidempotent_hor:BinaryIdempotentlor.Proof.intros?.compute.applypath_iff_hprop;hor_intros;auto.byapplytr,inl.Defined.Instanceidempotent_hand:BinaryIdempotenthand.Proof.intros?.applypath_iff_hprop.-intros[a_] ;applya.-introsa;apply(pairaa).Defined.Instanceleftidentity_hor:LeftIdentitylorFalse_hp.Proof.intros?.applypath_iff_hprop;hor_intros;trycontradiction||assumption.byapplytr,inr.Defined.Instancerightidentity_hor:RightIdentitylorFalse_hp.Proof.intros?.applypath_iff_hprop;hor_intros;trycontradiction||assumption.byapplytr,inl.Defined.Instanceleftidentity_hand:LeftIdentityhandUnit_hp.Proof.intros?.applypath_trunctype,prod_unit_l.Defined.Instancerightidentity_hand:RightIdentityhandUnit_hp.Proof.intros?.applypath_trunctype,prod_unit_r.Defined.Instanceabsorption_hor_hand:Absorptionlorhand.Proof.intros??.applypath_iff_hprop.-introsX;strip_truncations.destructXas[? | [?_]];assumption.-intros?.byapplytr,inl.Defined.Instanceabsorption_hand_hor:Absorptionhandlor.Proof.intros??.applypath_iff_hprop.-intros[?_];assumption.-intros?.split.*assumption.*byapplytr,inl.Defined.Global Instanceboundedlattice_hprop:IsBoundedLatticeHProp.Proof.repeatsplit;apply_.Defined.Endcontents.

--- Miscellaneous\HSet.html ---
HSetLibrary HSetRequireImportBasics.RequireImportTypes.SigmaTypes.PathsTypes.UnitTypes.Arrow.H-SetsLocal OpenScopepath_scope.A type is a set if and only if it satisfies Axiom K.DefinitionaxiomKA:=forall(x:A) (p:x=x),p=idpathx.DefinitionaxiomK_hset{A} :IsHSetA->axiomKA.Proof.introsHxp.nrapplypath_ishprop.exact(Hxx).Defined.Definitionhset_axiomK{A} `{axiomKA} :IsHSetA.Proof.applyistrunc_S;introsxy.apply@hprop_allpath.introspq.byinductionp.Defined.SectionAssumeFunext.Context`{Funext}.Theoremequiv_hset_axiomK{A} :IsHSetA<~>axiomKA.Proof.apply(equiv_adjointify(@axiomK_hsetA) (@hset_axiomKA)).-introsK.by_extensionalityx.by_extensionalityx'.cut(Contr(x=x)).+intro.eapplypath_contr.+apply(Build_Contr_1).intros.symmetry;applyK.-introK.eapplypath_ishprop.Defined.Global InstanceaxiomK_ispropA:IsHProp(axiomKA) | 0.Proof.apply(istrunc_equiv_istrunc_equiv_hset_axiomK).Defined.Theoremhset_path2{A} `{IsHSetA} {xy:A} (pq:x=y):p=q.Proof.inductionq.applyaxiomK_hset;assumption.Defined.Recall that axiom K says that any self-path is homotopic to the
   identity path.  In particular, the identity path is homotopic to
   itself.  The following lemma says that the endo-homotopy of the
   identity path thus specified is in fact (homotopic to) its identity
   homotopy (whew!).(* TODO: What was the purpose of this lemma?  Do we need it at all?  It's actually fairly trivial. *)LemmaaxiomK_idpath{A} (x:A) (K:axiomKA) :Kx(idpathx) =idpath(idpathx).Proof.pose(T1A:= @istrunc_succ_A(@hset_axiomKAK)).exact(@hset_path2(x=x) (T1Axx)____).Defined.EndAssumeFunext.We prove that ifRis a reflexive mere relation onXimplying identity, thenXis an hSet, and henceRxyis equivalent tox=y.Lemmaishset_hrel_subpaths{XR}`{ReflexiveXR}`{forallxy,IsHProp(Rxy)}(f:forallxy,Rxy->x=y):IsHSetX.Proof.apply@hset_axiomK.introsxp.refine(_@concat_Vp(fxx(transport(Rx)p^ (reflexivity_)))).applymoveL_Vp.refine((transport_paths_r__)^ @_).refine((transport_arrow___)^ @_).refine((ap10(apD(fx)p) (@reflexivityXR_x)) @_).applyap.applypath_ishprop.Defined.Global Instanceisequiv_hrel_subpathsXR`{ReflexiveXR}`{forallxy,IsHProp(Rxy)}(f:forallxy,Rxy->x=y)xy:IsEquiv(fxy) | 10000.Proof.poseproof(ishset_hrel_subpathsf).refine(isequiv_adjointify(fxy)(funp=>transport(Rx)p(reflexivityx))__);intro;applypath_ishprop.Defined.We will now prove that for sets, monos and injections are equivalent.Definitionismono{XY} (f:X->Y):=forall(Z:HSet),forallgh:Z->X,fog=foh->g=h.Global Instanceisinj_embedding{AB:Type} (m:A->B):IsEmbeddingm->IsInjectivem.Proof.introsisexyp.pose(ise(my)).assert(q: (x;p) = (y;1) :>hfiberm(my))byapplypath_ishprop.exact(appr1q).Defined.Computation rule for isinj_embedding.Lemmaisinj_embedding_beta{XY:Type} (f:X->Y) {I:IsEmbeddingf} {x:X}: (isinj_embeddingfIxxidpath) =idpath.Proof.exact(ap(appr1) (contr(idpath: (x;idpath) = (x;idpath)))).Defined.Definitionisinj_section{AB:Type} {s:A->B} {r:B->A}(H:ros==idmap) :IsInjectives.Proof.introsaa'alpha.exact((Ha)^ @apralpha@Ha').Defined.Lemmaisembedding_isinj_hset{AB:Type} `{IsHSetB} (m:A->B):IsInjectivem->IsEmbeddingm.Proof.introsisib.applyhprop_allpath;intros[xp] [yq].applypath_sigma_hprop;simpl.exact(isixy(p@q^)).Defined.Lemmaismono_isinj`{Funext} {XY} (f:X->Y) :IsInjectivef->ismonof.Proof.intros? ? ? ?H'.applypath_forall.applyap10inH'.hnfin*.eauto.Qed.Definitionisinj_ismono{XY} (f:X->Y)(H:ismonof):IsInjectivef:=funx0x1H'=>ap10(H(Build_HSetUnit)(fun_=>x0)(fun_=>x1)(ap(funx=>unit_namex)H'))tt.Lemmaismono_isequiv`{Funext}XY(f:X->Y) `{IsEquiv__f}:ismonof.Proof.intros?ghH'.applyap10inH'.applypath_forall.introx.transitivity(f^-1 (f(gx))).-byrewriteeissect.-transitivity(f^-1 (f(hx))).*applyap.applyH'.*byrewriteeissect.Qed.LemmacancelL_isembedding{ABC:Type} `{IsHSetB} {f:A->B} {g:B->C} `{IsEmbedding(gof)}:IsEmbeddingf.Proof.rapplyisembedding_isinj_hset.rapply(isinj_cancelL_g).Defined.

--- Miscellaneous\HSpace.html ---
HSpaceLibrary HSpaceRequireExportHSpace.Core.RequireExportHSpace.Coherent.RequireExportHSpace.Pointwise.RequireExportHSpace.Moduli.

--- Miscellaneous\HSpaceS1.html ---
HSpaceS1Library HSpaceS1RequireImportClasses.interfaces.canonical_names.RequireImportCubical.DPathCubical.PathSquare.RequireImportHomotopy.Suspension.RequireImportHomotopy.HSpace.Core.RequireImportHomotopy.HSpace.Coherent.RequireImportSpaces.Spheres.H-space structure on circle.SectionHSpace_S1.Context`{Univalence}.DefinitionSph1_ind(P:Sphere1 ->Type) (b:PNorth)(p:DPathP(meridNorth@ (meridSouth)^)bb):forallx:Sphere1,Px.Proof.srapplySusp_ind.1:exactb.1:exact(meridSouth#b).srapplySusp_ind;hnf.{applymoveL_transport_p.refine((transport_pp____)^ @_).applyp. }1:reflexivity.applyEmpty_ind.Defined.DefinitionSph1_rec(P:Type) (b:P) (p:b=b):Sphere1 ->P.Proof.srapplySusp_rec.1,2:exactb.simpl.srapplySusp_rec.1:exactp.1:reflexivity.applyEmpty_rec.Defined.DefinitionSph1_rec_beta_loop(P:Type) (b:P) (p:b=b):ap(Sph1_recPbp) (meridNorth@ (meridSouth)^) =p.Proof.rewriteap_pp.rewriteap_V.rewrite2Susp_rec_beta_merid.applyconcat_p1.Defined.Definitions1_turn:forallx:Sphere1,x=x.Proof.srapplySph1_ind.+exact(meridNorth@ (meridSouth)^).+applydp_paths_lr.byrewriteconcat_Vp,concat_1p.Defined.Global Instancesgop_s1:SgOp(psphere1):=funxy=>Sph1_rec_y(s1_turny)x.Global Instanceleftidentity_s1:LeftIdentitysgop_s1(point(psphere1)).Proof.srapplySph1_ind.1:reflexivity.applydp_paths_lr.rewriteconcat_p1.applyconcat_Vp.Defined.Global Instancerightidentity_s1:RightIdentitysgop_s1(point(psphere1)).Proof.srapplySph1_ind.1:reflexivity.applydp_paths_FlFr.rewriteconcat_p1.rewriteap_idmap.rewriteSph1_rec_beta_loop.applyconcat_Vp.Defined.Global Instancehspace_s1:IsHSpace(psphere1) := {}.Global Instanceiscoherent_s1:IsCoherent(psphere1) :=idpath.Definitioniscohhspace_s1:IsCohHSpace(psphere1):=Build_IsCohHSpace___.Global Instanceassociative_sgop_s1:Associativesgop_s1.Proof.introsxyz.revertx.srapplySph1_ind.1:reflexivity.applysq_dp^-1.reverty.srapplySph1_ind.{apply(sq_flip_v(px0:=1) (px1:=1)).exact(ap_nat'(funa=>ap(funb=>sgop_s1bz)(rightidentity_s1a)) (meridNorth@ (meridSouth)^)). }applypath_ishprop.Defined.Global Instancecommutative_sgop_s1:Commutativesgop_s1.Proof.introsxy.revertx.srapplySph1_ind.1:cbn;symmetry;applyright_identity.applysq_dp^-1.reverty.srapplySph1_ind.1:exact(ap_nat'rightidentity_s1_).srapplydp_ishprop.Defined.EndHSpace_S1.

--- Miscellaneous\Ideal.html ---
IdealLibrary IdealRequireImportBasicsTypes.RequireImportSpaces.Finite.Fin.RequireImportClasses.interfaces.canonical_names.RequireImportAlgebra.Rings.Ring.RequireImportAlgebra.Groups.Subgroup.RequireImportAlgebra.AbGroups.RequireImportWildCat.Core.Local OpenScopemc_scope.Declare Scopeideal_scope.DelimitScopeideal_scopewithideal.Local OpenScopeideal_scope.Left, Right and Two-sided IdealsDefinition of IdealsAn additive subgroupIof a ringRis a left ideal when it is closed under multiplciation on the left.ClassIsLeftIdeal{R:Ring} (I:SubgroupR) :=isleftideal(rx:R) :Ix->I(r*x).An additive subgroupIof a ringRis a right ideal when it is closed under multiplication on the right. We define this using the opposite ring allowing us to reduce redundancy between left and right ideals.ClassIsRightIdeal{R:Ring} (I:SubgroupR) :=isrightideal_isleftideal_op::IsLeftIdeal(R:=rng_opR)I.Definitionisrightideal{R:Ring} (I:SubgroupR) (xr:R):IsRightIdealI->Ix->I(x*r):=fun_=>isleftideal(R:=rng_opR)rx.An additive subgroupIof a ringRis a two-sided ideal when it is both a left and right ideal. In this case we just call it an ideal.ClassIsIdeal{R:Ring} (I:SubgroupR) := {ideal_isleftideal::IsLeftIdealI;ideal_isrightideal::IsRightIdealI;}.Definitionissig_IsIdeal{R:Ring} (I:SubgroupR) :_<~>IsIdealI:=ltac:(issig).Hint ImmediateBuild_IsIdeal:typeclass_instances.Any two-sided ideal is also a two-sided ideal of the opposite ring.Global Instanceisideal_op{R:Ring} (I:SubgroupR):IsIdealI->IsIdeal(R:=rng_opR)I.Proof.intros[? ?];exact_.Defined.A left ideal of a ringRis a subgroupIofRwhich is closed under left multiplication.RecordLeftIdeal(R:Ring) := {leftideal_subgroup:>SubgroupR;leftideal_isleftideal::IsLeftIdealleftideal_subgroup;}.Definitionissig_LeftIdeal(R:Ring) :_<~>LeftIdealR:=ltac:(issig).A right ideal of a ringRis a subgroupIofRwhich is closed under right multiplication.DefinitionRightIdeal(R:Ring) :=LeftIdeal(rng_opR).Global Instanceisrightdeal_rightideal{R} (I:RightIdealR):IsRightIdeal(R:=R)I:=leftideal_isleftideal_I.DefinitionBuild_RightIdeal(R:Ring) (I:SubgroupR) (H:IsRightIdealI):RightIdealR:=Build_LeftIdeal(rng_opR)IH.Definitionissig_RightIdeal(R:Ring): {I:SubgroupR&IsRightIdeal(R:=R)I} <~>RightIdealR:=ltac:(issig).A two-sided ideal of a ringR, or just an ideal, is a subgroupIofRwhich is closed under both left and right multiplication.RecordIdeal(R:Ring) := {ideal_subgroup:>SubgroupR;ideal_isideal::IsIdealideal_subgroup;}.Definitionissig_Ideal(R:Ring) :_<~>IdealR:=ltac:(issig).Definitionideal_op(R:Ring) :IdealR->Ideal(rng_opR):=funI=>Build_Ideal(rng_opR)I_.Coercionideal_op:Ideal>->Ideal.Truncatedness propertiesSectionIdealTrunc.AssumingFunextwe can show that the ideal predicates are propositions.Context`{Funext}.Being a left ideal is a proposition.Global Instanceishprop_isleftideal{R:Ring} (I:SubgroupR):IsHProp(IsLeftIdealI) :=ltac:(unfoldIsLeftIdeal;exact_).Being a right ideal is a proposition.Global Instanceishprop_isrightideal`{Funext} {R:Ring} (I:SubgroupR):IsHProp(IsRightIdealI) :=ishprop_isleftideal_.Being a two-sided ideal is a proposition.Global Instanceishprop_isideal{R:Ring} (I:SubgroupR):IsHProp(IsIdealI):=istrunc_equiv_istrunc_(issig_IsIdealI).AssumingUnivalencewe can show that the ideal types are sets. Note that univalence is only used to prove that the type ofSubgroups is a set.Context`{Univalence}.The type of left ideals is a set.Global Instanceishset_leftideal{R:Ring} :IsHSet(LeftIdealR):=istrunc_equiv_istrunc_(issig_LeftIdealR).The type of right ideals is a set.Global Instanceishset_rightideal{R:Ring} :IsHSet(RightIdealR):=_.The type of ideals is a set.Global Instanceishset_ideal{R:Ring} :IsHSet(IdealR):=istrunc_equiv_istrunc_(issig_IdealR).EndIdealTrunc.Conversion between IdealsEvery ideal is a left ideal.Definitionleftideal_of_ideal{R:Ring} :IdealR->LeftIdealR:=funI=>Build_LeftIdealRI_.Coercionleftideal_of_ideal:Ideal>->LeftIdeal.Every ideal is a right ideal.Definitionrightideal_of_ideal{R:Ring} :IdealR->RightIdealR:=funI=>Build_RightIdealRI_.Coercionrightideal_of_ideal:Ideal>->RightIdeal.Easy properties of idealsHere are some lemmas for proving certain elements are in an ideal. They are just special cases of the underlying subgroup lemmas. We write them out for clarity. Note thatIisn't actually assumed to be an ideal but only a subgroup.SectionIdealElements.Context{R:Ring} (I:SubgroupR) (ab:R).Definitionideal_in_zero:Iring_zero:=subgroup_in_unitI.Definitionideal_in_plus:Ia->Ib->I(a+b) :=subgroup_in_opIab.Definitionideal_in_negate:Ia->I(-a) :=subgroup_in_invIa.Definitionideal_in_negate':I(-a) ->Ia:=subgroup_in_inv'Ia.Definitionideal_in_plus_negate:Ia->Ib->I(a-b) :=subgroup_in_op_invIab.Definitionideal_in_negate_plus:Ia->Ib->I(-a+b) :=subgroup_in_inv_opIab.Definitionideal_in_plus_l:I(a+b) ->Ib->Ia:=subgroup_in_op_lIab.Definitionideal_in_plus_r:I(a+b) ->Ia->Ib:=subgroup_in_op_rIab.EndIdealElements.Constructions of idealsZero IdealThe trivial subgroup is a left ideal.Global Instanceisleftideal_trivial_subgroup(R:Ring):IsLeftIdeal(R:=R)trivial_subgroup.Proof.introsrxp.rhs_Vnrapply(rng_mult_zero_r).f_ap.Defined.The trivial subgroup is a right ideal.Global Instanceisrightideal_trivial_subgroup(R:Ring):IsRightIdeal(R:=R)trivial_subgroup:=isleftideal_trivial_subgroup_.The trivial subgroup is an ideal.Global Instanceisideal_trivial_subgroup(R:Ring):IsIdeal(R:=R)trivial_subgroup:= {}.We call the trivial subgroup the "zero ideal".Definitionideal_zero(R:Ring) :IdealR:=Build_IdealR__.The unit idealThe maximal subgroup is a left ideal.Global Instanceisleftideal_maximal_subgroup(R:Ring):IsLeftIdeal(R:=R)maximal_subgroup:=ltac:(done).The maximal subgroup is a right ideal.Global Instanceisrightideal_maximal_subgroup(R:Ring):IsRightIdeal(R:=R)maximal_subgroup:=isleftideal_maximal_subgroup_.The maximal subgroup is an ideal.Global Instanceisideal_maximal_subgroup(R:Ring):IsIdeal(R:=R)maximal_subgroup:= {}.We call the maximal subgroup the "unit ideal".Definitionideal_unit(R:Ring) :IdealR:=Build_IdealR_(isideal_maximal_subgroupR).Intersection of idealsIntersections of underlying subgroups of left ideals are again left ideals.Global Instanceisleftideal_subgroup_intersection(R:Ring) (IJ:SubgroupR)`{IsLeftIdealRI,IsLeftIdealRJ}:IsLeftIdeal(subgroup_intersectionIJ).Proof.introsrx[ab];split;byapplyisleftideal.Defined.Intersections of underlying subgroups of right ideals are again right ideals.Global Instanceisrightideal_subgroup_intersection(R:Ring) (IJ:SubgroupR)`{IsRightIdealRI,IsRightIdealRJ}:IsRightIdeal(subgroup_intersectionIJ):=isleftideal_subgroup_intersection___.Intersections of underlying subgroups of ideals are again ideals.Global Instanceisideal_subgroup_intersection(R:Ring) (IJ:SubgroupR)`{IsIdealRI,IsIdealRJ}:IsIdeal(subgroup_intersectionIJ):= {}.Intersection of left ideals.Definitionleftideal_intersection{R:Ring}:LeftIdealR->LeftIdealR->LeftIdealR:=funIJ=>Build_LeftIdealR(subgroup_intersectionIJ)_.Intersection of right ideals.Definitionrightideal_intersection{R:Ring}:RightIdealR->RightIdealR->RightIdealR:=leftideal_intersection.Intersection of ideals.Definitionideal_intersection{R:Ring}:IdealR->IdealR->IdealR:=funIJ=>Build_IdealR(subgroup_intersectionIJ)_.Sum of idealsThe subgroup product of left ideals is again an ideal.Global Instanceisleftideal_subgroup_product(R:Ring) (IJ:SubgroupR)`{IsLeftIdealRI,IsLeftIdealRJ}:IsLeftIdeal(subgroup_productIJ).Proof.introsr.nrapplysubgroup_product_ind.-introsxp.applytr,sgt_in.left;byapplyisleftideal.-introsxp.applytr,sgt_in.right;byapplyisleftideal.-applytr,sgt_in.left;applyisleftideal.applyideal_in_zero.-introsxypqIHpIHq;cbnbeta.rewriterng_dist_l.rewriterng_mult_negate_r.byapplysubgroup_in_op_inv.-exact_.Defined.The subgroup product of right ideals is again an ideal.Global Instanceisrightideal_subgroup_product(R:Ring) (IJ:SubgroupR)`{IsRightIdealRI,IsRightIdealRJ}:IsRightIdeal(subgroup_productIJ):=isleftideal_subgroup_product___.The subgroup product of ideals is again an ideal.Global Instanceisideal_subgroup_product(R:Ring) (IJ:SubgroupR)`{IsIdealRI,IsIdealRJ}:IsIdeal(subgroup_productIJ):= {}.Sum of left ideals.Definitionleftideal_sum{R:Ring}:LeftIdealR->LeftIdealR->LeftIdealR:=funIJ=>Build_LeftIdealR(subgroup_productIJ)_.Sum of right ideals.Definitionrightideal_sum{R:Ring}:RightIdealR->RightIdealR->RightIdealR:=leftideal_sum.Sum of ideals.Definitionideal_sum{R:Ring}:IdealR->IdealR->IdealR:=funIJ=>Build_IdealR(subgroup_productIJ)_.Definitionideal_sum_ind{R:Ring} (IJ:IdealR)(P:forallx,ideal_sumIJx->Type)(P_I_in:forallxy,Px(tr(sgt_in(inly))))(P_J_in:forallxy,Px(tr(sgt_in(inry))))(P_unit:Pmon_unit(trsgt_unit))(P_op:forallxyhk,Px(trh) ->Py(trk) ->P(x-y) (tr(sgt_ophk)))`{forallxy,IsHProp(Pxy)}:forallx(p:ideal_sumIJx),Pxp:=subgroup_product_indIJPP_I_inP_J_inP_unitP_op.Product of idealsFirst we form the "naive" product of ideals { a * b | a ∈ I /\ b ∈ J }. Note that this is not an ideal, but we can fix this.Inductiveideal_product_naive_type{R:Ring} (IJ:SubgroupR) :R->Type:=|ipn_in:forallxy,Ix->Jy->ideal_product_naive_typeIJ(x*y).We instead consider the subgroup generated by this naive product and later prove it happens to be an ideal. Note that the subgroup generated by a set and the ideal generated by a set are not the same in general.Definitionideal_product_type{R:Ring} (IJ:SubgroupR) :SubgroupR:=subgroup_generated(G:=R) (ideal_product_naive_typeIJ).The product of left ideals is a left ideal.Global Instanceisleftideal_ideal_product_type{R:Ring} (IJ:SubgroupR)`{IsLeftIdealRI,IsLeftIdealRJ}:IsLeftIdeal(ideal_product_typeIJ).Proof.intror.nrapply(functor_subgroup_generated__(grp_homo_rng_left_multr)).intross[s1s2p1p2];cbn.rewritesimple_associativity.nrefine(ipn_inIJ(r*s1)s2_p2).byapplyisleftideal.Defined.The product of right ideals is a right ideal.Global Instanceisrightideal_ideal_product_type{R:Ring} (IJ:SubgroupR)`{IsRightIdealRI,IsRightIdealRJ}:IsRightIdeal(ideal_product_typeIJ).Proof.intror.nrapply(functor_subgroup_generated__(grp_homo_rng_right_mult(R:=R)r)).intross[s1s2p1p2];cbn.rewrite<-simple_associativity.nrefine(ipn_inIJs1(s2*r)p1_).byapplyisrightideal.Defined.The product of ideals is an ideal.Global Instanceisideal_ideal_product_type{R:Ring} (IJ:SubgroupR)`{IsIdealRI,IsIdealRJ}:IsIdeal(ideal_product_typeIJ):= {}.Product of left ideals.Definitionleftideal_product{R:Ring}:LeftIdealR->LeftIdealR->LeftIdealR:=funIJ=>Build_LeftIdealR(ideal_product_typeIJ)_.Product of right ideals.Definitionrightideal_product{R:Ring}:RightIdealR->RightIdealR->RightIdealR:=leftideal_product.Product of ideals.Definitionideal_product{R:Ring}:IdealR->IdealR->IdealR:=funIJ=>Build_IdealR(ideal_product_typeIJ)_.The kernel of a ring homomorphismThe kernel of the underlying group homomorphism of a ring homomorphism is a left ideal.Global Instanceisleftideal_grp_kernel{RS:Ring} (f:RingHomomorphismRS):IsLeftIdeal(grp_kernelf).Proof.introsrxp.lhsnrapplyrng_homo_mult.rhs_Vnrapply(rng_mult_zero_r(fr)).byapplyap.Defined.The kernel of the underlying group homomorphism of a ring homomorphism is a right ideal.Global Instanceisrightideal_grp_kernel{RS:Ring} (f:RingHomomorphismRS):IsRightIdeal(grp_kernelf):=isleftideal_grp_kernel(fmaprng_opf).The kernel of the underlying group homomorphism of a ring homomorphism is an ideal.Global Instanceisideal_grp_kernel{RS:Ring} (f:RingHomomorphismRS):IsIdeal(grp_kernelf):= {}.The kernel of a ring homomorphism is an ideal.Definitionideal_kernel{RS:Ring} (f:RingHomomorphismRS) :IdealR:=Build_IdealR(grp_kernelf)_.Ideal generated by a subsetIt seems tempting to define ideals generated by a subset in terms of subgroups generated by a subset but this does not work. Left ideals also have to be closed under left multiplciation by ring elements, and similarly for right and two sided ideals. Therefore we will do an analagous construction to the one done in Subgroup.v.Underlying type family of a left ideal generated by subset.Inductiveleftideal_generated_type(R:Ring) (X:R->Type) :R->Type:=It should contain all elements of the original family.|ligt_in(r:R) :Xr->leftideal_generated_typeRXrIt should contain zero.|ligt_zero:leftideal_generated_typeRXring_zeroIt should be closed under negation and addition.|ligt_add_neg(rs:R):leftideal_generated_typeRXr->leftideal_generated_typeRXs->leftideal_generated_typeRX(r-s)And finally, it should be closed under left multiplication.|ligt_mul(rs:R):leftideal_generated_typeRXs->leftideal_generated_typeRX(r*s).Argumentsleftideal_generated_type{R}Xr.Argumentsligt_in{RXr}.Argumentsligt_zero{RX}.Argumentsligt_add_neg{RXrs}.Argumentsligt_mul{RXrs}.Left ideal generated by a subset.Definitionleftideal_generated@{uv} {R:Ring@{u}} (X:R->Type@{v}) :LeftIdeal@{uv}R.Proof.snrapplyBuild_LeftIdeal.-snrapplyBuild_Subgroup'.+exact(funx=>merely(leftideal_generated_typeXx)).+exact_.+applytr,ligt_zero.+introsxypq;strip_truncations.byapplytr,ligt_add_neg.-introsrx;applyTrunc_functor.applyligt_mul.Defined.Right ideal generated by a subset.Definitionrightideal_generated@{uv} {R:Ring@{u}} (X:R->Type@{v}) :RightIdeal@{uv}R:=Build_RightIdealR(leftideal_generated(R:=rng_opR)X)_.Underlying type family of a two-sided ideal generated by subset.Inductiveideal_generated_type(R:Ring) (X:R->Type) :R->Type:=It should contain all elements of the original family.|igt_in(r:R) :Xr->ideal_generated_typeRXrIt should contain zero.|igt_zero:ideal_generated_typeRXring_zeroIt should be closed under negation and addition.|igt_add_neg(rs:R):ideal_generated_typeRXr->ideal_generated_typeRXs->ideal_generated_typeRX(r-s)And finally, it should be closed under left and right multiplication.|igt_mul_l(rs:R):ideal_generated_typeRXs->ideal_generated_typeRX(r*s)|igt_mul_r(rs:R):ideal_generated_typeRXr->ideal_generated_typeRX(r*s).Argumentsideal_generated_type{R}Xr.Argumentsigt_in{RXr}.Argumentsigt_zero{RX}.Argumentsigt_add_neg{RXrs}.Argumentsigt_mul_l{RXrs}.Argumentsigt_mul_r{RXrs}.Two-sided ideal generated by a subset.Definitionideal_generated{R:Ring} (X:R->Type) :IdealR.Proof.snrapplyBuild_Ideal; [|split].-snrapplyBuild_Subgroup'.+exact(funx=>merely(ideal_generated_typeXx)).+exact_.+applytr,igt_zero.+introsxypq;strip_truncations.byapplytr,igt_add_neg.-introsrx;applyTrunc_functor.nrapplyigt_mul_l.-introsxr;applyTrunc_functor.nrapplyigt_mul_r.Defined.Finitely generated idealFinitely generated idealsDefinitionideal_generated_finite{R:Ring} {n:nat} (X:Finn->R) :IdealR.Proof.applyideal_generated.exact(hfiberX).Defined.Principal idealsA principal ideal is an ideal generated by a single element.Definitionideal_principal{R:Ring} (x:R) :IdealR:=ideal_generated(funr=>x=r).Ideal equalityClassically, set based equality suffices for ideals. Since we are talking about predicates, we use pointwise iffs. This can of course be shown to be equivalent to the identity type.Definitionideal_eq{R:Ring} (IJ:SubgroupR) :=forallx,Ix<->Jx.With univalence we can characterize equality of ideals.Lemmaequiv_path_ideal`{Univalence} {R:Ring} {IJ:IdealR} :ideal_eqIJ<~>I=J.Proof.refine((equiv_ap'(issig_IdealR)^-1__)^-1oE_).refine(equiv_path_sigma_hprop__oE_).rapplyequiv_path_subgroup'.Defined.Under funext, ideal equiality is a proposition.Global Instanceishprop_ideal_eq`{Funext} {R:Ring} (IJ:IdealR):IsHProp(ideal_eqIJ) :=_.Ideal equality is reflexive.Global Instancereflexive_ideal_eq{R:Ring} :Reflexive(@ideal_eqR).Proof.introsIx;bysplit.Defined.Ideal equality is symmetric.Global Instancesymmetric_ideal_eq{R:Ring} :Symmetric(@ideal_eqR).Proof.introsIJpx;specialize(px);bysymmetry.Defined.Ideal equality is transitive.Global Instancetransitive_ideal_eq{R:Ring} :Transitive(@ideal_eqR).Proof.introsIJKpqx;specialize(px);specialize(qx);bytransitivity(Jx).Defined.Subset relation on idealsWe define the subset relation on ideals in the usual way:Definitionideal_subset{R:Ring} (IJ:SubgroupR) := (forallx,Ix->Jx).The subset relation is reflexive.Global Instancereflexive_ideal_subset{R:Ring} :Reflexive(@ideal_subsetR):=fun__=>idmap.The subset relation is transitive.Global Instancetransitive_ideal_subset{R:Ring} :Transitive(@ideal_subsetR).Proof.introsxyzpqa.exact(qaopa).Defined.We can coerce equality to the subset relation, since equality is defined to be the subset relation in each direction.Coercionideal_eq_subset{R:Ring} {IJ:SubgroupR} :ideal_eqIJ->ideal_subsetIJ.Proof.introsfx;applyf.Defined.Quotient (a.k.a colon) idealsThe definitions here are not entirely standard, but will become so when considering only commutative rings. For the non-commutative case there isn't a lot written about ideal quotients.The subgroup corresponding to the left ideal quotient.Definitionsubgroup_leftideal_quotient{R:Ring} (IJ:SubgroupR):SubgroupR.Proof.snrapplyBuild_Subgroup'.-exact(funr=>merely(forallx,Jx->I(r*x))).-exact_.-applytr.introsrp.rewriterng_mult_zero_l.applyideal_in_zero.-introsxypq.strip_truncations;applytr.hnf;introssj.rewriterng_dist_r.rewriterng_mult_negate_l.applyideal_in_plus_negate.+byapplyp.+byapplyq.Defined.The left ideal quotient of a left ideal is a left ideal.Global Instanceisleftideal_subgroup_leftideal_quotient{R:Ring}(IJ:SubgroupR) `{IsLeftIdealRI}:IsLeftIdeal(subgroup_leftideal_quotientIJ).Proof.introsrxp.strip_truncations;applytr.introssj.rewrite<-rng_mult_assoc.applyisleftideal.bynrapplyp.Defined.The left ideal quotient of a right ideal by a left ideal is a right ideal.Global Instanceisrightideal_subgroup_leftideal_quotient{R:Ring}(IJ:SubgroupR) `{IsRightIdealRI,IsLeftIdealRJ}:IsRightIdeal(subgroup_leftideal_quotient(R:=R)IJ).Proof.introsrxp.strip_truncations;applytr.introssj.cbnin*.rewrite<-rng_mult_assoc.applyp.byrapplyisleftideal.Defined.We define the left ideal quotient as a left ideal.Definitionleftideal_quotient{R:Ring}:LeftIdealR->SubgroupR->LeftIdealR:=funIJ=>Build_LeftIdealR(subgroup_leftideal_quotientIJ)_.Definitionsubgroup_rightideal_quotient{R:Ring} (IJ:SubgroupR) :SubgroupR:=subgroup_leftideal_quotient(R:=rng_opR)IJ.Global Instanceisrightideal_subgroup_rightideal_quotient{R:Ring}(IJ:SubgroupR) `{IsRightIdealRI}:IsRightIdeal(subgroup_rightideal_quotientIJ):=isleftideal_subgroup_leftideal_quotient(R:=rng_opR)IJ.Global Instanceisleftideal_subgroup_rightideal_quotient{R:Ring}(IJ:SubgroupR) `{H:IsLeftIdealRI,IsRightIdealRJ}:IsLeftIdeal(subgroup_rightideal_quotientIJ).Proof.snrapply(isrightideal_subgroup_leftideal_quotient(R:=rng_opR)IJ).-exactH.-exact_.Defined.We define the right ideal quotient as a right ideal.Definitionrightideal_quotient{R:Ring}:RightIdealR->SubgroupR->RightIdealR:=funIJ=>Build_RightIdealR(subgroup_rightideal_quotient(R:=R)IJ)_.The ideal quotient is then the intersection of a left and right quotient of both two sided ideals.Definitionideal_quotient{R:Ring}:IdealR->IdealR->IdealR:=funIJ=>Build_IdealR(subgroup_intersection(leftideal_quotientIJ)(rightideal_quotientIJ))(Build_IsIdeal____).AnnihilatorThe left annihilator of a subset is the set of elements that annihilate the subgroup with left multiplication.Definitionsubgroup_ideal_left_annihilator{R:Ring} (S:R->Type):SubgroupR.Proof.snrapplyBuild_Subgroup'.If we assumeFunext, then it isn't necessary to usemerelyhere.-exact(funr=>merely(forallx,Sx->r*x=ring_zero)).-exact_.-applytr.introsrp.applyrng_mult_zero_l.-introsxypq.strip_truncations;applytr.introsrs.lhsrapplyrng_dist_r.rewrite(prs).rewriterng_mult_negate_l.rewrite(qrs).rewrite<-rng_mult_negate.rewriterng_mult_zero_r.applyleft_identity.Defined.The left annihilator of a subgroup of a ring is a left ideal of the ring.Global Instanceisleftideal_ideal_left_annihilator{R:Ring} (I:R->Type):IsLeftIdeal(subgroup_ideal_left_annihilatorI).Proof.introsrxp.strip_truncations;applytr.introssi.rewrite<-rng_mult_assoc, (psi).applyrng_mult_zero_r.Defined.The left annihilator of a left ideal also happens to be a right ideal. In fact, left ideal could be weakened to subset closed under multplication, however we don't need this generality currently.Global Instanceisrightideal_ideal_left_annihilator{R:Ring} (I:SubgroupR)`{IsLeftIdealRI}:IsRightIdeal(subgroup_ideal_left_annihilatorI).Proof.introsrxp.strip_truncations;applytr.introssi;cbn.rewrite<-rng_mult_assoc.byapplyp,isleftideal.Defined.Therefore the annihilator of a left ideal is an ideal.Global Instanceisideal_ideal_left_annihilator{R:Ring} (I:SubgroupR)`{IsLeftIdealRI}:IsIdeal(subgroup_ideal_left_annihilatorI):= {}.The left annihilator of a left ideal.Definitionideal_left_annihilator{R:Ring} (I:LeftIdealR) :IdealR:=Build_IdealR(subgroup_ideal_left_annihilatorI)_.The right annihilator of a subset of a ring is the set of elements that annihilate the elements of the subset with right multiplication.Definitionsubgroup_ideal_right_annihilator{R:Ring} (I:R->Type):SubgroupR:=subgroup_ideal_left_annihilator(R:=rng_opR)I.When the subset is a right ideal the right annihilator is a left ideal of the ring. This can be strengthened. See the comment in the left ideal version of this lemma above.Global Instanceisleftideal_ideal_right_annihilator{R:Ring} (I:SubgroupR)`{IsRightIdealRI}:IsLeftIdeal(subgroup_ideal_right_annihilatorI):=isrightideal_ideal_left_annihilator(R:=rng_opR)I.The right annihilator is a right ideal of the ring.Global Instanceisrightideal_ideal_right_annihilator{R:Ring} (I:R->Type):IsRightIdeal(subgroup_ideal_right_annihilator(R:=R)I):=isleftideal_ideal_left_annihilator(R:=rng_opR)I.Therefore the annihilator of a right ideal is an ideal.Global Instanceisideal_ideal_right_annihilator{R:Ring} (I:SubgroupR)`{IsRightIdealRI}:IsIdeal(subgroup_ideal_right_annihilator(R:=R)I):= {}.The right annihilator of a right ideal.Definitionideal_right_annihilator{R:Ring} (I:RightIdealR) :IdealR:=Build_IdealR(subgroup_ideal_right_annihilator(R:=R)I)(isideal_ideal_right_annihilator(R:=R)I).The annihilator of an ideal is the intersection of the left and right annihilators.Definitionideal_annihilator{R:Ring} (I:IdealR) :IdealR:=ideal_intersection(ideal_left_annihilatorI) (ideal_right_annihilatorI).Properties of idealsCoprime idealsTwo ideals are coprime if their sum is the unit ideal.DefinitionCoprime{R:Ring} (IJ:IdealR) :Type:=ideal_eq(ideal_sumIJ) (ideal_unitR).Existing ClassCoprime.Global Instanceishprop_coprime`{Funext} {R:Ring}(IJ:IdealR) :IsHProp(CoprimeIJ).Proof.unfoldCoprime.exact_.Defined.Lemmaequiv_coprime_sum`{Funext} {R:Ring} (IJ:IdealR):CoprimeIJ<~>hexists(fun'(((i;p) , (j;q)) :sigI*sigJ)=>i+j=ring_one).Proof.simpl.srapplyequiv_iff_hprop.-introsc.pose(snd(cring_one)tt)asd;clearbodyd;clearc.strip_truncations.applytr.inductiond.+destructx.*exists((g;s), (ring_zero;ideal_in_zero_)).applyrng_plus_zero_r.*exists((ring_zero;ideal_in_zero_), (g;s)).applyrng_plus_zero_l.+exists((ring_zero;ideal_in_zero_), (ring_zero;ideal_in_zero_)).applyrng_plus_zero_l.+destructIHd1as[[[xxi] [yyj]]p].destructIHd2as[[[wwi] [zzj]]q].srefine(((_;_),(_;_));_).*exact(x-w).*byapplyideal_in_plus_negate.*exact(y-z).*byapplyideal_in_plus_negate.*cbn.refine(_@ap011(funxy=>x-y)pq).rewrite<- 2rng_plus_assoc.f_ap.rewritenegate_sg_op.rewriterng_plus_comm.rewriterng_plus_assoc.reflexivity.-introx.strip_truncations.introsr.split;[intro;exacttt|].intros_.destructxas[[[xxi] [yyj]]p].rewrite<-rng_mult_one_r.change(x+y= 1)inp.rewrite<-p.rewriterng_dist_l.applytr.rapplysgt_op'.+applysgt_in.left.byapplyisleftideal.+applysgt_in.right.byapplyisleftideal.Defined.Ideal notationsWe declare and import a module for various (unicode) ideal notations. These exist in their own special case, and can be imported and used in other files when needing to reason about ideals.ModuleImportNotation.Infix"⊆" :=ideal_subset:ideal_scope.Infix"↔" :=ideal_eq:ideal_scope.Infix"+" :=ideal_sum:ideal_scope.Infix"⋅" :=ideal_product:ideal_scope.Infix"∩" :=ideal_intersection:ideal_scope.Infix"::" :=ideal_quotient:ideal_scope.Notation"〈 X 〉" := (ideal_generatedX)  :ideal_scope.NotationAnn:=ideal_annihilator.EndNotation.Ideal lemmasSectionIdealLemmas.Context{R:Ring}.Subset relation is antisymmetric.Lemmaideal_subset_antisymm(IJ:SubgroupR) :I⊆J->J⊆I->I↔J.Proof.introspqx;split;byrevertx.Defined.The zero ideal is contained in all ideals.Lemmaideal_zero_subset(I:SubgroupR) :ideal_zeroR⊆I.Proof.introsxp;rewritep;applyideal_in_zero.Defined.The unit ideal contains all ideals.Lemmaideal_unit_subset(I:SubgroupR) :I⊆ideal_unitR.Proof.hnf;cbn;trivial.Defined.Intersection includes into the leftLemmaideal_intersection_subset_l(IJ:IdealR) :I∩J⊆I.Proof.intro;exactfst.Defined.Intersection includes into the rightLemmaideal_intersection_subset_r(IJ:IdealR) :I∩J⊆J.Proof.intro;exactsnd.Defined.Subsets of intersectionsLemmaideal_intersection_subset(IJK:IdealR):K⊆I->K⊆J->K⊆I∩J.Proof.introspqxr;specialize(pxr);specialize(qxr);bysplit.Defined.Ideals include into their sum on the leftLemmaideal_sum_subset_l(IJ:IdealR) :I⊆ (I+J).Proof.introsxp.applytr,sgt_in.left;exactp.Defined.Ideals include into their sum on the rightLemmaideal_sum_subset_r(IJ:IdealR) :J⊆ (I+J).Proof.introsxp.applytr,sgt_in.right;exactp.Defined.#[local]HintExtern4 =>progress(cbvbetaiota) :typeclass_instances.Products of ideals are included in their left factorLemmaideal_product_subset_l(IJ:IdealR) :I⋅J⊆I.Proof.introsrp.strip_truncations.inductionpas[ri| |rsp1IHp1p2IHp2].+destructias[st].byrapplyisrightideal.+rapplyideal_in_zero.+byrapplyideal_in_plus_negate.Defined.Products of ideals are included in their right factor.Lemmaideal_product_subset_r(IJ:IdealR) :I⋅J⊆J.Proof.introsrp.strip_truncations.inductionpas[ri| |rsp1IHp1p2IHp2].+destructias[st].byapplyisleftideal.+rapplyideal_in_zero.+byrapplyideal_in_plus_negate.Defined.Products of ideals preserve subsets on the leftLemmaideal_product_subset_pres_l(IJK:IdealR) :I⊆J->I⋅K⊆J⋅K.Proof.introsprq.strip_truncations.inductionqas[ri| |rs].+destructi.applytr,sgt_in,ipn_in.1:applyp.1,2:assumption.+applyideal_in_zero.+byapplyideal_in_plus_negate.Defined.Products of ideals preserve subsets on the rightLemmaideal_product_subset_pres_r(IJK:IdealR) :I⊆J->K⋅I⊆K⋅J.Proof.introsprq.strip_truncations.inductionqas[ri| |rs].+destructi.applytr,sgt_in,ipn_in.2:applyp.1,2:assumption.+applyideal_in_zero.+byapplyideal_in_plus_negate.Defined.TODO:  The product of ideals is an associative operation.(* Lemma ideal_product_assoc (I J K : Ideal R) : I ⋅ (J ⋅ K) ↔ (I ⋅ J) ⋅ K.Proof.intros r; split; apply Trunc_functor.Abort. *)Products of ideals are subsets of their intersection.Lemmaideal_product_subset_intersection(IJ:IdealR) :I⋅J⊆I∩J.Proof.applyideal_intersection_subset.+applyideal_product_subset_l.+applyideal_product_subset_r.Defined.Sums of ideals are the smallest ideal containing the summands.Lemmaideal_sum_smallest(IJK:IdealR) :I⊆K->J⊆K-> (I+J) ⊆K.Proof.introspq.refine(ideal_sum_indIJ(funx_=>Kx)pq__).1:applyideal_in_zero.introsyzst.rapplyideal_in_plus_negate.Defined.Ideals absorb themselves under sum.Lemmaideal_sum_self(I:IdealR) :I+I↔I.Proof.applyideal_subset_antisymm.1:byrapplyideal_sum_smallest.rapplyideal_sum_subset_l.Defined.Sums preserve inclusions in the left summand.Lemmaideal_sum_subset_pres_l(IJK:IdealR) :I⊆J-> (I+K) ⊆ (J+K).Proof.introsp.applyideal_sum_smallest.{transitivityJ.1:exactp.applyideal_sum_subset_l. }applyideal_sum_subset_r.Defined.Sums preserve inclusions in the right summand.Lemmaideal_sum_subset_pres_r(IJK:IdealR) :I⊆J-> (K+I) ⊆ (K+J).Proof.introsp.applyideal_sum_smallest.1:applyideal_sum_subset_l.transitivityJ.1:exactp.applyideal_sum_subset_r.Defined.Products left distribute over sums  Note that this follows from left adjoints preserving colimits. The product of ideals is a functor whose right adjoint is the quotient ideal.Lemmaideal_dist_l(IJK:IdealR) :I⋅ (J+K) ↔I⋅J+I⋅K.Proof.We split into two directions.applyideal_subset_antisymm.We deal with the difficult inclusion first. The proof comes down to breaking down the definition and reassembling into the right.{introsrp.strip_truncations.inductionpas[ri| |rsp1IHp1p2IHp2].-destructias[rspq].strip_truncations.inductionqas[tk| |tkp1IHp1p2IHp2].+applytr,sgt_in.destructkas[j|k].*left;byapplytr,sgt_in,ipn_in.*right;byapplytr,sgt_in,ipn_in.+applytr,sgt_in;left.rewriterng_mult_zero_r.applyideal_in_zero.+rewriterng_dist_l.rewriterng_mult_negate_r.byapplyideal_in_plus_negate.-applyideal_in_zero.-byapplyideal_in_plus_negate. }This is the easy direction which can use previous lemmas.applyideal_sum_smallest.1,2:applyideal_product_subset_pres_r.1:applyideal_sum_subset_l.applyideal_sum_subset_r.Defined.Products distribute over sums on the right.  The proof is very similar to the left versionLemmaideal_dist_r(IJK:IdealR) : (I+J) ⋅K↔I⋅K+J⋅K.Proof.applyideal_subset_antisymm.{introsrp.strip_truncations.inductionpas[ri| |rsp1IHp1p2IHp2].-destructias[rspq].strip_truncations.inductionpas[tk| |tkp1IHp1p2IHp2].+applytr,sgt_in.destructkas[j|k].*left;byapplytr,sgt_in,ipn_in.*right;byapplytr,sgt_in,ipn_in.+applytr,sgt_in;left.rewriterng_mult_zero_l.applyideal_in_zero.+rewriterng_dist_r.rewriterng_mult_negate_l.byapplyideal_in_plus_negate.-applyideal_in_zero.-byapplyideal_in_plus_negate. }applyideal_sum_smallest.1,2:applyideal_product_subset_pres_l.1:applyideal_sum_subset_l.applyideal_sum_subset_r.Defined.Ideal sums are commutativeLemmaideal_sum_comm(IJ:IdealR) :I+J↔J+I.Proof.applyideal_subset_antisymm;applyideal_sum_smallest.1,3:applyideal_sum_subset_r.1,2:applyideal_sum_subset_l.Defined.Zero ideal is left additive identity.Lemmaideal_sum_zero_lI:ideal_zeroR+I↔I.Proof.applyideal_subset_antisymm.1:applyideal_sum_smallest.1:applyideal_zero_subset.1:reflexivity.applyideal_sum_subset_r.Defined.Zero ideal is right additive identity.Lemmaideal_sum_zero_rI:I+ideal_zeroR↔I.Proof.applyideal_subset_antisymm.1:applyideal_sum_smallest.1:reflexivity.1:applyideal_zero_subset.applyideal_sum_subset_l.Defined.Unit ideal is left multiplicative identity.Lemmaideal_product_unit_lI:ideal_unitR⋅I↔I.Proof.applyideal_subset_antisymm.1:applyideal_product_subset_r.introsrp.rewrite<-rng_mult_one_l.byapplytr,sgt_in,ipn_in.Defined.Unit ideal is right multiplicative identity.Lemmaideal_product_unit_rI:I⋅ideal_unitR↔I.Proof.applyideal_subset_antisymm.1:applyideal_product_subset_l.introsrp.rewrite<-rng_mult_one_r.byapplytr,sgt_in,ipn_in.Defined.Intersecting with unit ideal on the left does nothing.Lemmaideal_intresection_unit_lI:ideal_unitR∩I↔I.Proof.applyideal_subset_antisymm.1:applyideal_intersection_subset_r.applyideal_intersection_subset.1:applyideal_unit_subset.reflexivity.Defined.Intersecting with unit ideal on right does nothing.Lemmaideal_intersection_unit_rI:I∩ideal_unitR↔I.Proof.applyideal_subset_antisymm.1:applyideal_intersection_subset_l.applyideal_intersection_subset.1:reflexivity.applyideal_unit_subset.Defined.Product of intersection and sum is subset of sum of productsLemmaideal_product_intersection_sum_subset(IJ:IdealR): (I∩J) ⋅ (I+J) ⊆ (I⋅J+J⋅I).Proof.etransitivity.1:rapplyideal_dist_l.etransitivity.1:rapplyideal_sum_subset_pres_r.1:rapplyideal_product_subset_pres_l.1:applyideal_intersection_subset_l.etransitivity.1:rapplyideal_sum_subset_pres_l.1:rapplyideal_product_subset_pres_l.1:applyideal_intersection_subset_r.rapplyideal_sum_comm.Defined.Ideals are subsets of their ideal quotientsLemmaideal_quotient_subset(IJ:IdealR) :I⊆ (I::J).Proof.introsxi;split;applytr;introsrj;cbn.-byrapplyisrightideal.-byrapplyisleftideal.Defined.If J divides I then the ideal quotient of J by I is trivial.Lemmaideal_quotient_trivial(IJ:IdealR):I⊆J->J::I↔ideal_unitR.Proof.introsp.applyideal_subset_antisymm.1:cbv;trivial.introsr_;split;applytr;introsxq;cbn.-byapplyisleftideal,p.-rapplyisrightideal.byapplyp.Defined.The ideal quotient of I by unit is I.Lemmaideal_quotient_unit_bottom(I:IdealR): (I::ideal_unitR) ↔I.Proof.applyideal_subset_antisymm.-introsr[pq].strip_truncations.rewrite<-rng_mult_one_r.exact(pring_onett).-applyideal_quotient_subset.Defined.The ideal quotient of unit by I is unit.Lemmaideal_quotient_unit_top(I:IdealR): (ideal_unitR::I) ↔ideal_unitR.Proof.split.-cbn;trivial.-intros?;split;applytr;cbn;split;trivial.Defined.The ideal quotient by a sum is an intersection of ideal quotients.Lemmaideal_quotient_sum(IJK:IdealR): (I:: (J+K)) ↔ (I::J) ∩ (I::K).Proof.applyideal_subset_antisymm.{introsr[pq];strip_truncations;split;split;applytr;introsxjk.-byrapplyp;rapplyideal_sum_subset_l.-byrapplyq;rapplyideal_sum_subset_l.-byrapplyp;rapplyideal_sum_subset_r.-byrapplyq;rapplyideal_sum_subset_r. }introsr[[pq] [uv]];strip_truncations;split;applytr;introsxjk;strip_truncations.-inductionjkas[? [] | | ? ? ? ? ? ? ].+byapplyp.+byapplyu.+applyu,ideal_in_zero.+rewriterng_dist_l.rewriterng_mult_negate_r.byapplyideal_in_plus_negate.-inductionjkas[? [] | | ? ? ? ? ? ? ].+byapplyq.+byapplyv.+applyv,ideal_in_zero.+change(I((g-h) *r)).rewriterng_dist_r.rewriterng_mult_negate_l.byapplyideal_in_plus_negate.Defined.Ideal quotients distribute over intersections.Lemmaideal_quotient_intersection(IJK:IdealR): (I∩J::K) ↔ (I::K) ∩ (J::K).Proof.applyideal_subset_antisymm.-introsr[pq];strip_truncations;split;split;applytr;introsxk.1,3:byapplyp.1,2:byapplyq.-introsr[[pq] [uv]].strip_truncations;split;applytr;introsxk;split.+byapplyp.+byapplyu.+byapplyq.+byapplyv.Defined.Annihilators reverse the order of inclusion.Lemmaideal_annihilator_subset(IJ:IdealR) :I⊆J->AnnJ⊆AnnI.Proof.introspx[qq'];hnfinq,q';strip_truncations;split;applytr;introsyi.-byapplyq,p.-byapplyq',p.Defined.The annihilator of an ideal is equal to a quotient of zero.Lemmaideal_annihilator_zero_quotient(I:IdealR):AnnI↔ideal_zeroR::I.Proof.introsx;split.-intros[pq];strip_truncations;split;applytr;introsyi.+exact(pyi).+exact(qyi).-intros[pq];strip_truncations;split;applytr;introsyi.+exact(pyi).+exact(qyi).Defined.EndIdealLemmas.Preimage of ideals under ring homomorphismsThe preimage of an ideal under a ring homomorphism is also itself an ideal. This is also known as the contraction of an ideal.Global Instanceisleftideal_preimage{RS:Ring} (f:R$->S)(I:SubgroupS) `{IsLeftIdealSI}:IsLeftIdeal(subgroup_preimagefI).Proof.introsrxIfx.nrefine(transportI(rng_homo_multf__)^_).rapplyisleftideal.exactIfx.Defined.Global Instanceisrightideal_preimage{RS:Ring} (f:R$->S)(I:SubgroupS) `{IsRightIdealSI}:IsRightIdeal(subgroup_preimagefI):=isleftideal_preimage(R:=rng_opR) (S:=rng_opS)(fmaprng_opf)I.Global Instanceisideal_preimage{RS:Ring} (f:R$->S)(I:SubgroupS) `{IsIdealSI}:IsIdeal(subgroup_preimagefI):= {}.Definitionideal_preimage{RS:Ring} (f:R$->S) (I:IdealS):IdealR:=Build_IdealR(subgroup_preimagefI)_.Extensions of idealsThe extension of an ideal under a ring homomorphism is the ideal generated by the image of the ideal.Definitionideal_extension{RS:Ring} (f:R$->S) (I:IdealR) :IdealS:=ideal_generated(funs=>existsr,Ir/\fr=s).The extension of a preimage is always a subset of the original ideal.Definitionideal_subset_extension_preimage{RS:Ring} (f:R$->S)(I:IdealS):ideal_extensionf(ideal_preimagefI) ⊆I.Proof.introsx.applyTrunc_rec.introsy.inductiony.+destructxas[s[pq]].destructq;exactp.+applyideal_in_zero.+byapplyideal_in_plus_negate.+byrapplyisleftideal.+byrapplyisrightideal.Defined.TODO: Maximal ideals  TODO: Principal ideal  TODO: Prime ideals  TODO: Radical ideals  TODO: Minimal ideals  TODO: Primary ideals

--- Miscellaneous\Idempotent.html ---
IdempotentLibrary IdempotentRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoids.RequireImportBasics.EquivalencesBasics.TruncTypes.SigmaWildCat.Core.RequireImportNat.CoreRings.Ring.Local OpenScopemc_scope.Idempotent elements of ringsDefinitionClassIsIdempotent(R:Ring) (e:R):=rng_idem:e*e=e.Global Instanceishprop_isidempotentRe:IsHProp(IsIdempotentRe).Proof.unfoldIsIdempotent;exact_.Defined.ExamplesZero is idempotent.Global Instanceisidempotent_zero(R:Ring) :IsIdempotentR0:=rng_mult_zero_r0.One is idempotent.Global Instanceisidempotent_one(R:Ring) :IsIdempotentR1:=rng_mult_one_r1.Ifeis idempotent, then1-eis idempotent.Global Instanceisidempotent_complement(R:Ring) (e:R) `{IsIdempotentRe}:IsIdempotentR(1 -e).Proof.unfoldIsIdempotent.rewriterng_dist_l_negate.rewrite2rng_dist_r_negate.rewrite2rng_mult_one_l.rewriterng_mult_one_r.rewriterng_idem.rewriterng_plus_negate_r.rewriterng_negate_zero.nrapplyrng_plus_zero_r.Defined.Ifeis idempotent, then it is also an idempotent element of the opposite ring.Global Instanceisidempotent_op(R:Ring) (e:R) `{i:IsIdempotentRe}:IsIdempotent(rng_opR)e:=i.Any positive power of an idempotent elementeise.Definitionrng_power_idem{R:Ring} (e:R) `{IsIdempotentRe} (n:nat): (1 <=n)%nat->rng_poweren=e.Proof.introsL;inductionL.-snrapplyrng_mult_one_r.-rhs_Vrapplyrng_idem.exact(ap(e*.)IHL).Defined.Ring homomorphisms preserve idempotent elements.Global Instanceisidempotent_rng_homo{RS:Ring} (f:R$->S) (e:R):IsIdempotentRe->IsIdempotentS(fe).Proof.introsp.lhs_Vnrapplyrng_homo_mult.exact(apfp).Defined.Orthogonal idempotent elementsTwo idempotent elementseandfare orthogonal if bothe*f=0andf*e=0.ClassIsOrthogonal(R:Ring) (ef:R)`{!IsIdempotentRe, !IsIdempotentRf} := {rng_idem_orth:e*f= 0 ;rng_idem_orth':f*e= 0 ;}.Definitionissig_IsOrthogonal{R:Ring} {ef:R}`{IsIdempotentRe,IsIdempotentRf}:_<~>IsOrthogonalRef:=ltac:(issig).Global Instanceishprop_isorthogonalRef`{IsIdempotentRe,IsIdempotentRf}:IsHProp(IsOrthogonalRef).Proof.exact(istrunc_equiv_istrunc_issig_IsOrthogonal).Defined.PropertiesTwo idempotents being orthogonal is a symmetric relation.Definitionisorthogonal_swap(R:Ring) (ef:R) `{IsOrthogonalRef}:IsOrthogonalRfe:= {|rng_idem_orth:=rng_idem_orth';rng_idem_orth':=rng_idem_orth|}.Hint Immediateisorthogonal_swap:typeclass_instances.Ifeandfare orthogonal idempotents, then they are also orthogonal idempotents in the opposite ring.Global Instanceisorthogonal_op{R:Ring} (ef:R) `{r:IsOrthogonalRef}:IsOrthogonal(rng_opR)ef.Proof.snrapplyBuild_IsOrthogonal.-exact(rng_idem_orth'(R:=R)).-exact(rng_idem_orth(R:=R)).Defined.Ifeandfare orthogonal idempotents, thene+fis idempotent.Global Instanceisidempotent_plus_orthogonal{R:Ring} (ef:R)`{IsOrthogonalRef}:IsIdempotentR(e+f).Proof.unfoldIsIdempotent.rewriterng_dist_l.rewrite2rng_dist_r.rewrite2rng_idem.rewrite2rng_idem_orth.byrewriterng_plus_zero_r,rng_plus_zero_l.Defined.An idempotent elementeis orthogonal to its complement1-e.Global Instanceisorthogonal_complement{R:Ring} (e:R) `{IsIdempotentRe}:IsOrthogonalRe(1 -e).Proof.snrapplyBuild_IsOrthogonal.1:rewriterng_dist_l_negate,rng_mult_one_r.2:rewriterng_dist_r_negate,rng_mult_one_l.1,2:rewriterng_idem.1,2:applyrng_plus_negate_r.Defined.

--- Miscellaneous\Idempotents.html ---
IdempotentsLibrary IdempotentsRequireImportHoTT.BasicsHoTT.Types.RequireImportHFiberConstant.RequireImportTruncations.CoreModalities.Modality.RequireImportPathAny.Local OpenScopenat_scope.Local OpenScopepath_scope.LocalSetUniverseMinimizationToSet.Idempotents and their splittingsBasic definitionsRetractsA *retract* of a typeXis a typeAequipped with a pair of morphismsr:X->Aands:A->Xsuch that the compositerosis the identity ofA.RecordRetractOf{X:Type} :={retract_type:Type;retract_retr:X->retract_type;retract_sect:retract_type->X;retract_issect:retract_retroretract_sect==idmap}.ArgumentsRetractOfX:clearimplicits.Argumentsretract_type/ .Argumentsretract_retr/ .Argumentsretract_sect/ .Argumentsretract_issect/ .For example, here is the identity retraction.Definitionidmap_retractof(X:Type) :RetractOfX:=Build_RetractOfXXidmapidmap(fun_=> 1).Retractions can be composed with equivalences on either side.Definitionretractof_equiv{XY:Type} (f:X->Y) `{feq:IsEquiv__f}:RetractOfX->RetractOfY.Proof.intros[ArsH];refine(Build_RetractOfYA(rof^-1) (fos)_);introsx.exact(apr(eissectf(sx)) @Hx).Defined.Definitionretractof_equiv'{XY:Type} (f:X<~>Y):RetractOfX->RetractOfY:=retractof_equivf.Definitionequiv_retractof{X:Type} (R:RetractOfX){B:Type} (f:retract_typeR->B) `{feq:IsEquiv__f}:RetractOfX.Proof.destructRas[ArsH];refine(Build_RetractOfXB(for) (sof^-1)_);introsx.exact(apf(H(f^-1x)) @eisretrfx).Defined.Definitionequiv_retractof'{X:Type} (R:RetractOfX){B:Type} (f:retract_typeR<~>B):RetractOfX:=equiv_retractofRf.A commuting retract of the domain of map induces a retract of its fibers.Definitionretractof_hfiber{XY:Type} (R:RetractOfX) (f:X->Y)(g:retract_typeR->Y) (p:goretract_retrR==f)(y:Y):RetractOf(hfiberfy).Proof.destructRas[ArsH];simplin*.simplerefine(Build_RetractOf(hfiberfy) (hfibergy)___).-intros[xq].exists(rx).exact(px@q).-intros[aq].exists(sa).exact((p(sa))^ @apg(Ha) @q).-intros[aq].simplerefine(path_sigma'___).+exact(Ha).+abstract(rewritetransport_paths_Fl, !concat_p_pp,concat_pp_V,concat_Vp,concat_1p;reflexivity).Defined.Retraction preserves contractibilityDefinitioncontr_retracttype{X:Type} (R:RetractOfX) (contra:ContrX) :Contr(retract_typeR):=contr_retract(retract_retrR) (retract_sectR) (retract_issectR).Like any record type,RetractOfXis equivalent to a nested sigma-type.  We use a product at one place in the middle, rather than a sigma, to simplify the next proof.Definitionissig_retractof(X:Type): {A:Type& {r:X->A& {s:A->X&ros==idmap}}}<~>RetractOfX.Proof.issig.Defined.(* Path spaces of types of retractions *)DefinitionPathRetractOf(X:Type) (R'R:RetractOfX):= {Ap:retract_typeR'<~>retract_typeR&{rp:Aporetract_retrR'==retract_retrR&{sp:retract_sectR'oAp^-1 ==retract_sectR&foralla,apAp(retract_issectR'(Ap^-1a))@eisretrApa=rp(retract_sectR'(Ap^-1a))@ap(retract_retrR) (spa)@retract_issectRa} } }.Definitionequiv_path_retractof`{ua:Univalence} {X:Type}(R'R:RetractOfX):PathRetractOfXR'R<~>R'=R.Proof.revertR'R;apply(equiv_path_issig_contr(issig_retractofX)).{intros[A[r[sH]]];cbn.existsequiv_idmap.exists(funx=> 1%path).exists(funx=> 1%path).cbn.exact(funa=>equiv_p1_1q(ap_idmap(Ha))). }intros[A[r[sH]]];cbn.unfoldPathRetractOf.contr_sigsigA(equiv_idmapA);cbn.contr_sigsigr(funx:X=>idpath(rx));cbn.contr_sigsigs(funx:A=>idpath(sx));cbn.refine(contr_equiv'{K:ros==idmap&H==K}_).applyequiv_functor_sigma_id;introsK.applyequiv_functor_forall_id;introsa;cbn.applyequiv_concat_lr.-refine(concat_p1_@ap_idmap(Ha)).-symmetry;applyconcat_1p.Defined.Definitionpath_retractof`{ua:Univalence} {X:Type} {R'R:RetractOfX}AprpspHp:R'=R:=equiv_path_retractofR'R(Ap;rp;sp;Hp).SplittingsIf an endomapf:X->Xarises from a retract assor, we say that that retract is a *splitting* off.Definitionretract_idem{X:Type} (R:RetractOfX): (X->X):=retract_sectRoretract_retrR.Argumentsretract_idem{_}_/x.DefinitionSplitting{X:Type} (f:X->X):= {R:RetractOfX&retract_idemR==f}.For example, here is the canonical splitting of the identity.Definitionsplitting_idmap(X:Type) : @SplittingXidmap:= (idmap_retractofX;fun_=> 1).Pre-idempotentsAn "idempotent" is a map that at least "ought" to be splittable.  The naive definition of idempotent, which is correct in set-level mathematics, is a morphismf:X->Xsuch thatforallx,f(fx)=fx.  We will call this a "pre-idempotent".ClassIsPreIdempotent{X:Type} (f:X->X):=isidem:forallx,f(fx) =fx.Argumentsisidem{X}f{_}x.Definitionispreidem_homotopic{X:Type}(f:X->X) `{IsPreIdempotent_f} {g:X->X} (p:f==g):IsPreIdempotentg.Proof.introsx;refine(_@isidemfx@px).refine(_@ (p(fx))^).applyap;symmetry;applyp.Defined.Argumentsispreidem_homotopic/ .DefinitionPreIdempotent(X:Type) := {f:X->X&IsPreIdempotentf}.Definitionpreidempotent_pr1{X:Type} :PreIdempotentX->X->X:=pr1.Coercionpreidempotent_pr1:PreIdempotent>->Funclass.Global Instanceispreidem_preidem{X:Type} (f:PreIdempotentX):IsPreIdempotentf:=f.2.The identity function has a canonical structure of a pre-idempotent.Global Instanceispreidem_idmap(X:Type) : @IsPreIdempotentXidmap:=fun_=> 1.Definitionpreidem_idmap(X:Type) :PreIdempotentX.Proof.existsidmap;exact_.Defined.Any pre-idempotent on a set splits.Definitionsplit_preidem_set(X:Type) `{IsHSetX} (f:PreIdempotentX):Splittingf.Proof.simplerefine(Build_RetractOfX{x:X&fx=x}(funx=> (fx;isidemfx))pr1_;_).-intros[xp];simpl.applypath_sigmawithp;simpl.applypath_ishprop.-simpl.introsx;reflexivity.Defined.Any weakly constant pre-idempotent splits (Escardo)Definitionsplit_preidem_wconst(X:Type) (f:PreIdempotentX)`{WeaklyConstant__f}:Splittingf.Proof.simplerefine(Build_RetractOfX(FixedByf)(funx=> (fx;isidemfx))pr1_;_).-introsx;applypath_ishprop.-simpl.introsx;reflexivity.Defined.Iffis pre-idempotent andfx=xis collapsible for allx, thenfsplits (Escardo).Definitionsplit_preidem_splitsupp(X:Type) (f:PreIdempotentX)(ss:forallx,Collapsible(fx=x)):Splittingf.Proof.simplerefine(Build_RetractOfX{x:X&FixedBy(@collapse(fx=x)_) }_pr1_;_).-introsx;exists(fx);unfoldFixedBy.exists(collapse(isidemfx)).applywconst.-intros[x[pq]];simpl.applypath_sigmawithp.applypath_ishprop.-simpl.introsx;reflexivity.Defined.Moreover, in this case the section is an embedding.Definitionisemb_split_preidem_splitsupp(X:Type) (f:PreIdempotentX)(ss:forallx,Collapsible(fx=x)):IsEmbedding(retract_sect(split_preidem_splitsuppXfss).1).Proof.applyistruncmap_mapinO_tr;exact_.Defined.Conversely, iffsplits with a section that is an embedding, then (it is pre-idempotent and)fx=xis collapsible for allx(Escardo).Definitionsplitsupp_split_isemb(X:Type) (f:X->X) (S:Splittingf)`{IsEmbedding(retract_sectS.1)}:forallx,Collapsible(fx=x).Proof.introsx.destructSas[[ArsH]K];simplin*.assert(c1:fx=x-> {a:A&sa=x}).{introsp;exists(rx).exact(Kx@p). }assert(c2: {a:A&sa=x} ->fx=x).{intros[aq].exact((Kx)^ @ap(sor)q^ @aps(Ha) @q). }exists(c2oc1).applywconst_through_hprop.Defined.Quasi-idempotentsHowever, homotopically we may naturally expect to need some coherence on the witnessisidemof idempotency.  And indeed, in homotopy theory there are pre-idempotents which do not split; we will see an example later on.  We expect a "coherent idempotent" to involve infinitely many data.  However, Lemma 7.3.5.14 of *Higher Algebra* suggests that for an idempotent to admit *some* coherentification, hence also a splitting, it suffices to have *one* additional datum.  By modifying the construction given there, we can show similarly in type theory that any idempotent satisfying an additional coherence datum splits.  We will call a pre-idempotent with this one additional datum a "quasi-idempotent", since it is related to a fully coherent idempotent similarly to the way having a "quasi-inverse" is related to being a coherent equivalence.ClassIsQuasiIdempotent{X:Type} (f:X->X) `{IsPreIdempotent_f}:=isidem2:forallx,apf(isidemfx) =isidemf(fx).Argumentsisidem2{X}f{__}x.Definitionisqidem_homotopic{X:Type}(f:X->X) `{IsQuasiIdempotent_f} {g:X->X} (p:f==g): @IsQuasiIdempotentXg(ispreidem_homotopicfp).Proof.introsx;unfoldisidem;simpl.OpenScopelong_path_scope.rewrite(concat_Ap(funx=> (px)^) (px)^).rewrite!ap_pp, !concat_pp_p;applywhiskerL.rewrite!concat_p_pp;applymoveL_pM.rewrite(concat_pA_p(funx=> (px)^) (px)).rewrite(concat_pA_p(funx=> (px)^) (isidem_x)).rewrite(concat_Ap(funx=> (px)^) (apf(px)^)).rewrite!concat_pp_p;applywhiskerL.rewrite!ap_V;applymoveR_Vp.rewrite<-ap_compose.rewriteisidem2;tryexact_.symmetry;refine(concat_Ap(isidemf) (px)).CloseScopelong_path_scope.Qed.DefinitionQuasiIdempotent(X:Type) := {f:PreIdempotentX&IsQuasiIdempotentf}.Definitionquasiidempotent_pr1{X:Type} :QuasiIdempotentX->X->X:=pr1.Coercionquasiidempotent_pr1:QuasiIdempotent>->Funclass.Global Instanceisqidem_qidem{X:Type} (f:QuasiIdempotentX):IsQuasiIdempotentf:=f.2.The identity function has a canonical structure of a quasi-idempotent.Global Instanceisqidem_idmap(X:Type) : @IsQuasiIdempotentXidmap_:=fun_=> 1.Definitionqidem_idmap(X:Type) :QuasiIdempotentX.Proof.exists(preidem_idmapX);exact_.Defined.We have madeIsPreIdempotentandIsQuasiIdempotenttypeclasses as an experiment.  It could be that they should revert back toDefinitions.Split morphisms are quasi-idempotentFirst we show that given a retract, the compositesoris quasi-idempotent.Global Instanceispreidem_retract{X:Type} (R:RetractOfX):IsPreIdempotent(retract_idemR).Proof.exact(funx=>ap(retract_sectR) (retract_issectR(retract_retrRx))).Defined.Definitionpreidem_retract{X:Type} (R:RetractOfX):PreIdempotentX:= (retract_idemR;ispreidem_retractR).Argumentsispreidem_retract/ .Argumentspreidem_retract/ .Global Instanceisqidem_retract{X:Type} (R:RetractOfX):IsQuasiIdempotent(retract_idemR).Proof.destructRas[ArsH];introsx;unfoldisidem;simpl.refine((ap_compose___) @_).applyap.refine((ap_compose___)^ @_).refine(cancelR__(H(rx))_).refine(concat_A1pH(H(rx))).Defined.Definitionqidem_retract{X:Type} (R:RetractOfX):QuasiIdempotentX:= (preidem_retractR;isqidem_retractR).In particular, it follows that any split function is quasi-idempotent.Global Instanceispreidem_split{X:Type} (f:X->X) (S:Splittingf):IsPreIdempotentf.Proof.destructSas[Rp].refine(ispreidem_homotopic_p);exact_.Defined.Argumentsispreidem_split/ .Global Instanceisqidem_split{X:Type} (f:X->X) (S:Splittingf): @IsQuasiIdempotentXf(ispreidem_splitfS).Proof.destructSas[Rp].refine(isqidem_homotopic_p);exact_.Defined.Argumentsisqidem_split/ .Quasi-idempotents splitWe now show the converse, that every quasi-idempotent splits.SectionSplitting.We need funext because our construction will involve a sequential limit.  We could probably also use a HIT sequential colimit, which is more like what Lurie does.  (Note that, like an interval type, HIT sequential colimits probably imply funext, so our construction uses strictly weaker hypotheses.)Context`{Funext}.Context{X:Type} (f:X->X).Context`{IsQuasiIdempotent_f}.LetI:=isidemf.LetJ:forallx,apf(Ix) =I(fx):=isidem2f.The splitting will be the sequential limit of the sequence...->X->X->X.Definitionsplit_idem:Type:= {a:nat->X&foralln,f(an.+1) =an}.Definitionsplit_idem_pr1:split_idem-> (nat->X):=pr1.Coercionsplit_idem_pr1:split_idem>->Funclass.Argumentssplit_idem_pr1/ .The section, retraction, and the fact that the composite in one direction isfare easy.Definitionsplit_idem_sect:split_idem->X:=funa=>a0.Argumentssplit_idem_sect/ .Definitionsplit_idem_retr:X->split_idem.Proof.introsx.exists(funn=>fx).exact(funn=>Ix).Defined.Argumentssplit_idem_retr/ .Definitionsplit_idem_splits(x:X):split_idem_sect(split_idem_retrx) =fx:= 1.What remains is to show that the composite in the other direction is the identity.  We begin by showing how to construct paths insplit_idem.Definitionpath_split_idem{aa':split_idem}(p:a.1 ==a'.1)(q:foralln,a.2n@pn=apf(pn.+1) @a'.2n):a=a'.Proof.simplerefine(path_sigma'___).-applypath_arrow;introsn.exact(pn).-applypath_forall;introsn.abstract(rewritetransport_forall_constant;rewritetransport_paths_FlFr;rewriteap_apply_l,ap10_path_arrow;rewrite(ap_compose(funb=>bn.+1) (funx=>fx)_);rewriteap_apply_l,ap10_path_arrow;rewriteconcat_pp_p;applymoveR_Vp;bysymmetry).Defined.And we verify how those paths compute undersplit_idem_sect.Definitionsect_path_split_idem{aa':split_idem}(p:a.1 ==a'.1)(q:foralln,a.2n@pn=apf(pn.+1) @a'.2n):apsplit_idem_sect(path_split_idempq) =p0.Proof.change(ap((funb=>b0)opr1) (path_split_idempq) =p0).refine(ap_composepr1(funb=>b0)_@_).refine(ap(ap(funb=>b0)) (pr1_path_sigma__) @_).refine(ap_apply_l_0 @_).applyap10_path_arrow.Defined.Next we show that every element ofsplit_idemcan be nudged to an equivalent one in which all the elements ofXoccurring are double applications off.Local Definitionnudge(a:split_idem) :split_idem.Proof.exists(funn=>f(f(a(n.+1)))).exact(funn=>apf(apf(a.2n.+1))).Defined.Local Definitionnudge_eqa:nudgea=a.Proof.transparentassert(a':split_idem).{exists(funn=>f(a(n.+1))).exact(funn=>apf(a.2n.+1)). }transitivitya';simplerefine(path_split_idem__);introsn;simpl.-exact(I(an.+1)).-exact((ap_composeff_@@ 1)^@concat_ApI(a.2n.+1)@ (J_@@ 1)^).-exact(a.2n).-reflexivity.Defined.Now we're ready to prove the final condition.  We prove the two arguments ofpath_split_idemseparately, in order to make the first one transparent and the second opaque.Local Definitionsplit_idem_issect_part1(a:split_idem) (n:nat):f(f(an.+1)) =f(a0).Proof.inductionnas[|nIH].-exact(apf(a.2 0)).-exact(apf(a.2n.+1) @ (I(an.+1))^ @IH).Defined.Local Definitionsplit_idem_issect_part2(a:split_idem) (n:nat):apf(apf(a.2n.+1)) @split_idem_issect_part1an=apf((apf(a.2n.+1) @ (I(a.1n.+1))^) @split_idem_issect_part1an) @I(a.1 0).Proof.inductionnas[|nIH];simpl.OpenScopelong_path_scope.-rewrite!ap_pp,ap_V, !concat_pp_p.applywhiskerL,moveL_Vp.rewriteJ.rewrite<-ap_compose;symmetry;apply(concat_ApI).-rewriteap_pp.refine(_@ (1 @@IH) @concat_p_pp___).rewrite!ap_pp, !concat_p_pp,ap_V.rewriteJ.rewrite<- !ap_compose.refine((concat_pA_p(funx=> (Ix)^)__) @@ 1).CloseScopelong_path_scope.Qed.Definitionsplit_idem_issect(a:split_idem):split_idem_retr(split_idem_secta) =a.Proof.refine(_@nudge_eqa);symmetry.simplerefine(path_split_idem__).-exact(split_idem_issect_part1a).-exact(split_idem_issect_part2a).Defined.Definitionsplit_idem_retract:RetractOfX:=Build_RetractOfXsplit_idemsplit_idem_retrsplit_idem_sectsplit_idem_issect.Definitionsplit_idem_split:Splittingf:= (split_idem_retract;split_idem_splits).We end this section by showing that we can recover the witnessIof pre-idempotence from the splitting.Definitionsplit_idem_preidem(x:X):apsplit_idem_sect(split_idem_issect(split_idem_retrx))=Ix.Proof.unfoldsplit_idem_issect,nudge_eq.repeat(rewrite!ap_pp, ?ap_V, !sect_path_split_idem;simpl).applymoveR_Vp,whiskerR;symmetry;applyJ.Qed.However, the particular witnessJof quasi-idempotence can *not* in general be recovered from the splitting; we will mention a counterexample below.  This is analogous to howeissectandeisretrcannot both be recovered afterisequiv_adjointify; one of them has to be modified.EndSplitting.Definitionsplit_idem_retract'`{fs:Funext} {X:Type}:QuasiIdempotentX->RetractOfX:=funf=>split_idem_retractf.Definitionsplit_idem_split'`{fs:Funext} {X:Type}(f:QuasiIdempotentX):Splittingf:=split_idem_splitf.Splitting already-split idempotentsIn the other direction, suppose we are given a retract, we deduce from this a quasi-idempotent, and then split it by the above construction.  We will show that the resulting retract is equivalent to the original one, so thatRetractOfXis itelf a retract ofQuasiIdempotentX.SectionAlreadySplit.Context`{fs:Funext}.Context{X:Type} (R:RetractOfX).LetA:=retract_typeR.Letr:=retract_retrR.Lets:=retract_sectR.LetH:=retract_issectR.We begin by constructing an equivalence betweensplit_idem(sor)andA.  We want to make this equivalence transparent so that we can reason about it later.  In fact, we want to reason not only about the equivalence function and its inverse, but the section and retraction homotopies!  Therefore, instead of usingequiv_adjointifywe will give the coherence proof explicitly, so that we can control these homotopies.  However, we can (and should) make the coherence proof itself opaque.  Thus, we prove it first, and end it withQed.Lemmaequiv_split_idem_retract_isadj(a:split_idem(sor)):H(r(s(r(split_idem_sect(sor)a)))) @H(r(split_idem_sect(sor)a)) =ap(rosplit_idem_sect(sor))(ap(split_idem_retr(sor))(1 @ap(split_idem_sect(sor))(split_idem_issect(sor)a)) @split_idem_issect(sor)a).Proof.rewriteap_pp.rewrite<-ap_compose;simpl.rewriteconcat_1p.rewrite<- (ap_compose(split_idem_sect(sor)) (rosor)(split_idem_issect(sor)a)).rewrite(ap_compose_(rosor) (split_idem_issect(sor)a)).rewrite(ap_compose_r(split_idem_issect(sor)a)).unfoldsplit_idem_issect,nudge_eq;repeat(rewrite!ap_pp, ?ap_V, !sect_path_split_idem;simpl).unfoldisidem;foldrsH.rewrite!concat_pp_p.rewrite<- !ap_compose.rewrite<- (ap_compose(sor)r).rewrite<- (ap_compose(sor) (rosor)).rewrite(concat_p_Vp(ap(rosor) (a.2 0))).rewrite_moveL_Vp_p.rewrite(ap_compose(rosor) (ros) (a.2 0)).rewrite(concat_A1pH(ap(rosor) (a.2 0))).rewrite(ap_composer(ros) (a.2 0)).rewrite(concat_pA1_pH(apr(a.2 0))).applywhiskerR.refine(cancelR__(H(r(a.1 1%nat)))_).rewrite(concat_pA1_pH(H(r(a1%nat)))).rewrite!concat_pp_p;symmetry;refine(_@concat_pp_p___).exact(concat_A1p(funx=>H(r(sx)) @Hx) (H(r(a1%nat)))).Qed.Now we can construct the desired equivalence.Definitionequiv_split_idem_retract:split_idem(sor) <~>A.Proof.simplerefine(Build_Equiv__(rosplit_idem_sect(sor))(Build_IsEquiv___(split_idem_retr(sor)os)___)).-introsa;simpl.refine(H_@H_).-introsa;simpl.refine(_@split_idem_issect(sor)a).applyap.refine((split_idem_splits(sor)_)^ @_).applyap,split_idem_issect;exact_.-introsa;simpl;applyequiv_split_idem_retract_isadj.Defined.It is easy to show that this equivalence respects the section and the retraction.Definitionequiv_split_idem_retract_retr(x:X):equiv_split_idem_retract(split_idem_retr(sor)x) =rx:=H(rx).Definitionequiv_split_idem_retract_sect(a:A):split_idem_sect(sor) (equiv_split_idem_retract^-1a) =sa:=aps(Ha).Less trivial is to show that it respects the retract homotopy.Definitionequiv_split_idem_retract_issect(a:A):apequiv_split_idem_retract(split_idem_issect(sor) (equiv_split_idem_retract^-1a))@eisretrequiv_split_idem_retracta=equiv_split_idem_retract_retr(split_idem_sect(sor) (equiv_split_idem_retract^-1a))@apr(equiv_split_idem_retract_secta)@Ha.Proof.simpl.unfoldequiv_split_idem_retract_retr,equiv_split_idem_retract_sect.rewriteap_compose.unfoldsplit_idem_issect,nudge_eq.repeat(rewrite!ap_pp, ?ap_V, !sect_path_split_idem;simpl).unfoldisidem;foldArsH.OpenScopelong_path_scope.rewrite!concat_pp_p;applymoveR_Vp;rewrite!concat_p_pp.do4rewrite<-ap_compose.For some reason this last one needs help.rewrite<- (ap_compose(soros)r(H(r(sa)))).rewrite<- (ap_pp(ros)__).rewrite<- (concat_A1pH(H(r(sa)))).rewriteap_pp.rewrite<- (ap_compose(ros) (ros)_).rewrite!concat_pp_p;applywhiskerL;rewrite!concat_p_pp.rewrite(concat_A1pH(H(r(sa)))).rewrite!concat_pp_p;applywhiskerL.symmetry;refine(concat_A1pH(Ha)).CloseScopelong_path_scope.Qed.We will also show that it respects the homotopy to the split map.  It's unclear whether this has any use.Definitionequiv_split_idem_retract_splits(x:X):split_idem_splits(sor)x=ap(split_idem_sect(sor))(eissectequiv_split_idem_retract(split_idem_retr(sor)x))^@equiv_split_idem_retract_sect(equiv_split_idem_retract(split_idem_retr(sor)x))@aps(equiv_split_idem_retract_retrx).Proof.simpl.unfoldequiv_split_idem_retract_retr,equiv_split_idem_retract_sect,split_idem_splits.rewriteconcat_1p,concat_pp_p,ap_V;applymoveL_Vp;rewriteconcat_p1.Brace yourself.unfoldsplit_idem_issect,nudge_eq.repeat(rewrite!ap_pp, ?ap_V, !sect_path_split_idem;simpl).Whew, that's not so bad.unfoldisidem;foldArsH.OpenScopelong_path_scope.rewrite!concat_p_pp.rewrite<- !ap_compose;simpl.applywhiskerR.refine(_@ (concat_1p_));applywhiskerR.applymoveR_pV;rewriteconcat_1p,concat_pp_p;applymoveR_Vp.rewrite<- (ap_compose(soros) (sor)).rewrite(ap_compose(ros)s_).rewrite(ap_compose(ros)s_).rewrite(ap_compose(rosoros)s_).rewrite<- !ap_pp;applyap.refine(cancelR__(H(rx))_).rewrite(concat_pA1_pH(H(rx))_).rewrite(concat_pA1_pH(H(rx))_).refine((concat_A1pH(H(r(s(rx)))) @@ 1) @_).rewrite(ap_compose(ros) (ros)_).rewrite(concat_A1pH(ap(ros) (H(rx)))).rewrite!concat_pp_p;applywhiskerL.symmetry;refine(concat_A1pH(H(rx))).CloseScopelong_path_scope.Qed.EndAlreadySplit.Using these facts, we can show thatRetractOfXis a retract ofQuasiIdempotentX.SectionRetractOfRetracts.Context`{ua:Univalence} {X:Type}.Definitionretract_retractof_qidem:RetractOf(QuasiIdempotentX).Proof.refine(Build_RetractOf(QuasiIdempotentX)(RetractOfX)split_idem_retract'qidem_retract_).introsR.exact(@path_retractof__(split_idem_retract'(qidem_retractR))R(equiv_split_idem_retractR)(equiv_split_idem_retract_retrR)(equiv_split_idem_retract_sectR)(equiv_split_idem_retract_issectR)).Defined.We have a similar result for splittings of a fixed mapf.Definitionsplitting_retractof_isqidem(f:X->X):RetractOf{I:IsPreIdempotentf&IsQuasiIdempotentf}.Proof.simplerefine(@equiv_retractof'_(@retractof_equiv'(hfiberquasiidempotent_pr1f)__(retractof_hfiberretract_retractof_qidemquasiidempotent_pr1retract_idem(fun_=> 1)f))(Splittingf)_).-refine((hfiber_fibrationf(fung=> {I:IsPreIdempotentg& @IsQuasiIdempotent_gI}))^-1oE_).unfoldhfiber.refine(equiv_functor_sigma'(equiv_sigma_assoc__)^-1 (funa=>_));simpl.destructaas[[gI]J];unfoldquasiidempotent_pr1;simpl.applyequiv_idmap.-simpl.unfoldhfiber,Splitting.refine(equiv_functor_sigma_id_);introsR;simpl.applyequiv_ap10.Defined.And also for splittings of a fixed map that also induce a given witness of pre-idempotency.DefinitionSplitting_PreIdempotent(f:PreIdempotentX):= {S:Splittingf&forallx,apf(S.2x)^@ (S.2 (retract_idemS.1x))^@ap(retract_sectS.1) (retract_issectS.1 (retract_retrS.1x))@S.2x= (isidemfx) }.Definitionsplitting_preidem_retractof_qidem(f:PreIdempotentX):RetractOf(IsQuasiIdempotentf).Proof.simplerefine(@equiv_retractof'_(@retractof_equiv'(hfiber(@pr1_(funfi=> @IsQuasiIdempotent_fi.1fi.2))f)__(retractof_hfiberretract_retractof_qidempr1preidem_retract_f))(Splitting_PreIdempotentf)_).-symmetry;refine(hfiber_fibrationf_).-intros[[gI]J];simpl.refine(path_sigma'_1_);simpl.applypath_forall;introsx;applysplit_idem_preidem.-simpl;unfoldhfiber,Splitting.refine(equiv_sigma_assoc__oE_).applyequiv_functor_sigma_id;introsR;simpl.refine(_oE(equiv_path_sigma___)^-1);simpl.refine(equiv_functor_sigma'(equiv_ap10__)_);introsH;simpl.destructfas[fI];simplin*.destructH;simpl.refine(_oE(equiv_path_forall__)^-1);unfoldpointwise_paths.applyequiv_functor_forall_id;introsx;simpl.unfoldisidem.applyequiv_concat_l.refine(concat_p1_@concat_1p_).Defined.EndRetractOfRetracts.Fully coherent idempotentsThis gives us a way to define fully coherent idempotents.  By Corollary 4.4.5.14 of *Higher Topos Theory*, if we assume univalence thenRetractOfXhas the correct homotopy type of the type of fully coherent idempotents onX.  However, its defect is that it raises the universe level.  But now that we've shown thatRetractOfXis a retract of the typeQuasiIdempotentX, which is of the same size asX, we can obtain an equivalent type by splitting the resulting idempotent onQuasiIdempotentX.For convenience, we instead split the idempotent on splittings of a fixed mapf, and then sum them up to obtain the type of idempotents.SectionCoherentIdempotents.Context{ua:Univalence}.ClassIsIdempotent{X:Type} (f:X->X):=is_coherent_idem:split_idem(retract_idem(splitting_retractof_isqidemf)).DefinitionBuild_IsIdempotent{X:Type} (f:X->X):Splittingf->IsIdempotentf:= (equiv_split_idem_retract(splitting_retractof_isqidemf))^-1.Definitionisidem_isqidem{X:Type} (f:X->X) `{IsQuasiIdempotent_f}:IsIdempotentf:=Build_IsIdempotentf(split_idem_splitf).Global Instanceispreidem_isidem{X:Type} (f:X->X)`{IsIdempotent_f} :IsPreIdempotentf.Proof.refine(split_idem_sect(retract_idem(splitting_retractof_isqidemf))_).1.assumption.Defined.Global Instanceisqidem_isidem{X:Type} (f:X->X)`{IsIdempotent_f} : @IsQuasiIdempotentXf(ispreidem_isidemf).Proof.refine(split_idem_sect(retract_idem(splitting_retractof_isqidemf))_).2.Defined.DefinitionIdempotent(X:Type) := {f:X->X&IsIdempotentf}.Definitionidempotent_pr1{X:Type} :IdempotentX-> (X->X) :=pr1.Coercionidempotent_pr1:Idempotent>->Funclass.Global Instanceisidem_idem(X:Type) (f:IdempotentX) :IsIdempotentf:=f.2.The above definitions depend onUnivalence.  Technically this is the case by their construction, since they are a splitting of a map that we only know to be idempotent in the presence of univalence.  This map could be defined, and hence "split", without univalence; but also only with univalence do we know that they have the right homotopy type.  Thus univalence is used in two places: concluding (meta-theoretically) from HTT 4.4.5.14 thatRetractOfXhas the right homotopy type, and showing (in the next lemma) that it is equivalent toIdempotentX.  In the absence of univalence, we don't currently have *any* provably-correct definition of the type of coherent idempotents; it ought to involve an infinite tower of coherences as defined in HTT section 4.4.5.   However, there may be some Yoneda-like meta-theoretic argument which would imply that the above-defined types do have the correct homotopy type without univalence (though almost certainly not without funext).Definitionequiv_idempotent_retractof(X:Type):IdempotentX<~>RetractOfX.Proof.transitivity({f:X->X&Splittingf}).-unfoldIdempotent.refine(equiv_functor_sigma'(equiv_idmap_)_);introsf;simpl.refine(equiv_split_idem_retract(splitting_retractof_isqidemf)).-unfoldSplitting.refine(_oEequiv_sigma_symm_).applyequiv_sigma_contr;introsR.applycontr_basedhomotopy.Defined.For instance, here is the standard coherent idempotent structure on the identity map.Global Instanceisidem_idmap(X:Type@{i}): @IsIdempotent@{iij}Xidmap:=Build_IsIdempotentidmap(splitting_idmapX).Definitionidem_idmap(X:Type@{i}) :Idempotent@{iij}X:= (idmap;isidem_idmapX).EndCoherentIdempotents.Quasi-idempotents need not be fully coherentWe have shown that every quasi-idempotent can be "coherentified" into a fully coherent idempotent, analogously to how every quasi-inverse can be coherentified into an equivalence.  However, just as for quasi-inverses, not every witness to quasi-idempotency *is itself* coherent.  This is in contrast to a witness of pre-idempotency, which (if it extends to a quasi-idempotent) can itself be extended to a coherent idempotent; this is roughly the content ofsplit_idem_preidemandsplitting_preidem_retractof_qidem.The key step in showing this is to observe that whenfis the identity, the retract typeSplitting_PreIdempotentfofsplitting_preidem_retractof_qidemis equivalent to the type of types-equivalent-to-X, and hence contractible.Definitioncontr_splitting_preidem_idmap{ua:Univalence} (X:Type):Contr(Splitting_PreIdempotent(preidem_idmapX)).Proof.refine(contr_equiv'{Y:Type&X<~>Y}_).transitivity{S:Splitting(preidem_idmapX) &forallx:X, (retract_issectS.1) (retract_retrS.1x) =ap(retract_retrS.1) (S.2x) }.1:make_equiv.applyequiv_functor_sigma_id;intros[[Yrseta]ep];cbnin*.applyequiv_functor_forall_id;introsx.unfoldispreidem_idmap;simpl.rewriteap_idmap, !concat_pp_p.refine(equiv_moveR_Vp___oE_).rewriteconcat_p1,concat_p_pp.refine(equiv_concat_r(concat_1p_)_oE_).refine(equiv_whiskerR___oE_).refine(equiv_moveR_Vp___oE_).rewriteconcat_p1.pose(isequiv_adjointifysrepeta).refine(_oEequiv_ap(aps)__).applyequiv_concat_r.refine(cancelR__(epx)_).rewrite<-ap_compose.refine(concat_A1pep(epx)).Qed.Therefore, there is a unique coherentification of the canonical witnesspreidem_idmapof pre-idempotency for the identity.  Hence, to show that not every quasi-idempotent is coherent, it suffices to give a witness of quasi-idempotency extendingpreidem_idmapwhich is nontrivial (i.e. not equal toqidem_idmap).  Such a witness is exactly an element of the 2-center, and we know that some types such asBAut(BAutBool)have nontrivial 2-centers.  InSpaces.BAut.Bool.IncoherentIdempotentwe use this to construct an explicit counterexample.A pre-idempotent that is not quasi-idempotentWe can also give a specific example of a pre-idempotent that does not split, hence is not coherentifiable and not even quasi-idempotent.  The construction is inspired by Warning 1.2.4.8 in *Higher Algebra*, and can be found inSpaces.BAut.Cantor.

--- Miscellaneous\Identity.html ---
IdentityLibrary IdentityRequireImportHoTT.BasicsHoTT.Types.RequireImportModalityAccessible.Local OpenScopepath_scope.The identity modalityEverything to say here is fairly trivial.Definitionpurely:Modality.Proof.srapply(Build_Modality(fun_=>Unit)__idmap).1-2,6:intros;exacttt.-intros;assumption.-intros? ? ?fz;exact(fz).-intros;reflexivity.Defined.Global Instanceaccmodality_purely:IsAccModalitypurely.Proof.unshelveeconstructor.-econstructor.exact(@Empty_recType).-introsX;split.+intros_[].+intros;exacttt.Defined.

--- Miscellaneous\IdentityLaws.html ---
IdentityLawsLibrary IdentityLawsLeft and right identity laws of adjunction compositionRequireImportCategory.CoreFunctor.Core.RequireImportAdjoint.Composition.CoreAdjoint.CoreAdjoint.Identity.RequireAdjoint.Composition.LawsTactic.RequireImportTypes.SigmaTypes.Prod.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopeadjunction_scope.Local OpenScopemorphism_scope.Sectionidentity_lemmas.Local NotationAdjunctionWithFunctorsCD:={fg:FunctorCD*FunctorDC|fstfg-|sndfg}.Context`{Funext}.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.VariableA:F-|G.Local OpenScopeadjunction_scope.Lemmaleft_identity: ((_,_); 1oA) = ((_,_);A) :>AdjunctionWithFunctorsCD.Proof.applypath_sigma_uncurried;simpl.(exists(path_prod'(Functor.Composition.Laws.left_identity_)(Functor.Composition.Laws.right_identity_))).Adjoint.Composition.LawsTactic.law_t.Qed.Lemmaright_identity: ((_,_);Ao1) = ((_,_);A) :>AdjunctionWithFunctorsCD.Proof.applypath_sigma_uncurried;simpl.(exists(path_prod'(Functor.Composition.Laws.right_identity_)(Functor.Composition.Laws.left_identity_))).Adjoint.Composition.LawsTactic.law_t.Qed.Endidentity_lemmas.#[export]HintRewrite@left_identity@right_identity:category.#[export]HintImmediateleft_identityright_identity:category.

--- Miscellaneous\IdentityPrinciple.html ---
IdentityPrincipleLibrary IdentityPrincipleThe Structure Identity PrincipleRequireImportCategory.CoreCategory.UnivalentCategory.Morphisms.RequireImportStructure.Core.RequireImportTypes.SigmaTruncEquivalences.RequireImportBasics.IffBasics.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopepath_scope.Local OpenScopecategory_scope.Local OpenScopemorphism_scope.Local OpenScopestructure_scope.Quoting the Homotopy Type Theory Book (with slight changes for
    notational consistency):Theorem (Structure identity principle): IfXis a category and(P,H)is a standard notion of structure overX, then the
    precategoryStr_{(P,H)}(X)is a category.Sectionsip.VariableX:PreCategory.VariableP:NotionOfStructureX.Context`{IsCategoryX}.Context`{@IsStandardNotionOfStructureXP}.LetStrX:= @precategory_of_structuresXP.Definitionsip_isotoid_helper(xayb:StrX)(f:xa<~=~>yb):xa.1 <~=~>yb.1.Proof.exists(PreCategoryOfStructures.f(f:morphism___)).exists(PreCategoryOfStructures.ff^-1).-exact(ap(@PreCategoryOfStructures.f____) (@left_inverse____f)).-exact(ap(@PreCategoryOfStructures.f____) (@right_inverse____f)).Defined.Lemmasip_isotoid_helper_refl(xa:StrX): @sip_isotoid_helperxaxa(reflexivity_) =reflexivity_.Proof.unfoldsip_isotoid_helper,reflexivity,isomorphic_refl.applyap.applypath_ishprop.Defined.Lemmasip_helperxy(p:x=y) (a:Px) (b:Py):transportPpa=b<->is_structure_homomorphismP__(idtoisoXp)ab*is_structure_homomorphismP__(idtoisoXp)^-1ba.Proof.split.-intros;path_induction;split;applyreflexivity.-intros[H0H1];path_induction;simplin*.applyantisymmetry_structure;assumption.Defined.Definitionsip_isotoid(xayb:StrX)(f:xa<~=~>yb):xa=yb.Proof.refine(path_sigma_uncurried___(isotoidXxa.1yb.1(sip_isotoid_helperf);_)).applysip_helper;simpl.split;lazymatchgoalwith| [ |-context[idtoiso?X((isotoid?X?x?y) ?m)] ]=>poseproof(eisretr(@idtoisoXxy)m)asH';pattern(idtoisoX((isotoidXxy)m))end;refine(transport_H'^_);clearH';simpl;applyPreCategoryOfStructures.h.Defined.Lemmasip_isotoid_reflxa: @sip_isotoidxaxa(reflexivity_) =reflexivity_.Proof.refine(_@eta_path_sigma_uncurried_).refine(ap(path_sigma_uncurried___)_).applyequiv_path_sigma_hprop.simpl.refine(_@eisretr(isotoidXxa.1xa.1) 1%path).applyap.applysip_isotoid_helper_refl.Defined.Lemmapath_f_idtoiso_precategory_of_structuresxayb(p:xa=yb):PreCategoryOfStructures.f(idtoiso(precategory_of_structuresP)p:morphism___)=idtoisoXp..1.Proof.inductionp;reflexivity.Defined.Lemmastructure_identity_principle_helper(xayb:StrX)(x:xa<~=~>yb):PreCategoryOfStructures.f(idtoiso(precategory_of_structuresP) (sip_isotoidx) :morphism___)=PreCategoryOfStructures.f(x:morphism___).Proof.refine(path_f_idtoiso_precategory_of_structures_@_).refine((ap_(ap__))@ (ap(@morphism_isomorphic___)(eisretr(@idtoisoXxa.1yb.1) (sip_isotoid_helper_)))).exact(pr1_path_sigma_uncurried_).Defined.Global Instancestructure_identity_principle:IsCategory(precategory_of_structuresP).Proof.introsxayb.refine(isequiv_adjointify_(@sip_isotoidxayb)__);intro;simplin*.-abstract(applypath_isomorphic;simpl;applyPreCategoryOfStructures.path_morphism;applystructure_identity_principle_helper).-abstract(inductionx;applysip_isotoid_refl).Defined.Endsip.

--- Miscellaneous\Iff.html ---
IffLibrary IffRequireImportBasics.OvertureBasics.Tactics.LocalSetUniverseMinimizationToSet.If and only ifDefinitioniffAB, writtenA<->B, expresses the logical equivalence ofAandBDefinitioniff(AB:Type) :=prod(A->B) (B->A).Notation"A <-> B" := (iffAB) :type_scope.Basic PropertiesEverything is logically equivlaent to itself.Definitioniff_refl{A} :A<->A:= (idmap,idmap).iffis a reflexive relation.Global Instanceiff_reflexive:Reflexiveiff| 1:= @iff_refl.Logical equivalences can be inverted.Definitioniff_inverse{AB} : (A<->B) -> (B<->A):=funf=> (sndf,fstf).iffis a symmetric relation.Global Instancesymmetric_iff:Symmetriciff| 1:= @iff_inverse.Logical equivalences can be composed.Definitioniff_compose{ABC} (f:A<->B) (g:B<->C) :A<->C:= (fstgofstf,sndfosndg).iffis a transitive relation.Global Instancetransitive_iff:Transitiveiff| 1:= @iff_compose.Any equivalence can be considered a logical equivalence by discarding everything but the maps. We make this a coercion so that equivalences can be used in place of logical equivalences.Coercioniff_equiv{AB:Type} (f:A<~>B):A<->B:= (equiv_funf,f^-1).Logical LawsOne of De Morgan's Laws.  The dual statement about negating a product appears in Decidable.v due to decidability requirements.Definitioniff_not_sumAB: ~ (A+B) <-> ~A* ~B.Proof.split.-introsns.exact(nsoinl,nsoinr).-byintros[];snrapplysum_ind.Defined.Definitioniff_contradictionA:A* ~A<->Empty.Proof.split.-intros[ana];exact(naa).-introse;exact(Empty_rec_e).Defined.

--- Miscellaneous\Image.html ---
ImageLibrary ImageRequireImportBasicsTypes.RequireImportTruncations.Core.RequireImportAlgebra.Groups.Group.RequireImportAlgebra.Groups.Subgroup.RequireImportWildCat.Core.RequireImportHSet.Image of group homomorphismsLocal OpenScopemc_scope.Local OpenScopemc_mult_scope.The image of a group homomorphism between groups is a subgroupDefinitiongrp_image{AB:Group} (f:A$->B) :SubgroupB.Proof.snrapply(Build_Subgroup'(funb=>hexists(funa=>fa=b))).-exact_.-applytr.existsmon_unit.applygrp_homo_unit.-introsxypq;strip_truncations;applytr.destructpas[ap],qas[bq].exists(a* -b).lhsnrapplygrp_homo_op;f_ap.lhsnrapplygrp_homo_inv;f_ap.Defined.Definitiongrp_image_in{AB:Group} (f:A$->B) :A$->grp_imagef.Proof.snrapplyBuild_GroupHomomorphism.{introx.exists(fx).srapplytr.existsx.reflexivity. }cbn.grp_auto.Defined.When the homomorphism is an embedding, we don't need to truncate.Definitiongrp_image_embedding{AB:Group} (f:A$->B) `{IsEmbeddingf} :SubgroupB.Proof.snrapply(Build_Subgroup_(hfiberf)).repeatsplit.-exact_.-exact(mon_unit;grp_homo_unitf).-introsxy[a[]] [b[]].exists(a*b).applygrp_homo_op.-introsb[a[]].exists(-a).applygrp_homo_inv.Defined.Definitiongrp_image_in_embedding{AB:Group} (f:A$->B) `{IsEmbeddingf}:GroupIsomorphismA(grp_image_embeddingf).Proof.snrapplyBuild_GroupIsomorphism.-snrapplyBuild_GroupHomomorphism.+introx.exists(fx).existsx.reflexivity.+cbn;grp_auto.-applyisequiv_surj_emb.2:apply(cancelL_isembedding(g:=pr1)).intros[b[ap]];cbn.rapplycontr_inhabited_hprop.refine(tr(a;_)).srapplypath_sigma'.1:exactp.refine(transport_sigma'__@_).byapplypath_sigma_hprop.Defined.

--- Miscellaneous\ImpredicativeTruncation.html ---
ImpredicativeTruncationLibrary ImpredicativeTruncationImpredicative truncationsIn this file, under the assumptions of propositional resizingPropResizingand function extensionalityFunext, we define the proposition truncation in any universe. In the main library, these are constructed using HITs. The definitions here are meant to be for illustration.RequireImportHoTT.Basics.RequireImportUniverses.Smallness.Local OpenScopepath_scope.Using only function extensionality, we can define a "propositional truncation"TrmAof a typeAin universeiwhich eliminates into propositions in universej.  It lands inmax(i,j+1).  So if we want it to land in universei, then we can only eliminate into propositions in a strictly smaller universej.  Or, if we want it to eliminate into propositions in universei, then it must land in a strictly larger universe.DefinitionTrm@{ij| } (A:Type@{i}):=forallP:Type@{j},IsHPropP-> (A->P) ->P.Definitiontrm@{ij| } {A:Type@{i}} :A->Trm@{ij}A:=funaPHPf=>fa.Herekplays the role ofmax(i,j+1).Global Instanceishprop_Trm@{ijk|i<=k,j<k} `{Funext} (A:Type@{i}):IsHProp(Trm@{ij}A).Proof.nrapplyistrunc_forall@{kkk};introB.nrapplyistrunc_forall@{jkk};introishp.applyistrunc_forall@{kjk}.Defined.As mentioned above, it eliminates into propositions in universej.DefinitionTrm_rec@{ij| } {A:Type@{i}}{P:Type@{j}} {p:IsHProp@{j}P} (f:A->P):Trm@{ij}A->P:=funma=>maPpf.This computes definitionally.DefinitionTrm_rec_beta@{ij| } {A:Type@{i}}{P:Type@{j}} `{IsHPropP} (f:A->P):Trm_rec@{ij}fotrm==f:=fun_=>idpath.Because of the universe constraints, we can't make this into a functor onType@{i}.  We have a universe constrainti'<=jandTrm@{ij}Alands inmax(i,j+1), which is strictly larger.Definitionfunctor_Trm@{iji'j'|i'<=j,j'<j} `{Funext}{A:Type@{i}} {A':Type@{i'}} (f:A->A'):Trm@{ij}A->Trm@{i'j'}A':=Trm_rec(trmof).We also record the dependent induction principle.  But it only computes propositionally.DefinitionTrm_ind@{ijk|i<=k,j<k} {A:Type@{i}} `{Funext}{P:Trm@{ij}A->Type@{j}} {p:forallx,IsHProp@{j} (Px)} (f:foralla,P(trma)):forallx,Px.Proof.unfoldTrm.introx.rapplyx.introa.refine(transportP_(fa)).rapplypath_ishprop@{k}.Defined.The universe constraints go away if we assume propositional resizing.SectionAssumePropResizing.Context`{PropResizing}.If we assume propositions resizing, then we may as well quantify over propositions in the lowest universeSetwhen defining the truncation.  This reduces the number of universe variables.  We also assume thatSet<i, so that the construction lands in universei.Definitionimp_Trm@{i|Set<i} (A:Type@{i}) :Type@{i}:=Trm@{iSet}A.Here we use propositional resizing to resize a arbitrary propositionPfrom an arbitrary universejto universeSet, so there is no constraint on the universej.  In particular, we can takej=i, which shows thatimp_Trmis a reflective subuniverse ofType@{i}, since any two maps into a proposition agree.Definitionimp_Trm_rec@{ij|Set<i} {A:Type@{i}}{P:Type@{j}} `{IsHPropP} (f:A->P):imp_Trm@{i}A->P:=funma=> (equiv_smalltype@{Setj}P)(ma(smalltype@{Setj}P)_((equiv_smalltype@{Setj}P)^-1of)).Similarly, there are no constraints betweeniandi'in the next definition, so they could be taken to be equal.Definitionfunctor_imp_Trm@{ii'|Set<i,Set<i'} `{Funext}{A:Type@{i}} {A':Type@{i'}} (f:A->A'):imp_Trm@{i}A->imp_Trm@{i'}A':=imp_Trm_rec(trmof).Note thatimp_Trm_reconly computes propositionally.Definitionimp_Trm_rec_beta@{ij|Set<i} {A:Type@{i}}{P:Type@{j}} `{IsHPropP} (f:A->P):imp_Trm_rec@{ij}fotrm==f.Proof.introa.unfoldimp_Trm_rec,trm;cbnbeta.applyeisretr@{Setj}.Defined.EndAssumePropResizing.Above, we needed the constraintSet<i.  But one can use propositional resizing again to makeimp_Trmland in the lowest universe, if that is needed.  (We'll in fact let it land in any universeu.)  To do this, we need to assumeFunextin the definition of the truncation itself.SectionTruncationWithFunext.Context`{PropResizing} `{Funext}.Funextimplies thatTrmAis a proposition, soPropResizingcan be used to put it in any universe. The construction passes through universek, which representsmax(i,Set+1).Definitionresized_Trm@{iku|i<=k,Set<k} (A:Type@{i}):Type@{u}:=smalltype@{uk} (Trm@{iSet}A).Definitionresized_trm@{iku|i<=k,Set<k} {A:Type@{i}}:A->resized_Trm@{iku}A:= (equiv_smalltype_)^-1otrm.Definitionresized_Trm_rec@{ijku|i<=k,Set<k} {A:Type@{i}}{P:Type@{j}} `{IsHPropP} (f:A->P):resized_Trm@{iku}A->P.Proof.refine(_o(equiv_smalltype@{uk}_)).exact(funma=> (equiv_smalltype@{Setj}P)(ma(smalltype@{Setj}P)_((equiv_smalltype@{Setj}P)^-1of))).Defined.The beta rule is again propositional.Definitionresized_Trm_rec_beta@{ijku|i<=k,Set<k} {A:Type@{i}}{P:Type@{j}} `{IsHPropP} (f:A->P):resized_Trm_rec@{ijku}foresized_trm==f.Proof.introa.unfoldresized_Trm_rec,resized_trm,Trm,trm;cbnbeta.rewriteeisretr@{uk}.applyeisretr@{Setj}.Defined.EndTruncationWithFunext.

--- Miscellaneous\IncoherentIdempotent.html ---
IncoherentIdempotentLibrary IncoherentIdempotentRequireImportHoTT.BasicsHoTT.Types.RequireImportEquiv.BiInvIdempotents.RequireImportUniverses.BAutSpaces.BAut.Bool.Local OpenScopepath_scope.An incoherent quasi-idempotent onBAut(BAutBool).SectionIncoherentQuasiIdempotent.Context`{Univalence}.We use the identity map, and the nontrivial 2-central element ofBAut(BAutBool).Definitionnontrivial_qidem_baut_baut_bool:IsQuasiIdempotent(preidem_idmap(BAut(BAutBool))):=negb_center2_baut_baut_bool.Letret:=splitting_preidem_retractof_qidem(preidem_idmap(BAut(BAutBool))).Lets:=retract_sectret.Letr:=retract_retrret.Letissect:=retract_issectret:ros==idmap.Since the space of splittings of the identity pre-idempotent is contractible, nontriviality of this 2-central element implies that not every quasi-idempotence witness of the identity is recoverable from its own splitting.Definitionsplitting_preidem_notequiv_qidem_baut_baut_bool: ~ (sor==idmap).Proof.introsoops.assert(p:=oopsnontrivial_qidem_baut_baut_bool).assert(q:=oops(isqidem_idmap(BAut(BAutBool))));clearoops.applynontrivial_negb_center_baut_baut_bool.refine(p^ @aps_@q).pose(contr_splitting_preidem_idmap(BAut(BAutBool))).applypath_contr.Defined.Therefore, not every quasi-idempotence witness is obtainable from *any* splitting, i.e. it may not have any coherentification.Definitionnot_all_coherent_qidem_baut_baut_bool: ~ (forallq:IsQuasiIdempotent(preidem_idmap(BAut(BAutBool))),{S:Splitting_PreIdempotent(preidem_idmap_) &sS=q}).Proof.introsoops.assert(IsEquivs).{applyisequiv_biinv;split.-existsr;exactissect.-exists(funq=> (oopsq).1).exact(funq=> (oopsq).2). }applysplitting_preidem_notequiv_qidem_baut_baut_bool;introsq.refine(aps(apr(eisretrsq)^) @_).refine(aps(issect(s^-1q)) @_).applyeisretr.Defined.These results show only that not *every* quasi-idempotence witness is coherent.  "Clearly" the nontrivial quasi-idempotence witnessnontrivial_qidem_baut_baut_boolshould be the one that is not coherent.  To show this, we would probably need to show thatisqidem_idmap*is* in the image ofs, and this seems rather annoying to do based on our construction ofsplitting_preidem_retractof_qidem.EndIncoherentQuasiIdempotent.

--- Miscellaneous\index.html ---
IndexGlobal IndexABCDEFGHIJKLMNOPQRSTUVWXYZ_other(571 entries)Library IndexABCDEFGHIJKLMNOPQRSTUVWXYZ_other(571 entries)Global IndexAAbelianGroup[library]Abelianization[library]AbGroups[library]AbHom[library]AbProjective[library]AbPullback[library]AbPushout[library]AbSES[library]abstract_algebra[library]AC[library]Accessible[library]Addition[library]additional_operations[library]Adjoint[library]Adjoint[library]Algebra[library]apartness[library]archimedean[library]archimedean[library]Arithmetic[library]Arrow[library]AssociativityLaw[library]assume_rationals[library]Attributes[library]Attributes[library]Aut[library]Automorphisms[library]BBaerSum[library]Basics[library]BAut[library]Bifunctor[library]BiInv[library]binary_naturals[library]BinderApply[library]BinInt[library]Binomial[library]Biproduct[library]BlakersMassey[library]bool[library]Bool[library]Bool[library]BoundedSearch[library]Bouquet[library]Ccanonical_names[library]Cantor[library]Cantor[library]Card[library]Cat[library]Categories[library]Category[library]CategoryOfGroupoids[library]CategoryOfSections[library]cauchy[library]CayleyDickson[library]Centralizer[library]ChainCategory[library]ChineseRemainder[library]Choice[library]Circle[library]Classes[library]ClassifyingSpace[library]Closed[library]Cocone[library]Coeq[library]CoeqUnivProp[library]Coherent[library]Colimit[library]Colimit_Flattening[library]Colimit_Prod[library]Colimit_Sigma[library]Colimit_Pushout_Flattening[library]Colimit_Coequalizer[library]Colimit_Pushout[library]Comma[library]CommutativeSquares[library]Composition[library]Composition[library]Composition[library]Cone[library]Congruence[library]Congruence[library]Connectedness[library]Constant[library]ConstantDiagram[library]Contractible[library]Coproducts[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]Core[library]CoreflectiveSubuniverse[library]CoreLaws[library]CoreParts[library]Cover[library]CRing[library]Cyclic[library]DDDiagram[library]Decidable[library]Decimal[library]dec_fields[library]dec_fields[library]DependentProduct[library]Descent[library]Diagram[library]DirectSum[library]DiscreteCategory[library]Displayed[library]DisplayedEquiv[library]Division[library]DPath[library]DPathCube[library]DPathSquare[library]DProp[library]Dual[library]Dual[library]Dual[library]Dual[library]Dual[library]Dual[library]Dual[library]DualFunctor[library]EEmpty[library]EmptyCat[library]EMSpace[library]EncodeDecode[library]epi[library]Equalizer[library]Equiv[library]Equiv[library]Equiv[library]EquivalenceInduction[library]Equivalences[library]EquivGpd[library]EquivGroupoids[library]EvalIn[library]EvaluationFibration[library]ExactSequence[library]ExcludedMiddle[library]ExponentialLaws[library]Ext[library]Extensions[library]FFactorial[library]Factorization[library]family_prod[library]fields[library]fields[library]field_of_fractions[library]Fin[library]FinInduction[library]Finite[library]Finite[library]FiniteSum[library]FinNat[library]FinSeq[library]Flattening[library]Forall[library]Forall[library]Fracture[library]FreeAbelianGroup[library]FreeGroup[library]FreeInt[library]FreeIntQuotient[library]FreeProduct[library]Freudenthal[library]FromFunctor[library]Full[library]Functor[library]FunctorCat[library]FunctorCategory[library]Functorial[library]Functorial[library]Functorial[library]Functorial[library]Functorial[library]Functorial[library]Functorish[library]Functors[library]Functors[library]Functors[library]Functors[library]Functors[library]Functors[library]Functors[library]Functors[library]FundamentalPreGroupoidCategory[library]Funext[library]FunextVarieties[library]GGCH[library]GCHtoAC[library]Graph[library]GraphQuotient[library]Grothendieck[library]Group[library]GroupCoeq[library]GroupoidCategory[library]Groups[library]groups[library]GrpPullback[library]HHartogs[library]Hexadecimal[library]HFiber[library]Hom[library]HomCoercions[library]HomFunctor[library]Homomorphism[library]HomotopyGroup[library]HomotopyPreCategory[library]Hopf[library]HoTT[library]HProp[library]hprop_lattice[library]HSet[library]HSpace[library]HSpaceS1[library]IIdeal[library]Idempotent[library]Idempotents[library]Identity[library]Identity[library]Identity[library]Identity[library]Identity[library]Identity[library]IdentityLaws[library]IdentityPrinciple[library]Iff[library]Image[library]ImpredicativeTruncation[library]IncoherentIdempotent[library]IndiscreteCategory[library]Induced[library]InducedFunctors[library]InitialTerminalCategory[library]Int[library]integers[library]integers[library]integers[library]Interval[library]IntervalImpliesFunext[library]int_abs[library]iso[library]Isomorphisms[library]IWType[library]JJoin[library]JoinAssoc[library]JoinSusp[library]KKanExtensions[library]Kernel[library]KroneckerDelta[library]LLagrange[library]lattices[library]lattices[library]Law[library]Law[library]Law[library]Law[library]Laws[library]Laws[library]Laws[library]LawsTactic[library]Law0[library]Law1[library]Law2[library]Law3[library]Law4[library]LaxComma[library]Lex[library]Limit[library]Limits[library]Localization[library]Localization[library]Locator[library]LoopExp[library]Loops[library]MMappingCylinder[library]maps[library]Matrix[library]Meet[library]Misc[library]Modality[library]Module[library]Moduli[library]monad[library]Monoid[library]Monoidal[library]MonoidalCategory[library]MonoidalTwistConstruction[library]MonoidObject[library]Morphisms[library]Morphisms[library]Morphisms[library]Morphisms[library]Morphisms[library]Morphisms[library]NNameless[library]Nat[library]Nat[library]Nat[library]NatCategory[library]natpair_integers[library]NatTrans[library]naturals[library]naturals[library]naturals[library]NaturalTransformation[library]NaturalTransformations[library]nat_distance[library]nat_int[library]Negation[library]ne_list[library]No[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notations[library]Notnot[library]NullHomotopy[library]Nullification[library]Numeral[library]OObjectClassifier[library]Objects[library]OnMorphisms[library]OnObjects[library]ooAction[library]ooGroup[library]Open[library]Operation[library]Opposite[library]Option[library]orders[library]orders[library]Ordinals[library]Overture[library]PParallelPair[library]Parts[library]PathAny[library]PathCube[library]PathGroupoids[library]Paths[library]Paths[library]Paths[library]Paths[library]Paths[library]Paths[library]Paths[library]Paths[library]PathSplit[library]PathSquare[library]peano_naturals[library]pEquiv[library]pFiber[library]Pi[library]PinSn[library]pMap[library]pModality[library]Pointed[library]PointedCat[library]Pointwise[library]Pointwise[library]Pointwise[library]Pointwise[library]pointwise[library]Pos[library]Powers[library]premetric[library]Presentation[library]Prod[library]Prod[library]Prod[library]Prod[library]Prod[library]ProductLaws[library]Products[library]Profunctor[library]Projection[library]ProjectionFunctors[library]Projective[library]Properties[library]PropResizing[library]PropTrunc[library]pSect[library]Pseudofunctor[library]Pseudofunctors[library]PseudofunctorToCat[library]PseudonaturalTransformation[library]pSusp[library]pTrunc[library]Pullback[library]Pullback[library]PullbackFiberSequence[library]Pushout[library]Pushout[library]Qquotient[library]Quotient[library]QuotientGroup[library]QuotientRing[library]Rrationals[library]rationals[library]ReflectiveSubuniverse[library]Relational[library]Representable[library]RewriteLaws[library]RewriteModuloAssociativity[library]Rigid[library]Ring[library]Rings[library]rings[library]rings[library]rings[library]ring_quote[library]ring_tac[library]ring_pol[library]round[library]Ssemirings[library]SemiSimplicialSets[library]Separated[library]SeparatedTrunc[library]Sequence[library]Sequential[library]SetCategory[library]SetCone[library]SetProp[library]Settings[library]ShortExactSequence[library]Sigma[library]Sigma[library]Sigma[library]SimplicialSets[library]SixTerm[library]Smallness[library]Smash[library]Span[library]SpanPushout[library]Spec[library]Spec[library]Spectrum[library]Spheres[library]Square[library]Strict[library]Structure[library]Subcategory[library]Subgroup[library]SuccessorStructure[library]Sum[library]Sum[library]Sum[library]Sum[library]Sum[library]sum[library]surjective_factor[library]Suspension[library]Syllepsis[library]TTactics[library]Tactics[library]Tactics[library]Tactics[library]TensorProduct[library]TermAlgebra[library]Theory[library]ToCat[library]Topological[library]Torus[library]TorusEquivCircles[library]TorusHomotopy[library]ToSet[library]TriJoin[library]Trunc[library]Truncations[library]TruncImpliesFunext[library]TruncType[library]TwoOneCat[library]TwoSphere[library]Types[library]Uua_prod_algebra[library]ua_algebra[library]ua_subalgebra[library]ua_quotient_algebra[library]ua_isomorphic[library]ua_setalgebra[library]ua_first_isomorphism[library]ua_congruence[library]ua_third_isomorphism[library]ua_homomorphism[library]ua_second_isomorphism[library]ua_category[library]unique_choice[library]Unit[library]UnitCat[library]UnitCounit[library]UnitCounitCoercions[library]Univalence[library]UnivalenceImpliesFunext[library]UnivalenceVarieties[library]Univalent[library]Univalent[library]Univalent[library]Universal[library]UniversalMorphisms[library]UniversalProperties[library]Universe[library]Universe[library]UniverseLevel[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8[library]Utf8Minimal[library]VV[library]Vector[library]WWedge[library]WhiteheadsPrinciple[library]Wide[library]WildCat[library]WType[library]YYoneda[library]Yoneda[library]ZZ[library]Z[library]ZeroGroupoid[library]Library IndexAAbelianGroupAbelianizationAbGroupsAbHomAbProjectiveAbPullbackAbPushoutAbSESabstract_algebraACAccessibleAdditionadditional_operationsAdjointAdjointAlgebraapartnessarchimedeanarchimedeanArithmeticArrowAssociativityLawassume_rationalsAttributesAttributesAutAutomorphismsBBaerSumBasicsBAutBifunctorBiInvbinary_naturalsBinderApplyBinIntBinomialBiproductBlakersMasseyboolBoolBoolBoundedSearchBouquetCcanonical_namesCantorCantorCardCatCategoriesCategoryCategoryOfGroupoidsCategoryOfSectionscauchyCayleyDicksonCentralizerChainCategoryChineseRemainderChoiceCircleClassesClassifyingSpaceClosedCoconeCoeqCoeqUnivPropCoherentColimitColimit_FlatteningColimit_ProdColimit_SigmaColimit_Pushout_FlatteningColimit_CoequalizerColimit_PushoutCommaCommutativeSquaresCompositionCompositionCompositionConeCongruenceCongruenceConnectednessConstantConstantDiagramContractibleCoproductsCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreCoreflectiveSubuniverseCoreLawsCorePartsCoverCRingCyclicDDDiagramDecidableDecimaldec_fieldsdec_fieldsDependentProductDescentDiagramDirectSumDiscreteCategoryDisplayedDisplayedEquivDivisionDPathDPathCubeDPathSquareDPropDualDualDualDualDualDualDualDualFunctorEEmptyEmptyCatEMSpaceEncodeDecodeepiEqualizerEquivEquivEquivEquivalenceInductionEquivalencesEquivGpdEquivGroupoidsEvalInEvaluationFibrationExactSequenceExcludedMiddleExponentialLawsExtExtensionsFFactorialFactorizationfamily_prodfieldsfieldsfield_of_fractionsFinFinInductionFiniteFiniteFiniteSumFinNatFinSeqFlatteningForallForallFractureFreeAbelianGroupFreeGroupFreeIntFreeIntQuotientFreeProductFreudenthalFromFunctorFullFunctorFunctorCatFunctorCategoryFunctorialFunctorialFunctorialFunctorialFunctorialFunctorialFunctorishFunctorsFunctorsFunctorsFunctorsFunctorsFunctorsFunctorsFunctorsFundamentalPreGroupoidCategoryFunextFunextVarietiesGGCHGCHtoACGraphGraphQuotientGrothendieckGroupGroupCoeqGroupoidCategoryGroupsgroupsGrpPullbackHHartogsHexadecimalHFiberHomHomCoercionsHomFunctorHomomorphismHomotopyGroupHomotopyPreCategoryHopfHoTTHProphprop_latticeHSetHSpaceHSpaceS1IIdealIdempotentIdempotentsIdentityIdentityIdentityIdentityIdentityIdentityIdentityLawsIdentityPrincipleIffImageImpredicativeTruncationIncoherentIdempotentIndiscreteCategoryInducedInducedFunctorsInitialTerminalCategoryIntintegersintegersintegersIntervalIntervalImpliesFunextint_absisoIsomorphismsIWTypeJJoinJoinAssocJoinSuspKKanExtensionsKernelKroneckerDeltaLLagrangelatticeslatticesLawLawLawLawLawsLawsLawsLawsTacticLaw0Law1Law2Law3Law4LaxCommaLexLimitLimitsLocalizationLocalizationLocatorLoopExpLoopsMMappingCylindermapsMatrixMeetMiscModalityModuleModulimonadMonoidMonoidalMonoidalCategoryMonoidalTwistConstructionMonoidObjectMorphismsMorphismsMorphismsMorphismsMorphismsMorphismsNNamelessNatNatNatNatCategorynatpair_integersNatTransnaturalsnaturalsnaturalsNaturalTransformationNaturalTransformationsnat_distancenat_intNegationne_listNoNotationsNotationsNotationsNotationsNotationsNotationsNotationsNotationsNotationsNotationsNotationsNotationsNotnotNullHomotopyNullificationNumeralOObjectClassifierObjectsOnMorphismsOnObjectsooActionooGroupOpenOperationOppositeOptionordersordersOrdinalsOverturePParallelPairPartsPathAnyPathCubePathGroupoidsPathsPathsPathsPathsPathsPathsPathsPathsPathSplitPathSquarepeano_naturalspEquivpFiberPiPinSnpMappModalityPointedPointedCatPointwisePointwisePointwisePointwisepointwisePosPowerspremetricPresentationProdProdProdProdProdProductLawsProductsProfunctorProjectionProjectionFunctorsProjectivePropertiesPropResizingPropTruncpSectPseudofunctorPseudofunctorsPseudofunctorToCatPseudonaturalTransformationpSusppTruncPullbackPullbackPullbackFiberSequencePushoutPushoutQquotientQuotientQuotientGroupQuotientRingRrationalsrationalsReflectiveSubuniverseRelationalRepresentableRewriteLawsRewriteModuloAssociativityRigidRingRingsringsringsringsring_quotering_tacring_polroundSsemiringsSemiSimplicialSetsSeparatedSeparatedTruncSequenceSequentialSetCategorySetConeSetPropSettingsShortExactSequenceSigmaSigmaSigmaSimplicialSetsSixTermSmallnessSmashSpanSpanPushoutSpecSpecSpectrumSpheresSquareStrictStructureSubcategorySubgroupSuccessorStructureSumSumSumSumSumsumsurjective_factorSuspensionSyllepsisTTacticsTacticsTacticsTacticsTensorProductTermAlgebraTheoryToCatTopologicalTorusTorusEquivCirclesTorusHomotopyToSetTriJoinTruncTruncationsTruncImpliesFunextTruncTypeTwoOneCatTwoSphereTypesUua_prod_algebraua_algebraua_subalgebraua_quotient_algebraua_isomorphicua_setalgebraua_first_isomorphismua_congruenceua_third_isomorphismua_homomorphismua_second_isomorphismua_categoryunique_choiceUnitUnitCatUnitCounitUnitCounitCoercionsUnivalenceUnivalenceImpliesFunextUnivalenceVarietiesUnivalentUnivalentUnivalentUniversalUniversalMorphismsUniversalPropertiesUniverseUniverseUniverseLevelUtf8Utf8Utf8Utf8Utf8Utf8Utf8Utf8Utf8Utf8Utf8Utf8Utf8MinimalVVVectorWWedgeWhiteheadsPrincipleWideWildCatWTypeYYonedaYonedaZZZZeroGroupoidGlobal IndexABCDEFGHIJKLMNOPQRSTUVWXYZ_other(571 entries)Library IndexABCDEFGHIJKLMNOPQRSTUVWXYZ_other(571 entries)This page has been generated bycoqdoc

--- Miscellaneous\IndiscreteCategory.html ---
IndiscreteCategoryLibrary IndiscreteCategoryIndiscrete categoryRequireImportFunctor.CoreCategory.StrictCategory.UnivalentCategory.Morphisms.RequireImportTypes.UnitTruncHoTT.TacticsEquivalences.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Definition of an indiscrete categoryModuleExportCore.Sectionindiscrete_category.The indiscrete category has exactly one morphism between any two
      objects.VariableX:Type.We define the symmetrized version of associaitivity differently
      so that the dual of an indiscrete category is convertible with
      the indiscrete category.Definitionindiscrete_category:PreCategory:= @Build_PreCategory'X(fun__=>Unit)(fun_=>tt)(fun_____=>tt)(fun_______=>idpath)(fun_______=>idpath)(fun__f=>matchfwithtt=>idpathend)(fun__f=>matchfwithtt=>idpathend)(fun_=>idpath)_.Endindiscrete_category.Indiscrete categories are strict categoriesDefinitionisstrict_indiscrete_category`{H:IsHSetX}:IsStrictCategory(indiscrete_categoryX):=H.Indiscrete categories are (saturated/univalent) categoriesGlobal Instanceiscategory_indiscrete_category`{H:IsHPropX}:IsCategory(indiscrete_categoryX).Proof.intros.eapply(isequiv_adjointify(idtoiso(indiscrete_categoryX) (x:=s) (y:=d))(fun_=>center_));abstract(repeatintro;destruct_head_hnf@Isomorphic;destruct_head_hnf@IsIsomorphism;destruct_head_hnf@Unit;path_induction_hammer).Defined.EndCore.Functors to an indiscrete category are given by their action on objectsModuleFunctors.Sectionto.VariableX:Type.VariableC:PreCategory.VariableobjOf:C->X.Definitionto:FunctorC(indiscrete_categoryX):=Build_FunctorC(indiscrete_categoryX)objOf(fun___=>tt)(fun_____=>idpath)(fun_=>idpath).Endto.EndFunctors.

--- Miscellaneous\Induced.html ---
InducedLibrary InducedRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.RequireImportWildCat.Equiv.Induced wild categoriesA mapA->Bof types, whereBis some type of wild category, induces the same level of structure onA, via taking everything to be defined on the image.This needs to be separate from Core because of HasEquivs usage.  We don't make these definitions Global Instances because we only want to apply them manually, but we make them Local Instances so that subsequent ones can pick up the previous ones automatically.In most of the proofs, we only want to useintroon variables of typeA, so this will be handy.Ltacintros_of_typeA:=repeatmatchgoalwith|-forall(a:A),_=>introaend.SectionInduced_category.Context{AB:Type} (f:A->B).Local Instanceisgraph_induced`{IsGraphB} :IsGraphA.Proof.nrapplyBuild_IsGraph.introsa1a2.exact(fa1$->fa2).Defined.Local Instanceis01cat_induced`{Is01CatB} :Is01CatA.Proof.nrapplyBuild_Is01Cat;intros_of_typeA;cbn.+applyId.+applycat_comp.Defined.Local Instanceis0gpd_induced`{Is0GpdB} :Is0GpdA.Proof.nrapplyBuild_Is0Gpd;intros_of_typeA;cbn.applygpd_rev.Defined.The structure map along which we induce the category structure becomes a functor with respect to the induced structure.Local Instanceis0functor_induced`{IsGraphB} :Is0Functorf.Proof.nrapplyBuild_Is0Functor;intros_of_typeA;cbn.exactidmap.Defined.Local Instanceis2graph_induced`{Is2GraphB} :Is2GraphA.Proof.constructor;cbn.applyisgraph_hom.Defined.Local Instanceis1cat_induced`{Is1CatB} :Is1CatA.Proof.snrapplyBuild_Is1Cat;intros_of_typeA;cbn.+rapplyis01cat_hom.+nrapplyis0gpd_hom.+rapplyis0functor_postcomp.+rapplyis0functor_precomp.+rapplycat_assoc.+rapplycat_assoc_opp.+rapplycat_idl.+rapplycat_idr.Defined.Local Instanceis1functor_induced`{Is1CatB} :Is1Functorf.Proof.srapplyBuild_Is1Functor;intros_of_typeA;cbn.+introsgh.exactidmap.+exact(Id_).+introsgh.exact(Id_).Defined.Instancehasmorext_induced`{HasMorExtB} :HasMorExtA.Proof.constructor.intros_of_typeA;cbn.rapplyisequiv_Htpy_path.Defined.Definitionhasequivs_induced`{HasEquivsB} :HasEquivsA.Proof.srapplyBuild_HasEquivs;introsab;cbn.+exact(fa$<~>fb).+applyCatIsEquiv'.+applycate_fun.+applycate_isequiv'.+applycate_buildequiv'.+nrapplycate_buildequiv_fun'.+applycate_inv'.+nrapplycate_issect'.+nrapplycate_isretr'.+nrapplycatie_adjointify'.Defined.EndInduced_category.

--- Miscellaneous\InducedFunctors.html ---
InducedFunctorsLibrary InducedFunctorsInduced functors between comma categoriesRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportCategory.Dual.RequireImportCategory.Prod.RequireImportNaturalTransformation.Identity.RequireImportFunctorCategory.CoreCat.Core.RequireImportInitialTerminalCategory.CoreInitialTerminalCategory.Functors.RequireComma.Core.LocalSetWarningsAppend"-notation-overridden".(* work around bug 5567, https://coq.inria.fr/bugs/show_bug.cgi?id=5567, notation-overridden,parsing should not trigger for only printing notations *)ImportComma.Core.LocalSetWarningsAppend"notation-overridden".RequireImportHoTT.Tactics.RequireImportBasics.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.Local OpenScopecategory_scope.Morphisms in(A→C)ᵒᵖ×(B→C)from(s₀,s₁)to(d₀,d₁)induce functors(s₀/s₁)→(d₀/d₁)Sectioncomma_category_induced_functor.Context`{Funext}.VariablesABC:PreCategory.Definitioncomma_category_induced_functor_object_ofsd(m:morphism((A->C)^op* (B->C))sd)(x:fsts/snds): (fstd/sndd):=CommaCategory.Build_object(fstd) (sndd)(CommaCategory.ax)(CommaCategory.bx)((sndm) (CommaCategory.bx)oCommaCategory.fxo(fstm) (CommaCategory.ax)).Lemmacomma_category_induced_functor_object_of_identitysx:comma_category_induced_functor_object_of(Category.Core.identitys)x=x.Proof.letx1:=matchgoalwith|- ?x1= ?x2=>constr:(x1)endinletx2:=matchgoalwith|- ?x1= ?x2=>constr:(x2)endinapply(CommaCategory.path_object'x1x2idpathidpath).simpl.abstract(rewrite?left_identity, ?right_identity;reflexivity).Defined.Definitioncomma_category_induced_functor_object_of_composesdd'(m:morphism((A->C)^op* (B->C))dd')(m':morphism((A->C)^op* (B->C))sd)x:comma_category_induced_functor_object_of(mom')x=comma_category_induced_functor_object_ofm(comma_category_induced_functor_object_ofm'x).Proof.letx1:=matchgoalwith|- ?x1= ?x2=>constr:(x1)endinletx2:=matchgoalwith|- ?x1= ?x2=>constr:(x2)endinapply(CommaCategory.path_object'x1x2idpathidpath).abstract(destructm',m,x;simplin*;rewrite!associativity;reflexivity).Defined.Definitioncomma_category_induced_functor_morphism_ofsdms0d0(m0:morphism(fsts/snds)s0d0):morphism(fstd/sndd)(@comma_category_induced_functor_object_ofsdms0)(@comma_category_induced_functor_object_ofsdmd0).Proof.simpl.lets:=matchgoalwith|-CommaCategory.morphism?s?d=>constr:(s)endinletd:=matchgoalwith|-CommaCategory.morphism?s?d=>constr:(d)endinrefine(CommaCategory.Build_morphismsd(CommaCategory.gm0) (CommaCategory.hm0)_);simplin*;clear.abstract(destruct_headprod;destruct_headCommaCategory.morphism;destruct_headCommaCategory.object;simplin*;repeat(try_associativity_quick(rewrite<- !commutes|| (progressf_ap)));repeat(try_associativity_quick(rewrite!commutes|| (progressf_ap)));assumption).(* 3.495 s *)Defined.Definitioncomma_category_induced_functorsd(m:morphism((A->C)^op* (B->C))sd):Functor(fsts/snds) (fstd/sndd).Proof.refine(Build_Functor(fsts/snds) (fstd/sndd)(@comma_category_induced_functor_object_ofsdm)(@comma_category_induced_functor_morphism_ofsdm)__);abstract(intros;applyCommaCategory.path_morphism;reflexivity).Defined.Endcomma_category_induced_functor.Morphisms inCfromatoa'induce functors(C/a)→(C/a')Sectionslice_category_induced_functor.Context`{Funext}.VariableC:PreCategory.Sectionslice_coslice.VariableD:PreCategory.TODO(JasonGross): See if this can be recast as an exponential law functor about how1→Catis isomorphic toCat, or somethingDefinitionslice_category_induced_functor_ntsd(m:morphismDsd):NaturalTransformation!s!d.Proof.exists(fun_:Unit=>m);simpl;intros;clear;abstract(autorewritewithcategory;reflexivity).Defined.VariableF:FunctorCD.Variablea:D.Sectionslice.Definitionslice_category_induced_functorF'a'(m:morphismDaa')(T:NaturalTransformationF'F):Functor(F/a) (F'/a'):=comma_category_induced_functor(s:= (F, !a))(d:= (F', !a'))(T, @slice_category_induced_functor_ntaa'm).Definitionslice_category_nt_induced_functorF'T:= @slice_category_induced_functorF'a1T.Definitionslice_category_morphism_induced_functora'm:= @slice_category_induced_functorFa'm1.Endslice.Sectioncoslice.Definitioncoslice_category_induced_functorF'a'(m:morphismDa'a)(T:NaturalTransformationFF'):Functor(a/F) (a'/F'):=comma_category_induced_functor(s:= (!a,F))(d:= (!a',F'))(@slice_category_induced_functor_nta'am,T).Definitioncoslice_category_nt_induced_functorF'T:= @coslice_category_induced_functorF'a1T.Definitioncoslice_category_morphism_induced_functora'm:= @coslice_category_induced_functorFa'm1.Endcoslice.Endslice_coslice.Definitionslice_category_over_induced_functoraa'(m:morphismCaa'):Functor(C/a) (C/a'):=Evalhnfinslice_category_morphism_induced_functor___m.Definitioncoslice_category_over_induced_functoraa'(m:morphismCa'a):Functor(a\C) (a'\C):=Evalhnfincoslice_category_morphism_induced_functor___m.Endslice_category_induced_functor.FunctorsA→A'functors(cat/A)→(cat/A')Sectioncat_over_induced_functor.Local OpenScopetype_scope.Context`{Funext}.VariableP:PreCategory->Type.Context`{H0:forallCD,PC->PD->IsHSet(FunctorCD)}.Local Notationcat:= (@sub_pre_cat_PH0).Definitioncat_over_induced_functoraa'(m:morphismcataa'):Functor(cat/a) (cat/a'):=slice_category_over_induced_functorcataa'm.Definitionover_cat_induced_functoraa'(m:morphismcata'a):Functor(a\cat) (a'\cat):=coslice_category_over_induced_functorcataa'm.Endcat_over_induced_functor.

--- Miscellaneous\InitialTerminalCategory.html ---
InitialTerminalCategoryLibrary InitialTerminalCategoryInitial and terminal categoriesDefinitionsRequireInitialTerminalCategory.Core.IncludeInitialTerminalCategory.Core.We want to have the following as subdirectories/modules, not at top level.  Unfortunately, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.Functors to and from initial and terminal categoriesRequireInitialTerminalCategory.Functors.Natural transformations between functors from initial categories and to terminal categoriesRequireInitialTerminalCategory.NaturalTransformations.Pseudounctors from initial and terminal categoriesRequireInitialTerminalCategory.Pseudofunctors.RequireExportInitialTerminalCategory.Notations.

--- Miscellaneous\Int.html ---
IntLibrary IntRequireImportBasics.OvertureBasics.NatBasics.TacticsBasics.DecidableBasics.EquivalencesBasics.PathGroupoidsTypes.PathsTypes.Universe.RequireBasics.Numerals.Decimal.RequireImportSpaces.Nat.Core.UnsetEliminationSchemes.SetUniverseMinimizationToSet.Declare Scopeint_scope.DelimitScopeint_scopewithint.Local OpenScopeint_scope.The IntegersDefinitionWe define the integers as two copies ofnatstuck together around azero.InductiveInt:Type0:=|negS:nat->Int|zero:Int|posS:nat->Int.We can convert anatto anIntby mapping0tozeroandSntoposSn. Various operations onnatare preserved by this function. See the section on conversion functions starting withint_nat_succ.Definitionint_of_nat(n:nat) :=matchnwith|O=>zero|Sn=>posSnend.We declare this conversion as a coercion so we can freely usenats in statements about integers.Coercionint_of_nat:nat>->Int.Number NotationsHere we define some printing and parsing functions that convert the integers between numeral representations so that we can use notations such as123forposS122and-123fornegS122.PrintingDefinitionint_to_number_int(n:Int) :Numeral.int:=matchnwith|posSn=>Numeral.IntDec(Decimal.Pos(Nat.to_uint(Sn)))|zero=>Numeral.IntDec(Decimal.Pos(Nat.to_uint0))|negSn=>Numeral.IntDec(Decimal.Neg(Nat.to_uint(Sn)))end.ParsingDefinitionint_of_number_int(d:Numeral.int) :=matchdwith|Numeral.IntDec(Decimal.Posd) =>int_of_nat(Nat.of_uintd)|Numeral.IntDec(Decimal.Negd) =>negS(nat_pred(Nat.of_uintd))|Numeral.IntHex(Hexadecimal.Posu) =>int_of_nat(Nat.of_hex_uintu)|Numeral.IntHex(Hexadecimal.Negu) =>negS(nat_pred(Nat.of_hex_uintu))end.Number NotationIntint_of_number_intint_to_number_int:int_scope.Successor, Predecessor and NegationThese operations will be used in the induction principle we derive forIntso we need to define them early on.Successor and PredecessorDefinitionint_succ(n:Int) :Int:=matchnwith|posSn=>posS(Sn)| 0 => 1| -1 => 0|negS(Sn) =>negSnend.Notation"n .+1" := (int_succn) :int_scope.Definitionint_pred(n:Int) :Int:=matchnwith|posS(Sn) =>posSn| 1 => 0| 0 => -1|negSn=>negS(Sn)end.Notation"n .-1" := (int_predn) :int_scope.NegationDefinitionint_neg@{} (x:Int) :Int:=matchxwith|posSx=>negSx|zero=>zero|negSx=>posSxend.Notation"- x" := (int_negx) :int_scope.Basic PropertiesInteger inductionThe induction principle for integers is similar to the induction principle for natural numbers. However we have two induction hypotheses going in either direction starting from 0.DefinitionInt_ind@{i} (P:Int->Type@{i})(H0:P0)(HP:foralln:nat,Pn->P(int_succn))(HN:foralln:nat,P(-n) ->P(int_pred(-n))):forallx,Px.Proof.intros[x| |x].-inductionxas[|xIHx].+apply(HN0%nat),H0.+apply(HNx.+1%nat),IHx.-exactH0.-inductionxas[|xIHx].*apply(HP0%nat),H0.*apply(HPx.+1%nat),IHx.Defined.We record these so that they can be used with theinductiontactic.DefinitionInt_rect:=Int_ind.DefinitionInt_rec:=Int_ind.Decidable EqualityThe integers have decidable equality.Global Instancedecidable_paths_int@{} :DecidablePathsInt.Proof.introsxy.destructxas[x| |x],yas[y|  |y].2-4,6-8:right;intros;discriminate.2:byleft.1,2:nrapplydecidable_iff.1,3:split.1,3:nrapplyap.1,2:introsH;byinjectionH.1,2:exact_.Defined.By Hedberg's theorem, we have that the integers are a set.Global Instanceishset_int@{} :IsHSetInt:=_.PointednessWe sometimes want to treat the integers as a pointed type with basepoint given by 0.Global Instanceispointed_int:IsPointedInt:= 0.OperationsAdditionAddition for integers is defined by integer inductionn on the first argument.Definitionint_add@{} (xy:Int) :Int.Proof.inductionxas[|xIHx|xIHx]iny|- *.0+y=y-exacty.x.+1+y=(x+y).+1-exact(int_succ(IHxy)).x.-1+y=(x+y).-1-exact(int_pred(IHxy)).Defined.Infix"+" :=int_add:int_scope.Infix"-" := (funxy=>x+ -y) :int_scope.MultiplicationMultiplication for integers is defined by integer induction on the first argument.Definitionint_mul@{} (xy:Int) :Int.Proof.inductionxas[|xIHx|xIHx]iny|- *.0*y=0-exact0.x.+1*y=y+x*y-exact(y+IHxy).x.-1*y=-y+x*y-exact(-y+IHxy).Defined.Infix"*" :=int_mul:int_scope.Properties of OperationsNegationNegation is involutive.Definitionint_neg_neg@{} (x:Int) : - -x=x.Proof.bydestructx.Defined.Negation is an equivalence.Global Instanceisequiv_int_neg@{} :IsEquivint_neg.Proof.snrapply(isequiv_adjointifyint_negint_neg).1,2:nrapplyint_neg_neg.Defined.Negation is injective.Definitionisinj_int_neg@{} (xy:Int) : -x= -y->x=y:=equiv_injint_neg.The negation of a successor is the predecessor of the negation.Definitionint_neg_succ(x:Int) : -x.+1 = (-x).-1.Proof.bydestructxas[[] | | ].Defined.The negation of a predecessor is the successor of the negation.Definitionint_neg_pred(x:Int) : -x.-1 = (-x).+1.Proof.bydestructxas[ | | []].Defined.The successor of a predecessor is the identity.Definitionint_pred_succ@{} (x:Int) :x.-1.+1 =x.Proof.bydestructxas[ | | []].Defined.The predecessor of a successor is the identity.Definitionint_succ_pred@{} (x:Int) :x.+1.-1 =x.Proof.bydestructxas[[] | | ].Defined.The successor is an equivalence onIntGlobal Instanceisequiv_int_succ@{} :IsEquivint_succ:=isequiv_adjointifyint_succint_predint_pred_succint_succ_pred.The predecessor is an equivalence onIntGlobal Instanceisequiv_int_pred@{} :IsEquivint_pred:=isequiv_inverseint_succ.AdditionInteger addition with zero on the left is the identity by definition.Definitionint_add_0_l@{} (x:Int) : 0 +x=x:= 1.Integer addition with zero on the right is the identity.Definitionint_add_0_r@{} (x:Int) :x+ 0 =x.Proof.inductionxas[|[|x]IHx|[|x]IHx].-reflexivity.-reflexivity.-change(?z.+1 + 0)with(z+ 0).+1.exact(ap_IHx).-reflexivity.-change(?z.-1 + 0)with(z+ 0).-1.exact(ap_IHx).Defined.Adding a successor on the left is the successor of the sum.Definitionint_add_succ_l@{} (xy:Int) :x.+1 +y= (x+y).+1.Proof.inductionxas[|[|x]IHx|[|x]IHx]iny|- *.1-3:reflexivity.all:symmetry;applyint_pred_succ.Defined.Adding a predecessor on the left is the predecessor of the sum.Definitionint_add_pred_l@{} (xy:Int) :x.-1 +y= (x+y).-1.Proof.inductionxas[|[|x]IHx|[|x]IHx]iny|- *.1,4,5:reflexivity.all:symmetry;applyint_succ_pred.Defined.Adding a successor on the right is the successor of the sum.Definitionint_add_succ_r@{} (xy:Int) :x+y.+1 = (x+y).+1.Proof.inductionxas[|xIHx|[]IHx]iny|- *.-reflexivity.-byrewrite2int_add_succ_l,IHx.-cbn;byrewriteint_succ_pred,int_pred_succ.-change((- (n.+1%nat)).-1 +y.+1 = ((- (n.+1%nat)).-1 +y).+1).rewriteint_add_pred_l.rewriteIHx.rewrite<- 2int_add_succ_l.rewrite<-int_add_pred_l.byrewriteint_pred_succ,int_succ_pred.Defined.Adding a predecessor on the right is the predecessor of the sum.Definitionint_add_pred_r(xy:Int) :x+y.-1 = (x+y).-1.Proof.inductionxas[|xIHx|[]IHx]iny|- *.-reflexivity.-rewrite2int_add_succ_l.rewriteIHx.byrewriteint_pred_succ,int_succ_pred.-reflexivity.-rewrite2int_add_pred_l.byrewriteIHx.Defined.Integer addition is commutative.Definitionint_add_comm@{} (xy:Int) :x+y=y+x.Proof.inductionyas[|yIHy|yIHy]inx|- *.-applyint_add_0_r.-rewriteint_add_succ_l.rewrite<-IHy.byrewriteint_add_succ_r.-rewriteint_add_pred_r.rewriteint_add_pred_l.f_ap.Defined.Integer addition is associative.Definitionint_add_assoc@{} (xyz:Int) :x+ (y+z) =x+y+z.Proof.inductionxas[|xIHx|xIHx]iny,z|- *.-reflexivity.-byrewrite!int_add_succ_l,IHx.-byrewrite!int_add_pred_l,IHx.Defined.Negation is a left inverse with respect to integer addition.Definitionint_add_neg_l@{} (x:Int) : -x+x= 0.Proof.inductionxas[|xIHx|xIHx].-reflexivity.-byrewriteint_neg_succ,int_add_pred_l,int_add_succ_r,IHx.-byrewriteint_neg_pred,int_add_succ_l,int_add_pred_r,IHx.Defined.Negation is a right inverse with respect to integer addition.Definitionint_add_neg_r@{} (x:Int) :x-x= 0.Proof.unfold"-";byrewriteint_add_comm,int_add_neg_l.Defined.Negation distributes over addition.Definitionint_neg_add@{} (xy:Int) : - (x+y) = -x-y.Proof.inductionxas[|xIHx|xIHx]iny|- *.-reflexivity.-rewriteint_add_succ_l.rewrite2int_neg_succ.rewriteint_add_pred_l.f_ap.-rewriteint_neg_pred.rewriteint_add_succ_l.rewriteint_add_pred_l.rewriteint_neg_pred.f_ap.Defined.MultiplicationMultiplication with a successor on the left is the sum of the multplication without the sucesseor and the multiplicand which was not a successor.Definitionint_mul_succ_l@{} (xy:Int) :x.+1 *y=y+x*y.Proof.inductionxas[|[|x]IHx|[]IHx]iny|- *.-reflexivity.-reflexivity.-reflexivity.-cbn.rewriteint_add_0_r.byrewriteint_add_neg_r.-rewriteint_pred_succ.cbn.rewriteint_add_assoc.rewriteint_add_neg_r.byrewriteint_add_0_l.Defined.Similarly, multiplication with a predecessor on the left is the sum of the multiplication without the predecessor and the negation of the multiplicand which was not a predecessor.Definitionint_mul_pred_l@{} (xy:Int) :x.-1 *y= -y+x*y.Proof.inductionxas[|xIHx|[]IHx]iny|- *.-reflexivity.-rewriteint_mul_succ_l.rewriteint_succ_pred.rewriteint_add_assoc.byrewriteint_add_neg_l.-reflexivity.-reflexivity.Defined.Integer multiplication with zero on the left is zero by definition.Definitionint_mul_0_l@{} (x:Int) : 0 *x= 0 := 1.Integer multiplication with zero on the right is zero.Definitionint_mul_0_r@{} (x:Int) :x* 0 = 0.Proof.inductionxas[|xIHx|xIHx].-reflexivity.-byrewriteint_mul_succ_l,int_add_0_l.-byrewriteint_mul_pred_l,int_add_0_l.Defined.Integer multiplication with one on the left is the identity.Definitionint_mul_1_l@{} (x:Int) : 1 *x=x.Proof.applyint_add_0_r.Defined.Integer multiplication with one on the right is the identity.Definitionint_mul_1_r@{} (x:Int) :x* 1 =x.Proof.inductionxas[|xIHx|xIHx].-reflexivity.-byrewriteint_mul_succ_l,IHx.-byrewriteint_mul_pred_l,IHx.Defined.Multiplying with a negation on the left is the same as negating the product.Definitionint_mul_neg_l@{} (xy:Int) : -x*y= - (x*y).Proof.inductionxas[|xIHx|xIHx]iny|- *.-reflexivity.-rewriteint_neg_succ.rewriteint_mul_pred_l.rewriteint_mul_succ_l.rewriteint_neg_add.byrewriteIHx.-rewriteint_neg_pred.rewriteint_mul_succ_l.rewriteint_mul_pred_l.rewriteint_neg_add.rewriteIHx.byrewriteint_neg_neg.Defined.Multiplying with a successor on the right is the sum of the multiplication without the successor and the product of the multiplicand which was not a successor and the multiplicand.Definitionint_mul_succ_r@{} (xy:Int) :x*y.+1 =x+x*y.Proof.inductionxas[|xIHx|xIHx]iny|- *.-reflexivity.-rewrite2int_mul_succ_l.rewrite2int_add_succ_l.f_ap.rewriteIHx.rewrite!int_add_assoc;f_ap.byrewriteint_add_comm.-rewrite2int_mul_pred_l.rewriteint_neg_succ.rewriteint_mul_neg_l.rewrite2int_add_pred_l.f_ap.rewrite<-int_mul_neg_l.rewriteIHx.rewrite!int_add_assoc;f_ap.byrewriteint_add_comm.Defined.Multiplying with a predecessor on the right is the sum of the multiplication without the predecessor and the product of the multiplicand which was not a predecessor and the negation of the multiplicand which was not a predecessor.Definitionint_mul_pred_r@{} (xy:Int) :x*y.-1 = -x+x*y.Proof.inductionxas[|xIHx|xIHx]iny|- *.-reflexivity.-rewrite2int_mul_succ_l.rewriteIHx.rewrite!int_add_assoc;f_ap.rewrite<- (int_neg_negy.-1).rewrite<-int_neg_add.rewriteint_neg_pred.rewriteint_add_succ_l.rewriteint_add_comm.rewrite<-int_add_succ_l.rewriteint_neg_add.byrewriteint_neg_neg.-rewriteint_neg_pred.rewriteint_neg_neg.rewrite2int_mul_pred_l.rewriteIHx.rewrite!int_add_assoc;f_ap.rewriteint_neg_pred.rewriteint_neg_neg.rewrite2int_add_succ_l;f_ap.byrewriteint_add_comm.Defined.Integer multiplication is commutative.Definitionint_mul_comm@{} (xy:Int) :x*y=y*x.Proof.inductionyas[|yIHy|yIHy]inx|- *.-applyint_mul_0_r.-rewriteint_mul_succ_l.rewriteint_mul_succ_r.byrewriteIHy.-rewriteint_mul_pred_l.rewriteint_mul_pred_r.byrewriteIHy.Defined.Multiplying with a negation on the right is the same as negating the product.Definitionint_mul_neg_r@{} (xy:Int) :x* -y= - (x*y).Proof.rewrite!(int_mul_commx).applyint_mul_neg_l.Defined.Multiplication distributes over addition on the left.Definitionint_dist_l@{} (xyz:Int) :x* (y+z) =x*y+x*z.Proof.inductionxas[|xIHx|xIHx]iny,z|- *.-reflexivity.-rewrite3int_mul_succ_l.rewriteIHx.rewrite!int_add_assoc;f_ap.rewrite<- !int_add_assoc;f_ap.byrewriteint_add_comm.-rewrite3int_mul_pred_l.rewriteIHx.rewrite!int_add_assoc;f_ap.rewriteint_neg_add.rewrite<- !int_add_assoc;f_ap.byrewriteint_add_comm.Defined.Multiplication distributes over addition on the right.Definitionint_dist_r@{} (xyz:Int) : (x+y) *z=x*z+y*z.Proof.byrewriteint_mul_comm,int_dist_l, !(int_mul_commz).Defined.Multiplication is associative.Definitionint_mul_assoc@{} (xyz:Int) :x* (y*z) =x*y*z.Proof.inductionxas[|xIHx|xIHx]iny,z|- *.-reflexivity.-rewrite2int_mul_succ_l.rewriteint_dist_r.byrewriteIHx.-rewrite2int_mul_pred_l.rewriteint_dist_r.rewrite<-int_mul_neg_l.byrewriteIHx.Defined.Iteration of equivalencesIteration by arbitrary integersIteration by arbitrary integers requires the endofunction to be an equivalence, so that we can define a negative iteration by using its inverse.Definitionint_iter{A} (f:A->A) `{!IsEquivf} (n:Int) :A->A:=matchnwith|negSn=>funx=>nat_itern.+1%natf^-1x|zero=>idmap|posSn=>funx=>nat_itern.+1%natfxend.Definitionint_iter_neg{A} (f:A->A) `{IsEquiv__f} (n:Int) (a:A):int_iterf(-n)a=int_iterf^-1na.Proof.bydestructn.Defined.Definitionint_iter_succ_l{A} (f:A->A) `{IsEquiv__f} (n:Int) (a:A):int_iterf(int_succn)a=f(int_iterfna).Proof.inductionnas[|n|n].-reflexivity.-bydestructn.-rewriteint_pred_succ.destructn.all:symmetry;applyeisretr.Defined.Definitionint_iter_succ_r{A} (f:A->A) `{IsEquiv__f} (n:Int) (a:A):int_iterf(int_succn)a=int_iterfn(fa).Proof.inductionnas[|n|n].-reflexivity.-destructn.1:reflexivity.cbn;f_ap.-destructn.1:symmetry;applyeissect.rewriteint_pred_succ.apply(apf^-1).rhs_VnrapplyIHn.bydestructn.Defined.Definitionint_iter_pred_l{A} (f:A->A) `{IsEquiv__f} (n:Int) (a:A):int_iterf(int_predn)a=f^-1 (int_iterfna).Proof.(* Convert the problem to be a problem aboutf^-1and-n. *)lhs_Vexact(int_iter_negf^-1 (n.-1)a).rhs_Vexact(apf^-1 (int_iter_negf^-1na)).(* Thenint_iter_succ_lapplies, after changing-n.-1to(-n).+1. *)rewriteint_neg_pred.applyint_iter_succ_l.Defined.Definitionint_iter_pred_r{A} (f:A->A) `{IsEquiv__f} (n:Int) (a:A):int_iterf(int_predn)a=int_iterfn(f^-1a).Proof.(* Convert the problem to be a problem aboutf^-1and-n. *)lhs_Vexact(int_iter_negf^-1 (n.-1)a).rhs_Vexact(int_iter_negf^-1n(f^-1a)).(* Thenint_iter_succ_rapplies, after changing-n.-1to(-n).+1. *)rewriteint_neg_pred.applyint_iter_succ_r.Defined.Definitionint_iter_add{A} (f:A->A) `{IsEquiv__f} (mn:Int):int_iterf(m+n) ==int_iterfmoint_iterfn.Proof.introsa.inductionmas[|m|m].-reflexivity.-rewriteint_add_succ_l.rewrite2int_iter_succ_l.f_ap.-rewriteint_add_pred_l.rewrite2int_iter_pred_l.f_ap.Defined.Ifg:A->A'commutes with automorphisms ofAandA', then it commutes with iteration.Definitionint_iter_commute_map{AA'} (f:A->A) `{!IsEquivf}(f':A'->A') `{!IsEquivf'}(g:A->A') (p:gof==f'og) (n:Int) (a:A):g(int_iterfna) =int_iterf'n(ga).Proof.inductionnas[|nIHn|nIHn]ina|- *.-reflexivity.-rewrite2int_iter_succ_r.rewriteIHn.f_ap.-rewrite2int_iter_pred_r.rewriteIHn.f_ap.applymoveL_equiv_V.lhs_Vnrapplyp.f_ap.applyeisretr.Defined.In particular, homotopic maps have homotopic iterations.Definitionint_iter_homotopic(n:Int) {A} (ff':A->A) `{!IsEquivf} `{!IsEquivf'}(h:f==f'):int_iterfn==int_iterf'n:=int_iter_commute_mapff'idmaphn.int_iterfnxdoesn't depend on the proof thatfis an equivalence.Definitionint_iter_agree(n:Int) {A} (f:A->A) {iefief':IsEquivf}:forallx, @int_iterAfiefnx= @int_iterAfief'nx:=int_iter_homotopicnff(fun_=>idpath).Definitionint_iter_invariant(n:Int) {A} (f:A->A) `{!IsEquivf}(P:A->Type)(Psucc:forallx,Px->P(fx))(Ppred:forallx,Px->P(f^-1x)):forallx,Px->P(int_iterfnx).Proof.inductionnas[|nIHn|nIHn];introx.-exactidmap.-introH.rewriteint_iter_succ_l.applyPsucc,IHn,H.-introH.rewriteint_iter_pred_l.applyPpred,IHn,H.Defined.Exponentiation of loopsDefinitionloopexp{A:Type} {x:A} (p:x=x) (z:Int) : (x=x):=int_iter(equiv_concat_rpx)zidpath.Definitionloopexp_succ_r{A:Type} {x:A} (p:x=x) (z:Int):loopexppz.+1 =loopexppz@p:=int_iter_succ_l___.Definitionloopexp_pred_r{A:Type} {x:A} (p:x=x) (z:Int):loopexppz.-1 =loopexppz@p^:=int_iter_pred_l___.Definitionloopexp_succ_l{A:Type} {x:A} (p:x=x) (z:Int):loopexppz.+1 =p@loopexppz.Proof.lhsnrapplyloopexp_succ_r.inductionzas[|z|z].-nrapplyconcat_1p_p1.-rewriteloopexp_succ_r.rhsnrapplyconcat_p_pp.f_ap.-rewriteloopexp_pred_r.lhsnrapplyconcat_pV_p.rhsnrapplyconcat_p_pp.byapplymoveL_pV.Defined.Definitionloopexp_pred_l{A:Type} {x:A} (p:x=x) (z:Int):loopexppz.-1 =p^ @loopexppz.Proof.rewriteloopexp_pred_r.inductionzas[|z|z].-exact(concat_1p_@ (concat_p1_)^).-rewriteloopexp_succ_r.lhsnrapplyconcat_pp_V.rhsnrapplyconcat_p_pp.byapplymoveL_pM.-rewriteloopexp_pred_r.rhsnrapplyconcat_p_pp.f_ap.Defined.Definitionap_loopexp{AB} (f:A->B) {x:A} (p:x=x) (z:Int):apf(loopexppz) =loopexp(apfp)z.Proof.nrapplyint_iter_commute_map.introq;applyap_pp.Defined.Definitionloopexp_add{A:Type} {x:A} (p:x=x)mn:loopexpp(m+n) =loopexppm@loopexppn.Proof.inductionmas[|m|m].-symmetry;applyconcat_1p.-rewriteint_add_succ_l.rewrite2loopexp_succ_l.byrewriteIHm,concat_p_pp.-rewriteint_add_pred_l.rewrite2loopexp_pred_l.byrewriteIHm,concat_p_pp.Defined.Under univalence, exponentiation of loops corresponds to iteration of autoequivalences.Definitionequiv_path_loopexp{A:Type} (p:A=A) (z:Int) (a:A):equiv_pathAA(loopexppz)a=int_iter(equiv_pathAAp)za.Proof.refine(int_iter_commute_map__(funp=>equiv_pathAApa)___).introq;cbn.nrapplytransport_pp.Defined.Definitionloopexp_path_universe`{Univalence} {A:Type} (f:A<~>A)(z:Int) (a:A):transportidmap(loopexp(path_universef)z)a=int_iterfza.Proof.revertf.equiv_intro(equiv_pathAA)p.refine(_@equiv_path_loopexppza).refine(ap(funq=>equiv_pathAA(loopexpqz)a)_).applyeissect.Defined.Converting between integers and naturalsint_of_natpreserves successors.Definitionint_nat_succ(n:nat): (n.+1)%int= (n.+1)%nat:>Int.Proof.byinductionn.Defined.int_of_natpreserves addition. Hence is a monoid homomorphism.Definitionint_nat_add(nm:nat): (n+m)%int= (n+m)%nat:>Int.Proof.inductionnas[|nIHn].-reflexivity.-rewrite<- 2int_nat_succ.rewriteint_add_succ_l.exact(ap_IHn).Defined.int_of_natpreserves subtraction when not truncated.Definitionint_nat_sub(nm:nat): (m<=n)%nat-> (n-m)%int= (n-m)%nat:>Int.Proof.introsH.inductionHas[|nHIHn].-lhsnrapplyint_add_neg_r.byrewritenat_sub_cancel.-rewritenat_sub_succ_l;only2:exact_.rewrite<- 2int_nat_succ.rewriteint_add_succ_l.exact(ap_IHn).Defined.int_of_natpreserves multiplication. This makesint_of_nata semiring homomorphism.Definitionint_nat_mul(nm:nat):  (n*m)%int= (n*m)%nat:>Int.Proof.inductionnas[|nIHn].-reflexivity.-rewrite<-int_nat_succ.rewriteint_mul_succ_l.rewritenat_mul_succ_l.rhs_Vnrapplyint_nat_add.exact(ap_IHn).Defined.

--- Miscellaneous\integers.html ---
integersLibrary integers(* General results about arbitrary integer implementations. *)RequireImportHoTT.Basics.Decidable.RequireImportHoTT.Classes.theory.nat_distanceHoTT.Classes.implementations.peano_naturalsHoTT.Classes.interfaces.naturalsHoTT.Classes.interfaces.ordersHoTT.Classes.implementations.natpair_integersHoTT.Classes.theory.ringsHoTT.Classes.isomorphisms.rings.RequireExportHoTT.Classes.interfaces.integers.ImportNatPair.Instances.Generalizable VariablesNZRf.Lemmato_ring_unique`{IntegersZ} `{IsCRingR} (f:Z->R){h:IsSemiRingPreservingf}x:fx=integers_to_ringZRx.Proof.symmetry.applyintegers_initial.Qed.Lemmato_ring_unique_alt`{IntegersZ} `{IsCRingR} (fg:Z->R)`{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg}x:fx=gx.Proof.rewrite(to_ring_uniquef), (to_ring_uniqueg);reflexivity.Qed.Lemmato_ring_involutiveZ`{IntegersZ}Z2`{IntegersZ2}x:integers_to_ringZ2Z(integers_to_ringZZ2x) =x.Proof.change(Compose(integers_to_ringZ2Z) (integers_to_ringZZ2)x=idx).applyto_ring_unique_alt;apply_.Qed.Lemmamorphisms_involutive`{IntegersZ} `{IsCRingR} (f:R->Z) (g:Z->R)`{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg}x:f(gx) =x.Proof.exact(to_ring_unique_alt(f∘g)id_).Qed.Lemmato_ring_twice`{IntegersZ} `{IsCRingR1} `{IsCRingR2}(f:R1->R2) (g:Z->R1) (h:Z->R2)`{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg} `{!IsSemiRingPreservingh}x:f(gx) =hx.Proof.exact(to_ring_unique_alt(f∘g)h_).Qed.Lemmato_ring_self`{IntegersZ} (f:Z->Z) `{!IsSemiRingPreservingf}x:fx=x.Proof.exact(to_ring_unique_altfid_).Qed.(* A ring morphism from integers to another ring is injectiveif there's an injection in the other direction: *)Lemmato_ring_injective`{IntegersZ} `{IsCRingR} (f:R->Z) (g:Z->R)`{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg}:IsInjectiveg.Proof.introsxyE.change(idx=idy).rewrite<-(to_ring_twicefgidx), <-(to_ring_twicefgidy).applyap,E.Qed.Global Instanceintegers_to_integers_injective`{IntegersZ} `{IntegersZ2}(f:Z->Z2) `{!IsSemiRingPreservingf}:IsInjectivef.Proof.exact(to_ring_injective(integers_to_ringZ2Z)_).Qed.Global Instancenaturals_to_integers_injective`{Funext} `{Univalence}`{Integers@{iiiiiiii}Z} `{Naturals@{iiiiiiii}N}(f:N->Z) `{!IsSemiRingPreservingf}:IsInjectivef.Proof.introsxyE.apply(injective(castN(NatPair.ZN))).rewrite<-2!(naturals.to_semiring_twice(integers_to_ringZ(NatPair.ZN))f(castN(NatPair.ZN))).applyap,E.Qed.Sectionretract_is_int.Context`{Funext}.Context`{IntegersZ} `{IsCRingZ2}{Z2ap:ApartZ2} {Z2leZ2lt} `{!FullPseudoSemiRingOrder(A:=Z2)Z2leZ2lt}.Context(f:Z->Z2) `{!IsEquivf} `{!IsSemiRingPreservingf}`{!IsSemiRingPreserving(f^-1)}.(* If we make this an instance, then instance resolution will often loop *)Definitionretract_is_int_to_ring:IntegersToRingZ2:=funZ2______=>integers_to_ringZZ2∘f^-1.Sectionfor_another_ring.Context`{IsCRingR}.Instance:IsSemiRingPreserving(integers_to_ringZR∘f^-1) := {}.Context(h:Z2->R) `{!IsSemiRingPreservingh}.Lemmasame_morphismx: (integers_to_ringZR∘f^-1)x=hx.Proof.transitivity((h∘ (f∘f^-1))x).-symmetry.apply(to_ring_unique(h∘f)).-unfoldCompose.applyap.applyeisretr.Qed.Endfor_another_ring.(* If we make this an instance, then instance resolution will often loop *)Lemmaretract_is_int:IntegersZ2(U:=retract_is_int_to_ring).Proof.split;tryapply_.-unfoldintegers_to_ring,retract_is_int_to_ring.apply_.-intros;applysame_morphism;apply_.Qed.Endretract_is_int.Sectionint_to_int_iso.Context`{IntegersZ1} `{IntegersZ2}.Global Instanceint_to_int_equiv:IsEquiv(integers_to_ringZ1Z2).Proof.applyEquivalences.isequiv_adjointifywith(integers_to_ringZ2Z1);red;apply(to_ring_involutive__).Defined.Endint_to_int_iso.Sectioncontents.UniverseU.Context`{Funext} `{Univalence}.Context(Z:Type@{U}) `{Integers@{UUUUUUUU}Z}.Lemmafrom_int_stmt(Z':Type@{U}) `{Integers@{UUUUUUUU}Z'}:forall(P:Rings.Operations->Type),P(Rings.BuildOperationsZ') ->P(Rings.BuildOperationsZ).Proof.applyRings.iso_leibnitzwith(integers_to_ringZ'Z);apply_.Qed.Global Instanceint_dec:DecidablePathsZ| 10.Proof.applydecidablepaths_equivwith(NatPair.Znat)(integers_to_ring(NatPair.Znat)Z);apply_.Qed.Global Instanceslow_int_abs`{NaturalsN} :IntAbsZN| 10.Proof.introsx.destruct(int_abs_sig(NatPair.ZN)N(integers_to_ringZ(NatPair.ZN)x))as[[nE]|[nE]];[left|right];existsn.-apply(injective(integers_to_ringZ(NatPair.ZN))).rewrite<-E.apply(naturals.to_semiring_twice___).-apply(injective(integers_to_ringZ(NatPair.ZN))).rewriterings.preserves_negate, <-E.apply(naturals.to_semiring_twice___).Qed.Instanceint_nontrivial:PropHolds((1:Z) <>0).Proof.introsE.apply(rings.is_ne_0(1:nat)).apply(injective(naturals_to_semiringnatZ)).exactE.(* becausenaturals_to_semiringnatplays nice with 1 *)Qed.Global Instanceint_zero_product:ZeroProductZ.Proof.introsxyE.destruct(zero_product(integers_to_ringZ(NatPair.Znat)x)(integers_to_ringZ(NatPair.Znat)y)).-rewrite<-(rings.preserves_mult(A:=Z)),E, (rings.preserves_0(A:=Z)).trivial.-left.apply(injective(integers_to_ringZ(NatPair.Znat))).rewriterings.preserves_0.trivial.-right.apply(injective(integers_to_ringZ(NatPair.Znat))).rewriterings.preserves_0.trivial.Qed.Global Instanceint_integral_domain:IsIntegralDomainZ:= {}.Endcontents.

--- Miscellaneous\IntervalImpliesFunext.html ---
IntervalImpliesFunextLibrary IntervalImpliesFunextAn interval type implies function extensionalityRequireImportHoTT.Basics.RequireImportHIT.Interval.RequireImportMetatheory.CoreMetatheory.FunextVarieties.From an interval type with definitional computation rules on the end points, we can prove function extensionality.Definitionfunext_type_from_interval:Funext_type:=WeakFunext_implies_Funext(NaiveFunext_implies_WeakFunext(funAPfgp=>leth:=fun(x:interval) (a:A) =>interval_rec_(fa) (ga) (pa)xinaphseg)).Note that the converse is also true:  function extensionality implies that an interval type exists, with definitional computation rules.  This is illustrated in TruncImpliesFunext.v.

--- Miscellaneous\int_abs.html ---
int_absLibrary int_absRequireImportHoTT.Classes.interfaces.naturalsHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.orders.nat_intHoTT.Classes.theory.integersHoTT.Classes.theory.ringsHoTT.Classes.theory.groupsHoTT.Classes.orders.rings.Generalizable VariablesNZZleZltRf.Sectioncontents.Context`{Funext} `{Univalence}.Context`{IntegersZ} `{ApartZ} `{!TrivialApartZ}`{!FullPseudoSemiRingOrderZleZlt} `{NaturalsN}.(* Add Ring Z : (rings.stdlib_ring_theory Z). *)Lemmaint_abs_unique(ab:IntAbsZN) (z:Z) :int_absZN(ia:=a)z=int_absZN(ia:=b)z.Proof.unfoldint_abs.destruct(int_abs_sigZN(IntAbs:=a)z)as[[n1E1]|[n1E1]];destruct(int_abs_sigZN(IntAbs:=b)z)as[[n2E2]|[n2E2]].-apply(injective(naturals_to_semiringNZ)).path_viaz.-assert(E:n1+n2= 0);[|path_via0;[|symmetry];apply(naturals.zero_sum__E)].apply(injective(naturals_to_semiringNZ)).rewritepreserves_0,preserves_plus.rewriteE1,E2.applyplus_negate_r.-assert(E:n1+n2= 0);[|path_via0;[|symmetry];apply(naturals.zero_sum__E)].apply(injective(naturals_to_semiringNZ)).rewritepreserves_0,preserves_plus.rewriteE1,E2.applyplus_negate_l.-apply(injective(naturals_to_semiringNZ)).path_via(-z).Qed.Context`{!IntAbsZN}.Context`{!IsSemiRingPreserving(f:N->Z)}.Lemmaint_abs_specx:(0 ≤x/\f(int_absZNx) =x) |_| (x≤ 0 /\f(int_absZNx) = -x).Proof.unfoldint_abs.destruct(int_abs_sigZNx)as[[nE]|[nE]].-left.rewrite<-E.split.+eapply@to_semiring_nonneg;apply_.+apply(naturals.to_semiring_unique_alt__).-right.split.+applyflip_nonpos_negate.rewrite<-E.eapply@to_semiring_nonneg;apply_.+rewrite<-E.apply(naturals.to_semiring_unique_alt__).Qed.Lemmaint_abs_sig_altx:(sig(funn:N=>fn=x)) |_| (sig(funn:N=>fn= -x)).Proof.destruct(int_abs_specx)as[[??]|[??]];eauto.Qed.Lemmaint_abs_natn:int_absZN(fn) =n.Proof.apply(injectivef).destruct(int_abs_spec(fn))as[[?E]|[?E]];trivial.applynaturals.negate_to_ring.rewriteE,involutive.trivial.Qed.Lemmaint_abs_negate_natn:int_absZN(-fn) =n.Proof.apply(injectivef).destruct(int_abs_spec(-fn))as[[?E]|[?E]].-symmetry.applynaturals.negate_to_ring.applysymmetry;trivial.-rewriteinvolutiveinE.trivial.Qed.Lemmaint_abs_negatex:int_absZN(-x) =int_absZNx.Proof.destruct(int_abs_specx)as[[_E]|[_E]].-path_via(int_absZN(-f(int_absZNx))).applyint_abs_negate_nat.-rewrite<-E.applyint_abs_nat.Qed.Lemmaint_abs_0_altx:int_absZNx= 0 <->x= 0.Proof.split;introsE1.-destruct(int_abs_specx)as[[_E2]|[_E2]];[|applyflip_negate_0];rewrite<-E2,E1, (preserves_0(f:=f));trivial.-rewriteE1, <-(preserves_0(f:=f)).applyint_abs_nat.Qed.Lemmaint_abs_ne_0x:int_absZNx<> 0 <->x<> 0.Proof.destruct(int_abs_0_altx).split;introsE1E2;auto.Qed.Lemmaint_abs_0:int_absZN0 = 0.Proof.applyint_abs_0_alt;trivial.Qed.Lemmaint_abs_nonnegx:0 ≤x->f(int_absZNx) =x.Proof.introsE1.destruct(int_abs_specx)as[[nE2]|[nE2]];trivial.assert(Hrw:x= 0).-apply(antisymmetry(<=));trivial.-rewriteHrw,int_abs_0, (preserves_0(f:=f)).trivial.Qed.Lemmaint_abs_nonposx:x≤ 0 ->f(int_absZNx) = -x.Proof.introsE.rewrite<-int_abs_negate,int_abs_nonneg;auto.applyflip_nonpos_negate.trivial.Qed.Lemmaint_abs_1:int_absZN1 = 1.Proof.apply(injectivef).rewrite(preserves_1(f:=f)).applyint_abs_nonneg;solve_propholds.Qed.Lemmaint_abs_nonneg_plusxy:0 ≤x-> 0 ≤y->int_absZN(x+y) =int_absZNx+int_absZNy.Proof.intros.apply(injectivef).rewrite(preserves_plus(f:=f)), !int_abs_nonneg;auto.applynonneg_plus_compat;trivial.Qed.Lemmaint_abs_multxy:int_absZN(x*y) =int_absZNx*int_absZNy.Proof.apply(injectivef).rewrite(preserves_mult(f:=f)).destruct(int_abs_specx)as[[?Ex]|[?Ex]],(int_abs_specy)as[[?Ey]|[?Ey]];rewriteEx,Ey.-rewriteint_abs_nonneg;trivial.applynonneg_mult_compat;trivial.-rewriteint_abs_nonpos.+applynegate_mult_distr_r.+applynonneg_nonpos_mult;trivial.-rewriteint_abs_nonpos.+applynegate_mult_distr_l.+applynonpos_nonneg_mult;trivial.-rewriteint_abs_nonneg.+symmetry;applynegate_mult_negate.+applynonpos_mult;trivial.Qed.Endcontents.

--- Miscellaneous\iso.html ---
isoLibrary isoRequireImportHoTT.Basics.RequireImportTypes.Universe.RequireImportHSet.RequireImportHIT.epiHIT.unique_choice.Local OpenScopepath_scope.We prove thatepi+mono<->IsEquivSectioniso.Context`{Univalence}.VariablesXY:HSet.Variablef:X->Y.Lemmaatmost1P_isinj(injf:IsInjectivef):forally:Y,atmost1P(funx=>fx=y).Proof.introsyxx'pq.apply(injectivef).exact(p@q^).Defined.Definitionisequiv_isepi_ismono(epif:isepif) (monof:ismonof):IsEquivf.Proof.poseproof(@isepi_issurj___fepif)assurjf.poseproof(isinj_ismono_monof)asinjf.poseproof(unique_choice(funyx=>fx=y)_(funy=> (@center_(surjfy),atmost1P_isinjinjfy)))asH_unique_choice.apply(isequiv_adjointify_H_unique_choice.1).-intro.applyH_unique_choice.2.-intro.applyinjf.applyH_unique_choice.2.Defined.Endiso.

--- Miscellaneous\Isomorphisms.html ---
IsomorphismsLibrary IsomorphismsNatural isomorphismsRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportNaturalTransformation.Composition.Core.RequireImportFunctor.Composition.Core.RequireImportCategory.Morphisms.RequireImportFunctorCategory.Core.RequireImportNaturalTransformation.Paths.RequireImportBasics.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Local OpenScopenatural_transformation_scope.Local OpenScopemorphism_scope.Local Ltaciso_whisker_t:=path_natural_transformation;tryrewrite<-composition_of, <-identity_of;tryf_ap;matchgoalwith| [H:IsIsomorphism_|-context[components_of?T0?xocomponents_of?T1?x] ]=>change(T0xoT1x)with(components_of((T0:morphism(_->_)__)o(T1:morphism(_->_)__))%morphismx);progressrewrite?(@left_inverse____H), ?(@right_inverse____H)end;reflexivity.Sectioncomposition.Context`{Funext}.Natural isomorphism respects compositionGlobal Instanceisisomorphism_compose`(T': @NaturalTransformationCDF'F'')`(T: @NaturalTransformationCDFF')`{@IsIsomorphism(C->D)F'F''T'}`{@IsIsomorphism(C->D)FF'T}: @IsIsomorphism(C->D)FF''(T'oT)%natural_transformation:= @isisomorphism_compose(C->D)__T'__T_.Left whiskering preserves natural isomorphismsGlobal Instanceiso_whisker_lCDE(F:FunctorDE)(GG':FunctorCD)(T:NaturalTransformationGG')`{@IsIsomorphism(C->D)GG'T}: @IsIsomorphism(C->E) (FoG)%functor(FoG')%functor(whisker_lFT).Proof.exists(whisker_lF(T:morphism(_->_)__)^-1);abstractiso_whisker_t.Defined.Right whiskering preserves natural isomorphismsGlobal Instanceiso_whisker_rCDE(FF':FunctorDE)(T:NaturalTransformationFF')(G:FunctorCD)`{@IsIsomorphism(D->E)FF'T}: @IsIsomorphism(C->E) (FoG)%functor(F'oG)%functor(whisker_rTG).Proof.exists(whisker_r(T:morphism(_->_)__)^-1G);abstractiso_whisker_t.Defined.action ofidtoisoon objectsDefinitionidtoiso_components_ofCD(FG:FunctorCD)(T':F=G)x: (Category.Morphisms.idtoiso(_->_)T':morphism___)x=Category.Morphisms.idtoiso_(ap10(apobject_ofT')x).Proof.destructT'.reflexivity.Defined.idtoisorespsects compositionDefinitionidtoiso_composeCD(FF'F'':FunctorCD)(T':F'=F'')(T:F=F'): ((Category.Morphisms.idtoiso(_->_)T':morphism___)o(Category.Morphisms.idtoiso(_->_)T:morphism___))%natural_transformation= (Category.Morphisms.idtoiso(_->_) (T@T')%path:morphism___).Proof.path_natural_transformation;path_induction;simpl;autowithmorphism.Defined.left whiskering respectsidtoisoDefinitionidtoiso_whisker_lCDE(F:FunctorDE)(GG':FunctorCD)(T:G=G'):whisker_lF(Category.Morphisms.idtoiso(_->_)T:morphism___)= (Category.Morphisms.idtoiso(_->_) (ap_T) :morphism___).Proof.path_natural_transformation;path_induction;simpl;autowithfunctor.Defined.right whiskering respectsidtoisoDefinitionidtoiso_whisker_rCDE(FF':FunctorDE)(T:F=F')(G:FunctorCD):whisker_r(Category.Morphisms.idtoiso(_->_)T:morphism___)G= (Category.Morphisms.idtoiso(_->_) (ap(fun_=>_o_)%functorT) :morphism___).Proof.path_natural_transformation;path_induction;simpl;autowithfunctor.Defined.Endcomposition.Argumentsisisomorphism_compose{HCDF'F''}T'{F}T{H0H1}.Argumentsiso_whisker_l{H}CDEFGG'T{H0}.Argumentsiso_whisker_r{H}CDEFF'TG{H0}.Equalities induced by isomorphisms of objectsSectionobject_isomorphisms.Lemmapath_components_of_isisomorphism`{IsIsomorphismCsdm}D(FG:FunctorCD) (T:NaturalTransformationFG): (G_1m)^-1o(TdoF_1m) =Ts.Proof.applyiso_moveR_Vp.applycommutes.Qed.Lemmapath_components_of_isisomorphism'`{IsIsomorphismCsdm}D(FG:FunctorCD) (T:NaturalTransformationFG): (G_1moTs)o(F_1m)^-1 =Td.Proof.applyiso_moveR_pV.symmetry.applycommutes.Qed.Definitionpath_components_of_isomorphic`(m: @IsomorphicCsd)D(FG:FunctorCD) (T:NaturalTransformationFG): (G_1m)^-1o(TdoF_1m) =Ts:= @path_components_of_isisomorphism___mmDFGT.Definitionpath_components_of_isomorphic'`(m: @IsomorphicCsd)D(FG:FunctorCD) (T:NaturalTransformationFG): (G_1moTs)o(F_1m)^-1 =Td:= @path_components_of_isisomorphism'___mmDFGT.Endobject_isomorphisms.

--- Miscellaneous\IWType.html ---
IWTypeLibrary IWTypeRequireImportBasics.RequireImportTypes.ForallTypes.SigmaTypes.ProdTypes.WType.In this file we define indexed W-types. We show that indexed W-types can be reduced to W-types whilst still having definitional computation rules. We also characterize the path space of indexed W-types. This allows us to derive sufficient conditions for an indexed W-type to be truncated.This is mostly adapted from Jasper Hugunin's formalization in coq: https://github.com/jashug/IWTypesOn a more meta-theoretic note, this partly justifies the use of indexed inductive types in Coq with respect to homotopy type theory.InductiveIW(I:Type)The indexing type(A:Type)The type of labels / constructors / data(B:A->Type)The the type of arities / arguments / children(i:A->I)The index map (for labels)(j:forallx,Bx->I)The index map for arguments:I->Type:=|iw_sup(x:A): (forall(y:Bx),IWIABij(jxy)) ->IWIABij(ix).Definitioniw_label{ABIij} {l:I} (w:IWIABijl) :A:=matchwwith|iw_supxy=>xend.Definitioniw_arity{ABIij} (l:I) (w:IWIABijl):forall(y:B(iw_labelw)),IWIABij(j(iw_labelw)y) :=matchwwith|iw_supxy=>yend.Definitionpath_index_iw_label{ABIij} (l:I) (w:IWIABijl):i(iw_labelw) =l.Proof.bydestructw.Defined.Definitioniw_eta{ABIij} (l:I) (w:IWIABijl):path_index_iw_labellw#iw_supIABij(iw_labelw) (iw_aritylw) =w.Proof.bydestructw.Defined.We have a canonical map from the IW-type to the fiber of the index mapDefinitioniw_to_hfiber_index{ABIij} (l:I) :IWIABijl->hfiberil.Proof.introsw.exists(iw_labelw).applypath_index_iw_label.Defined.Definitionpointwise_paths_ind`{Funext} {A:Type} {B:A->Type}(a:forallx,Bx)(P:forallb,a==b->Type)(f:Pa(fun_=> 1%path)){b:forallx,Bx} (p:a==b):Pbp.Proof.refine(equiv_indapD10(Pb)_p).intros[].exactf.Defined.Reduction of indexed W-types to W-typesJasper Hugunin found this construction (typecheck unindexed trees) in "Indexed Containers by Thorsten Altenkirch and Peter Morris". http://www.cs.nott.ac.uk/~psztxa/publ/ICont.pdf
This references the following:M. Abbott, T. Altenkirch, and N. Ghani. Containers - constructing strictly positive types. Theoretical Computer Science, 342:327, September 2005. Applied Semantics: Selected Topics.N. Gambino and M. Hyland. Wellfounded trees and dependent polynomial functors. In S. Berardi, M. Coppo, and F. Damiani, editors, types for Proofs and Programs (TYPES 2003), Lecture Notes in Computer Science, 2004as previous examples of the technique.SectionReduction.Context(I:Type) (A:Type) (B:A->Type)(i:A->I) (j:forallx,Bx->I).FixpointIsIndexedBy(x:I) (w:WAB) :Type:=matchwwith|w_supab=> (ia=x) * (forallc,IsIndexedBy(jac) (bc))end.DefinitionIW'(x:I) :=sig(IsIndexedByx).Definitioniw_sup'(x:A) (y:forallz:Bx,IW'(jxz)) :IW'(ix):= (w_supABx(funa=>pr1(ya)); (idpath, (funa=>pr2(ya)))).We can derive the induction principle for IW-typesDefinitionIW'_ind(P:foralli,IW'i->Type)(S:forallxy, (forallc,P_(yc)) ->P_(iw_sup'xy)):forallxw,Pxw.Proof.introsx[wr].revertwxr.inductionwas[abk].introsx[pIH].destructp.refine(Sa(func=> (bc;IHc))_).introsc.applyk.Defined.We have definitional computation rules for this eliminator.DefinitionIW'_ind_beta_iw_sup'(P:foralli,IW'i->Type)(S:forallxy, (forallc,P_(yc)) ->P_(iw_sup'xy))xy:IW'_indPS_(iw_sup'xy) =Sxy(func=>IW'_indPS_(yc)):=idpath.Showing that IW-types are equivalent to W-types requries funext.Definitionequiv_wtype_iwtype`{Funext} (x:I):IW'x<~>IWIABijx.Proof.snrapplyequiv_adjointify.{rapply(IW'_ind(funl_=>IWIABijl)).introsabc.applyiw_sup.introsy.applyc. }{rapply(IW_rectIABij(funl_=>IW'l)).introsabc.applyiw_sup'.introsy.applyc. }{rapply(IW_rectIABij(funxy=>IW'_ind__x_=y)).cbn;introsabc.applyap.funexty.applyc. }simpl.introy.rapply(IW'_ind(funxy=>IW_rectIABij__x_=y)).cbn;introsabc.applyap.funextd.applyc.Defined.EndReduction.Characterization of path types of IW-types. Argument due to Jasper Hugunin.SectionPaths.Context`{Funext}(I:Type) (A:Type) (B:A->Type)(i:A->I) (j:forallx,Bx->I).We wish to show that path types of IW-types are IW-types themselves. We do this by showing the path type satisfies the same induction principle as the IW-type hence they are equivalent.LetI':Type:= {k:I&IWIABijk*IWIABijk}.LetA':Type:= {e:A& (forallc,IWIABij(jec)) * (forallc,IWIABij(jec))}.LetB':A'->Type:=funX=>BX.1.Leti':A'->I':=functor_sigmai(funa:A=>functor_prod(iw_supIABija) (iw_supIABija)).Letj':forallk,B'k->I':=funkc=> (jk.1c; (fstk.2c,sndk.2c)).LetIWPath:I'->Type:=funx=>fst(pr2x) =snd(pr2x).Definitioniwpath_sup(x:A'): (forally:B'x,IWPath(j'xy)) ->IWPath(i'x).Proof.destructxas[x[c1c2]].introsy.unfoldIWPath.cbn;applyap.funextl.applyy.Defined.Definitioniwpath_sup_refl(x:A) (a:forallc:Bx,IWIABij(jxc)):iwpath_sup(x; (a,a)) (apD101) =idpath.Proof.unfoldiwpath_sup.rewritepath_forall_1.reflexivity.Defined.SectionInd.Context(P:forallxab,IWPathxab->Type)(S:forallab, (forallc,P_(bc)) ->P(i'a) (iwpath_supab)).DefinitionIWPath_ind_refl:forallla,P(l; (a,a))idpath.Proof.rapply(IW_rectIABij(funla=>P(l; (a,a))idpath)).introsxaq.pose(S(x; (a,a))_q)asp.unfoldiwpath_supinp.refine(transport(P(ix; (iw_supIABijxa,iw_supIABijxa)))_p).change(ap(iw_supIABijx) (path_forallaa(apD10idpath))=ap(iw_supIABijx) 1%path).refine(ap__).applyeissect.Defined.DefinitionIWPath_ind:forallxp,Pxp.Proof.intros[x[ab]].unfoldIWPath;cbn.destructp.applyIWPath_ind_refl.Defined.The computation rule for the induction principle.DefinitionIWPath_ind_beta_iwpath_sup(x:A') (h:forally:B'x,IWPath(j'xy)):IWPath_ind_(iwpath_supxh)=Sxh(func=>IWPath_ind_(hc)).Proof.destructxas[x[ab]].cbvinh.refine(_@_).{refine(_@ap_(eisadj(path_forall__)h)).refine(paths_ind_(funbp'=>paths_ind_(funrp''=>P(ix; (iw_supIABijxa,r))p'')(IWPath_ind_refl(ix) (iw_supIABijxa))_(ap(iw_supIABijx)p')=paths_rec(path_forall__(apD10p'))(funp''=>P(_; (_,_)) (ap(iw_supIABijx)p''))(S(x; (a,b)) (apD10p')(func=>IWPath_ind(_; (_,_)) (apD10p'c)))p'(eissectapD10p'))___).exact(transport_compose____)^. }bycbn;destruct(eisretrapD10h).Defined.EndInd.The path type of an IW-type is again an IW-type.Definitionequiv_path_iwtype(x:I) (ab:IWIABijx):IWI'A'B'i'j'(x; (a,b)) <~>a=b.Proof.change(IWI'A'B'i'j'(x; (a,b)) <~>IWPath(x; (a,b))).snrapplyequiv_adjointify.{introsy.inductionyas[efg].applyiwpath_sup.introsy.applyg. }{introsy.inductionyas[efg]usingIWPath_ind.applyiw_sup.introsy.applyg. }{introsy;cbn.inductionyas[a'b'IH]usingIWPath_ind.rewriteIWPath_ind_beta_iwpath_sup.simpl;f_ap.funextc.applyIH. }introsy;cbn.inductionyas[efIH].rewriteIWPath_ind_beta_iwpath_sup.f_ap;funextc.applyIH.Defined.Characterization of fiberWe begin with two auxillary lemmas that will be explained shortly.Local Definitionadjust_hfiber{XY} {f:X->Y} {yz}:hfiberfy->y=z->hfiberfz:=fun'(x;p) =>matchpwithidpath=>funq=> (x;q)end.Local Definitionadjust_hfiber_idpath{XY} {f:X->Y} {yxp}:adjust_hfiber(f:=f)xp(idpath:y=y) =xp.Proof.bydestructxpas[x[]].Defined.We wish to show an induction principle coming from the path type of the fiber. However to do this we need to be a bit more general by allowing the elements of the IW-type to differ in label upto equality. This allows us to do prove this induction principle easily, and later we will derive the induction principle where the labels are the same.Local Definitionpath_iw_to_hfiber_ind'(P:forall(lalb:I) (le:lb=la) (a:IWIABijla) (b:IWIABijlb),iw_to_hfiber_indexlaa=adjust_hfiber(iw_to_hfiber_indexlbb)le->Type)(h:forallxab,P(ix) (ix)idpath(iw_supIABijxa) (iw_supIABijxb)idpath):foralllalbleabp,Plalbleabp.Proof.introslalbleab.destructaas[xacha],bas[xbchb].introsp.refine(paths_ind_(fun_q=>forallchb,P____(iw_sup______chb)q)__pchb).introsx.applyh.Defined.Induction principle for paths in the fiber.Local Definitionpath_iw_to_hfiber_ind(P:forall(l:I) (ab:IWIABijl),iw_to_hfiber_indexla=iw_to_hfiber_indexlb->Type)(h:forallxab,P(ix) (iw_supIABijxa) (iw_supIABijxb)idpath):foralllabp,Plabp.Proof.introslabp.transparentassert(Q: (forall(lalb:I) (le:lb=la)(a:IWIABijla) (b:IWIABijlb),iw_to_hfiber_indexlaa=adjust_hfiber(iw_to_hfiber_indexlbb)le->Type)).{introslalble.destructle.introsa'b'p'.refine(Plb___).exact(p'@adjust_hfiber_idpath). }transparentassert(h': ((forall(x:A) (ab:forally:Bx,IWIABij(jxy)),Q(ix) (ix)idpath(iw_supIABijxa) (iw_supIABijxb)idpath))).{introsxa'b'.applyh. }pose(path_iw_to_hfiber_ind'Qh'llidpathab(p@adjust_hfiber_idpath^))asq.refine(transport(Plab)_q).applyconcat_pV_p.Defined.Induction principle for families over hfiber of i'Local Definitionhfiber_ind(P:foralllab,hfiberi'(l; (a,b)) ->Type)(h:forallxab,P(ix) (iw_supIABijxa)(iw_supIABijxb) ((x; (a,b));idpath)):foralllabp,Plabp.Proof.introslab[[x[yz]]p].unfoldi',functor_sigma,functor_prodinp;simplinp.revertp.refine(equiv_ind(equiv_path_sigma___)__).intros[pq];simplinp,q.destructp.revertq;cbn.refine(equiv_ind(equiv_path_prod__)__).cbn;intros[pq].destructp,q.applyh.Defined.Local Definitionpath_iw_to_hfiberlab:iw_to_hfiber_indexla=iw_to_hfiber_indexlb->hfiberi'(l; (a,b)):=path_iw_to_hfiber_ind(funlab_=>hfiberi'(l; (a,b)))(funxab=> ((x; (a,b));idpath))lab.Local Definitionhfiber_to_path_iwlab:hfiberi'(l; (a,b)) ->iw_to_hfiber_indexla=iw_to_hfiber_indexlb:=hfiber_ind(funlab_=>iw_to_hfiber_indexla=iw_to_hfiber_indexlb)(funxab=>idpath)lab.Local Definitionpath_iw_to_hfiber_to_path_iw:foralllabp,path_iw_to_hfiberlab(hfiber_to_path_iwlabp) =p.Proof.refine(hfiber_ind(funlabp=>path_iw_to_hfiberlab(hfiber_to_path_iwlabp) =p)_).introsxab.reflexivity.Defined.Local Definitionhfiber_to_path_iw_to_hfiber:foralllabp,hfiber_to_path_iwlab(path_iw_to_hfiberlabp) =p.Proof.rapplypath_iw_to_hfiber_ind.introsxab.reflexivity.Defined.The path type of the fibers ofiis equivalent to the fibers ofi'.Definitionequiv_path_hfiber_index(l:I) (ab:IWIABijl):iw_to_hfiber_indexla=iw_to_hfiber_indexlb<~>hfiberi'(l; (a,b)).Proof.srapplyequiv_adjointify.+applypath_iw_to_hfiber.+applyhfiber_to_path_iw.+rapplypath_iw_to_hfiber_to_path_iw.+rapplyhfiber_to_path_iw_to_hfiber.Defined.EndPaths.Some properties of the (fibers of the) index mapihold for the IW-type as well. For example, ifiis an embedding then the corresponding IW-type is a hprop.IW-types preserve truncationWe can show that if the index map is an embedding then the IW-type is a hprop.Global Instanceishprop_iwtype`{Funext}(I:Type) (A:Type) (B:A->Type)(i:A->I) (j:forallx,Bx->I) {h:IsEmbeddingi}:forallx,IsHProp(IWIABijx).Proof.introsl.applyhprop_allpath.introsx.inductionxas[xx'IHx].introsy.We need to induct on y and at the same time generalize the goal to become a dependent equality. This can be difficult to do with tactics so we just refine the corresponding match statement. All we have done is turn the RHS into a transport over an equality allowing the induction on y to go through.refine(matchyin(IW_____l)return(forallq:l=ix,iw_supIABijxx'=q#y)withiw_supyy'=>_endidpath).introsq.pose(r:= @path_ishprop_(h(ix)) (x;idpath) (y;q)).set(r2:=r..2);cbninr2.set(r1:=r..1)inr2;cbninr1.clearbodyr1r2.destructr1.simplinr2.destructr2.cbn;f_ap.funexta.applyIHx.Defined.Now by induction on truncation indices we show that IW-types are n.+1 truncated if the index maps are also n.+1 truncated.Global Instanceistrunc_iwtype`{Funext}(I:Type) (A:Type) (B:A->Type) (i:A->I)(j:forallx,Bx->I) (n:trunc_index) {h:IsTruncMapn.+1i} (l:I):IsTruncn.+1 (IWIABijl).Proof.We need a general induction hypothesisrevertnIABijhl.inductionnas[|nIHn].1:applyishprop_iwtype.introsIABijhl.applyistrunc_S.introsxy.refine(istrunc_equiv_istrunc_(equiv_path_iwtypeIABijlxy) (n:=n.+1)).applyIHn.intros[k[ab]].The crucial step is to characterize the fiber ofi'which was done previously.apply(istrunc_equiv_istrunc_(equiv_path_hfiber_indexIABijkab)).Defined.Decidable equality for IW-typesIf A has decidable paths then it is a hset and therefore equality of sigma types over it are determined by the second component.Local Definitioninj_right_pair_on{A:Type} {A_dec:DecidablePathsA}(P:A->Type) (x:A) (yy':Px)(H: (x;y) = (x;y')) :y=y'.Proof.apply(equiv_path_sigma___)^-1%equivinH.destructHas[pq];cbninp,q.assert(r:idpath=p)byapplypath_ishprop.destructr.exactq.Defined.IW-types have decidable equality if liftP holds and the fibers of the indexing map have decidable paths. Notably, if B x is finitely enumerable, then liftP holds.SectionDecidablePaths.Context`{Funext}(I:Type) (A:Type) (B:A->Type) (i:A->I) (j:forallx,Bx->I)(liftP:forall(x:A) (P:Bx->Type),(forallc,Decidable(Pc)) ->Decidable(forallc,Pc))(fibers_dec:forallx,DecidablePaths(hfiberix)).Letchildren_for(x:A) :Type:=forallc,IWIABij(jxc).Letgetfib{x} (a:IWIABijx) :hfiberix:=matchawithiw_supx_=> (x;idpath)end.Letgetfib_computesxychildrenp:getfib(paths_rec(iy)_(iw_sup_____ychildren) (ix)p) =exist_yp:=matchpreturngetfib(paths_rec__(iw_sup_____ychildren)_p) =exist_ypwithidpath=>idpathend.Letgetfib_plus{x} (a:IWIABijx): {f:hfiberix&children_for(pr1f)}:=matchawithiw_supxc=> ((x;idpath);c)end.Letchildren_eq(x:A) (c1c2:forallc,IWIABij(jxc)):iw_supIABijxc1=iw_supIABijxc2->c1=c2:=funr=>inj_right_pair_on(funf=>children_for(pr1f))(x;idpath)__(apgetfib_plusr).Fixpointdecide_eql(a:IWIABijl) :forallb,Decidable(a=b).Proof.destructaas[xc1].introb.transparentassert(decide_children: (forallc2,Decidable(c1=c2))).{introsc2.destruct(liftPx(func=>c1c=c2c) (func=>decide_eq_(c1c) (c2c)))as[p|p].+left;byapplypath_forall.+right;introh;byapplyp,apD10. }snrefine(matchbin(IW_____l)returnforalliy:l=ix,Decidable(iw_supIABijxc1=paths_recl(IWIABij)b(ix)iy)withiw_supyc2=>funiy:iy=ix=>_endidpath).destruct(fibers_dec(ix) (x;idpath) (y;iy))as[feq|fneq].+refine(matchfeqin(_= (y;iy))returnforallc2,Decidable(iw_sup_____xc1=paths_rec(iy) (IWIABij) (iw_sup_____yc2) (ix)iy)withidpath=>_endc2).cbn;introsc3.destruct(decide_childrenc3)as[ceq|cneq].-left;exact(ap_ceq).-right;introsr;applycneq.exact(children_eqxc1c3r).+right;introsr;applyfneq.exact(apgetfibr@getfib_computesxyc2iy).Defined.Definitiondecidablepaths_iwtype:forallx,DecidablePaths(IWIABijx).Proof.introsxab.applydecide_eq.Defined.EndDecidablePaths.

--- Miscellaneous\Join.html ---
JoinLibrary JoinRequireExportJoin.Core.RequireExportJoin.TriJoin.RequireExportJoin.JoinAssoc.RequireExportJoin.JoinSusp.

--- Miscellaneous\JoinAssoc.html ---
JoinAssocLibrary JoinAssocRequireImportBasicsTypesWildCatJoin.CoreJoin.TriJoinSpaces.Nat.Core.The associativity ofJoinWe use the recursion principle for the triple join (from TriJoin.v) to prove the associativity of Join.  We'll use the common technique of combining symmetry and a twist equivalence.  Temporarily writing * for Join, symmetry says thatA*B<~>B*Aand the twist says thatA*(B*C)<~>B*(A*C).  From these we get a composite equivalenceA*(B*C)<~>A*(C*B)<~>C*(A*B)<~>(A*B)*C.  One advantage of this approach is that both symmetry and the twist are their own inverses, so there are fewer maps to define and fewer composites to prove are homotopic to the identity. Symmetry is proved in Join/Core.v.The twist equivalenceTriJoinABC<~>TriJoinBACWe prove the twist equivalence using the Yoneda lemma.  The idea is thatTriJoinABC->Pis equivalent (as a 0-groupoid) toTriJoinRecDataABCP, and the latter is very symmetrical by construction, which makes it easy to show that it is equivalent toTriJoinRecDataBACP.  Going back along the first equivalence gets us toTriJoinBAC->P.  These equivalences are natural inP, so the twist equivalence follows from the Yoneda lemma.First we define a map of 0-groupoids that will underlie the natural equivalence.Definitiontrijoinrecdata_twist(ABCP:Type):trijoinrecdata_0gpdABCP$->trijoinrecdata_0gpdBACP.Proof.snrapplyBuild_Morphism_0Gpd.(* The map of typesTriJoinRecDataABCP->TriJoinRecDataBACP: *)-cbn.intros[f1f2f3f12f13f23f123].snrapply(Build_TriJoinRecDataf2f1f3).+introsba;exact(f12ab)^.+exactf23.+exactf13.+introsabc;cbnbeta.applymoveR_Vp.symmetry;applyf123.(* It respects the paths. *)-applyBuild_Is0Functor.introsfgh;cbnin*.snrapplyBuild_TriJoinRecPath;intros;simpl.1, 2, 3, 5, 6:applyh.+cbnzeta.prism_ind_twoghba_X_;cbnbeta.applyconcat_p1_1p.+cbnbetazeta.prism_indghbac;cbnbeta.bytriangle_indfbac.Defined.This map is its own inverse in the 1-category of 0-groupoids.Definitiontrijoinrecdata_twist_inv(ABCP:Type):trijoinrecdata_twistBACP$otrijoinrecdata_twistABCP$==Id_.Proof.introf;simpl.bundle_trijoinrecpath.all:intros;cbn.-applyinv_V.-reflexivity.-reflexivity.-bytriangle_indfabc.Defined.We get the twist natural equivalence onTriJoinRecData.Definitiontrijoinrecdata_twist_natequiv(ABC:Type):NatEquiv(trijoinrecdata_0gpd_funABC) (trijoinrecdata_0gpd_funBAC).Proof.snrapplyBuild_NatEquiv.(* An equivalence of 0-groupoids for eachP: *)-introP.snrapplycate_adjointify.1, 2:applytrijoinrecdata_twist.1, 2:applytrijoinrecdata_twist_inv.(* Naturality: *)-snrapplyBuild_Is1Natural.introsPQgf;simpl.bundle_trijoinrecpath.all:intros;cbn.+symmetry;applyap_V.+reflexivity.+reflexivity.+bytriangle_indfbac.Defined.Combining with the recursion equivalencetrijoin_rec_inv_natequivand its inverse gives the twist natural equivalence between the representable functors.Definitiontrijoinrecdata_fun_twist(ABC:Type):NatEquiv(opyon_0gpd(TriJoinABC)) (opyon_0gpd(TriJoinBAC)):=natequiv_compose(trijoin_rec_natequivBAC)(natequiv_compose(trijoinrecdata_twist_natequivABC) (trijoin_rec_inv_natequivABC)).The Yoneda lemma for 0-groupoid valued functors therefore gives us an equivalence between the representing objects.  We mark this with a prime, since we'll use a homotopic map with a slightly simpler definition.Definitionequiv_trijoin_twist'(ABC:Type):TriJoinABC<~>TriJoinBAC.Proof.rapply(opyon_equiv_0gpd(A:=Type)).applytrijoinrecdata_fun_twist.Defined.It has the nice property that the underlying function of the inverse is againequiv_trijoin_twist', with arguments permuted.Local Definitiontrijoin_twist_check1(ABC:Type): (equiv_trijoin_twist'ABC)^-1 =equiv_fun(equiv_trijoin_twist'BAC):=idpath.The definition we end up with is almost the same as the obvious one, but has some extraapidmaps in it.Local Definitiontwijoin_twist_check2(ABC:Type):equiv_fun(equiv_trijoin_twist'ABC)=trijoin_rec{|j1:=join2;j2:=join1;j3:=join3;j12:=fun(b:A) (a:B) => (apidmap(join12ab))^;j13:=fun(b:A) (c:C) =>apidmap(join23bc);j23:=fun(a:B) (c:C) =>apidmap(join13ac);j123:=fun(a:A) (b:B) (c:C) =>moveR_Vp___(ap_triangleidmap(join123bac))^ |}:=idpath.The next two give the obvious definition.Definitiontrijoin_twist_recdata(ABC:Type):TriJoinRecDataABC(TriJoinBAC):=Build_TriJoinRecDatajoin2join1join3(funab=> (join12ba)^)join23join13(funabc=>moveR_Vp___(join123bac)^).Definitiontrijoin_twist(ABC:Type):TriJoinABC->TriJoinBAC:=trijoin_rec(trijoin_twist_recdataABC).As an aside, note thattrijoin_twistcomputes nicely onjoinr.Local Definitiontrijoin_twist_joinr(ABC:Type):trijoin_twistABCojoinr=functor_joinidmapjoinr:=idpath.The obvious definition is homotopic to the definition via the Yoneda lemma.Definitiontrijoin_twist_homotopic(ABC:Type):trijoin_twistABC==equiv_trijoin_twist'ABC.Proof.symmetry.Both sides aretrijoin_recapplied toTriJoinRecData:rapply(fmaptrijoin_rec).bundle_trijoinrecpath;intros;cbn.1:refine(apinverse_).1, 2, 3:applyap_idmap.generalize(join123bac).generalize(join23(A:=B)ac).generalize(join13(B:=A)bc).generalize(join12(C:=C)ba).generalize(join3(A:=B) (B:=A)c).generalize(join2(A:=B) (C:=C)a).generalize(join1(B:=A) (C:=C)b).introsk1k2k3k12k13k23k123.inductionk12,k23,k123.reflexivity.Defined.Therefore the obvious definition is also an equivalence, and the inverse function can also be chosen to betrijoin_twist.Definitionequiv_trijoin_twist(ABC:Type):TriJoinABC<~>TriJoinBAC:=equiv_homotopic_inverse(equiv_trijoin_twist'ABC)(trijoin_twist_homotopicABC)(trijoin_twist_homotopicBAC).The associativity ofJointrijoin_twistcorresponds to the permutation (1,2).  The equivalence corresponding to the permutation (2,3) also plays a key role, so we name it here.Definitiontrijoin_id_symABC:TriJoinABC<~>TriJoinACB:=equiv_functor_joinequiv_idmap(equiv_join_symBC).Argumentstrijoin_id_sym:simplnever.Definitionjoin_assocABC:JoinA(JoinBC) <~>Join(JoinAB)C.Proof.refine(_oEtrijoin_id_sym___).refine(_oEequiv_trijoin_twist___).applyequiv_join_sym.Defined.Argumentsjoin_assoc:simplnever.As a consequence, we get associativity of powers.Corollaryjoin_join_powerAnm:Join(join_powerAn) (join_powerAm) <~>join_powerA(n+m)%nat.Proof.inductionnas[|nIHn].1:exact(equiv_join_empty_left_).simpl.refine(_oE(join_assoc___)^-1%equiv).exact(equiv_functor_joinequiv_idmapIHn).Defined.Naturality oftrijoin_twistOur goal is to prove thattrijoin_twistA'B'C'ofunctor_joinf(functor_joingh)is homotopic tofunctor_joing(functor_joinfh)otrijoin_twistABC.We first give a way to write anything of the formtrijoin_recfotrijoin_twistABCastrijoin_recapplied to someTriJoinRecData.Definitiontrijoin_rec_trijoin_twist{ABCP} (f:TriJoinRecDataBACP):trijoin_recfotrijoin_twistABC==trijoin_rec(trijoinrecdata_twist____f).Proof.(* We first replacetrijoin_twistwithequiv_trijoin_twist'. *)transitivity(trijoin_recfoequiv_trijoin_twist'ABC).1:exact(funx=>ap(trijoin_recf) (trijoin_twist_homotopicABCx)).(* The LHS is now the twist natural transformation applied toId, followed by postcomposition; naturality states that that is the same as the natural trans applied totrijoin_recf. *)refine((isnat_natequiv(trijoinrecdata_fun_twistBAC) (trijoin_recf)_)^$ $@_).(* The LHS simplifies totrijoinrecdata_fun_twistapplied totrijoin_recf.  The former is a composite oftrijoin_rec,trijoinrecdata_twistandtrijoin_rec_inv, so we can write the LHS as: *)change(?L$== ?R)with(trijoin_rec(trijoinrecdata_twistBACP(trijoin_rec_inv(trijoin_recf))) $==R).refine(fmaptrijoin_rec_).refine(fmap(trijoinrecdata_twistBACP)_).applytrijoin_rec_beta.Defined.Naturality oftrijoin_twist.  This version usesfunctor_trijoinand simply combines previous results.Definitiontrijoin_twist_nat'{ABCA'B'C'} (f:A->A') (g:B->B') (h:C->C'):trijoin_twistA'B'C'ofunctor_trijoinfgh==functor_trijoingfhotrijoin_twistABC.Proof.introx.rhsnrapplytrijoin_rec_trijoin_twist.nrapplytrijoin_rec_functor_trijoin.Defined.And now a version usingfunctor_join.Definitiontrijoin_twist_nat{ABCA'B'C'} (f:A->A') (g:B->B') (h:C->C'):trijoin_twistA'B'C'ofunctor_joinf(functor_joingh)==functor_joing(functor_joinfh)otrijoin_twistABC.Proof.introx.lhsnrefine(ap_(functor_trijoin_as_functor_joinfghx)).rhsnrapplyfunctor_trijoin_as_functor_join.applytrijoin_twist_nat'.Defined.Naturality oftrijoin_id_symNaturality oftrijoin_id_sym, usingfunctor_join.  In this case, it's easier to do this version first.Definitiontrijoin_id_sym_nat{ABCA'B'C'} (f:A->A') (g:B->B') (h:C->C'):trijoin_id_symA'B'C'ofunctor_joinf(functor_joingh)==functor_joinf(functor_joinhg)otrijoin_id_symABC.Proof.introx;simpl.lhs_Vnrapplyfunctor_join_compose.rhs_Vnrapplyfunctor_join_compose.applyfunctor2_join.-reflexivity.-applyjoin_sym_nat.Defined.Naturality oftrijoin_id_sym, usingfunctor_trijoin.Definitiontrijoin_id_sym_nat'{ABCA'B'C'} (f:A->A') (g:B->B') (h:C->C'):trijoin_id_symA'B'C'ofunctor_trijoinfgh==functor_trijoinfhgotrijoin_id_symABC.Proof.introx.lhs_Vnrefine(ap_(functor_trijoin_as_functor_joinfghx)).rhs_Vnrapplyfunctor_trijoin_as_functor_join.applytrijoin_id_sym_nat.Defined.Naturality ofjoin_assocSincejoin_associs a composite ofjoin_sym,trijoin_twistandtrijoin_id_sym, we just use their naturality.Definitionjoin_assoc_nat{ABCA'B'C'} (f:A->A') (g:B->B') (h:C->C'):join_assocA'B'C'ofunctor_joinf(functor_joingh)==functor_join(functor_joinfg)hojoin_assocABC.Proof.(* We'll work from right to left, as it is easier to work near the head of a term. *)introx.unfoldjoin_assoc;cbn.(* First we pass thefunctor_joinss through the outerjoin_sym. *)rhs_Vnrapplyjoin_sym_nat.(* Strip off the outerjoin_sym. *)apply(ap_).(* Next we pass thefunctor_joins throughtrijoin_twist. *)rhs_Vnrapplytrijoin_twist_nat.(* Strip off thetrijoin_twist. *)apply(ap_).(* Finally, we pass thefunctor_joins throughtrijoin_id_sym. *)applytrijoin_id_sym_nat.Defined.Global Instancejoin_associator:AssociatorJoin.Proof.snrapplyBuild_Associator;simpl.-exactjoin_assoc.-snrapplyBuild_Is1Natural.intros[[AB]C] [[A'B']C'] [[fg]h];cbn.applyjoin_assoc_nat.Defined.The Triangle LawThe unitors were defined in Join/Core.v, since they do not require associativity.Here's a version of the triangle law expressed usingtrijoin_twistinstead ofjoin_assoc, and only using the right unitor. Since the left unitor is defined usingjoin_sym, the usual triangle law follows.Definitionjoin_trianglelaw'AB:join_symBAofunctor_joinidmap(equiv_join_empty_rightA)otrijoin_twistABEmpty==functor_joinidmap(equiv_join_empty_rightB).Proof.(* A direct proof withJoin_indthree times is not hard, but the path algebra is slightly simpler if we manipulate things ahead of time usingfunctor_join_join_recandtrijoin_rec_trijoin_twist. *)introx.rapplymoveR_equiv_M.unfoldequiv_join_empty_rightat1;cbn.lhsnrapplyfunctor_join_join_rec;cbn.lhsnrapplytrijoin_rec_trijoin_twist.revertx.applymoveR_trijoin_rec.snrapplyBuild_TriJoinRecPath;intros;cbn.3, 5, 6, 7:bydestructc.-reflexivity.-reflexivity.-applyequiv_p1_1q.symmetry.lhsnrapply(ap_compose(functor_joinidmap_)_(join12ab)).lhsnrapplyap.1:applyfunctor_join_beta_jglue.applyjoin_sym_beta_jglue.Defined.Definitionjoin_trianglelaw:TriangleIdentityJoinEmpty.Proof.introsABx;cbn.lhsnrapply(functor_join_composeidmap_idmap_).lhs_Vnrapplyjoin_trianglelaw'.unfoldjoin_assoc;cbn.applyjoin_sym_nat.Defined.The hexagon axiomFor the hexagon, we'll need to know how to composetrijoin_id_symwith something of the formtrijoin_recf. For some reason, the proof is harder than it was fortrijoin_twist.This describes the transformation onTriJoinRecDatacorresponding to precomposition withtrijoin_id_sym, as in the next result.Definitiontrijoinrecdata_id_sym{ABCP} (f:TriJoinRecDataABCP):TriJoinRecDataACBP.Proof.snrapply(Build_TriJoinRecData(j1f) (j3f) (j2f));intros.-apply(j13f).-apply(j12f).-symmetry;apply(j23f).-cbnbeta.applymoveR_pV;symmetry.apply(j123f).Defined.This is analogous totrijoin_rec_trijoin_twistabove, withtrijoin_twistreplaced bytrijoin_id_sym.Definitiontrijoin_rec_id_sym{ABCP} (f:TriJoinRecDataACBP):trijoin_recfotrijoin_id_symABC==trijoin_rec(trijoinrecdata_id_symf).Proof.(* First we usefunctor_join_join_recon the LHS. *)etransitivity.{refine(cat_postwhisker(A:=Type) (trijoin_recf)_).applyfunctor_join_join_rec. }unfoldjoin_sym_recdata,jl,jr,jg.(* And now we use naturality of the secondtrijoin_recon the LHS. *)refine((trijoin_rec_natABC(trijoin_recf)_)^$ $@_).refine(fmaptrijoin_rec_).(* Finally, we provide the neededTriJoinRecPath. *)bundle_trijoinrecpath;intros;cbn.-applytrijoin_rec_beta_join13.-applytrijoin_rec_beta_join12.-lhsrefine(ap_(ap_V__)).lhsrefine(ap_V(trijoin_recf)_).apply(apinverse).applytrijoin_rec_beta_join23.-unfoldprism'.rewriteap_trijoin_V.rewritetrijoin_rec_beta_join123.set(f':=f).destructfas[f1f2f3f12f13f23f123];cbn.generalize(f123acb).generalize(trijoin_rec_beta_join23f'cb);cbn.generalize(f23cb).generalize(trijoin_rec_beta_join13f'ab);cbn.generalize(f13ab).generalize(trijoin_rec_beta_join12f'ac);cbn.generalize(f12ac);cbn.introsp12beta12p13beta13p23beta23p123.inductionbeta12,beta13,beta23;cbn.rewrite3concat_p1,concat_1p.reflexivity.Defined.Here is our first hexagon law.  This is not the usual hexagon axiom, but we will see that it is equivalent, and is itself useful.  This law states that the following diagram commutes, where we write*forJoin:A * (B * C) -> A * (C * B) -> C * (A * B)
        |                            |
        v                            v
    B * (A * C) -> B * (C * A) -> C * (B * A)Here every arrow is eithertrijoin_twist___ortrijoin_id_sym___, and they alternate as you go around.  These correspond to the permutations (1,2) and (2,3) in the symmetric group on three letters.  We already know that they are their own inverses, i.e., they have order two.  The above says that the composite (1,2)(2,3) has order three.  These are the only relations in this presentation ofS_3.  Note also that every object in this diagram is parenthesized in the same way.  That will be important in our proof.Definitionhexagon_join_twist_symABC:trijoin_id_symCABotrijoin_twistACBotrijoin_id_symABC==trijoin_twistBCAotrijoin_id_symBACotrijoin_twistABC.Proof.(* It's enough to show that both sides induces the same natural transformation under the covariant Yoneda embedding, i.e., after postcomposing with a general functionf. *)rapply(opyon_faithful_0gpd(A:=Type)).introsPf.(* We replacefbytrijoin_rectfor generict.  This will allow induction later. *)poseproof(p:=issect_trijoin_rec_invf).introx;refine((p_)^ @_@p_);clearp.generalize(trijoin_rec_invf)ast.introt;clearf.(* Now we use how these various maps postcompose withtrijoin_recfoo. *)lhsrapplytrijoin_rec_id_sym.lhsrapplytrijoin_rec_trijoin_twist.lhsrapplytrijoin_rec_id_sym.rhsrapplytrijoin_rec_trijoin_twist.rhsrapplytrijoin_rec_id_sym.rhsrapplytrijoin_rec_trijoin_twist.revertx;refine(fmaptrijoin_rec_).bundle_trijoinrecpath;intros;cbn.1, 2, 3:reflexivity.bytriangle_indtcba.Defined.Next we paste on a naturality square forjoin_symon the right of the diagram:A * (B * C) -> A * (C * B) -> C * (A * B) -> (A * B) * C
        |                            |                |
        v                            v                v
    B * (A * C) -> B * (C * A) -> C * (B * A) -> (B * A) * CThe new horizontal maps arejoin_sym__and the new vertical map isfunctor_join(join_symAB)idmap. This makes both horizontal composites definitionally equal tojoin_assoc___, so the statement is about a square.Definitionsquare_join_sym_assoc_twistABC:functor_join(join_symAB)idmapojoin_assocABC==join_assocBACotrijoin_twistABC.Proof.unfoldjoin_assoc;cbn.introx;lhs_Vrapplyjoin_sym_nat.applyap.applyhexagon_join_twist_sym.Defined.Finally, we paste on the defining square forjoin_assocon the left to get the hexagon axiom for the symmetric monoidal structure:A * (C * B) -> A * (B * C) -> (A * B) * C
         |              |              |
         v              v              v
    (A * C) * B -> B * (A * C) -> (B * A) * CThe right-hand square is a horizontally-compressed version of the rectangle from the previous result, whose horizontal arrows are associativity. In the left-hand square, the new vertical map isjoin_assocACBand the horizontal maps aretrijoin_id_symACBandjoin_sym(JoinAC)B.Definitionhexagon_join_assoc_symABC:functor_join(join_symAB)idmapojoin_assocABCotrijoin_id_symACB==join_assocBACojoin_sym(JoinAC)Bojoin_assocACB.Proof.introx.refine(square_join_sym_assoc_twistABC_@_).applyap.simpl.symmetry.exact(eissect(equiv_join_symB(JoinAC))_).Defined.

--- Miscellaneous\JoinSusp.html ---
JoinSuspLibrary JoinSuspRequireImportBasicsTypes.RequireImportJoin.CoreJoin.JoinAssocSuspensionSpaces.Spheres.RequireImportWildCat.RequireImportSpaces.Nat.Core.JoinBoolAis equivalent toSuspAWe give a direct proof of this fact. It is also possible to give a proof usingopyon_equiv_0gpd; see PR1769.Definitionjoin_to_susp(A:Type) :JoinBoolA->SuspA.Proof.srapplyJoin_rec.-exact(funb=>ifbthenNorthelseSouth).-exact(funa=>South).-intros[|]a.+exact(merida).+reflexivity.Defined.Definitionsusp_to_join(A:Type) :SuspA->JoinBoolA.Proof.srapply(Susp_rec(joinltrue) (joinlfalse)).introsa.exact(jglue_a@ (jglue_a)^).Defined.Global Instanceisequiv_join_to_susp(A:Type) :IsEquiv(join_to_suspA).Proof.snrapply(isequiv_adjointify_(susp_to_joinA)).-snrapplySusp_ind.1,2:reflexivity.introsa.apply(transport_paths_FFlr'(f:=susp_to_joinA)).applyequiv_p1_1q.lhsnrapply(ap__); [nrapplySusp_rec_beta_merid| ].lhsnrapply(ap_pp__(jgluefalsea)^).lhsnrefine(_@@_).1:lhsnrapplyap_V;nrapply(apinverse).1,2:nrapplyJoin_rec_beta_jglue.applyconcat_p1.-srapply(Join_ind_FFlr(join_to_suspA));cbnbeta.1:intros[|];reflexivity.1:introsa;applyjglue.introsba;cbnbeta.lhsnrefine(ap__@@ 1).1:nrapplyJoin_rec_beta_jglue.destructb.all:rhsnrapplyconcat_1p.+lhsnrefine(_@@ 1); [nrapplySusp_rec_beta_merid| ].applyconcat_pV_p.+applyconcat_1p.Defined.Definitionequiv_join_susp(A:Type) :JoinBoolA<~>SuspA:=Build_Equiv__(join_to_suspA)_.It follows that the join powers ofBoolare spheres.  These are sometimes a convenient alternative to working with spheres, so we give them a name.Definitionbool_pow(n:nat) :=join_powerBooln.Definitionequiv_bool_pow_sphere(n:nat):bool_pown<~>Sphere(n.-1).Proof.inductionnas[|nIHn].-reflexivity.-simpl.refine(_oEequiv_join_susp_).exact(emapSuspIHn).Defined.It follows that joins of spheres are spheres, starting in dimension -1.Definitionequiv_join_sphere(nm:nat):Join(Spheren.-1) (Spherem.-1) <~>Sphere(n+m)%nat.-1.Proof.refine(_oEequiv_functor_join__).2,3:symmetry;exact(equiv_bool_pow_sphere_).refine(equiv_bool_pow_sphere_oE_).applyjoin_join_power.Defined.

--- Miscellaneous\KanExtensions.html ---
KanExtensionsLibrary KanExtensionsKan ExtensionsDefinitionsRequireKanExtensions.Core.Kan Extensions assemble into functorsRequireKanExtensions.Functors.IncludeKanExtensions.Core.IncludeKanExtensions.Functors.

--- Miscellaneous\Kernel.html ---
KernelLibrary KernelRequireImportBasicsTypes.RequireImportAlgebra.Groups.Group.RequireImportAlgebra.Groups.Subgroup.RequireImportWildCat.Core.Kernels of group homomorphismsLocal OpenScopemc_scope.Local OpenScopemc_mult_scope.Definitiongrp_kernel{AB:Group} (f:GroupHomomorphismAB) :NormalSubgroupA.Proof.snrapplyBuild_NormalSubgroup.-srapply(Build_Subgroup'(funx=>fx=group_unit));cbnbeta.1:applygrp_homo_unit.introsxypq.apply(grp_homo_moveL_1M___)^-1.exact(p@q^).-introsxy;cbn;introsp.apply(grp_homo_moveL_1V___)^-1.lhs_Vnrapplygrp_inv_inv.apply(ap(-)).exact((grp_homo_moveL_1Vfxy)p)^.Defined.Corecursion principle for group kernelsPropositiongrp_kernel_corec{ABG:Group} {f:A$->B} (g:G$->A)(h:f$og==grp_homo_const) :G$->grp_kernelf.Proof.snrapplyBuild_GroupHomomorphism.-exact(funx:G=> (gx;hx)).-introsxx'.applypath_sigma_hprop;cbn.applygrp_homo_op.Defined.Theoremequiv_grp_kernel_corec`{Funext} {ABG:Group} {f:A$->B}: (G$->grp_kernelf) <~> (existsg:G$->A,f$og==grp_homo_const).Proof.srapplyequiv_adjointify.-introk.srefine(_$ok;_).1:applysubgroup_incl.introx;cbn.exact(kx).2.-intros[gp].exact(grp_kernel_corec_p).-intros[gp].applypath_sigma_hprop;unfoldpr1.applyequiv_path_grouphomomorphism;intro;reflexivity.-introk.applyequiv_path_grouphomomorphism;introx.applypath_sigma_hprop;reflexivity.Defined.Characterisation of group embeddingsPropositionequiv_kernel_isembedding`{Univalence} {AB:Group} (f:A$->B): (grp_kernelf=trivial_subgroup:>SubgroupA) <~>IsEmbeddingf.Proof.refine(_oE(equiv_path_subgroup'__)^-1%equiv).applyequiv_iff_hprop_uncurried.refine(iff_compose_(isembedding_grouphomomorphismf));split.-introsE? ?.byapplyE.-introsea;split.+applye.+introp.exact(ap_p@grp_homo_unitf).Defined.

--- Miscellaneous\KroneckerDelta.html ---
KroneckerDeltaLibrary KroneckerDeltaRequireImportBasics.OvertureBasics.DecidableSpaces.Nat.RequireImportAlgebra.Rings.Ring.RequireImportClasses.interfaces.abstract_algebra.LocalSetUniverseMinimizationToSet.LocalSetPolymorphicInductiveCumulativity.Kronecker DeltaSectionAssumeDecidable.Throughout this section, we assume that we have a typeAwith decidable equality. This will be our indexing type and can be thought of asnatfor reading purposes.Universesuv.Context{A:Type@{u}} `{DecidablePaths@{u}A} {R:Ring@{v}}.The Kronecker delta function is a function of elements ofAthat is 1 when the two numbers are equal and 0 otherwise. It is useful for working with finite sums of ring elements.Definitionkronecker_delta@{} (ij:A) :R:=ifdec(i=j)then1else0.Kronecker delta with the same index is 1.Definitionkronecker_delta_refl@{} (i:A):kronecker_deltaii= 1.Proof.unfoldkronecker_delta.generalize(dec(i=i)).byrapplydecidable_paths_refl.Defined.Kronecker delta with differing indices is 0.Definitionkronecker_delta_neq@{} {ij:A} (p:i<>j):kronecker_deltaij= 0.Proof.unfoldkronecker_delta.bydecidable_false(dec(i=j))p.Defined.Kronecker delta is symmetric in its arguments.Definitionkronecker_delta_symm@{} (ij:A):kronecker_deltaij=kronecker_deltaji.Proof.unfoldkronecker_delta.destruct(dec(i=j))as[p|q].-bydecidable_true(dec(j=i))p^.-bydecidable_false(dec(j=i)) (symmetric_neqq).Defined.An injective endofunction onApreserves the Kronecker delta.Definitionkronecker_delta_map_inj@{} (ij:A) (f:A->A)`{!IsInjectivef}:kronecker_delta(fi) (fj) =kronecker_deltaij.Proof.unfoldkronecker_delta.destruct(dec(i=j))as[p|p].-bydecidable_true(dec(fi=fj)) (apfp).-destruct(dec(fi=fj))as[q|q].+apply(injectivef)inq.contradiction.+reflexivity.Defined.Kronecker delta commutes with any ring element.Definitionkronecker_delta_comm@{} (ij:A) (r:R):r*kronecker_deltaij=kronecker_deltaij*r.Proof.unfoldkronecker_delta.destruct(dec(i=j)).-exact(rng_mult_one_r_@ (rng_mult_one_l_)^).-exact(rng_mult_zero_r_@ (rng_mult_zero_l_)^).Defined.EndAssumeDecidable.The following lemmas are specialised to when the indexing type isnat.Kronecker delta where the first index is strictly less than the second is 0.Definitionkronecker_delta_lt{R:Ring} {ij:nat} (p: (i<j)%nat):kronecker_delta(R:=R)ij= 0.Proof.applykronecker_delta_neq.introsq;destructq.byapplylt_irreflinp.Defined.Kronecker delta where the first index is strictly greater than the second is 0.Definitionkronecker_delta_gt{R:Ring} {ij:nat} (p: (j<i)%nat):kronecker_delta(R:=R)ij= 0.Proof.applykronecker_delta_neq.introsq;destructq.byapplylt_irreflinp.Defined.Kronecker delta can be used to extract a single term from a finite sum.Definitionrng_sum_kronecker_delta_l{R:Ring} (ni:nat) (Hi: (i<n)%nat)(f:forallk, (k<n)%nat->R):ab_sumn(funjHj=>kronecker_deltaij*fjHj) =fiHi.Proof.revertiHif;simple_inductionnnIHn;introsiHif.1:destruct(not_lt_zero_r_Hi).destruct(dec(i=n))as[p|p].-destructp;simpl.rewritekronecker_delta_refl.rewriterng_mult_one_l.rewrite<-rng_plus_zero_r.applyap11.{apply(ap(funh=>plus(fih))),path_ishprop. }nrapplyab_sum_zero.introskHk.rewrite(kronecker_delta_gtHk).applyrng_mult_zero_l.-simpl;lhsnrapplyap.+nrapplyIHn.applyneq_iff_lt_or_gtinp.destructp; [assumption|].applygt_iff_not_leqinHi.contradictionHi.+rewrite(kronecker_delta_neqp).rewriterng_mult_zero_l.rewritegrp_unit_l.applyap,path_ishprop.Defined.Variant ofrng_sum_kronecker_delta_lwhere the indexing is swapped.Definitionrng_sum_kronecker_delta_l'{R:Ring} (ni:nat) (Hi: (i<n)%nat)(f:forallk, (k<n)%nat->R):ab_sumn(funjHj=>kronecker_deltaji*fjHj) =fiHi.Proof.lhsnrapplypath_ab_sum.2:nrapplyrng_sum_kronecker_delta_l.introskHk.cbn;f_ap;applykronecker_delta_symm.Defined.Variant ofrng_sum_kronecker_delta_lwhere the Kronecker delta appears on the right.Definitionrng_sum_kronecker_delta_r{R:Ring} (ni:nat) (Hi: (i<n)%nat)(f:forallk, (k<n)%nat->R):ab_sumn(funjHj=>fjHj*kronecker_deltaij) =fiHi.Proof.lhsnrapplypath_ab_sum.2:nrapplyrng_sum_kronecker_delta_l.introskHk.applykronecker_delta_comm.Defined.Variant ofrng_sum_kronecker_delta_rwhere the indexing is swapped.Definitionrng_sum_kronecker_delta_r'{R:Ring} (ni:nat) (Hi: (i<n)%nat)(f:forallk, (k<n)%nat->R):ab_sumn(funjHj=>fjHj*kronecker_deltaji) =fiHi.Proof.lhsnrapplypath_ab_sum.2:nrapplyrng_sum_kronecker_delta_l'.introskHk.applykronecker_delta_comm.Defined.

--- Miscellaneous\Lagrange.html ---
LagrangeLibrary LagrangeRequireImportBasicsTypes.RequireImportAlgebra.Groups.Group.RequireImportAlgebra.Groups.Subgroup.RequireImportAlgebra.Groups.QuotientGroup.RequireImportSpaces.Finite.Finite.RequireImportSpaces.Nat.Core.Lagrange's theoremLocal OpenScopemc_scope.Local OpenScopenat_scope.Definitionsubgroup_index{U:Univalence} (G:Group) (H:SubgroupG)(fin_G:FiniteG) (fin_H:FiniteH):nat.Proof.refine(fcard(Quotient(in_cosetLH))).nrapplyfinite_quotient.1-5:exact_.introsxy.pose(dec_H:=detachable_finite_subsetH).applydec_H.Defined.Given a finite group G and a finite subgroup H of G, the order of H divides the order of G. Note that constructively, a subgroup of a finite group cannot be shown to be finite without exlcluded middle. We therefore have to assume it is. This in turn implies that the subgroup is decidable.Theoremlagrange{U:Univalence} (G:Group) (H:SubgroupG)(fin_G:FiniteG) (fin_H:FiniteH):existsd,d* (fcardH) =fcardG.Proof.exists(subgroup_indexGH__).symmetry.refine(fcard_quotient(in_cosetLH) @_).refine(_@finadd_const__).applyap,path_forall.srapplyQuotient_ind_hprop.simpl.simpl is better than cbn hereintrosx.applyfcard_equiv'.Now we must show that cosets are all equivalent as types.simpl.snrapplyequiv_functor_sigma.2:apply(isequiv_group_left_op(-x)).1:hnf;trivial.exact_.Defined.Corollarylagrange_normal{U:Univalence} (G:Group) (H:NormalSubgroupG)(fin_G:FiniteG) (fin_H:FiniteH):fcard(QuotientGroupGH) *fcardH=fcardG.Proof.applylagrange.Defined.

--- Miscellaneous\lattices.html ---
latticesLibrary latticesRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.theory.groups.Generalizable VariablesABCKLf.Global Instancebounded_sl_is_sl`{IsBoundedSemiLatticeL} :IsSemiLatticeL.Proof.repeat(split;tryapply_).Qed.Global Instancebounded_join_sl_is_join_sl`{IsBoundedJoinSemiLatticeL} :IsJoinSemiLatticeL.Proof.repeat(split;tryapply_).Qed.Global Instancebounded_meet_sl_is_meet_sl`{IsBoundedMeetSemiLatticeL} :IsMeetSemiLatticeL.Proof.repeat(split;tryapply_).Qed.Global Instancebounded_lattice_is_lattice`{IsBoundedLatticeL} :IsLatticeL.Proof.repeatsplit;apply_.Qed.Global Instancebounded_sl_mor_is_sl_mor`{H:IsBoundedJoinPreservingABf}:IsJoinPreservingf.Proof.red;apply_.Qed.Lemmapreserves_join`{IsJoinPreservingLKf}xy:f(x⊔y) =fx⊔fy.Proof.applypreserves_sg_op.Qed.Lemmapreserves_bottom`{IsBoundedJoinPreservingLKf}:f⊥ = ⊥.Proof.applypreserves_mon_unit.Qed.Lemmapreserves_meet`{IsMeetPreservingLKf}xy:f(x⊓y) =fx⊓fy.Proof.applypreserves_sg_op.Qed.Sectionbounded_join_sl_props.Context`{IsBoundedJoinSemiLatticeL}.Instancejoin_bottom_l:LeftIdentity(⊔) ⊥ :=_.Instancejoin_bottom_r:RightIdentity(⊔) ⊥ :=_.Endbounded_join_sl_props.Sectionlattice_props.Context`{IsLatticeL}.Definitionmeet_join_absorptionxy:x⊓ (x⊔y) =x:=absorptionxy.Definitionjoin_meet_absorptionxy:x⊔ (x⊓y) =x:=absorptionxy.Endlattice_props.Sectiondistributive_lattice_props.Context`{IsDistributiveLatticeL}.Instancejoin_meet_distr_l:LeftDistribute(⊔) (⊓).Proof.exact(join_meet_distr_l_).Qed.Global Instancejoin_meet_distr_r:RightDistribute(⊔) (⊓).Proof.introsxyz.rewrite!(commutativity_z).applydistribute_l.Qed.Global Instancemeet_join_distr_l:LeftDistribute(⊓) (⊔).Proof.introsxyz.rewrite(simple_distribute_l(f:=join)).rewrite(simple_distribute_r(f:=join)).rewrite(idempotency(⊔)x).rewrite(commutativity(f:=join)yx),meet_join_absorption.path_via((x⊓ (x⊔z)) ⊓ (y⊔z)).-rewrite(meet_join_absorptionxz).reflexivity.-rewrite<-simple_associativity.rewrite<-distribute_r.reflexivity.Qed.Global Instancemeet_join_distr_r:RightDistribute(⊓) (⊔).Proof.introsxyz.rewrite!(commutativity_z).applydistribute_l.Qed.Lemmadistribute_altxyz: (x⊓y) ⊔ (x⊓z) ⊔ (y⊓z) = (x⊔y) ⊓ (x⊔z) ⊓ (y⊔z).Proof.rewrite(distribute_rxy(x⊓z)),join_meet_absorption.rewrite(distribute_r__(y⊓z)).rewrite(distribute_lxyz).rewrite(commutativityy(x⊓z)), <-(simple_associativity_y).rewritejoin_meet_absorption.rewrite(distribute_rxzy).rewrite(commutativity(f:=join)zy).rewrite(commutativity(x⊔y) (x⊔z)).rewritesimple_associativity, <-(simple_associativity(x⊔z)).rewrite(idempotency__).rewrite(commutativity(x⊔z) (x⊔y)).reflexivity.Qed.Enddistributive_lattice_props.Sectionlower_bounded_lattice.Context`{IsLatticeL} `{BottomL} `{!IsBoundedJoinSemiLatticeL}.Global Instancemeet_bottom_l:LeftAbsorb(⊓) ⊥.Proof.introsx.rewrite<-(join_bottom_lx),absorption.trivial.Qed.Global Instancemeet_bottom_r:RightAbsorb(⊓) ⊥.Proof.introsx.rewrite(commutativity(f:=meet)),left_absorb.trivial.Qed.Endlower_bounded_lattice.Sectionfrom_another_sl.Local OpenScopemc_add_scope.Context`{IsSemiLatticeA} `{IsHSetB}`{Bop:SgOpB} (f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x+y) =fx+fy).Lemmaprojected_sl:IsSemiLatticeB.Proof.split.-apply(projected_com_sgf).assumption.-repeatintro;apply(injectivef).rewrite!op_correct, (idempotency(+)_).reflexivity.Qed.Endfrom_another_sl.Sectionfrom_another_bounded_sl.Local OpenScopemc_add_scope.Context`{IsBoundedSemiLatticeA} `{IsHSetB}`{Bop:SgOpB} `{Bunit:MonUnitB} (f:B->A) `{!IsInjectivef}(op_correct:forallxy,f(x+y) =fx+fy)(unit_correct:fmon_unit=mon_unit).Lemmaprojected_bounded_sl:IsBoundedSemiLatticeB.Proof.split.-apply(projected_com_monoidf);trivial.-repeatintro;apply(injectivef).rewriteop_correct, (idempotency(+)_).trivial.Qed.Endfrom_another_bounded_sl.Global Instanceid_join_sl_morphism`{IsJoinSemiLatticeA} :IsJoinPreserving(@idA):= {}.Global Instanceid_meet_sl_morphism`{IsMeetSemiLatticeA} :IsMeetPreserving(@idA):= {}.Global Instanceid_bounded_join_sl_morphism`{IsBoundedJoinSemiLatticeA}:IsBoundedJoinPreserving(@idA):= {}.Global Instanceid_lattice_morphism`{IsLatticeA} :IsLatticePreserving(@idA):= {}.Sectionmorphism_composition.Context`{JoinA} `{MeetA} `{BottomA}`{JoinB} `{MeetB} `{BottomB}`{JoinC} `{MeetC} `{BottomC}(f:A->B) (g:B->C).Instancecompose_join_sl_morphism:IsJoinPreservingf->IsJoinPreservingg->IsJoinPreserving(g∘f).Proof.red;apply_.Qed.Instancecompose_meet_sl_morphism:IsMeetPreservingf->IsMeetPreservingg->IsMeetPreserving(g∘f).Proof.red;apply_.Qed.Instancecompose_bounded_join_sl_morphism:IsBoundedJoinPreservingf->IsBoundedJoinPreservingg->IsBoundedJoinPreserving(g∘f).Proof.red;apply_.Qed.Instancecompose_lattice_morphism:IsLatticePreservingf->IsLatticePreservingg->IsLatticePreserving(g∘f).Proof.split;apply_.Qed.Instanceinvert_join_sl_morphism:forall`{!IsEquivf},IsJoinPreservingf->IsJoinPreserving(f^-1).Proof.red;apply_.Qed.Instanceinvert_meet_sl_morphism:forall`{!IsEquivf},IsMeetPreservingf->IsMeetPreserving(f^-1).Proof.red;apply_.Qed.Instanceinvert_bounded_join_sl_morphism:forall`{!IsEquivf},IsBoundedJoinPreservingf->IsBoundedJoinPreserving(f^-1).Proof.red;apply_.Qed.Instanceinvert_lattice_morphism:forall`{!IsEquivf},IsLatticePreservingf->IsLatticePreserving(f^-1).Proof.split;apply_.Qed.Endmorphism_composition.#[export]HintExtern4 (IsJoinPreserving(_∘_)) =>class_apply@compose_join_sl_morphism:typeclass_instances.#[export]HintExtern4 (IsMeetPreserving(_∘_)) =>class_apply@compose_meet_sl_morphism:typeclass_instances.#[export]HintExtern4 (IsBoundedJoinPreserving(_∘_)) =>class_apply@compose_bounded_join_sl_morphism:typeclass_instances.#[export]HintExtern4 (IsLatticePreserving(_∘_)) =>class_apply@compose_lattice_morphism:typeclass_instances.#[export]HintExtern4 (IsJoinPreserving(_^-1)) =>class_apply@invert_join_sl_morphism:typeclass_instances.#[export]HintExtern4 (IsMeetPreserving(_^-1)) =>class_apply@invert_meet_sl_morphism:typeclass_instances.#[export]HintExtern4 (IsBoundedJoinPreserving(_^-1)) =>class_apply@invert_bounded_join_sl_morphism:typeclass_instances.#[export]HintExtern4 (IsLatticePreserving(_^-1)) =>class_apply@invert_lattice_morphism:typeclass_instances.

--- Miscellaneous\Law.html ---
LawLibrary LawLaw about curryingRequireImportCategory.CoreFunctor.Core.RequireImportFunctor.Paths.RequireImportFunctor.IdentityFunctor.Composition.Core.RequireImportExponentialLaws.Law4.Functors.RequireImportExponentialLaws.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.(C₁×C₂→D)≅(C₁→(C₂→D))SectionLaw4.Context`{Funext}.VariablesC1C2D:PreCategory.Lemmahelper1c:functorC1C2D(inverseC1C2Dc) =c.Proof.path_functor.abstract(exp_laws_t;rewrite<-composition_of;exp_laws_t).Defined.Lemmahelper2_helpercx:inverseC1C2D(functorC1C2Dc)x=cx.Proof.path_functor.abstractexp_laws_t.Defined.Lemmahelper2c:inverseC1C2D(functorC1C2Dc) =c.Proof.path_functor.exists(path_forall__(helper2_helperc)).abstract(unfoldhelper2_helper;exp_laws_t).Defined.Lemmalaw:functorC1C2DoinverseC1C2D= 1/\inverseC1C2DofunctorC1C2D= 1.Proof.split;path_functor;[ (exists(path_forall__helper1))| (exists(path_forall__helper2)) ];unfoldhelper1,helper2,helper2_helper;exp_laws_t.Qed.EndLaw4.

--- Miscellaneous\Law0.html ---
Law0Library Law0Exponential laws about the initial categoryRequireImportCategory.CoreFunctor.CoreFunctorCategory.CoreFunctor.Identity.RequireImportInitialTerminalCategory.CoreInitialTerminalCategory.FunctorsInitialTerminalCategory.NaturalTransformations.RequireImportHoTT.BasicsHoTT.Types.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.In this file, we prove thatx⁰≅10ˣ≅0ifx≠00⁰≅1x⁰ ≅ 1Sectionlaw0.Context`{Funext}.Context`{IsInitialCategoryzero}.Context`{IsTerminalCategoryone}.Local Notation"0" :=zero:category_scope.Local Notation"1" :=one:category_scope.VariableC:PreCategory.Global InstanceIsTerminalCategory_functors_from_initial:IsTerminalCategory(0 ->C) := {}.There is only one functor to the terminal category1.Definitionfunctor:Functor(0 ->C) 1:=center_.We have already proven inInitialTerminalCategory.vthat0->Cis a terminal category, so there is only one functor to it.Definitioninverse:Functor1 (0 ->C):=center_.Since the objects and morphisms in terminal categories are contractible, functors to a terminal category are also contractible, bytrunc_functor.Definitionlaw:functoroinverse= 1/\inverseofunctor= 1:=center_.Endlaw0.0ˣ≅0ifx≠0Sectionlaw0'.Context`{Funext}.Context`{IsInitialCategoryzero}.Context`{IsTerminalCategoryone}.Local Notation"0" :=zero:category_scope.Local Notation"1" :=one:category_scope.VariableC:PreCategory.Variablec:C.Local InstanceIsInitialCategory_functors_to_initial_from_inhabited:IsInitialCategory(C-> 0):=funPF=> @Functors.to_initial_category_emptyC__FPc.There is exactly one functor from an initial category, and we proved above that ifCis inhabited, thenC->0is initial.Definitionfunctor':Functor(C-> 0) 0:=center_.There is exactly one functor from the initial category0.Definitioninverse':Functor0 (C-> 0):=center_.Since objects and morphisms in an initial category are -1-truncated, so are functors to an initial category.Definitionlaw':functor'oinverse'= 1/\inverse'ofunctor'= 1:=center_.Endlaw0'.0⁰≅1Sectionlaw00.Context`{Funext}.Context`{IsInitialCategoryzero}.Context`{IsInitialCategoryzero'}.Context`{IsTerminalCategoryone}.Local Notation"0" :=zero:category_scope.Local Notation"00" :=zero':category_scope.Local Notation"1" :=one:category_scope.This is just a special case of the first law above.Definitionfunctor00:Functor(0 -> 0) 1:=functor_.Definitioninverse00:Functor1 (0 -> 0):=inverse_.Definitionlaw00:functor00oinverse00= 1/\inverse00ofunctor00= 1:=law_.Endlaw00.

--- Miscellaneous\Law1.html ---
Law1Library Law1Laws about the terminal categoryx¹≅x1ˣ≅1RequireExponentialLaws.Law1.Functors.RequireExponentialLaws.Law1.Law.IncludeExponentialLaws.Law1.Functors.IncludeExponentialLaws.Law1.Law.

--- Miscellaneous\Law2.html ---
Law2Library Law2The law that a sum in an exponent is a productyⁿ⁺ᵐ≅yⁿ×yᵐRequireExponentialLaws.Law2.Functors.RequireExponentialLaws.Law2.Law.IncludeExponentialLaws.Law2.Functors.IncludeExponentialLaws.Law2.Law.

--- Miscellaneous\Law3.html ---
Law3Library Law3The law that exponentiation distributes over product(y×z)ⁿ≅yⁿ×zⁿRequireExponentialLaws.Law3.Functors.RequireExponentialLaws.Law3.Law.IncludeExponentialLaws.Law3.Functors.IncludeExponentialLaws.Law3.Law.

--- Miscellaneous\Law4.html ---
Law4Library Law4Currying(yⁿ)ᵐ≅yⁿᵐRequireExponentialLaws.Law4.Functors.RequireExponentialLaws.Law4.Law.IncludeExponentialLaws.Law4.Functors.IncludeExponentialLaws.Law4.Law.

--- Miscellaneous\Laws.html ---
LawsLibrary LawsLaws about composition of functorsRequireImportCategory.CoreFunctor.CoreFunctor.IdentityFunctor.Composition.CoreNaturalTransformation.CoreNaturalTransformation.IdentityNaturalTransformation.Composition.CoreNaturalTransformation.Paths.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.Local OpenScopenatural_transformation_scope.Sectionnatural_transformation_identity.Context`{Funext}.VariablesCD:PreCategory.left identity :1∘T=TLemmaleft_identity(FF':FunctorCD)(T:NaturalTransformationFF'): 1oT=T.Proof.path_natural_transformation;autowithmorphism.Qed.right identity :T∘1=TLemmaright_identity(FF':FunctorCD)(T:NaturalTransformationFF'):To1 =T.Proof.path_natural_transformation;autowithmorphism.Qed.right whisker left identity :1∘ᴿF=1Definitionwhisker_r_left_identityE(G:FunctorDE) (F:FunctorCD):identityGoRF= 1.Proof.path_natural_transformation;autowithmorphism.Qed.left whisker right identity :G∘ᴸ1=1Definitionwhisker_l_right_identityE(G:FunctorDE) (F:FunctorCD):GoLidentityF= 1.Proof.path_natural_transformation;autowithfunctor.Qed.Endnatural_transformation_identity.#[export]HintRewrite@left_identity@right_identity:category.#[export]HintRewrite@left_identity@right_identity:natural_transformation.Sectionwhisker.Context`{fs:Funext}.whisker exchange law :(G'∘ᴸT)∘(T'∘ᴿF)=(T'∘ᴿF')∘(G∘ᴸT)Sectionexch.VariablesCDE:PreCategory.VariablesGG':FunctorDE.VariablesFF':FunctorCD.VariableT':NaturalTransformationGG'.VariableT:NaturalTransformationFF'.Lemmaexchange_whisker: (G'oLT)o(T'oRF) = (T'oRF')o(GoLT).Proof.path_natural_transformation;simpl.symmetry.applyNaturalTransformation.Core.commutes.Qed.Endexch.Sectionwhisker.VariablesCD:PreCategory.VariablesFGH:FunctorCD.VariableT:NaturalTransformationGH.VariableT':NaturalTransformationFG.left whisker composition :F∘ᴸ(T∘T')=(F∘ᴸT)∘(F∘ᴸT')Lemmacomposition_of_whisker_lE(I:FunctorDE):IoL(ToT') = (IoLT)o(IoLT').Proof.path_natural_transformation;applycomposition_of.Qed.right whisker composition :(T∘T')∘ᴿF=(T∘ᴿF)∘(T'∘ᴿF)Lemmacomposition_of_whisker_rB(I:FunctorBC): (ToT')oRI= (ToRI)o(T'oRI).Proof.path_natural_transformation;applyidpath.Qed.Endwhisker.Endwhisker.Sectionassociativity.associators - natural transformations betweenF∘(G∘H)and(F∘G)∘HSectionfunctors.VariablesBCDE:PreCategory.VariableF:FunctorDE.VariableG:FunctorCD.VariableH:FunctorBC.Local NotationF0:= ((FoG)oH)%functor.Local NotationF1:= (Fo(GoH))%functor.Definitionassociator_1:NaturalTransformationF0F1:=Evalsimplingeneralized_identityF0F1idpathidpath.Definitionassociator_2:NaturalTransformationF1F0:=Evalsimplingeneralized_identityF1F0idpathidpath.Endfunctors.associativity :(T∘U)∘V=T∘(U∘V)Sectionnt.Context`{fs:Funext}.Local OpenScopenatural_transformation_scope.DefinitionassociativityCDFGHI(V: @NaturalTransformationCDFG)(U: @NaturalTransformationCDGH)(T: @NaturalTransformationCDHI): (ToU)oV=To(UoV).Proof.path_natural_transformation.applyassociativity.Qed.Endnt.Endassociativity.Sectionfunctor_identity.Context`{Funext}.VariablesCD:PreCategory.Local Ltacnt_id_t:=split;path_natural_transformation;autorewritewithmorphism;reflexivity.left unitors : natural transformations between1∘FandFSectionleft.VariableF:FunctorDC.Definitionleft_identity_natural_transformation_1:NaturalTransformation(1oF)F:=Evalsimplingeneralized_identity(1oF)Fidpathidpath.Definitionleft_identity_natural_transformation_2:NaturalTransformationF(1oF):=Evalsimplingeneralized_identityF(1oF)idpathidpath.Theoremleft_identity_isomorphism:left_identity_natural_transformation_1oleft_identity_natural_transformation_2= 1/\left_identity_natural_transformation_2oleft_identity_natural_transformation_1= 1.Proof.nt_id_t.Qed.Endleft.right unitors : natural transformations betweenF∘1andFSectionright.VariableF:FunctorCD.Definitionright_identity_natural_transformation_1:NaturalTransformation(Fo1)F:=Evalsimplingeneralized_identity(Fo1)Fidpathidpath.Definitionright_identity_natural_transformation_2:NaturalTransformationF(Fo1):=Evalsimplingeneralized_identityF(Fo1)idpathidpath.Theoremright_identity_isomorphism:right_identity_natural_transformation_1oright_identity_natural_transformation_2= 1/\right_identity_natural_transformation_2oright_identity_natural_transformation_1= 1.Proof.nt_id_t.Qed.Endright.Endfunctor_identity.Tactics for inserting appropriate associators, whiskers, and unitorsLtacnt_solve_associator':=repeatmatchgoalwith|_=>exact(associator_1___)|_=>exact(associator_2___)|_=>exact(left_identity_natural_transformation_1_)|_=>exact(left_identity_natural_transformation_2_)|_=>exact(right_identity_natural_transformation_1_)|_=>exact(right_identity_natural_transformation_2_)| [ |-NaturalTransformation(?Fo_) (?Fo_) ] =>refine(whisker_lF_)| [ |-NaturalTransformation(_o?F) (_o?F) ] =>refine(whisker_r_F)end.Ltacnt_solve_associator:=repeatfirst[progressnt_solve_associator'|refine(compose(associator_1___)_);progressnt_solve_associator'|refine(compose_(associator_1___));progressnt_solve_associator'|refine(compose(associator_2___)_);progressnt_solve_associator'|refine(compose_(associator_2___));progressnt_solve_associator'].

--- Miscellaneous\LawsTactic.html ---
LawsTacticLibrary LawsTacticTactic for proving laws about adjoint compositionRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportFunctor.Composition.Laws.RequireImportAdjoint.UnitCounitAdjoint.Paths.RequireImportPathGroupoidsHoTT.TacticsTypes.ProdTypes.Forall.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Ltaclaw_t:=rewrite!transport_path_prod';simpl;path_adjunction;simpl;repeatmatchgoalwith| [ |-context[unit(transport?P?p?z)] ]=>simplrewrite(@ap_transport_P___p(fun_=> @unit____)z)| [ |-context[counit(transport?P?p?z)] ]=>simplrewrite(@ap_transport_P___p(fun_=> @counit____)z)| [ |-context[components_of(transport?P?p?z)] ]=>simplrewrite(@ap_transport_P___p(fun_=> @components_of____)z)end;rewrite!transport_forall_constant;repeatmatchgoalwith| [ |-context[transport(funy:Functor?C?D=> ?f(y_0?x)%object)] ]=>rewrite(funab=> @transport_compose__ab(funy'=>f(y'x)) (@object_ofCD))| [ |-context[transport(funy:Functor?C?D=> ?f(?g(y_0?x)%object))] ]=>rewrite(funab=> @transport_compose__ab(funy'=>f(g(y'x))) (@object_ofCD))| [ |-context[transport(funy:Functor?C?D=> ?f(?g(?h(?i(y_0?x)%object))))] ]=>rewrite(funab=> @transport_compose__ab(funy'=>f(g(h(i(y'x))))) (@object_ofCD))| [ |-context[transport(funy:Functor?C?D=> ?f(y_0?x)%object?z)] ]=>rewrite(funab=> @transport_compose__ab(funy'=>f(y'x)z) (@object_ofCD))| [ |-context[transport(funy:Functor?C?D=> ?f(?g(y_0?x)%object) ?z)] ]=>rewrite(funab=> @transport_compose__ab(funy'=>f(g(y'x))z) (@object_ofCD))| [ |-context[transport(funy:Functor?C?D=> ?f(?g(?h(?i(y_0?x)%object))) ?z)] ]=>rewrite(funab=> @transport_compose__ab(funy'=>f(g(h(i(y'x))))z) (@object_ofCD))end;unfoldsymmetry,symmetric_paths;rewrite?ap_V;rewrite?left_identity_fst, ?right_identity_fst, ?associativity_fst;simpl;repeat(rewrite?identity_of,?composition_of,?Category.Core.left_identity,?Category.Core.right_identity,?Category.Core.associativity);tryreflexivity.

--- Miscellaneous\LaxComma.html ---
LaxCommaLibrary LaxCommaLax Comma CategoriesSince there are only notations inLaxComma.Notations, we can just export those.LocalSetWarningsAppend"-notation-overridden".RequireExportLaxComma.Notations.DefinitionsRequireLaxComma.Core.IncludeLaxComma.Core.We don't want to make utf-8 notations the default, so we don't export them.

--- Miscellaneous\Lex.html ---
LexLibrary LexRequireImportHoTT.BasicsHoTT.Types.RequireImportHFiberLimits.PullbackFactorizationTruncations.Core.RequireImportModalityAccessibleModalities.LocalizationDescentSeparated.Local OpenScopepath_scope.Local OpenScopesubuniverse_scope.Lex modalitiesA lex modality is one that preserves finite limits, or equivalently pullbacks.  Many equivalent characterizations of this can be found in Theorem 3.1 of RSS.We choose as our definition that a lex modality to be a reflective subuniverse such thatO<<<O, which is close to (but not quite the same as) RSS Theorem 3.1 (xiii).Note that since this includesO<<Oas a precondition, such anOmust indeed be a modality (and since modalities coerce to reflective subuniverses, in the following notationOcould be either an element ofReflectiveSubuniverseor ofModality).NotationLexO:= (O<<<O).Properties of lex modalitiesWe now show that lex modalities have all the other properties from RSS Theorem 3.1 (which are equivalent to lex-ness).  All of them are simple specializations of properties fromDescent.vto the caseO'=O(although in the general case they are not known to be equivalent).SectionLexModality.Context(O:Modality) `{LexO}.RSS Theorem 3.1 (i)Definitionisconnected_paths{A:Type} `{IsConnectedOA} (xy:A):IsConnectedO(x=y):=OO_isconnected_pathsOOxy.RSS Theorem 3.1 (iii)Definitionconn_map_lex{YX:Type} `{IsConnectedOY,IsConnectedOX} (f:Y->X):IsConnMapOf:=OO_conn_map_isconnectedOOf.RSS Theorem 3.1 (iv)Definitionisequiv_mapino_isconnected{YX:Type} `{IsConnectedOY,IsConnectedOX}(f:Y->X) `{MapInO__f}:IsEquivf:=OO_isequiv_mapino_isconnectedOOf.RSS Theorem 3.1 (vi)Definitionconn_map_functor_hfiber{ABCD:Type}{f:A->B} {g:C->D} {h:A->C} {k:B->D}`{IsConnMapO__h,IsConnMapO__k}(p:kof==goh) (b:B):IsConnMapO(functor_hfiberpb):=OO_conn_map_functor_hfiberOOpb.RSS Theorem 3.1 (vii)Definitionispullback_connmap_mapino_commsq{ABCD:Type} {f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh)`{O_invertsOh,O_invertsOk,MapInO__f,MapInO__g}:IsPullbackp:=OO_ispullback_connmap_mapinoOOp.RSS Theorem 3.1 (viii)Global Instanceconn_map_functor_hfiber_to_O{YX:Type} (f:Y->X) (x:X):IsConnMapO(functor_hfiber(funy=> (to_O_naturalOfy)^)x):=OO_conn_map_functor_hfiber_to_OOOfx.Global Instanceisequiv_O_functor_hfiber{AB} (f:A->B) (b:B):IsEquiv(O_functor_hfiberOfb).Proof.apply(isequiv_O_rec_O_invertsO).applyO_inverts_conn_map.refine(conn_map_homotopicO(functor_hfiber(funx=> (to_O_naturalOfx)^)b)___).intros[ap].unfoldfunctor_hfiber,functor_sigma.applyap.applywhiskerR,inv_V.Defined.Definitionequiv_O_functor_hfiber{AB} (f:A->B) (b:B):O(hfiberfb) <~>hfiber(O_functorOf) (toOBb):=Build_Equiv__(O_functor_hfiberOfb)_.RSS Theorem 3.1 (ix)Global Instanceisequiv_path_O{X:Type@{i}} (xy:X):IsEquiv(path_OOOOxy):=isequiv_path_OOOOxy.Definitionequiv_path_O{X:Type@{i}} (xy:X):O(x=y) <~> (toOXx=toOXy):=equiv_path_OOOOxy.Definitionequiv_path_O_to_O{X:Type} (xy:X): (equiv_path_Oxy)o(toO(x=y)) == @ap__(toOX)xy.Proof.introsp;unfoldequiv_path_O,equiv_path_OO,path_OO;cbn.applyO_rec_beta.Defined.RSS Theorem 3.1 (x).  This justifies the term "left exact".Global InstanceO_inverts_functor_pullback_to_O{ABC:Type} (f:B->A) (g:C->A):O_invertsO(functor_pullbackfg(O_functorOf) (O_functorOg)(toOA) (toOB) (toOC)(to_O_naturalOf) (to_O_naturalOg)):=OO_inverts_functor_pullback_to_OOOfg.Definitionequiv_O_pullback{ABC:Type} (f:B->A) (g:C->A):O(Pullbackfg) <~>Pullback(O_functorOf) (O_functorOg):=equiv_O_rec_O_invertsO(functor_pullbackfg(O_functorOf) (O_functorOg)(toOA) (toOB) (toOC)(to_O_naturalOf) (to_O_naturalOg)).DefinitionO_functor_pullback{ABC:Type} (f:B->A) (g:C->A):IsPullback(O_functor_squareO____(pullback_commsqfg)).Proof.unfoldIsPullback.nrapply(isequiv_homotopic(O_rec(functor_pullback_______(to_O_naturalOf) (to_O_naturalOg)))).1:applyisequiv_O_rec_O_inverts;exact_.applyO_indpaths.etransitivity.1:introx;applyO_rec_beta.symmetry.snrapplypullback_homotopic;intros[b[ce]];cbn.all:change(to(modality_subunivO))with(toO).-nrapply(to_O_naturalO).-nrapply(to_O_naturalO).-OpenScopelong_path_scope.lhsnrapplyconcat_p_pp.lhsnrapply(concat_p_pp___@@ 1).rewriteto_O_natural_compose.unfoldO_functor_square.rewriteO_functor_homotopy_beta.rewrite6concat_pp_p.do3applywhiskerL.rhs_Vnrapplyconcat_pp_p.applymoveL_pM.lhs_Vnrapplyinv_pp.rhs_Vnrapplyinv_Vp.apply(apinverse).nrapplyto_O_natural_compose.CloseScopelong_path_scope.Defined.Definitiondiagonal_O_functor{AB:Type} (f:A->B):diagonal(O_functorOf) ==equiv_O_pullbackffoO_functorO(diagonalf).Proof.applyO_indpaths;introsx.refine(_@ (ap_(to_O_natural___))^).cbn.refine(_@ (O_rec_beta__)^).unfolddiagonal,functor_pullback,functor_sigma;cbn.applyap,ap.applymoveL_pV;exact(concat_1p_p1_).Defined.RSS Theorem 3.1 (xi)DefinitioncancelL_conn_map{YXZ:Type} (f:Y->X) (g:X->Z)`{IsConnMapO__(gof)} `{IsConnMapO__g}:IsConnMapOf:=OO_cancelL_conn_mapOOfg.RSS Theorem 3.1 (xii)Global Instanceconn_map_O_inverts{AB:Type} (f:A->B) `{O_invertsOf}:IsConnMapOf:=conn_map_OO_invertsOOf.RSS Theorem 3.1 (xiii)Definitionmodal_over_connected_isconst_lex(A:Type) `{IsConnectedOA}(P:A->Type) `{forallx,InO(Px)}: {Q:Type&InOQ*forallx,Q<~>Px}.Proof.poseproof(O_inverts_isconnectedO(fun_:A=>tt)).exists(OO_descend_O_invertsOO(fun_:A=>tt)Ptt);split.-applyOO_descend_O_inverts_inO.-intros;nrapplyOO_descend_O_inverts_beta.Defined.RSS Theorem 3.11 (iii): in the accessible case, the universe is modal.Global InstanceinO_typeO_lex`{Univalence} `{IsAccRSUO}:In(lift_accrsuO) (Type_O):=_.Part of RSS Corollary 3.9: lex modalities preserven-types for alln.  This is definitely not equivalent to lex-ness, since it is true for the truncation modalities that are not lex.  But it is also not true of all modalities; e.g. the shape modality in a cohesive topos can take 0-types tooo-types.  With a little more work, this can probably be proven withoutFunext.Global Instanceistrunc_O_lex`{Funext}{n:trunc_index} {A:Type} `{IsTruncnA}:IsTruncn(OA).Proof.generalizedependentA;simple_inductionnnIHn;introsA?.-exact_.Already proven for all modalities.-applyistrunc_S.refine(O_ind(funx=>forally,IsTruncn(x=y))_);introsx.refine(O_ind(funy=>IsTruncn(toOAx=y))_);introsy.refine(istrunc_equiv_istrunc_(equiv_path_Oxy)).Defined.EndLexModality.Equivalent characterizations of lex-nessWe will not prove that *all* of the above properties from RSS Theorem 3.1 are equivalent to lex-ness, but we will do it for some of them.SectionImpliesLex.Context{O:Modality}.RSS 3.1 (xiii) implies lexnessDefinitionlex_from_modal_over_connected_isconst(H:forall(A:Type) (A_isC:IsConnectedOA)(P:A->Type) (P_inO:forallx,InO(Px)),{Q:Type&InOQ*forallx,Q<~>Px}):LexO.Proof.introsA;unshelveeconstructor;introsPP_inO.all:pose(Q:=funz:OA=>H(hfiber(toOA)z)_(Popr1)_).-exact(funz=> (Qz).1).-exact(funz=>fst(Qz).2).-introsx;cbn.exact(snd(Q(toOAx)).2 (x;1)).Defined.RSS 3.11 (iii), the universe is modal, implies lex-nessDefinitionlex_from_inO_typeO`{IsAccRSUO} `{In(lift_accrsuO) (Type_O)}:LexO.Proof.apply(O_lex_leq_inO_TypeOOO).Defined.RSS Theorem 3.1 (xi) implies lex-nessDefinitionlex_from_cancelL_conn_map(cancel:forall{YXZ:Type} (f:Y->X) (g:X->Z),(IsConnMapO(gof)) -> (IsConnMapOg)->IsConnMapOf):LexO.Proof.applylex_from_modal_over_connected_isconst;intros.exists(O{x:A&Px});split; [exact_|introsx;symmetry].refine(Build_Equiv__(funp=>toO_(x;p))_).nrefine(isequiv_conn_map_inoO_). 1-2:exact_.revertx;applyconn_map_fiber.nrefine(cancel____(funz:{x:A&O{x:A&Px}} =>z.2)__).1:clearcancel;exact_.introsz.refine(isconnected_equiv'OA__).unfoldhfiber.refine(equiv_adjointify(funx=> ((x;z) ; 1))(funy=>y.1.1)__).-intros[[xy] []];reflexivity.-introsx;reflexivity.Defined.RSS Theorem 3.1 (iii) implies lex-nessDefinitionlex_from_conn_map_lex(H:forallAB(f:A->B),(IsConnectedOA) -> (IsConnectedOB) ->IsConnMapOf):LexO.Proof.applylex_from_cancelL_conn_map.introsYXZfggfcgcx.pose(h:= @functor_hfiberYZXZ(gof)gfidmap(funa=> 1%path)).assert(cc:=H__(h(gx)) (gfc(gx)) (gc(gx))).refine(isconnected_equiv'O__(cc(x;1))).unfoldhfiber.substh;unfoldfunctor_hfiber,functor_sigma;cbn.refine(_oE(equiv_sigma_assoc__)^-1).applyequiv_functor_sigma_id;introsy;cbn.refine(_oE(equiv_functor_sigma_id_)).2:intros;symmetry;applyequiv_path_sigma.cbn.refine(_oEequiv_sigma_symm_).applyequiv_sigma_contr;introsp.destructp;cbn.refine(contr_equiv'{p:g(fy) =g(fy) &p= 1%path}_).applyequiv_functor_sigma_id;introsp;cbn.applyequiv_concat_l.exact(concat_1p_@ap_idmap_).Defined.RSS Theorem 3.1 (i) implies lex-nessDefinitionlex_from_isconnected_paths(H:forall(A:Type) (Ac:IsConnectedOA) (xy:A),IsConnectedO(x=y)):LexO.Proof.applylex_from_conn_map_lex.introsABfAcBcc.rapplyisconnected_sigma.Defined.RSS Theorem 3.1 (iv) implies lex-nessDefinitionlex_from_isequiv_ismodal_isconnected_types(H:forallAB(f:A->B),(IsConnectedOA) -> (IsConnectedOB) ->(MapInOf) ->IsEquivf):LexO.Proof.applylex_from_conn_map_lex.introsABfACBC.apply(conn_map_homotopicO__(fact_factors(imageOf))).applyconn_map_compose; [exact_| ].applyconn_map_isequiv.applyH; [ |exact_|exact_].applyisconnected_conn_map_to_unit.apply(cancelR_conn_mapO(factor1(imageOf)) (const_tt_)).Defined.RSS Theorem 3.1 (vii) implies lex-nessDefinitionlex_from_ispullback_connmap_mapino_commsq(H:forall{ABCD}(f:A->B) (g:C->D) (h:A->C) (k:B->D),(IsConnMapOf) -> (IsConnMapOg) ->(MapInOh) -> (MapInOk) ->forall(p:kof==goh),IsPullbackp):LexO.Proof.applylex_from_isequiv_ismodal_isconnected_types.introsABfACBCfM.specialize(HAUnitBUnit(const_tt_) (const_tt_)fidmap____(fun_=> 1)).unfoldIsPullback,pullback_corecinH.refine(@isequiv_compose___H_(funx=>x.2.1)_).unfoldPullback.refine(@isequiv_compose_{b:Unit&B}(functor_sigmaidmap(funa=>pr1))__pr2_).refine(@isequiv_compose__(equiv_sigma_prod0UnitB)__snd_).apply(equiv_isequiv(prod_unit_lB)).Defined.EndImpliesLex.Lex reflective subuniversesA reflective subuniverse that preserves fibers is in fact a modality (and hence lex).Definitionismodality_isequiv_O_functor_hfiber(O:ReflectiveSubuniverse)(H:forall{AB:Type} (f:A->B) (b:B),IsEquiv(O_functor_hfiberOfb)):IsModalityO.Proof.introsA';rapplyreflectsD_from_inO_sigma.introsBB_inO.pose(A:=OA').pose(g:=O_recpr1:O{x:A&Bx} ->A).transparentassert(p: (forallx,g(toO_x) =x.1)).{introsx;substg;applyO_rec_beta. }applyinO_isequiv_to_O.applyisequiv_contr_map;introsx.snrefine(contr_equiv'_(hfiber_hfiber_compose_map_gx)).applycontr_map_isequiv.unfoldhfiber_compose_map.transparentassert(h: (hfiber(@pr1AB) (gx) <~>hfiberg(gx))).{refine(_oEequiv_to_OO_).refine(_oEBuild_Equiv__(O_functor_hfiberO(@pr1AB) (gx))_).unfoldhfiber.applyequiv_functor_sigma_id.introsy;cbn.refine(_oE(equiv_moveR_equiv_V__)).applyequiv_concat_l.applymoveL_equiv_V.unfoldg,O_functor.reverty;applyO_indpaths;intros[aq];cbn.refine(_@ (O_rec_beta__)^).applyap,O_rec_beta. }refine(isequiv_homotopic(hoEequiv_hfiber_homotopic__p(gx))_).intros[[ab]q];cbn.clearh.unfoldO_functor_hfiber.rewriteO_rec_beta.unfoldfunctor_sigma;cbn.refine(path_sigma'_1_).rewriteO_indpaths_beta;cbn.unfoldmoveL_equiv_V,moveR_equiv_V.OpenScopelong_path_scope.Local Opaqueeissect.(* work around bug 4533 *)(* Even though https://github.com/coq/coq/issues/4533 is closed, this is still needed. *)rewrite!ap_pp, !concat_p_pp, !ap_V.unfoldto_O_natural.rewriteconcat_pV_p.substp.rewriteconcat_pp_V.rewriteconcat_pp_p;applymoveR_Vp.rewrite<- !(ap_compose(toOA) (toOA)^-1).rapply@concat_A1p.Local Transparenteissect.(* work around bug 4533 *)CloseScopelong_path_scope.Qed.Lexness via generatorsHere the characterization of when an accessible presentation yields a lex modality from Anel-Biederman-Finster-Joyal ("Higher Sheaves and Left-Exact Localizations of ∞-Topoi", arXiv:2101.02791): it's enough for path spaces of the generators to be connected.Definitionlex_gen`{Univalence} (O:Modality) `{IsAccModalityO}(lexgen:forall(i:ngen_indices(acc_ngenO)) (xy:ngen_type(acc_ngenO)i),IsConnectedO(x=y)):LexO.Proof.srapplylex_from_inO_typeO; [exact_|introsi].rapplyooextendable_TypeO_from_extension;introsP;srefine(_;_).1:intros;exists(forallx,Px);exact_.assert(wc:forallyz,Py<~>Pz).{introsyz.Here we use the hypothesislexgen(typeclass inference finds it automatically).refine(pr1(isconnected_elimO_(@equiv_transport_Pyz))). }introsx;applypath_TypeO,path_universe_uncurried.refine(equiv_adjointify(funf=>fx) (funuy=>wcxy((wcxx)^-1u))__).-introsu;applyeisretr.-introsf;applypath_forall;introsy;applymoveR_equiv_M.destruct(isconnected_elimO_(funy=> (wcxy)^-1 (fy)))as[zp].exact(px@ (py)^).Defined.n-fold separationA type isn-O-separated, for n >= -2, if all its (n+2)-fold iterated identity types areO-modal.  Inductively, this means that it is (-2)-O-separated if it is O-modal, and (n+1)-O-separated if its identity types are n-O-separated.FixpointnSep(n:trunc_index) (O:Subuniverse) :Subuniverse:=matchnwith| -2 =>O|n.+1 =>Sep(nSepnO)end.The reason for indexing this notion by atrunc_indexrather than anatis that when O is lex, a type is n-O-separated if and only if its O-unit is an n-truncated map.Definitionnsep_iff_trunc_to_O(n:trunc_index) (O:Modality) `{LexO} (A:Type):In(nSepnO)A<->IsTruncMapn(toOA).Proof.revertA;inductionnas[|nIHn];introsA;split;intros?.-applycontr_map_isequiv;rapplyisequiv_to_O_inO.-apply(inO_equiv_inO(OA) (toOA)^-1).-applyistruncmap_from_ap;introsxy.pose(i:=fst(IHn(x=y))_).applyistruncmap_mapinO_tr, (mapinO_homotopic__(equiv_path_O_to_OOxy)).-introsxy.apply(snd(IHn(x=y))).pose(i:=istruncmap_apn(toOA)xy).applymapinO_tr_istruncmapini.applyistruncmap_mapinO_tr, (mapinO_homotopic_((equiv_path_OOxy)^-1o(@ap__(toOA)xy))).{introsp;applymoveR_equiv_V;symmetry;applyequiv_path_O_to_O. }posemapinO_isequiv.(* This speeds up the next line. *)rapplymapinO_compose.Defined.

--- Miscellaneous\Limit.html ---
LimitLibrary LimitRequireImportBasics.RequireImportDiagrams.Diagram.RequireImportDiagrams.Graph.RequireImportDiagrams.Cone.RequireImportDiagrams.ConstantDiagram.Local OpenScopepath_scope.Generalizable All Variables.This file contains the definition of limits, and functoriality results on limits.LimitsA Limit is the extremity of a cone.ClassIsLimit`(D:DiagramG) (Q:Type) := {islimit_cone:ConeQD;islimit_unicone:UniversalConeislimit_cone;}.(* Use :> and remove the two following lines,once Coq 8.16 is the minimum required version. *)#[export]ExistingInstanceislimit_cone.Coercionislimit_cone:IsLimit>->Cone.ArgumentsBuild_IsLimit{GDQ}CH:rename.Argumentsislimit_cone{GDQ}C:rename.Argumentsislimit_unicone{GDQ}H:rename.cone_precompose_invis defined for convenience: it is only the inverse ofcone_precompose. It allows to recover the maphfrom a coneC'.Definitioncone_precompose_inv`{D:DiagramG} {QX}(H:IsLimitDQ) (C':ConeXD) :X->Q:= @equiv_inv___(islimit_uniconeHX)C'.Existence of limitsRecordLimit`(D:DiagramG) := {lim:foralli,Di;limp:forallij(g:Gij),D_fg(limi) =limj;}.Argumentslim{__}.Argumentslimp{__}.Definitioncone_limit`(D:DiagramG) :Cone(LimitD)D.Proof.srapplyBuild_Cone.+introsix.apply(limxi).+introsijgx.applylimp.Defined.Global Instanceunicone_limit`(D:DiagramG):UniversalCone(cone_limitD).Proof.srapplyBuild_UniversalCone;introY.srapplyisequiv_adjointify.{introscy.srapplyBuild_Limit.{introi.apply(legsciy). }introsijg.applylegs_comm. }all:intro;reflexivity.Defined.Global Instanceislimit_limit`(D:DiagramG) :IsLimitD(LimitD):=Build_IsLimit(cone_limit_)_.Functoriality of limitsSectionFunctorialityLimit.Context`{Funext} {G:Graph}.Limits are preserved by composition with a (diagram) equivalence.Definitionislimit_precompose_equiv{D:DiagramG} `(f:Q<~>Q'):IsLimitDQ'->IsLimitDQ.Proof.introsHQ.srapply(Build_IsLimit(cone_precomposeHQf)_).applycone_precompose_equiv_universality,HQ.Defined.Definitionislimit_postcompose_equiv{D1D2:DiagramG} (m:D1~d~D2){Q:Type} :IsLimitD1Q->IsLimitD2Q.Proof.introsHQ.srapply(Build_IsLimit(cone_postcomposemHQ)_).applycone_postcompose_equiv_universality,HQ.Defined.A diagram mapm:D1=>D2induces a map between any two limits ofD1andD2.Definitionfunctor_limit{D1D2:DiagramG} (m:DiagramMapD1D2){Q1Q2} (HQ1:IsLimitD1Q1) (HQ2:IsLimitD2Q2):Q1->Q2:=cone_precompose_invHQ2(cone_postcomposemHQ1).And this map commutes with diagram map.Definitionfunctor_limit_commute{D1D2:DiagramG}(m:DiagramMapD1D2) {Q1Q2}(HQ1:IsLimitD1Q1) (HQ2:IsLimitD2Q2):cone_postcomposemHQ1=cone_precomposeHQ2(functor_limitmHQ1HQ2):= (eisretr(cone_precomposeHQ2)_)^.Limits of equivalent diagramsNow we have than two equivalent diagrams have equivalent limits.Context{D1D2:DiagramG} (m:D1~d~D2) {Q1Q2}(HQ1:IsLimitD1Q1) (HQ2:IsLimitD2Q2).Definitionfunctor_limit_eissect:functor_limitmHQ1HQ2ofunctor_limit(diagram_equiv_invm)HQ2HQ1==idmap.Proof.applyap10.srapply(equiv_inj(cone_precomposeHQ2)_).1:applyHQ2.etransitivity.2:symmetry;applycone_precompose_identity.etransitivity.1:applycone_precompose_comp.rewriteeisretr,cone_postcompose_precompose,eisretr.rewritecone_postcompose_comp,diagram_inv_is_section.applycone_postcompose_identity.Defined.Definitionfunctor_limit_eisretr:functor_limit(diagram_equiv_invm)HQ2HQ1ofunctor_limitmHQ1HQ2==idmap.Proof.applyap10.srapply(equiv_inj(cone_precomposeHQ1)_).1:applyHQ1.etransitivity.2:symmetry;applycone_precompose_identity.etransitivity.1:applycone_precompose_comp.rewriteeisretr,cone_postcompose_precompose,eisretr.rewritecone_postcompose_comp,diagram_inv_is_retraction.applycone_postcompose_identity.Defined.Global Instanceisequiv_functor_limit:IsEquiv(functor_limitmHQ1HQ2):=isequiv_adjointify__functor_limit_eissectfunctor_limit_eisretr.Definitionequiv_functor_limit:Q1<~>Q2:=Build_Equiv___isequiv_functor_limit.EndFunctorialityLimit.Unicity of limitsA particuliar case of the functoriality result is that all limits of a diagram are equivalent (and hence equal in presence of univalence).Theoremlimit_unicity`{Funext} {G:Graph} {D:DiagramG} {Q1Q2:Type}(HQ1:IsLimitDQ1) (HQ2:IsLimitDQ2):Q1<~>Q2.Proof.srapplyequiv_functor_limit.srapply(Build_diagram_equiv(diagram_idmapD)).Defined.Limits are right adjoint to constant diagramTheoremlimit_adjoint{G:Graph} {D:DiagramG} {C:Type}: (C->LimitD) <~>DiagramMap(diagram_constC)D.Proof.srapplyequiv_adjointify.{introf.srapplyBuild_DiagramMap.{introsic.applylim,f,c. }introsijgx.applylimp. }{intros[fp]c.srapplyBuild_Limit.{introi.applyf,c. }introsijg.applyp. }1,2:intro;reflexivity.Defined.

--- Miscellaneous\Localization.html ---
LocalizationLibrary LocalizationLocalizationRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensions.RequireImportReflectiveSubuniverseAccessible.Local OpenScopenat_scope.Local OpenScopepath_scope.Suppose given a family of mapsf:forall(i:I),Si->Ti.  A typeXis said to bef-local if for alli:I, the map(Ti->X)->(Si->X)given by precomposition withfiis an equivalence.  Our goal is to show that thef-local types form a reflective subuniverse, with a reflector constructed by localization.  That is, morally we want to sayInductive Localize f (X : Type) : Type :=
| loc : X -> Localize X
| islocal_localize : forall i, IsEquiv (fun (g : T i -> X) => g o f i).This is not a valid HIT by the usual rules, but if we expand out the definition ofIsEquivand applypath_sigmaandpath_forall, then it becomes one.  We get a simpler definition (no 2-path constructors) if we do this withBiInvrather thanIsEquiv:Inductive Localize f (X : Type) : Type :=
| loc : X -> Localize X
| lsect : forall i (g : S i -> X), T i -> X
| lissect : forall i (g : S i -> X) (s : S i), lsect i g (f i s) = g s
| lretr : forall i (g : S i -> X), T i -> X
| lisretr : forall i (h : T i -> X) (t : T i), lretr i (h o f i) t = h t.This definition works, and from it one can prove that thef-local types form a reflective subuniverse.  However, the proof inextricably involvesFunext.  We can avoidFunextin the same way that we did in the definition of aReflectiveSubuniverse, by using pointwise path-split precomposition equivalences.  Observe that the assertionExtendableAlongnfCconsists entirely of points, paths, and higher paths inC.  Therefore, for anynwe might choose, we can defineLocalizefXas a HIT to universally forceExtendableAlongn(fi)(fun_=>LocalizefX)to hold for alli.  For instance, whennis 2 (the smallest value which will ensure thatLocalizefXis actuallyf-local), we getInductive Localize f (X : Type) : Type :=
| loc : X -> Localize X
| lrec : forall i (g : S i -> X), T i -> X
| lrec_beta : forall i (g : S i -> X) (s : T i), lrec i g (f i s) = g s
| lindpaths : forall i (h k : T i -> X) (p : h o f i == k o f i) (t : T i), h t = k t
| lindpaths_beta : forall i (h k : T i -> X) (p : h o f i == k o f i) (s : S i),
                     lindpaths i h k p (f i s) = p s.However, just as forReflectiveSubuniverse, in order to completely avoidFunextwe need theoo-version of path-splitness.  Written out as above, this would involve infinitely many constructors (but it would not otherwise be problematic, so for instance it can be constructed semantically in model categories).  We can't actually write out infinitely many constructors in Coq, of course, but since we have a finite definition ofooExtendableAlong, we can just assert directly thatooExtendableAlong(fi)(fun_=>LocalizefX)holds for alli.Then, however, we have to express the hypotheses of the induction principle.  We know what these should be for each path-constructor and higher path-constructor, so all we need is a way to package up those infinitely many hypotheses into a single one, analogously toooExtendableAlong.  Thus, we begin this file by defining a "dependent" version ofooExtendableAlong, and of course we start this with a version for finiten.Dependent extendabilityFixpointExtendableAlong_Over@{abcdm|a<=m,b<=m,c<=m,d<=m}(n:nat) {A:Type@{a}} {B:Type@{b}} (f:A->B)(C:B->Type@{c})(D:forallb,Cb->Type@{d})(ext:ExtendableAlong@{abcm}nfC):Type@{m}:=matchnreturnExtendableAlong@{abcm}nfC->Type@{m}with| 0 =>fun_=>Unit|Sn=>funext'=>(forall(g:foralla,C(fa)) (g':foralla,D(fa) (ga)),sig@{mm}Control universe parameters(fun(rec:forallb,Db((fstext'g).1b)) =>foralla, (fstext'g).2a#rec(fa) =g'a)) *forall(hk:forallb,Cb)(h':forallb,Db(hb)) (k':forallb,Db(kb)),ExtendableAlong_Overnf(funb=>hb=kb)(funbc=>c#h'b=k'b) (sndext'hk)endext.LikeExtendableAlong, these can be postcomposed with known equivalences.Definitionextendable_over_postcompose'(n:nat){AB:Type} (C:B->Type) (f:A->B)(ext:ExtendableAlongnfC)(DE:forallb,Cb->Type)(g:forallbc,Dbc<~>Ebc):ExtendableAlong_OvernfCDext->ExtendableAlong_OvernfCEext.Proof.revertCextDEg;simple_inductionnnIHn;introsCextDEg;simpl.1:byapplyidmap.introsext'.split.-introshk.exists(funb=>gb((fstexth).1b)((fstext'h(funa=> (g__)^-1 (ka))).1b)).introsa.refine((ap_transport((fstexth).2a) (g(fa))_)^ @_).applymoveR_equiv_M.exact((fstext'h(funa=> (g__)^-1 (ka))).2a).-introspqp'q'.refine(IHn(funb=>pb=qb)_(funb=>func=>transport(Db)c((gb(pb))^-1 (p'b))= ((gb(qb))^-1 (q'b)))__(sndext'pq(funb=> (gb(pb))^-1 (p'b))(funb=> (gb(qb))^-1 (q'b)))).introsbc.refine(_oEequiv_moveR_equiv_M__).applyequiv_concat_l.refine(_@ (ap_transportc(gb)_)^).applyap,symmetry,eisretr.Defined.Definitionextendable_over_postcompose(n:nat){AB:Type} (C:B->Type) (f:A->B)(ext:ExtendableAlongnfC)(DE:forallb,Cb->Type)(g:forallbc,Dbc->Ebc)`{forallbc,IsEquiv(gbc)}:ExtendableAlong_OvernfCDext->ExtendableAlong_OvernfCEext:=extendable_over_postcompose'nCfextDE(funbc=>Build_Equiv__(gbc)_).And if the dependency is trivial, we obtain them from an ordinaryExtendableAlong.Definitionextendable_over_const(n:nat) {AB:Type} (C:B->Type) (f:A->B)(ext:ExtendableAlongnfC) (D:B->Type):ExtendableAlongnfD->ExtendableAlong_OvernfC(funb_=>Db)ext.Proof.revertCextD.simple_inductionnnIHn;introsCextDext'.1:exacttt.split.-introsgg'.exists((fstext'g').1).exact(funa=>transport_const((fstextg).2a)_@ (fstext'g').2a).-introshkh'k'.refine(extendable_over_postcompose'_______(IHn(funb=>hb=kb) (sndexthk)(funb=>h'b=k'b) (sndext'h'k'))).exact(funbc=>equiv_concat_l(transport_constc(h'b)) (k'b)).Defined.This lemma will be used in stating the computation rule for localization.FixpointapD_extendable_eq(n:nat) {AB:Type} (C:B->Type) (f:A->B)(ext:ExtendableAlongnfC) (D:forallb,Cb->Type)(g:forallbc,Dbc)(ext':ExtendableAlong_OvernfCDext){structn}:Type.Proof.destructn.-exactUnit.-applyprod.+exact(forall(h:foralla,C(fa)) (b:B),gb((fstexth).1b) = (fstext'h(funa=>g(fa) (ha))).1b).+exact(forallhk,apD_extendable_eqnAB(funb=>hb=kb)f(sndexthk)(funbc=>c#gb(hb) =gb(kb))(funbc=>apD(gb)c)(sndext'hk__)).Defined.Here's theoo-version.DefinitionooExtendableAlong_Over@{abcdm|a<=m,b<=m,c<=m,d<=m}{A:Type@{a}} {B:Type@{b}} (f:A->B) (C:B->Type@{c})(D:forallb,Cb->Type@{d}) (ext:ooExtendableAlongfC):=foralln,ExtendableAlong_Over@{abcdm}nfCD(extn).Theoo-version for trivial dependency.Definitionooextendable_over_const{AB:Type} (C:B->Type) (f:A->B)(ext:ooExtendableAlongfC) (D:B->Type):ooExtendableAlongfD->ooExtendableAlong_OverfC(funb_=>Db)ext:=funext'n=>extendable_over_constnCf(extn)D(ext'n).A crucial fact: theoo-version is inherited by types of homotopies.Definitionooextendable_over_homotopy{AB:Type} (C:B->Type) (f:A->B)(ext:ooExtendableAlongfC)(D:forallb,Cb->Type)(rs:forallbc,Dbc):ooExtendableAlong_OverfCDext->ooExtendableAlong_OverfC(funbc=>rbc=sbc)ext.Proof.introsext'n.revertCextDrsext'.simple_inductionnnIHn;introsCextDrsext'.1:exacttt.split.-introsgg'.simplerefine(_;_);simpl.+introsb.refine(_@ (fst(snd(ext'2)__(funb'=>rb'((fst(extn.+1)g).1b'))(funb'=>sb'((fst(extn.+1)g).1b')))(fun_=> 1)_).1b).*refine(transport2(Db) (p:= 1)__).refine((fst(snd(snd(ext3)__) (funb'=> 1)((fst(snd(ext2)__) (funa:A=> 1)).1))_).1b);introsa.symmetry;refine((fst(snd(ext2)__) (funa'=> 1)).2a).*introsa;simpl.refine(_@ap(transport(D(fa)) ((fst(extn.+1)g).2a)^) (g'a)@_);[symmetry;byapplyapD|byapplyapD].+introsa;simpl.set(h:= (fst(extn.+1)g).1).matchgoalwith|-context[   (fst(snd(ext'2)__?k1?k2) (fun_=> 1) ?l).1 ]=>pose(p:= (fst(snd(ext'2)__k1k2) (fun_=> 1)l).2a);simplinpend.rewritetransport_paths_Flinp.applymoveL_Mpinp.refine(ap(transport__) (1 @@p) @_);clearp.unfoldtransport2;rewriteconcat_p_pp.matchgoalwith|-transport?P?p((ap?f?q@ap?f?r) @ ?s) = ?t=>refine(ap(transportPp) ((ap_ppfqr)^ @@ (idpaths)) @_)end.pose(p:= (fst(snd(snd(ext3)hh) (funb':B=> 1)((fst(snd(ext2)hh) (funa0:A=> 1)).1))(funa':A=> ((fst(snd(ext2)hh)(funa':A=> 1)).2a')^)).2a);simplinp.refine(ap(transport__) (ap(ap_) (p@@ 1) @@ 1) @_);clearp.rewriteconcat_Vp;simpl;rewriteconcat_1p.refine(transport_paths_FlFr_D__@_).OpenScopelong_path_scope.rewrite!ap_pp, !concat_p_pp,ap_transport_pV.(* Even though https://github.com/coq/coq/issues/4533 is closed, this workaround is still needed. Without the Opaque setting, therewriteunfolds the firsttransport_pVin the goal, and the firstmoveR_Vpbelow fails. *)Local Opaquetransport_pV.(* work around bug 4533 *)rewrite!concat_p_pp.Local Transparenttransport_pV.(* work around bug 4533 *)refine((((_@@ 1) @concat_1p_) @@ 1 @@ 1 @@ 1) @_).*rewriteap_V,concat_pp_p.do2applymoveR_Vp.rewriteconcat_p1.symmetry;applytransport_pV_ap.*rewrite!concat_pp_p.refine((1 @@_) @ (concat_p1_)).applymoveR_Vp;rewriteconcat_p1.applytransport_pV_ap.CloseScopelong_path_scope.-introshkh'k'.refine(extendable_over_postcompose'______(funbc=>equiv_cancelL(apD(rb)c)__)_).refine(IHn_____(funn=>snd(ext'n.+1)hk(funb=>rb(hb)) (funb=>sb(kb)))).Qed.Local typesImportIsLocal_Internal.Definitionislocal_equiv_islocal(f:LocalGenerators@{a})(X:Type@{i}) {Y:Type@{j}}(Xloc:IsLocal@{ii'a}fX)(g:X->Y) `{IsEquiv@{ij}__g}:IsLocal@{jj'a}fY.Proof.introsi.We have to fiddle with the max universes to get this to work, sinceooextendable_postcomposerequires the max universe in both cases to be the same, whereas we don't want to assume that the hypothesis and conclusion are related in any way.applylift_ooextendablealong@{aaaaaajjjkj'}.refine(ooextendable_postcompose@{aaijkkkkkk}__(fi) (fun_=>g)_).applylift_ooextendablealong@{aaaaaaiiii'k}.applyXloc.Defined.Localization as a HITModuleExportLocalizationHIT.Cumulative Private InductiveLocalize(f:LocalGenerators@{a}) (X:Type@{i}):Type@{max(a,i)} :=|loc:X->LocalizefX.Argumentsloc{fX}x.Note that the following axiom actually contains a point-constructor.  We could separate out that point-constructor and make it an actual argument of the private inductive type, thereby getting a judgmental computation rule for it.  However, since locality is an hprop, there seems little point to this.Axiomislocal_localize:forall(f:LocalGenerators@{a}) (X:Type@{i}),IsLocal@{ika}f(LocalizefX).DefinitionLocalize_ind(f:LocalGenerators@{a}) (X:Type@{i})(P:LocalizefX->Type@{j})(loc':forallx,P(locx))(islocal':foralli,ooExtendableAlong_Over@{aaijk}(fi) (fun_=>Localize@{ai}fX)(fun_=>P)(islocal_localize@{aik}fXi))(z:LocalizefX):Pz:=matchzwith|locx=>fun_=>loc'xendislocal'.We now state the computation rule forislocal_localize.  Since locality is an hprop, we never actually have any use for it, but the fact that we can state it is a reassuring check that we have defined a meaningful HIT.AxiomLocalize_ind_islocal_localize_beta:forall(f:LocalGenerators) (X:Type)(P:LocalizefX->Type)(loc':forallx,P(locx))(islocal':foralli,ooExtendableAlong_Over(fi) (fun_=>LocalizefX)(fun_=>P)(islocal_localizefXi))in,apD_extendable_eqn(fun_=>LocalizefX) (fi)(islocal_localizefXin) (fun_=>P)(fun_=>Localize_indfXPloc'islocal')(islocal'in).EndLocalizationHIT.Now we prove that localization is a reflective subuniverse.SectionLocalization.Context(f:LocalGenerators).The induction principle is an equivalence.Definitionext_localize_ind(X:Type)(P:LocalizefX->Type)(Ploc:foralli,ooExtendableAlong_Over(fi) (fun_=>LocalizefX)(fun_=>P) (islocal_localizefXi)):ooExtendableAlonglocP.Proof.introsn;generalizedependentP.simple_inductionnnIHn;introsPPloc.1:exacttt.split.-introsg.exists(Localize_indfXPgPloc).introsx;reflexivity.-introshk;applyIHn;introsim.applyooextendable_over_homotopy.exact(Ploci).Defined.EndLocalization.DefinitionLoc@{ai} (f:LocalGenerators@{a}) :ReflectiveSubuniverse@{i}.Proof.snrefine(Build_ReflectiveSubuniverse(Build_Subuniverse(IsLocalf)__)(funA=>Build_PreReflects_A(LocalizefA)_(@locfA))(funA=>Build_Reflects____)).-Typeclass inference can find this, but we give it explicitly to prevent extra universes from cropping up.intros?T;unfoldIsLocal.nrefine(istrunc_forall@{aii});tryassumption.introsi.applyishprop_ooextendable@{aaiiiiiiiiiiiiii}.-applyislocal_equiv_islocal.-applyislocal_localize.-cbn.introsQQ_inO.applyext_localize_ind;intros?.applyooextendable_over_const.applyQ_inO.Defined.Here is the "real" definition of the notationIsLocal.  Defining it this way allows it to inherit typeclass inference fromIn, unlike (for instance) the slightly annoying case ofIsTruncnversusIn(Trn).NotationIsLocalf:= (In(Locf)).SectionLocalTypes.Context(f:LocalGenerators).A remark on universes: recall thatooExtendableAlongtakes four universe parameters, three for the sizes of the types involved and one for the max of all of them.  In the definition ofIsLocalfXwe set that max universe to be the same as the size ofX, so thatIn(Locf)Xwould lie in the same universes asX, which is necessary for our definition of a reflective subuniverse.  However, in practice we may need this extendability property with the max universe being larger, to avoid coalescing universes undesiredly.  Thus, in making it available by the following name, we also insert aliftto generalize the max universe.Definitionooextendable_islocal{X:Type@{i}} {Xloc:IsLocalfX}i:ooExtendableAlong@{aaik} (fi) (fun_=>X):= (lift_ooextendablealong__(Xloci)).Global Instanceislocal_loc(X:Type) :IsLocalf(LocalizefX):=islocal_localizefX.Global Instanceisequiv_precomp_islocal`{Funext}{X:Type} `{IsLocalfX}i:IsEquiv(fung=>gofi):=isequiv_ooextendable(fun_=>X) (fi) (ooextendable_islocali).The non-dependent eliminatorDefinitionLocalize_rec{XZ:Type} `{IsLocalfZ} (g:X->Z):LocalizefX->Z.Proof.refine(Localize_indfX(fun_=>Z)g_);introsi.applyooextendable_over_const.applyooextendable_islocal.Defined.Definitionlocal_rec{X} `{IsLocalfX} {i} (g:lgen_domainfi->X):lgen_codomainfi->X:= (fst(ooextendable_islocali1%nat)g).1.Definitionlocal_rec_beta{X} `{IsLocalfX} {i} (g:lgen_domainfi->X)s:local_recg(fis) =gs:= (fst(ooextendable_islocali1%nat)g).2s.Definitionlocal_indpaths{X} `{IsLocalfX} {i} {hk:lgen_codomainfi->X}(p:hofi==kofi):h==k:= (fst(snd(ooextendable_islocali2)hk)p).1.Definitionlocal_indpaths_beta{X} `{IsLocalfX} {i} (hk:lgen_codomainfi->X)(p:hofi==kofi)s:local_indpathsp(fis) =ps:= (fst(snd(ooextendable_islocali2)hk)p).2s.EndLocalTypes.Argumentslocal_rec:simplnever.Argumentslocal_rec_beta:simplnever.Argumentslocal_indpaths:simplnever.Argumentslocal_indpaths_beta:simplnever.Localization and accessibilityLocalization subuniverses are accessible, essentially by definition.  Without the universe annotations,aandiget collapsed.Global Instanceaccrsu_loc@{ai} (f:LocalGenerators@{a}) :IsAccRSU@{ai} (Loc@{ai}f).Proof.unshelveeconstructor.-exactf.-intros;split;applyidmap.Defined.Conversely, if a subuniverse is accessible, then the corresponding localization subuniverse is equivalent to it, and moreover exists at every universe level and satisfies its computation rules judgmentally.  This is calledlift_accrsubut in fact it works equally well to *lower* the universe level, as long as both levels are no smaller than the sizeaof the generators.Definitionlift_accrsu@{aij} (O:Subuniverse@{i}) `{IsAccRSU@{ai}O}:ReflectiveSubuniverse@{j}:=Loc@{aj} (acc_lgenO).The lifted universe agrees with the original one, on any universe contained in bothiandjGlobal InstanceO_eq_lift_accrsu@{aijk} (O:Subuniverse@{i}) `{IsAccRSU@{ai}O}:O_eq@{ijk}O(lift_accrsu@{aij}O).Proof.Anyone stepping through this proof should doSetPrintingUniverses.split;introsAA_inO.-introsi.assert(e:=fst(inO_iff_islocalOA)A_inOi).apply(lift_ooextendablealong@{aaaaaaijkij} (acc_lgenOi) (fun_=>A)).exacte.-apply(inO_iff_islocalO).introsi.pose(e:=A_inOi).apply(lift_ooextendablealong@{aaaaaajikji} (acc_lgenOi) (fun_=>A)).exacte.Defined.DefinitionO_leq_lift_accrsu@{ai1i2}(O1:ReflectiveSubuniverse@{i1}) (O2:ReflectiveSubuniverse@{i2}) `{IsAccRSU@{ai1}O1}`{O_leq@{i1i2i2}O1O2}:O_leq@{i2i2i2} (lift_accrsu@{ai1i2}O1)O2.Proof.introsBB_inO1.apply(inO_leq@{i1i2i2}O1O2).apply(snd(inO_iff_islocalO1B)).introsi.specialize(B_inO1i).apply(lift_ooextendablealong@{aaaaaai2i1i2i2i1} (acc_lgenO1i) (fun_=>B)).exactB_inO1.Defined.Similarly, because localization is a HIT that has an elimination rule into types in *all* universes, for accessible reflective subuniverses we can show that containment implies connectedness properties with the universe containments in the other order.Definitionisconnected_O_leq'@{ai1i2}(O1:ReflectiveSubuniverse@{i1}) (O2:ReflectiveSubuniverse@{i2}) `{IsAccRSU@{ai1}O1}Compared toO_leq@{i1i2i1}andA:Type@{i1}inisconnected_O_leq, these two lines are what makei2<=i1instead of vice versa.`{O_leq@{i1i2i2}O1O2} (A:Type@{i2})`{IsConnectedO2A}:IsConnectedO1A.Proof.Anyone stepping through this proof should doSetPrintingUniverses.srefine(isconnected_O_leqO1(lift_accrsu@{ai1i1}O1)A).1-2:exact_.change(Contr@{i1} (Localize@{ai2} (acc_lgen@{ai1}O1)A)).At this point you should also doUnsetPrintingNotationsto see the universe annotation onIsTruncchange.refine(contr_equiv'@{i2i1}_1%equiv).change(IsConnected@{i2} (lift_accrsu@{ai1i2}O1)A).srapply(isconnected_O_leq_O2).rapplyO_leq_lift_accrsu.Defined.And similarly for connected maps.Definitionconn_map_O_leq'@{ai1i2}(O1:ReflectiveSubuniverse@{i1}) (O2:ReflectiveSubuniverse@{i2}) `{IsAccRSU@{ai1}O1}`{O_leq@{i1i2i2}O1O2} {AB:Type@{i2}}(f:A->B) `{IsConnMapO2ABf}:IsConnMapO1f.Proof.Anyone stepping through this proof should doSetPrintingUniverses.introsb.apply(isconnected_equiv'O1(hfiber@{i2i2}fb)).-srapplyequiv_adjointify.1-2:intros[up];exact(u;p).all:intros[up];reflexivity.-apply(isconnected_O_leq'O1O2).applyisconnected_hfiber_conn_map.Defined.The same is true for inverted maps, too.DefinitionO_inverts_O_leq'@{ai1i2}(O1:ReflectiveSubuniverse@{i1}) (O2:ReflectiveSubuniverse@{i2}) `{IsAccRSU@{ai1}O1}`{O_leq@{i1i2i2}O1O2} {AB:Type@{i2}}(f:A->B) `{O_invertsO2f}:O_invertsO1f.Proof.assert(oleq:=O_leq_lift_accrsuO1O2).assert(e:=O_inverts_O_leq(lift_accrsu@{ai1i2}O1)O2f);clearoleq.nrapply(O_inverts_O_leqO1(lift_accrsu@{ai1i1}O1)f).1:exact_.It looks like we can sayexacte, but that would collapse the universesi1andi2.  You can check withSetPrintingUniverses.UnsetPrintingNotations.thateand the goal have different universes.  So instead we do this:refine(@isequiv_homotopic____e_).applyO_indpaths;introsx;reflexivity.Defined.

--- Miscellaneous\Locator.html ---
LocatorLibrary LocatorRequireImportBasicsDPropBoundedSearchSpaces.Finite.FinExcludedMiddleClasses.interfaces.abstract_algebraClasses.interfaces.ordersClasses.interfaces.rationalsClasses.interfaces.cauchyClasses.interfaces.archimedeanClasses.interfaces.roundClasses.interfaces.naturalsClasses.implementations.peano_naturalsClasses.orders.archimedeanClasses.orders.dec_fieldsClasses.orders.latticesClasses.theory.apartnessClasses.theory.rationalsClasses.orders.fieldsClasses.theory.fieldsClasses.theory.dec_fields.Local OpenScopetype_scope.Sectionlocator.Context(Q:Type).Context`{Qrats:RationalsQ}.Context{Qdec_paths:DecidablePathsQ}.Context{Qtriv:TrivialApartQ}.Context`{!Trichotomy(<)}.Context(F:Type).Context`{Forderedfield:OrderedFieldF}.Context{Fabs:AbsF}.Context{Farchimedean:ArchimedeanPropertyQF}.Context{Fcomplete:IsCompleteQF}.Context{Qroundup:RoundUpStrictQ}.Context`{Funext} `{Univalence}.(* Assume we have enumerations of the rationals, and of pairs of ordered rationals. *)Context(Q_eq:nat<~>Q).Context(QQpos_eq:nat<~>Q*QposQ).Instanceqinc:CastQF:=rationals_to_fieldQF.(* TODO The following two instances should probably come from the `Rationals` instance. *)Context(cast_pres_ordering:StrictlyOrderPreservingqinc)(qinc_strong_presving:IsSemiRingStrongPreservingqinc).Existing Instancecast_pres_ordering.Existing Instanceqinc_strong_presving.(* Definition of a locator for a fixed real number. *)Definitionlocator(x:F) :=forallqr:Q,q<r-> ('q<x) + (x< 'r).(* Alternative definition; see equivalence below *)Recordlocator'(x:F) :={locates_right:forallqr:Q,q<r->DHProp;locates_right_true:forallqr:Q,forallnu:q<r,locates_rightqrnu-> 'q<x;locates_right_false:forallqr:Q,forallnu:q<r, ~locates_rightqrnu->x< 'r}.Argumentslocates_right[x]_[q] [r]_.Argumentslocates_right_true[x]_[q] [r]_.Argumentslocates_right_false[x]_[q] [r]_.Definitionlocates_left{x:F} (l:locator'x) {qr:Q} :q<r->DHProp:=funnu=>Build_DHProp(Build_HProp(~ (locates_rightlnu)))_.Sectionclassical.Context`{ExcludedMiddle}.Lemmaall_reals_locators(x:F) :locatorx.Proof.introsqrltqr.case(LEM('q<x)).-apply_.-exactinl.-introsnotlt.applyinr.assert(ltqr': 'q< 'r)byauto.exact(nlt_lt_transnotltltqr').Qed.Endclassical.Sectionrational.Context(s:Q).Lemmalocator_left:locator('s).Proof.introsqrltqr.destruct(trichotomy_qs)as[ltqs|[eqqs|ltsq]].-applyinl.apply(strictly_order_preserving_);assumption.-rewriteeqqsinltqr.applyinr, (strictly_order_preserving_);assumption.-applyinr, (strictly_order_preserving_), (transitivityltsqltqr);assumption.Qed.Definitionlocator_second:locator('s).Proof.introsqrltqr.destruct(trichotomy_sr)as[ltsr|[eqsr|ltrs]].-applyinr, (strictly_order_preserving_);assumption.-rewrite<-eqsrinltqr.applyinl, (strictly_order_preserving_);assumption.-applyinl, (strictly_order_preserving_), (transitivityltqrltrs).Qed.Endrational.Sectionlogic.Context{x:F}.Definitionlocator_locator':locatorx->locator'x.Proof.introsl.refine(Build_locator'x(funqrnu=>Build_DHProp(Build_HProp(is_inl(lqrnu)))_)__).-introsqrnu.simpl.applyun_inl.-introsqrnu.simpl.destruct(lqrnu)as[ltqx|].+simpl;introsf;destruct(ftt).+intros?;assumption.Defined.Definitionlocator'_locator:locator'x->locatorx.Proof.introsl'qrnu.destruct(dec(locates_rightl'nu))as[yes|no].-applyinl.exact(locates_right_truel'nuyes).-applyinr.exact(locates_right_falsel'nuno).Defined.Endlogic.Sectionlogic2.Context{x:F}.Coercionlocator_locator':locator>->locator'.Definitionlocator_locator'_locator(l:locatorx) :locator'_locator(locator_locator'l) =l.Proof.applypath_forall;introsq.applypath_forall;introsr.applypath_forall;introsnu.unfoldlocator'_locator,locator_locator'.simpl.destruct(lqrnu);auto.Qed.Local Definitionlocsig:_<~>locator'x:=ltac:(issig).Lemmalocator'_locator_locator'(l':locator'x):locator_locator'(locator'_locatorl') =l'.Proof.enough(p:locsig^-1 (locator_locator'(locator'_locatorl')) =locsig^-1l').-refine(equiv_inj(locsig^-1)p).-unfoldlocsig;simpl.destructl';unfoldlocator'_locator,locator_locator';simpl.applypath_sigma_hprop;simpl.applypath_forall;introq;applypath_forall;intror;applypath_arrow;intronu.applyequiv_path_dhprop;simpl.rewrite(path_dec(locates_right0qrnu)).destruct(dec(locates_right0qrnu));auto.Qed.Definitionequiv_locator_locator':locatorx<~>locator'x:=equiv_adjointifylocator_locator'locator'_locatorlocator'_locator_locator'locator_locator'_locator.Lemmanltqx_locates_left{qr:Q} (l':locator'x) (ltqr:q<r): ~ ('q<x) ->locates_leftl'ltqr.Proof.assert(f:=locates_right_truel'ltqr).exact(not_contrapositivef).Qed.Lemmaltxq_locates_left{qr:Q} (l':locator'x) (ltqr:q<r):x< 'q->locates_leftl'ltqr.Proof.introsltxq.applynltqx_locates_left.applylt_flip;assumption.Qed.Lemmanltxr_locates_right{qr:Q} (l':locator'x) (ltqr:q<r): ~ (x< 'r) ->locates_rightl'ltqr.Proof.introsnltxr.applystable.assert(f:=locates_right_falsel'ltqr).exact(not_contrapositivefnltxr).Qed.Lemmaltrx_locates_right{qr:Q} (l':locator'x) (ltqr:q<r): 'r<x->locates_rightl'ltqr.Proof.introsltrx.applynltxr_locates_right.applylt_flip;assumption.Qed.Endlogic2.Local DefinitionltQnegQ(q:Q) (eps:QposQ) :q- 'eps<q.Proof.apply(pos_minus_lt_compat_rq('eps)),eps.Qed.Local OpenScopemc_scope.Local DefinitionltQposQ(q:Q) (eps:QposQ) :q<q+ 'eps.Proof.apply(pos_plus_lt_compat_rq('eps)),eps.Qed.Sectionbounds.(* Given a real with a locator, we can find (integer) bounds. *)Context{x:F}(l:locatorx).Local DefinitionltN1(q:Q) :q- 1 <q:=ltQnegQq1.Local DefinitionP_lower(q:Q) :Type:=locates_rightl(ltN1q).DefinitionP_lower_prop{k} :IsHProp(P_lowerk).Proof.apply_.Qed.Local DefinitionltxN1:x- 1 <x:= (fst(pos_minus_lt_compat_rx1)lt_0_1).Local DefinitionP_lower_inhab:hexists(funq=>P_lowerq).Proof.assert(hqlt:hexists(funq=> 'q<x)).{assert(hex:=archimedean_propertyQF(x-1)xltxN1).refine(Trunc_rec_hex);introshex'.applytr.destructhex'as[q[ltx1qltqx]];existsq;assumption.}refine(Trunc_rec_hqlt);introshqlt'.inductionhqlt'as[qlt].applytr.existsq.unfoldP_lower.applyltrx_locates_right;assumption.Qed.Definitionlower_bound: {q:Q| 'q<x}.Proof.assert(qP_lower: {q:Q|P_lowerq})byrefine(minimal_n_alt_typeQQ_eqP_lower_P_lower_inhab).destructqP_loweras[qPq].exists(q- 1).unfoldP_lowerinPq.simplin*.apply(un_inl_Pq).Qed.Local Definitionlt1N(r:Q) :r<r+ 1 :=ltQposQr1.Local DefinitionP_upper(r:Q) :DHProp:=locates_leftl(lt1Nr).DefinitionP_upper_prop{k} :IsHProp(P_upperk).Proof.apply_.Qed.Local Definitionltx1N:x<x+ 1 := (fst(pos_plus_lt_compat_rx1)lt_0_1).Local DefinitionP_upper_inhab:hexists(funr=>P_upperr).Proof.assert(hqlt:hexists(funr=>x< 'r)).{assert(hex:=archimedean_propertyQFx(x+1)ltx1N).refine(Trunc_rec_hex);introshex'.applytr.destructhex'as[r[ltxrltrx1]];existsr;assumption.}refine(Trunc_rec_hqlt);introshqlt'.inductionhqlt'as[rlt].applytr.existsr.unfoldP_upper.applyltxq_locates_left;assumption.Qed.Definitionupper_bound: {r:Q|x< 'r}.Proof.assert(rP_upper: {r:Q|P_upperr})byrefine(minimal_n_alt_typeQQ_eqP_upper_P_upper_inhab).destructrP_upperas[rPr].exists(r+ 1).unfoldP_upperinPr.simplin*.destruct(lr(r+ 1) (lt1Nr)).-simplinPr.destruct(Prtt).-assumption.Qed.Instanceinc_N_Q:CastnatQ:=naturals_to_semiringnatQ.Instanceinc_fin_N{n} :Cast(Finn)nat:=fin_to_nat.Lemmatight_bound(epsilon:QposQ) : {u:Q| 'u<x< ' (u+ 'epsilon)}.Proof.destructlower_boundas[qltqx],upper_boundas[rltxr], (round_up_strictQ((3/'epsilon)*(r-q)))as[nlt3rqn].assert(lt0: 0 < 'epsilon/ 3).{applypos_mult.-applyepsilon.-applypos_dec_recip_compat,lt_0_3.}assert(lt0': 0 < 3 / 'epsilon).{applypos_mult.-applylt_0_3.-applypos_dec_recip_compat,epsilon.}assert(ap30: (3 :Q) <> 0)byapplylt_ne_flip,lt_0_3.clear-lqltqxrltxrnlt3rqnlt0'ap30QtrivQdec_pathsHcast_pres_ordering.assert(ltn3eps:r<q+ 'n* 'epsilon/ 3).{rewrite(commutativityq('n* 'epsilon/ 3)).applyflip_lt_minus_l.apply(pos_mult_reflect_r(3 / 'epsilon)lt0').rewrite(commutativity(r-q) (3 / 'epsilon)).rewrite<- (associativity('n) ('epsilon) (/3)).rewrite<- (associativity('n) ('epsilon/ 3) (3 / 'epsilon)).rewrite<- (associativity('epsilon) (/3) (3/'epsilon)).rewrite(associativity(/3) 3 (/'epsilon)).rewrite(commutativity(/3) 3).rewrite(dec_recip_inverse3ap30).rewritemult_1_l.assert(apepsilon0: 'epsilon<> 0)byapplylt_ne_flip,epsilon.rewrite(dec_recip_inverse('epsilon)apepsilon0).rewritemult_1_r.assumption.}set(grid(k:Finn.+3) :=q+ (' ('k) - 1)*('epsilon/3) :Q).assert(lt_grid:forallk:Fin_,grid(fin_inclk) <grid(fsucck)).{introsk.unfoldgrid.change('fin_inclk)with(fin_to_nat(fin_inclk));rewritepath_nat_fin_incl.change('fsucck)with(fin_to_nat(fsucck));rewritepath_nat_fsucc.assert(' (S('k)) = (' ('k) + 1))as->.{rewriteS_nat_plus_1.rewrite(preserves_plus('k) 1).rewritepreserves_1.reflexivity.}assert(' ('k) + 1 - 1 = ' ('k) - 1 + 1)as->.{rewrite<- (associativity_1 (-1)).rewrite(commutativity1 (-1)).rewrite(associativity_(-1) 1).reflexivity.}assert(lt1: ' ('k) - 1 < ' ('k) - 1 + 1)byapplypos_plus_lt_compat_r,lt_0_1.assert(lt2: (' ('k) - 1) * ('epsilon/ 3) < (' ('k) - 1 + 1) * ('epsilon/ 3)).{nrefine(pos_mult_lt_r('epsilon/3)_(' ('k) - 1) (' ('k) - 1 + 1)_);tryapply_.applylt1.}applypseudo_srorder_plus.exactlt2.}set(Pk:=locates_rightl(lt_gridk)).assert(left_true:Pfin_zero).{applyltrx_locates_right.unfoldgrid.change('fsuccfin_zero)with(fin_to_nat(@fsucc(Sn)fin_zero)).rewritepath_nat_fsucc,path_nat_fin_zero.rewrite(@preserves_1natQ__________).rewriteplus_negate_r.rewritemult_0_l.rewriteplus_0_r.assumption.}assert(right_false: ~Pfin_last).{applyltxq_locates_left.unfoldgrid.change('fin_inclfin_last)with(fin_to_nat(@fin_incl(S(Sn))fin_last)).rewritepath_nat_fin_incl,path_nat_fin_last.rewriteS_nat_plus_1.rewrite(preserves_plusn1).rewrite(@preserves_1natQ__________).rewrite<- (associativity('n) 1 (-1)).rewriteplus_negate_r.rewriteplus_0_r.rewrite(associativity('n) ('epsilon) (/3)).transitivity('r).-exactltxr.-applystrictly_order_preserving;trytrivial.}destruct(sperners_lemma_1dPleft_trueright_false)as[u[PltuxPltxueps]].exists(grid(fin_incl(fin_inclu))).unfoldPinPltux,Pltxueps.split.-apply(locates_right_truel(lt_grid(fin_inclu))Pltux).-clear-PltxuepsQtrivQdec_pathsap30cast_pres_ordering.set(ltxbla:=locates_right_falsel(lt_grid(fsuccu))Pltxueps).unfoldgridin*.change('fin_incl(fin_inclu))with(fin_to_nat(fin_incl(fin_inclu))).rewritepath_nat_fin_incl,path_nat_fin_incl.change('fsucc(fsuccu))with(fin_to_nat(fsucc(fsuccu)))inltxbla.rewritepath_nat_fsucc,path_nat_fsuccinltxbla.rewriteS_nat_plus_1,S_nat_plus_1inltxbla.rewrite(preserves_plus(fin_to_natu+ 1) 1)inltxbla.rewrite(preserves_plus(fin_to_natu) 1)inltxbla.rewritepreserves_1inltxbla.rewrite<- (associativity('fin_to_natu) 1 1)inltxbla.rewrite<- (associativity('fin_to_natu) 2 (-1))inltxbla.rewrite(commutativity2 (-1))inltxbla.rewrite(associativity('fin_to_natu) (-1) 2)inltxbla.rewriteplus_mult_distr_rinltxbla.rewrite(associativityq(('fin_to_natu- 1) * ('epsilon/ 3)) (2 * ('epsilon/ 3)))inltxbla.refine(transitivityltxbla_).applystrictly_order_preserving;tryapply_.applypseudo_srorder_plus.rewrite(associativity2 ('epsilon) (/3)).rewrite(commutativity2 ('epsilon)).rewrite<- (mult_1_r('epsilon)).rewrite<- (associativity('epsilon) 1 2).rewrite(mult_1_l2).rewrite<- (associativity('epsilon) 2 (/3)).applypos_mult_lt_l.+applyepsilon.+nrefine(pos_mult_reflect_r(3 :Q)lt_0_3___);tryapply_.rewrite<- (associativity2 (/3) 3).rewrite(commutativity(/3) 3).rewrite(dec_recip_inverse(3 :Q)ap30).rewrite(mult_1_r2).rewrite(mult_1_l3).exactlt_2_3.Qed.Endbounds.Sectionarch_struct.Context{xy:F}(l:locatorx)(m:locatory)(ltxy:x<y).Local DefinitionP(qeps':Q*QposQ) :Type:=matchqeps'with| (q',eps') =>(prod(locates_leftl(ltQnegQq'eps'))(locates_rightm(ltQposQq'eps')))end.Local DefinitionP_isHPropqeps':IsHProp(Pqeps').Proof.destructqeps'as[qeps'].applyistrunc_prod.Qed.Local DefinitionP_decqeps':Decidable(Pqeps').Proof.destructqeps'as[qeps'].unfoldP.apply_.Qed.Local DefinitionP_inhab:hexistsP.Proof.assert(hs:= (archimedean_propertyQFxyltxy)).refine(Trunc_ind__hs);intros[s[ltxsltsy]].assert(ht:= (archimedean_propertyQF('s)yltsy)).refine(Trunc_ind__ht);intros[t[ltst'ltty]].set(q:= (t+s) / 2).assert(ltst:s<t).{ExistingInstancefull_pseudo_order_reflecting.refine(strictly_order_reflecting___ltst').}set(epsilon:= (Qpos_diffstltst) / 2).applytr.exists(q,epsilon).unfoldP;split.-applyltxq_locates_left.assert(q- 'epsilon=s)as->.{unfoldq;cbn.rewrite<-path_avg_split_diff_l.rewrite<- (plus_assocs((t-s)/2) (-((t-s)/2))).rewriteplus_negate_r.rewriteplus_0_r.reflexivity.}assumption.-applyltrx_locates_right.assert(q+ 'epsilon=t)as->.{unfoldq;cbn.rewrite<-path_avg_split_diff_r.rewrite<- (plus_assoct(-((t-s)/2)) ((t-s)/2)).rewriteplus_negate_l.rewriteplus_0_r.reflexivity.}assumption.Qed.Definitionarchimedean_structure: {q:Q|x< 'q<y}.Proof.assert(R:sigP).{applyminimal_n_alt_type.-applyQQpos_eq.-applyP_dec.-applyP_inhab.}unfoldPinR.destructRas[[qeps] [lleftmright]].existsq;split.-nrefine(locates_right_falsel_lleft).-nrefine(locates_right_truem_mright).Qed.Endarch_struct.Sectionunary_ops.Context{x:F}(l:locatorx).Definitionlocator_minus:locator(-x).Proof.introsqrltqr.assert(ltnrnq:=snd(flip_lt_negateqr)ltqr: -r< -q).destruct(l__ltnrnq)as[ltnrx|ltxnq].-applyinr.applychar_minus_left.rewrite<-preserves_negate.assumption.-applyinl.applychar_minus_right.rewrite<-preserves_negate.assumption.Qed.Sectionrecip_pos.Context(xpos: 0 <x).Local Definitionrecip_nu:=positive_apart_zeroxxpos.Definitionlocator_recip_pos:locator(// (x;recip_nu)).Proof.assert(recippos: 0 < // (x;recip_nu))byapplypos_recip_compat.introsqrltqr.destruct(trichotomy_q0)as[qneg|[qzero|qpos]].+applyinl.refine(transitivity__).*apply(strictly_order_preserving_).exactqneg.*rewritepreserves_0;assumption.+applyinl.rewriteqzero,preserves_0;assumption.+assert(qap0:q≶ 0)byapply(pseudo_order_lt_apart_flip__qpos).assert(rap0:r≶ 0).{refine(pseudo_order_lt_apart_flip___).apply(transitivityqposltqr).}assert(ltrrrq: /r< /q)by(applyflip_lt_dec_recip;assumption).destruct(l(/r) (/q)ltrrrq)as[ltrrx|ltxrq].*applyinr.assert(rpos: 0 <r)by(transitivityq;assumption).assert(rpos': 0 < 'r).{rewrite<- (@preserves_0QF__________).applystrictly_order_preserving;tryapply_;assumption.}rewrite(dec_recip_to_recipr(positive_apart_zero('r)rpos'))inltrrx.assert(ltxrr:=flip_lt_recip_lx('r)rpos'ltrrx).cbninltxrr.rewrite(recip_irrelevantx(positive_apart_zerox(transitivity(pos_recip_compat('r)rpos')ltrrx))recip_nu)inltxrr.exactltxrr.*applyinl.assert(qpos': 0 < 'q).{rewrite<- (@preserves_0QF__________).applystrictly_order_preserving;tryapply_;assumption.}rewrite(dec_recip_to_recipq(positive_apart_zero('q)qpos'))inltxrq.assert(ltrqx:=flip_lt_recip_r('q)xqpos'xposltxrq).rewrite(recip_irrelevantx(positive_apart_zeroxxpos)recip_nu)inltrqx.exactltrqx.Qed.Endrecip_pos.Endunary_ops.Sectionrecip_neg.Context{x:F}(l:locatorx)(xneg:x< 0).Local Definitionrecip_neg_nu:=negative_apart_zeroxxneg.Definitionlocator_recip_neg:locator(// (x;recip_neg_nu)).Proof.assert(negxpos: 0 < (-x))by(applyflip_neg_negate;assumption).assert(l':=locator_minus(locator_recip_pos(locator_minusl)negxpos)).rewrite(recip_negate(-x))inl'.unfoldnegate_apartinl'.rewrite(recip_proper_alt(- -x)x(apart_negate(-x) (positive_apart_zero(-x)negxpos))recip_neg_nu)inl'.-assumption.-applynegate_involutive.Qed.Endrecip_neg.Sectionunary_ops2.Context{x:F}(l:locatorx)(nu:x≶ 0).Definitionlocator_recip:locator(// (x;nu)).Proof.destruct(fst(apart_iff_total_ltx0)nu)as[xneg|xpos].-set(l':=locator_recip_neglxneg).rewrite(recip_proper_altxx(negative_apart_zeroxxneg)nu)inl';tryreflexivity;exactl'.-set(l':=locator_recip_poslxpos).rewrite(recip_proper_altxx(positive_apart_zeroxxpos)nu)inl';tryreflexivity;exactl'.Qed.Endunary_ops2.Sectionbinary_ops.Context{xy:F}(l:locatorx)(m:locatory).TODO the following two should be proven in Classes/orders/archimedean.vContext(char_plus_left:forall(q:Q) (xy:F),'q<x+y<->hexists(funs:Q=> ('s<x) /\ (' (q-s) <y)))(char_plus_right:forall(r:Q) (xy:F),x+y< 'r<->hexists(funt:Q=> (x< 't) /\ (y< ' (r-t)))).Definitionlocator_plus:locator(x+y).Proof.introsqrltqr.set(epsilon:= (Qpos_diffqrltqr) / 2).assert(q+'epsilon=r-'epsilon)by(rewritepath_avg_split_diff_l,path_avg_split_diff_r;reflexivity).destruct(tight_boundmepsilon)as[u[ltuyltyuepsilon]].set(s:=q-u).assert(qsltx: 'q-'s<y).{unfolds.rewrite(preserves_plusq(-u)).rewritenegate_plus_distr.rewrite(associativity('q) (-'q) (-'(-u))).rewriteplus_negate_r.rewriteplus_0_l.rewrite(preserves_negateu).rewritenegate_involutive.assumption.}assert(sltseps:s<s+'epsilon)byapplyltQposQ.destruct(ls(s+'epsilon)sltseps)as[ltsx|ltxseps].-applyinl.applychar_plus_left.applytr;existss;split;tryassumption.rewritepreserves_minus;assumption.-applyinr.applychar_plus_right.applytr.set(t:=s+ 'epsilon);existst.split;tryassumption.assert(r-(q-u+(r-q)/2)=u+'epsilon)as->.{change((r-q) / 2)with('epsilon).rewritenegate_plus_distr.rewrite<-negate_swap_l.rewrite(plus_comm(-q)u).rewrite(plus_assocr(u-q) (-'epsilon)).rewrite(plus_assocru(-q)).rewrite(plus_commru).rewrite<- (plus_assocur(-q)).rewrite<- (plus_assocu(r-q) (-'epsilon)).rewrite(plus_commr(-q)).rewrite<- (plus_assoc(-q)r(-'epsilon)).rewritepath_avg_split_diff_r.rewrite<-path_avg_split_diff_l.rewrite(plus_assoc(-q)q((r-q)/2)).rewrite(plus_negate_lq).rewrite(plus_0_l_).reflexivity.}assumption.Qed.(* TODO construct locators for multiplications. *)Lemmalocator_times:locator(x*y).Proof.Abort.Lemmalocator_meet:locator(meetxy).Proof.introsqrltqr.destruct(lqrltqr,mqrltqr)as[[ltqx|ltxr] [ltqy|ltyr]].-applyinl,meet_lt_l;assumption.-applyinr,meet_lt_r_r;assumption.-applyinr,meet_lt_r_l;assumption.-applyinr,meet_lt_r_r;assumption.Qed.Lemmalocator_join:locator(joinxy).Proof.introsqrltqr.destruct(lqrltqr,mqrltqr)as[[ltqx|ltxr] [ltqy|ltyr]].-applyinl,join_lt_l_l;assumption.-applyinl,join_lt_l_l;assumption.-applyinl,join_lt_l_r;assumption.-applyinr,join_lt_r;assumption.Qed.Endbinary_ops.Sectionlimit.Context{xs:nat->F}.Context{M} {M_ismod:CauchyModulusQFxsM}.Context(ls:foralln,locator(xsn)).Lemmalocator_limit{l} :IsLimit__xsl->locatorl.Proof.introsislim.introsqrltqr.set(epsilon:= (Qpos_diffqrltqr) / 3).(* TODO we are doing trisection so we have the inequality: *)assert(ltqepsreps:q+ 'epsilon<r- 'epsilon).{apply(strictly_order_reflecting(+'epsilon)).rewrite<- (plus_assocr(-'epsilon) ('epsilon)).rewriteplus_negate_l.rewriteplus_0_r.rewrite<- (plus_assocq('epsilon) ('epsilon)).apply(strictly_order_reflecting((-q)+)).rewrite(plus_assoc(-q)q_).rewriteplus_negate_l,plus_0_l.rewrite(plus_comm(-q)r).rewrite<- (mult_1_r('epsilon)).rewrite<-plus_mult_distr_l.unfoldepsilon,cast,Qpos_diff;cbn.rewrite<- (mult_assoc(r-q) (/3) 2).pattern(r-q)at2.rewrite<- (mult_1_r(r-q)).assert(rqpos: 0 <r-q)byapply(Qpos_diffqrltqr).apply(strictly_order_preserving((r-q)*.)).apply(strictly_order_reflecting(3*.)).rewrite(mult_assoc3 (/3) 2).rewrite(dec_recip_inverse3).-rewritemult_1_r,mult_1_l.exactlt_2_3.-applyapart_ne,positive_apart_zero,lt_0_3.}destruct(ls(M(epsilon/ 2)) (q+ 'epsilon) (r- 'epsilon)ltqepsreps)as[ltqepsxs|ltxsreps].+applyinl.rewritepreserves_plusinltqepsxs.assert(ltqxseps: 'q<xs(M(epsilon/ 2)) - ' ('epsilon))by(applyflip_lt_minus_r;assumption).refine(transitivityltqxseps_).apply(modulus_close_limit_____).+applyinr.rewrite(preserves_plusr(-'epsilon))inltxsreps.rewrite(preserves_negate('epsilon))inltxsreps.assert(ltxsepsr:xs(M(epsilon/ 2)) + ' ('epsilon) < 'r)by(applyflip_lt_minus_r;assumption).refine(transitivity_ltxsepsr).apply(modulus_close_limit_____).Qed.Endlimit.Endlocator.

--- Miscellaneous\LoopExp.html ---
LoopExpLibrary LoopExpRequireImportBasics.RequireImportTypes.Universe.RequireImportSpaces.Pos.RequireImportSpaces.BinInt.Core.RequireImportSpaces.BinInt.Spec.RequireImportSpaces.BinInt.Equiv.Local OpenScopepositive_scope.Local OpenScopebinint_scope.Exponentiation of loopsDefinitionloopexp_pos{A:Type} {x:A} (p:x=x) (n:Pos) : (x=x).Proof.revertn.srapplypos_peano_ind.+exactp.+introsnq.exact(q@p).Defined.Definitionloopexp{A:Type} {x:A} (p:x=x) (z:BinInt) : (x=x):=matchzwith|negn=>loopexp_posp^n|zero=> 1|posn=>loopexp_pospnend.TODO: One can also defineloopexpasint_iter(equiv_concat_rpx)zidpath.  This has slightly different computational behaviour, e.g., it sends1:intto1@prather thanp.  But with this definition, some of the results below become special cases of results in BinInt.Equiv, and others could be generalized to results belonging in BinInt.Equiv.  It's probably worth investigating this.Lemmaloopexp_pos_inv{A:Type} {x:A} (p:x=x) (n:Pos):loopexp_posp^n= (loopexp_pospn)^.Proof.revertn.srapplypos_peano_ind;cbn;trivial.unfoldloopexp_pos.introsnq.rewrite2pos_peano_ind_beta_pos_succ,q.refine((inv_pp__)^ @_).applyap.clearq.revertn.srapplypos_peano_ind;cbn;trivial.introsnq.byrewritepos_peano_ind_beta_pos_succ,concat_p_pp,q.Qed.Definitionap_loopexp_pos{AB} (f:A->B) {x:A} (p:x=x) (n:Pos):apf(loopexp_pospn) =loopexp_pos(apfp)n.Proof.revertn.srapplypos_peano_ind;cbn;trivial.unfoldloopexp_pos.introsnq.rewrite2pos_peano_ind_beta_pos_succ.byrewriteap_pp,q.Qed.Definitionap_loopexp{AB} (f:A->B) {x:A} (p:x=x) (z:BinInt):apf(loopexppz) =loopexp(apfp)z.Proof.destructzas[n| |n];trivial.+cbn.rewriteloopexp_pos_inv,ap_V,loopexp_pos_inv.applyap.applyap_loopexp_pos.+applyap_loopexp_pos.Qed.Lemmaloopexp_pos_concat{A:Type} {x:A} (p:x=x) (a:Pos):loopexp_pospa@p=p@loopexp_pospa.Proof.inductionaas[|aaH]usingpos_peano_ind;trivial.unfoldloopexp_pos.rewritepos_peano_ind_beta_pos_succ.change((loopexp_pospa@p) @p=p@ (loopexp_pospa@p)).byrewriteconcat_p_pp,aH.Qed.Lemmaloopexp_pos_add{A:Type} {x:A} (p:x=x) (ab:Pos):loopexp_posp(a+b)%pos=loopexp_pospa@loopexp_pospb.Proof.revertab.inductionaas[|aaH]usingpos_peano_ind;inductionbas[|bbH]usingpos_peano_ind;trivial.+rewritepos_add_1_lin*.unfoldloopexp_pos.rewritepos_peano_ind_beta_pos_succ.change(loopexp_posp(pos_succb) @p=p@loopexp_posp(pos_succb)).rewritebH;cbn.byrewriteconcat_pp_p,loopexp_pos_concat.+rewritepos_add_1_rin*.unfoldloopexp_pos.byrewritepos_peano_ind_beta_pos_succ.+rewritepos_add_succ_l.unfoldloopexp_pos.rewrite2pos_peano_ind_beta_pos_succ.change(loopexp_posp(a+pos_succb)%pos@p= (loopexp_pospa@p) @loopexp_posp(pos_succb)).byrewriteaH, 2concat_pp_p,loopexp_pos_concat.Qed.Lemmaloopexp_binint_pos_sub_l{A:Type} {x:A} (p:x=x) (ab:Pos):loopexpp(binint_pos_subab) =loopexp_posp^b@loopexp_pospa.Proof.symmetry.revertab.inductionaas[|aaH]usingpos_peano_ind;inductionbas[|bbH]usingpos_peano_ind.+applyconcat_Vp.+cbn;rewritebinint_pos_sub_succ_r.unfoldloopexp_pos.rewritepos_peano_ind_beta_pos_succ.byrewriteconcat_pp_p,concat_Vp,concat_p1.+rewritebinint_pos_sub_succ_l;cbn.unfoldloopexp_pos.rewritepos_peano_ind_beta_pos_succ.rewriteloopexp_pos_concat.byrewriteconcat_p_pp,concat_Vp,concat_1p.+rewritebinint_pos_sub_succ_succ.unfoldloopexp_pos.rewrite2pos_peano_ind_beta_pos_succ.change((loopexp_posp^b@p^) @ (loopexp_pospa@p)=loopexpp(binint_pos_subab)).rewrite(loopexp_pos_concatp).rewriteconcat_pp_p, (concat_p_ppp^p).rewriteconcat_Vp,concat_1p.applyaH.Qed.Lemmaloopexp_binint_pos_sub_r{A:Type} {x:A} (p:x=x) (ab:Pos):loopexpp(binint_pos_subab) =loopexp_pospa@loopexp_posp^b.Proof.symmetry.revertab.inductionaas[|aaH]usingpos_peano_ind;inductionbas[|bbH]usingpos_peano_ind.+applyconcat_pV.+cbn;rewritebinint_pos_sub_succ_r.unfoldloopexp_pos.rewritepos_peano_ind_beta_pos_succ.change(p@ (loopexp_posp^b@p^) =loopexpp(negb)).rewriteloopexp_pos_concat.byrewriteconcat_p_pp,concat_pV,concat_1p.+rewritebinint_pos_sub_succ_l;cbn.unfoldloopexp_pos.rewritepos_peano_ind_beta_pos_succ.change((loopexp_pospa@p) @p^ =loopexp_pospa).byrewriteconcat_pp_p,concat_pV,concat_p1.+rewritebinint_pos_sub_succ_succ.unfoldloopexp_pos.rewrite2pos_peano_ind_beta_pos_succ.change((loopexp_pospa@p) @ (loopexp_posp^b@p^)=loopexpp(binint_pos_subab)).rewrite(loopexp_pos_concatp^).rewriteconcat_pp_p, (concat_p_pppp^).rewriteconcat_pV,concat_1p.applyaH.Qed.Lemmaloopexp_add{A:Type} {x:A} (p:x=x)ab:loopexpp(a+b) =loopexppa@loopexppb.Proof.destructaas[a| |a],bas[b| |b];trivial;tryapplyloopexp_pos_add;cbn.1,6:symmetry;applyconcat_p1.2,3:symmetry;applyconcat_1p.1:applyloopexp_binint_pos_sub_l.applyloopexp_binint_pos_sub_r.Qed.Under univalence, exponentiation of loops corresponds to iteration of autoequivalences.Definitionequiv_path_loopexp{A:Type} (p:A=A) (z:BinInt) (a:A):equiv_pathAA(loopexppz)a=binint_iter(equiv_pathAAp)za.Proof.destructzas[n| |n];trivial.all:inductionnas[|nIH]usingpos_peano_ind;tryreflexivity;cbnin*.all:unfoldloopexp_pos;rewritepos_peano_ind_beta_pos_succ.all:unfoldpos_iter;rewritepos_peano_rec_beta_pos_succ.all:refine(transport_pp____@_);cbn;applyap,IH.Defined.Definitionloopexp_path_universe`{Univalence}{A:Type} (f:A<~>A) (z:BinInt) (a:A):transportidmap(loopexp(path_universef)z)a=binint_iterfza.Proof.revertf.equiv_intro(equiv_pathAA)p.refine(_@equiv_path_loopexppza).refine(ap(funq=>equiv_pathAA(loopexpqz)a)_).applyeissect.Defined.

--- Miscellaneous\Loops.html ---
LoopsLibrary LoopsRequireImportHoTT.BasicsHoTT.Types.RequireImportHFiberFactorizationTruncations.CoreTruncations.ConnectednessHProp.RequireImportPointed.CorePointed.pEquiv.RequireImportWildCat.RequireImportSpaces.Nat.Core.Local OpenScopepointed_scope.Local OpenScopepath_scope.Loop spacesThe typex=xis pointed.Global Instanceispointed_loopsA(a:A) :IsPointed(a=a) := 1.Definitionloops(A:pType) :pType:= [pointA=pointA, 1].Definitioniterated_loops(n:nat) (A:pType) :pType:=nat_iternloopsA.(* Inner unfolding for iterated loops *)Definitionunfold_iterated_loops(n:nat) (X:pType):iterated_loopsn.+1X=iterated_loopsn(loopsX):=nat_iter_succ_r___.The loop space decreases the truncation level by one.  We don't bother making this an instance because it is automatically found by typeclass search, but we record it here in case anyone is looking for it.Definitionistrunc_loops{n} (A:pType) `{IsTruncn.+1A}:IsTruncn(loopsA) :=_.Similarly for connectedness.Definitionisconnected_loops`{Univalence} {n} (A:pType)`{IsConnectedn.+1A} :IsConnectedn(loopsA) :=_.Lemmapequiv_loops_punit:loopspUnit<~>*pUnit.Proof.snrapplyBuild_pEquiv'.{srapply(equiv_adjointify(fun_=>tt) (fun_=>idpath)).1:byintros[].rapplypath_contr. }reflexivity.Defined.Functoriality of loop spacesAction on 1-cellsGlobal Instanceis0functor_loops:Is0Functorloops.Proof.applyBuild_Is0Functor.introsABf.refine(Build_pMap(loopsA) (loopsB)(funp=> (point_eqf)^ @ (apfp@point_eqf))_).refine(_@concat_Vp(point_eqf)).applywhiskerL.applyconcat_1p.Defined.Global Instanceis1functor_loops:Is1Functorloops.Proof.applyBuild_Is1Functor.Action on 2-cells-introsABfgp.pointed_reduce.srapplyBuild_pHomotopy;cbn.{introq.refine(_@ (concat_p1_)^ @ (concat_1p_)^).applymoveR_Vp.apply(concat_Ap(funx=>px@ 1)). }simpl.generalize(ppoint0).generalize(gpoint0).intros_[].reflexivity.Preservation of identity.-introsA.srapplyBuild_pHomotopy.{introp.refine(concat_1p_@concat_p1_@ap_idmap_). }reflexivity.Preservation of compositon.-introsABcgf.srapplyBuild_pHomotopy.{introsp.cbn.refine((inv_pp__@@ 1) @concat_pp_p___@_).applywhiskerL.refine(((ap_V__)^ @@ 1) @_@concat_p_pp___@ ((ap_pp___)^ @@ 1)).applywhiskerL.refine(_@concat_p_pp___@ ((ap_pp___)^ @@ 1)).applywhiskerR.applyap_compose. }bypointed_reduce.Defined.Properties of loops functorLoops functor distributes over concatenationLemmafmap_loops_pp{XY:pType} (f:X->*Y) (xy:loopsX):fmaploopsf(x@y) =fmaploopsfx@fmaploopsfy.Proof.pointed_reduce_rewrite.applyap_pp.Defined.Loops is a pointed functorGlobal Instanceispointedfunctor_loops:IsPointedFunctorloops.Proof.snrapplyBuild_IsPointedFunctor'.1-4:exact_.exactpequiv_loops_punit.Defined.Lemmafmap_loops_pconst{AB:pType} :fmaploops(@pconstAB) ==*pconst.Proof.rapplyfmap_zero_morphism.Defined.Iterated loops functorAction on 1-cellsGlobal Instanceis0functor_iterated_loopsn:Is0Functor(iterated_loopsn).Proof.inductionn.1:exact_.nrapplyis0functor_compose;exact_.Defined.Global Instanceis1functor_iterated_loopsn:Is1Functor(iterated_loopsn).Proof.inductionn.1:exact_.nrapplyis1functor_compose;exact_.Defined.Lemmafmap_iterated_loops_pp{XY:pType} (f:X->*Y)n(xy:iterated_loopsn.+1X):fmap(iterated_loopsn.+1)f(x@y)=fmap(iterated_loopsn.+1)fx@fmap(iterated_loopsn.+1)fy.Proof.applyfmap_loops_pp.Defined.The fiber offmaploopsfis equivalent to a fiber ofapf.Definitionhfiber_fmap_loops{AB:pType} (f:A->*B) (p:loopsB): {q:loopsA&apfq= (point_eqf@p) @ (point_eqf)^}<~>hfiber(fmaploopsf)p.Proof.applyequiv_functor_sigma_id;introsq.refine(equiv_moveR_Vp___oE_).applyequiv_moveR_pM.Defined.The loop space functor decreases the truncation level by one.Global Instanceistrunc_fmap_loops{n} (AB:pType) (f:A->*B)`{IsTruncMapn.+1__f} :IsTruncMapn(fmaploopsf).Proof.introp.apply(istrunc_equiv_istrunc_(hfiber_fmap_loopsfp)).Defined.And likewise the connectedness.Global Instanceisconnected_fmap_loops`{Univalence} {n:trunc_index}(AB:pType) (f:A->*B) `{IsConnMapn.+1__f}:IsConnMapn(fmaploopsf).Proof.introsp;eapplyisconnected_equiv'.-refine(hfiber_fmap_loopsfpoE_).symmetry;applyhfiber_ap.-exact_.Defined.Definitionisconnected_iterated_fmap_loops`{Univalence}(n:trunc_index) (k:nat) (AB:pType) (f:A->*B)(C:IsConnMap(trunc_index_inc'nk)f):IsConnMapn(fmap(iterated_loopsk)f).Proof.inductionkinn,C|- *.-exactC.-applyisconnected_fmap_loops.applyIHk.exactC.Defined.It follows that loop spaces "commute with images".Definitionequiv_loops_image`{Univalence}n{AB:pType} (f:A->*B):loops([imagen.+1f,factor1(imagen.+1f) (pointA)])<~>imagen(fmaploopsf).Proof.set(C:= [imagen.+1f,factor1(imagen.+1f) (pointA)]).pose(g:=Build_pMapAC(factor1(imagen.+1f)) 1).pose(h:=Build_pMapCB(factor2(imagen.+1f)) (point_eqf)).transparentassert(I: (Factorization(@IsConnMapn) (@MapInn) (fmaploopsf))).{refine(@Build_Factorization(@IsConnMapn) (@MapInn)(loopsA) (loopsB) (fmaploopsf) (loopsC)(fmaploopsg) (fmaploopsh)___).introsx;symmetry.refine(_@fmap_comploopsghx).simpl.abstract(rewrite!concat_1p;reflexivity). }exact(path_intermediate(path_factor(O_factsysn) (fmaploopsf)I(imagen(fmaploopsf)))).Defined.Loop inversion is a pointed equivalenceDefinitionloops_inv(A:pType) :loopsA<~>*loopsA.Proof.srapplyBuild_pEquiv.1:exact(Build_pMap(loopsA) (loopsA)inverse1).applyisequiv_path_inverse.Defined.Loops functor preserves equivalencesDefinitionpequiv_fmap_loops{AB:pType}:A$<~>B->loopsA$<~>loopsB:=emaploops.A version ofunfold_iterated_loopsthat's an equivalence rather than an equality.  We could get this from the equality, but it's more useful to construct it explicitly since then we can reason about it.Definitionunfold_iterated_loops'(n:nat) (X:pType):iterated_loopsn.+1X<~>*iterated_loopsn(loopsX).Proof.inductionn.1:reflexivity.change(iterated_loopsn.+2X)with(loops(iterated_loopsn.+1X)).applypequiv_fmap_loops,IHn.Defined.For instance, we can prove that it's natural.Definitionunfold_iterated_fmap_loops{AB:pType} (n:nat) (f:A->*B): (unfold_iterated_loops'nB)o* (fmap(iterated_loopsn.+1)f)==* (fmap(iterated_loopsn) (fmaploopsf))o* (unfold_iterated_loops'nA).Proof.inductionn.-srefine(Build_pHomotopy__).+reflexivity.+cbn.applymoveL_pV.refine(concat_1p_@_).refine(concat_1p_@_).refine(_@ (concat_p1_)^).exact((ap_idmap_)^).-refine((fmap_comploops__)^* @*_).refine(_@* (fmap_comploops__)).rapply(fmap2loops).applyIHn.Defined.Iterated loops preserves equivalencesDefinitionpequiv_fmap_iterated_loops{AB}n:A<~>*B->iterated_loopsnA<~>*iterated_loopsnB:=emap(iterated_loopsn).Loops preserves products.Lemmaloops_prod(XY:pType) :loops(X*Y) <~>*loopsX*loopsY.Proof.snrapplyBuild_pEquiv'.1:exact(equiv_path_prod(point(X*Y)) (point(X*Y)))^-1%equiv.reflexivity.Defined.There is a natural map fromloops(X*Y)toloopsX*loopsY, and ideally it would definitionally underly the equivalenceloops_prod.  That's not the case, but we show thatloops_prodis homotopic to the expected maps after projecting to each factor.Definitionpfst_loops_prod(XY:pType):pfsto*loops_prodXY==*fmaploopspfst.Proof.snrapplyBuild_pHomotopy.-introp;simpl.rhsnrapplyconcat_1p.symmetry;applyconcat_p1.-reflexivity.Defined.Definitionpsnd_loops_prod(XY:pType):psndo*loops_prodXY==*fmaploopspsnd.Proof.snrapplyBuild_pHomotopy.-introp;simpl.rhsnrapplyconcat_1p.symmetry;applyconcat_p1.-reflexivity.Defined.Iterated loops of products are products of iterated loops.Lemmaiterated_loops_prod(XY:pType) {n}:iterated_loopsn(X*Y) <~>* (iterated_loopsnX) * (iterated_loopsnY).Proof.inductionnas[|nIHn].1:reflexivity.exact(loops_prod__o*EemaploopsIHn).Defined.Similarly, we compute the projections here.Definitionpfst_iterated_loops_prod(XY:pType) {n}:pfsto*iterated_loops_prodXY==*fmap(iterated_loopsn)pfst.Proof.inductionnas[|nIHn].-reflexivity.-change(_==* ?R)with(pfsto* (loops_prod__o*fmaploops(iterated_loops_prod__)) ==*R).refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhisker_(pfst_loops_prod__) @*_).refine((fmap_comploops__)^* @*_).change(?L==*_)with(L==*fmaploops(fmap(iterated_loopsn)pfst)).rapply(fmap2loops);simpl.exactIHn.Defined.Definitionpsnd_iterated_loops_prod(XY:pType) {n}:psndo*iterated_loops_prodXY==*fmap(iterated_loopsn)psnd.Proof.inductionnas[|nIHn].-reflexivity.-change(_==* ?R)with(psndo* (loops_prod__o*fmaploops(iterated_loops_prod__)) ==*R).refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhisker_(psnd_loops_prod__) @*_).refine((fmap_comploops__)^* @*_).change(?L==*_)with(L==*fmaploops(fmap(iterated_loopsn)psnd)).rapply(fmap2loops);simpl.exactIHn.Defined.(* A dependent form of loops *)DefinitionloopsD{A} :pFamA->pFam(loopsA):=funPp=>Build_pFam(funq:loopsA=>transportPpq(dpointPp) = (dpointPp)) 1.Global Instanceistrunc_pfam_loopsD{n} {A} (P:pFamA){H:IsTrunc_pFamn.+1P}:IsTrunc_pFamn(loopsDP).Proof.introsa.pose(H(pointA)).exact_.Defined.(* psigma and loops 'commute' *)Lemmaloops_psigma_commute(A:pType) (P:pFamA):loops(psigmaP) <~>*psigma(loopsDP).Proof.snrapplyBuild_pEquiv'.1:exact(equiv_path_sigma___)^-1%equiv.reflexivity.Defined.(* product and loops 'commute' *)Lemmaloops_pproduct_commute`{Funext} (A:Type) (F:A->pType):loops(pproductF) <~>*pproduct(loopsoF).Proof.snrapplyBuild_pEquiv'.1:applyequiv_apD10.reflexivity.Defined.(* product and iterated loops commute *)Lemmaiterated_loops_pproduct_commute`{Funext} (A:Type) (F:A->pType) (n:nat):iterated_loopsn(pproductF) <~>*pproduct(iterated_loopsnoF).Proof.inductionn.1:reflexivity.refine(loops_pproduct_commute__o*E_).rapply(emaploops).exactIHn.Defined.(* Loops neutralise sigmas when truncated *)Lemmaloops_psigma_trunc(n:nat) (Aa:pType)(Pp:pFamAa) (istrunc_Pp:IsTrunc_pFam(trunc_index_incminus_twon)Pp):iterated_loopsn(psigmaPp) <~>*iterated_loopsnAa.Proof.inductionninAa,Pp,istrunc_Pp|- *.{snrapplyBuild_pEquiv'.1:refine(@equiv_sigma_contr__istrunc_Pp).reflexivity. }refine(pequiv_inverse(unfold_iterated_loops'__)o*E_o*Eunfold_iterated_loops'__).refine(IHn___o*E_).rapply(emap(iterated_loops_)).applyloops_psigma_commute.Defined.(* We can convert between loops in a type and loops inTypeat that type. *)Definitionloops_type`{Univalence} (A:Type@{i}):loops[Type@{i},A] <~>* [A<~>A,equiv_idmap].Proof.applyissig_pequiv'.exists(equiv_equiv_pathAA).reflexivity.Defined.(* An iterated version.  Note that the statement with "-1" substituted fornisloops[Type,A]<~>*[A->A,idmap], which is not true in general. Compare the previous result. *)Lemmalocal_global_looping`{Univalence} (A:Type@{i}) (n:nat):iterated_loops@{j}n.+2 [Type@{i},A]<~>*pproduct(funa=>iterated_loops@{j}n.+1 [A,a]).Proof.inductionn.{refine(_o*Eemaploops(loops_typeA)).applyissig_pequiv'.exists(equiv_inverse(equiv_path_arrow1%equiv1%equiv)oEequiv_inverse(equiv_path_equiv1%equiv1%equiv)).reflexivity. }exact(loops_pproduct_commute__o*EemaploopsIHn).Defined.(* 7.2.7 *)Theoremequiv_istrunc_istrunc_loops`{Funext}nX:IsTruncn.+2X<~>forall(x:X),IsTruncn.+1 (loops[X,x]).Proof.srapplyequiv_iff_hprop.introtr_loops.applyistrunc_S;introsxy.applyistrunc_S;introsp.destructp.nrapplytr_loops.Defined.(* 7.2.9, withnhere meaning the same asn-1there. Note thatn.-1in the statement is short fortrunc_index_pred(nat_to_trunc_indexn)which is definitionally equal to(trunc_index_incminus_twon).+1. *)Theoremequiv_istrunc_contr_iterated_loops`{Funext} (n:nat) (A:Type):IsTruncn.-1A<~>foralla:A,Contr(iterated_loopsn[A,a]).Proof.inductionninA|- *.{cbn.exactequiv_hprop_inhabited_contr. }refine(_oEequiv_istrunc_istrunc_loopsn.-2_).srapplyequiv_functor_forall_id.introa.cbnbeta.refine(_oEIHn(loops[A,a])).refine(equiv_inO_equiv(-2) (unfold_iterated_loops'n[A,a])^-1oE_).rapplyequiv_iff_hprop.introsXp.refine(@contr_equiv'___X).rapply(emap(iterated_loops_)).srapplyBuild_pEquiv'.1:exact(equiv_concat_lrp1).cbn;unfoldispointed_loops.exact(concat_p1_@concat_p1_).Defined.loops_invis a natural transformation.Global Instanceis1natural_loops_inv:Is1Naturalloopsloopsloops_inv.Proof.snrapplyBuild_Is1Natural.introsABf.srapplyBuild_pHomotopy.+introsp.refine(inv_Vp__@whiskerR_(point_eqf) @concat_pp_p___).refine(inv_pp__@whiskerL(point_eqf)^ (ap_Vfp)^).+pointed_reduce.reflexivity.Defined.Loops on the pointed type of dependent pointed maps correspond to pointed dependent maps into a family of loops.  We define this in this direction, because the forward map is pointed by reflexivity.Definitionequiv_loops_ppforall`{Funext} {A:pType} (B:A->pType):loops(ppforallx:A,Bx) <~>* (ppforallx:A,loops(Bx)).Proof.srapplyBuild_pEquiv'.1:symmetry;exact(equiv_path_pforall(point_pforallB) (point_pforallB)).reflexivity.Defined.

--- Miscellaneous\MappingCylinder.html ---
MappingCylinderLibrary MappingCylinderMapping CylindersRequireImportHoTT.BasicsCubical.DPathCubical.PathSquare.RequireImportColimits.Pushout.Local OpenScopepath_scope.As in topology, the mapping cylinder of a functionf:A->Bis a way to replace it with an equivalent cofibration (dually to howhfiberreplaces it with an equivalent fibration).  We can't talk *internally* in type theory about cofibrations, but we can say metatheoretically what they are: functions with the isomorphism extension property.  So while we can't literally say "letfbe a cofibration" we can do a mostly equivalent thing and say "letfbe a map and consider its mapping cylinder".  Replacing a map by a cofibration can be useful because it allows us to make more equalities true definitionally.DefinitionsWe define the mapping cylinder as the pushout offand an identity map.  Peter Lumsdaine has given a definition of HIT mapping cylinders that are dependent on the codomain, so that the second factor is not just an equivalence but a trivial fibration.  However, at the moment we don't have a need for that.DefinitionCyl{AB:Type} (f:A->B) :Type:=Pushoutidmapf.SectionMappingCylinder.Context{AB:Type} {f:A->B}.Definitioncyl(a:A) :Cylf:=pushla.Definitioncyr(b:B) :Cylf:=pushrb.Definitioncyglue(a:A):cyla=cyr(fa):=pgluea.SectionCylInd.Context(P:Cylf->Type)(cyla:foralla,P(cyla))(cylb:forallb,P(cyrb))(cylg:foralla,DPathP(cygluea) (cylaa) (cylb(fa))).DefinitionCyl_ind:forallc,Pc:=Pushout_ind_cylacylbcylg.DefinitionCyl_ind_beta_cyglue(a:A):apDCyl_ind(cygluea) =cylga:=Pushout_ind_beta_pglue_____.EndCylInd.SectionCylRec.Context{P:Type} (cyla:A->P) (cylb:B->P) (cylg:cyla==cylbof).DefinitionCyl_rec:Cylf->P:=Pushout_rec_cylacylbcylg.DefinitionCyl_rec_beta_cyglue(a:A):apCyl_rec(cygluea) =cylga:=Pushout_rec_beta_pglue_____.EndCylRec.Definitionpr_cyl:Cylf<~>B.Proof.Rather than adjointifying, we give all parts of the equivalence explicitly, so we can be sure of retaining the computational behavior ofeissectandeisretr.  However, it's easier to proveeisadjon the other side, so we reverse the equivalence first.symmetry.srapplyBuild_Equiv.1:applycyr.srapplyBuild_IsEquiv.-srapplyCyl_rec.+exactf.+exactidmap.+reflexivity.-srapplyCyl_ind.+introsa;cbn.symmetry;applycyglue.+introsb;reflexivity.+introsa;cbn.applydp_paths_FFlr.rewriteCyl_rec_beta_cyglue.applyconcat_pV_p.-introsb;reflexivity.-introsb;reflexivity.Defined.Definitionap_pr_cyl_cyglue(a:A):appr_cyl(cygluea) = 1:=Cyl_rec_beta_cyglue___a.The original mapffactors definitionally throughCylf.Definitionpr_cyl_cyl(a:A) :pr_cyl(cyla) =fa:= 1.EndMappingCylinder.Sometimes we have to specify the map explicitly.Definitioncyl'{AB} (f:A->B) :A->Cylf:=cyl.Definitionpr_cyl'{AB} (f:A->B) :Cylf->B:=pr_cyl.FunctorialitySectionFunctorCyl.Context{ABA'B':Type} {f:A->B} {f':A'->B'}{ga:A->A'} {gb:B->B'}(g:f'oga==gbof).Definitionfunctor_cyl:Cylf->Cylf'.Proof.srapplyCyl_rec.-exact(cyloga).-exact(cyrogb).-introsa.refine(_@apcyr(ga)).exact(cyglue(gaa)).Defined.Definitionap_functor_cyl_cyglue(a:A):apfunctor_cyl(cygluea) =cyglue(gaa) @apcyr(ga):=Cyl_rec_beta_cyglue___a.The benefit of passing to the mapping cylinder is that it makes a square commute definitionally.Definitionfunctor_cyl_cyl(a:A) :cyl(gaa) =functor_cyl(cyla):= 1.The other square also commutes, though not definitionally.Definitionpr_functor_cyl(c:Cylf):pr_cyl(functor_cylc) =gb(pr_cylc):=ap(pr_cylofunctor_cyl) (eissectpr_cylc)^.Definitionpr_functor_cyl_cyl(a:A):pr_functor_cyl(cyla) =ga.Proof.Here we needeissectpr_cyl(cyla)to compute.refine(ap_(inv_V_) @_).refine(ap_composefunctor_cylpr_cyl(cygluea) @_).refine(ap_(ap_functor_cyl_cygluea) @_).refine(ap_pp___@_).refine(whiskerR(ap_pr_cyl_cyglue(gaa))_@concat_1p_@_).refine((ap_composecyr_(ga))^ @_).applyap_idmap.Defined.EndFunctorCyl.CoequalizersA particularly useful application is to replace a map of coequalizers with one where both squares commute definitionally.SectionCylCoeq.Context{BAfgB'A'f'g'}{h:B->B'} {k:A->A'}(p:kof==f'oh) (q:kog==g'oh).DefinitionCylCoeq:Type:=Coeq(functor_cylp) (functor_cylq).Definitioncyl_cylcoeq:Coeqfg->CylCoeq:=functor_coeqcylcyl(functor_cyl_cylp) (functor_cyl_cylq).Definitionap_cyl_cylcoeq_cglue(b:B):apcyl_cylcoeq(cglueb) =cglue(cylb).Proof.etransitivity.1:rapplyfunctor_coeq_beta_cglue.exact(concat_p1_@concat_1p_).Defined.Definitionpr_cylcoeq:CylCoeq<~>Coeqf'g':=equiv_functor_coeqpr_cylpr_cyl(pr_functor_cylp) (pr_functor_cylq).Definitionap_pr_cylcoeq_cglue(x:Cylh):PathSquare(appr_cylcoeq(cgluex)) (cglue(pr_cylx))(apcoeq(pr_functor_cylpx))(apcoeq(pr_functor_cylqx)).Proof.applysq_path.applymoveR_pM.rewrite<- (ap_Vcoeq).rapplyfunctor_coeq_beta_cglue.Defined.Definitionpr_cyl_cylcoeq:functor_coeqhkpq==pr_cylcoeqocyl_cylcoeq.Proof.introsc.refine(_@functor_coeq_composecylcyl(functor_cyl_cylp) (functor_cyl_cylq)pr_cylpr_cyl(pr_functor_cylp) (pr_functor_cylq)c).srapplyfunctor_coeq_homotopy.1-2:reflexivity.all:introsb;cbn.all:refine(concat_1p_@concat_1p_@_@ (concat_p1_)^).all:applypr_functor_cyl_cyl.Defined.EndCylCoeq.

--- Miscellaneous\maps.html ---
mapsLibrary mapsRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.orders.ordersHoTT.Classes.theory.apartness.Generalizable VariablesABCRSfgz.(* If a function between strict partial orders is order preserving (back), we canderive that it is strictly order preserving (back) *)Sectionstrictly_order_preserving.Context`{FullPartialOrderA} `{FullPartialOrderB}.Global Instancestrictly_order_preserving_inj`{!OrderPreserving(f:A->B)}`{!IsStrongInjectivef} :StrictlyOrderPreservingf| 20.Proof.introsxyE.applylt_iff_le_apartinE.applylt_iff_le_apart.destructEas[E1E2].split.-apply(order_preservingf);trivial.-apply(strong_injectivef);trivial.Qed.Global Instancestrictly_order_reflecting_mor`{!OrderReflecting(f:A->B)}`{!StrongExtensionalityf} :StrictlyOrderReflectingf| 20.Proof.introsxyE.applylt_iff_le_apartinE.applylt_iff_le_apart.destructEas[E1E2].split.-apply(order_reflectingf);trivial.-apply(strong_extensionalityf);trivial.Qed.Endstrictly_order_preserving.(* For structures with a trivial apartness relationwe have a stronger result of the above *)Sectionstrictly_order_preserving_dec.Context`{FullPartialOrderA} `{!TrivialApartA}`{FullPartialOrderB} `{!TrivialApartB}.Local Existing Instancestrict_po_apart.Global Instancedec_strictly_order_preserving_inj`{!OrderPreserving(f:A->B)}`{!IsInjectivef} :StrictlyOrderPreservingf| 19.Proof.poseproof(dec_strong_injectivef).apply_.Qed.Global Instancedec_strictly_order_reflecting_mor`{!OrderReflecting(f:A->B)}:StrictlyOrderReflectingf| 19.Proof.poseproof(dec_strong_morphismf).apply_.Qed.Endstrictly_order_preserving_dec.Sectionpseudo_injective.Context`{PseudoOrderA} `{PseudoOrderB}.Local Existing Instancepseudo_order_apart.Instancepseudo_order_embedding_ext`{!StrictOrderEmbedding(f:A->B)} :StrongExtensionalityf.Proof.introsxyE.applyapart_iff_total_lt;applyapart_iff_total_ltinE.destructE; [left|right];apply(strictly_order_reflectingf);trivial.Qed.Lemmapseudo_order_embedding_inj`{!StrictOrderEmbedding(f:A->B)} :IsStrongInjectivef.Proof.split;tryapply_.introsxyE.applyapart_iff_total_lt;applyapart_iff_total_ltinE.destructE; [left|right];apply(strictly_order_preservingf);trivial.Qed.Endpseudo_injective.(* If a function between pseudo partial orders is strictly order preserving (back),we can derive that it is order preserving (back) *)Sectionfull_pseudo_strictly_preserving.Context`{FullPseudoOrderA} `{FullPseudoOrderB}.Local Existing Instancepseudo_order_apart.Lemmafull_pseudo_order_preserving`{!StrictlyOrderReflecting(f:A->B)}:OrderPreservingf.Proof.introsxyE1.applyle_iff_not_lt_flip;applyle_iff_not_lt_flipinE1.introsE2.applyE1.apply(strictly_order_reflectingf).trivial.Qed.Lemmafull_pseudo_order_reflecting`{!StrictlyOrderPreserving(f:A->B)}:OrderReflectingf.Proof.introsxyE1.applyle_iff_not_lt_flip;applyle_iff_not_lt_flipinE1.introsE2.applyE1.apply(strictly_order_preservingf).trivial.Qed.Endfull_pseudo_strictly_preserving.(* Some helper lemmas to easily transform order preserving instances. *)Sectionorder_preserving_ops.Context`{LeR}.Lemmaorder_preserving_flip{op} `{!Commutativeop} `{!OrderPreserving(opz)}:OrderPreserving(funy=>opyz).Proof.introsxyE.rewrite2!(commutativity_z).applyorder_preserving;trivial.Qed.Lemmaorder_reflecting_flip{op} `{!Commutativeop}`{!OrderReflecting(opz) }:OrderReflecting(funy=>opyz).Proof.introsxyE.apply(order_reflecting(opz)).rewrite2!(commutativity(f:=op)z).trivial.Qed.Lemmaorder_preserving_nonneg(op:R->R->R) `{!ZeroR}`{forallz,PropHolds(0 ≤z) ->OrderPreserving(opz)}z: 0 ≤z->forallxy,x≤y->opzx≤opzy.Proof.auto.Qed.Lemmaorder_preserving_flip_nonneg(op:R->R->R) `{!ZeroR}{E:forallz,PropHolds(0 ≤z) ->OrderPreserving(funy=>opyz)}z: 0 ≤z->forallxy,x≤y->opxz≤opyz.Proof.applyE.Qed.Context`{LtR}.Lemmaorder_reflecting_pos(op:R->R->R) `{!ZeroR}{E:forallz,PropHolds(0 <z) ->OrderReflecting(opz)}z: 0 <z->forallxy,opzx≤opzy->x≤y.Proof.applyE.Qed.Lemmaorder_reflecting_flip_pos(op:R->R->R) `{!ZeroR}{E:forallz,PropHolds(0 <z) ->OrderReflecting(funy=>opyz)}z: 0 <z->forallxy,opxz≤opyz->x≤y.Proof.applyE.Qed.Endorder_preserving_ops.Sectionstrict_order_preserving_ops.Context`{LtR}.Lemmastrictly_order_preserving_flip{op} `{!Commutativeop}`{!StrictlyOrderPreserving(opz)}:StrictlyOrderPreserving(funy=>opyz).Proof.introsxyE.rewrite2!(commutativity_z).applystrictly_order_preserving;trivial.Qed.Lemmastrictly_order_reflecting_flip{op} `{!Commutativeop}`{!StrictlyOrderReflecting(opz) }:StrictlyOrderReflecting(funy=>opyz).Proof.introsxyE.apply(strictly_order_reflecting(opz)).rewrite2!(commutativity(f:=op)z).trivial.Qed.Lemmastrictly_order_preserving_pos(op:R->R->R) `{!ZeroR}{E:forallz,PropHolds(0 <z) ->StrictlyOrderPreserving(opz)}z: 0 <z->forallxy,x<y->opzx<opzy.Proof.applyE.Qed.Lemmastrictly_order_preserving_flip_pos(op:R->R->R) `{!ZeroR}{E:forallz,PropHolds(0 <z) ->StrictlyOrderPreserving(funy=>opyz)}z: 0 <z->forallxy,x<y->opxz<opyz.Proof.applyE.Qed.Endstrict_order_preserving_ops.Lemmaprojected_partial_order`{IsHSetA} {Ale:LeA}`{is_mere_relationAAle} `{Ble:LeB}(f:A->B) `{!IsInjectivef} `{!PartialOrderBle}: (forallxy,x≤y<->fx≤fy) ->PartialOrderAle.Proof.introsP.repeatsplit.-apply_.-apply_.-introsx.applyP.applyreflexivity.-introsxyzE1E2.applyP.transitivity(fy);applyP;trivial.-introsxyE1E2.apply(injectivef).apply(antisymmetry(≤));applyP;trivial.Qed.Lemmaprojected_total_order`{Ale:LeA} `{Ble:LeB}(f:A->B) `{!TotalRelationBle}: (forallxy,x≤y<->fx≤fy) ->TotalRelationAle.Proof.introsPxy.destruct(total(≤) (fx) (fy)); [left|right];applyP;trivial.Qed.Lemmaprojected_strict_order`{Alt:LtA} `{is_mere_relationAlt} `{Blt:LtB}(f:A->B) `{!StrictOrderBlt}: (forallxy,x<y<->fx<fy) ->StrictOrderAlt.Proof.introsP.split.-apply_.-introsxE.destruct(irreflexivity(<) (fx)).applyP.trivial.-introsxyzE1E2.applyP.transitivity(fy);applyP;trivial.Qed.Lemmaprojected_pseudo_order`{IsApartA} `{Alt:LtA} `{is_mere_relationAlt}`{ApartB} `{Blt:LtB}(f:A->B) `{!IsStrongInjectivef} `{!PseudoOrderBlt}: (forallxy,x<y<->fx<fy) ->PseudoOrderAlt.Proof.poseproof(strong_injective_morf).introsP.split;tryapply_.-introsxyE.apply(pseudo_order_antisym(fx) (fy)).split;applyP,E.-introsxyEz.applyPinE.apply(merely_destruct(cotransitiveE(fz)));intros[?|?];applytr; [left|right];applyP;trivial.-introsxy;split;introsE.+apply(strong_injectivef)inE.applyapart_iff_total_ltinE.destructE; [left|right];applyP;trivial.+apply(strong_extensionalityf).applyapart_iff_total_lt.destructE; [left|right];applyP;trivial.Qed.Lemmaprojected_full_pseudo_order`{IsApartA} `{Ale:LeA} `{Alt:LtA}`{is_mere_relationAle} `{is_mere_relationAlt}`{ApartB} `{Ble:LeB} `{Blt:LtB}(f:A->B) `{!IsStrongInjectivef} `{!FullPseudoOrderBleBlt}: (forallxy,x≤y<->fx≤fy) -> (forallxy,x<y<->fx<fy) ->FullPseudoOrderAleAlt.Proof.introsP1P2.split.-apply_.-apply(projected_pseudo_orderf);assumption.-introsxy;split;introsE.+introsF.destruct(le_not_lt_flip(fy) (fx));[applyP1|applyP2];trivial.+applyP1.applynot_lt_le_flip.introsF.applyE,P2.trivial.Qed.Global Instanceid_order_preserving`{PartialOrderA} :OrderPreserving(@idA).Proof.red;trivial.Qed.Global Instanceid_order_reflecting`{PartialOrderA} :OrderReflecting(@idA).Proof.red;trivial.Qed.Sectioncomposition.Context{ABC} `{LeA} `{LeB} `{LeC} (f:A->B) (g:B->C).Instancecompose_order_preserving:OrderPreservingf->OrderPreservingg->OrderPreserving(g∘f).Proof.red;intros.unfoldCompose.do2apply(order_preserving_).trivial.Qed.Instancecompose_order_reflecting:OrderReflectingf->OrderReflectingg->OrderReflecting(g∘f).Proof.intros??xyE.unfoldComposeinE.do2apply(order_reflecting_)inE.trivial.Qed.Instancecompose_order_embedding:OrderEmbeddingf->OrderEmbeddingg->OrderEmbedding(g∘f) := {}.Endcomposition.#[export]HintExtern4 (OrderPreserving(_∘_)) =>class_apply@compose_order_preserving:typeclass_instances.#[export]HintExtern4 (OrderReflecting(_∘_)) =>class_apply@compose_order_reflecting:typeclass_instances.#[export]HintExtern4 (OrderEmbedding(_∘_)) =>class_apply@compose_order_embedding:typeclass_instances.

--- Miscellaneous\Matrix.html ---
MatrixLibrary MatrixRequireImportBasics.OvertureBasics.TruncBasics.TacticsBasics.Decidable.RequireImportTypes.Sigma.RequireImportSpaces.List.CoreSpaces.List.TheorySpaces.List.Paths.RequireImportAlgebra.Rings.RingAlgebra.Rings.ModuleAlgebra.Rings.CRingAlgebra.Rings.KroneckerDeltaAlgebra.Rings.Vector.RequireImportabstract_algebra.RequireImportWildCat.CoreWildCat.Paths.RequireImportModalities.ReflectiveSubuniverse.SetUniverseMinimizationToSet.Local OpenScopemc_scope.MatricesDefinitionDefinitionMatrix@{i} (R:Type@{i}) (mn:nat) :Type@{i}:=Vector(VectorRn)m.Global Instanceistrunc_matrix(R:Type)k`{IsTrunck.+2R}mn:IsTrunck.+2 (MatrixRmn):=_.Building a matrix from a function that takes row and column indices.DefinitionBuild_Matrix(R:Type) (mn:nat)(M_fun:forall(i:nat) (j:nat), (i<m)%nat-> (j<n)%nat->R):MatrixRmn.Proof.snrapplyBuild_Vector.introsiHi.snrapplyBuild_Vector.introsjHj.exact(M_funijHiHj).Defined.The length conditions here are decidable so can be inferred in proofs.DefinitionBuild_Matrix'(R:Type) (mn:nat)(l:list(listR))(wf_row:lengthl=m)(wf_col:for_all(funrow=>lengthrow=n)l):MatrixRmn.Proof.snrefine(_;_).-snrapplylist_sigma.+exactl.+exactwf_col.-bylhsnrapplylength_list_sigma.Defined.Definitionentries@{i|} {R:Type@{i}} {mn} (M:MatrixRmn):list(listR):=list_map@{ii}pr1(pr1M).The entry at rowiand columnjof a matrixM.Definitionentry{R:Type} {mn} (M:MatrixRmn) (ij:nat){H1: (i<m)%nat} {H2: (j<n)%nat}:R:=Vector.entry(Vector.entryMi)j.Mapping a function on all the entries of a matrix.Definitionmatrix_map{RS:Type} {mn} (f:R->S):MatrixRmn->MatrixSmn:=funM=>Build_MatrixSmn(funij__=>f(entryMij)).Definitionmatrix_map2{RST:Type} {mn} (f:R->S->T):MatrixRmn->MatrixSmn->MatrixTmn:=funMN=>Build_MatrixTmn(funij__=>f(entryMij) (entryNij)).The(i,j)-entry ofBuild_MatrixRmnM_funisM_funij.Definitionentry_Build_Matrix{R:Type} {mn}(M_fun:forallij, (i<m)%nat-> (j<n)%nat->R)(ij:nat) (H1: (i<m)%nat) (H2: (j<n)%nat):entry(Build_MatrixRmnM_fun)ij=M_funij__.Proof.unfoldentry.byrewrite2entry_Build_Vector.Defined.Two matrices are equal if all their entries are equal.Definitionpath_matrix{R:Type} {mn} (MN:MatrixRmn)(H:forallij(Hi: (i<m)%nat) (Hj: (j<n)%nat),entryMij=entryNij):M=N.Proof.snrapplypath_vector.introsiHi.snrapplypath_vector.introsjHj.exact(HijHiHj).Defined.Addition and module structureHere we define the abelian group of (n x m)-matrices over a ring. This follows from the abelian group structure of the underlying vectors. We are also able to derive a left module strucutre when the entries come from a left module.Definitionabgroup_matrix(A:AbGroup) (mn:nat) :AbGroup:=abgroup_vector(abgroup_vectorAn)m.Definitionmatrix_plus{A:AbGroup} {mn}:MatrixAmn->MatrixAmn->MatrixAmn:= @sg_op(abgroup_matrixAmn)_.Definitionmatrix_zero(A:AbGroup)mn:MatrixAmn:= @mon_unit(abgroup_matrixAmn)_.Definitionmatrix_negate{A:AbGroup} {mn}:MatrixAmn->MatrixAmn:= @negate(abgroup_matrixAmn)_.Global Instanceisleftmodule_isleftmodule_matrix(A:AbGroup) (mn:nat){R:Ring} `{IsLeftModuleRA}:IsLeftModuleR(abgroup_matrixAmn).Proof.snrapplyisleftmodule_isleftmodule_vector.snrapplyisleftmodule_isleftmodule_vector.exact_.Defined.As a special case, we get the left module of matrices over a ring.Global Instanceisleftmodule_abgroup_matrix(R:Ring) (mn:nat):IsLeftModuleR(abgroup_matrixRmn):=_.Definitionmatrix_lact{R:Ring} {mn:nat} (r:R) (M:MatrixRmn):MatrixRmn:=lactrM.MultiplicationMatrix multiplication is defined such that the entry at rowiand columnjof the resulting matrix is the sum of the products of the corresponding entries from theith row of the first matrix and thejth column of the second matrix. Matrices correspond to module homomorphisms between free modules of finite rank (think vector spaces), and matrix multiplication represents the composition of these homomorphisms.Definitionmatrix_mult{R:Ring@{i}} {mnk:nat} (M:MatrixRmn) (N:MatrixRnk):MatrixRmk.Proof.snrapplyBuild_Matrix.introsijHiHj.exact(ab_sumn(funkHk=>entryMik*entryNkj)).Defined.The identity matrix is the matrix with ones on the diagonal and zeros elsewhere. It acts as the multiplicative identity for matrix multiplication. We define it here using thekronecker_deltafunction which will make proving properties about it conceptually easier later.Definitionidentity_matrix(R:Ring@{i}) (n:nat) :MatrixRnn:=Build_MatrixRnn(funij__=>kronecker_deltaij).This is the most general statement of associativity for matrix multiplication.Definitionassociative_matrix_mult(R:Ring) (mnpq:nat):HeteroAssociative(@matrix_multRmnq) (@matrix_multRnpq)(@matrix_multRmpq) (@matrix_multRmnp).Proof.introsMNP;nrapplypath_matrix;introsijHiHj.rewrite2entry_Build_Matrix.lhsnrapplypath_ab_sum.{introskHk.rewriteentry_Build_Matrix.applyrng_sum_dist_l. }lhsnrapplyab_sum_sum.rhsnrapplypath_ab_sum.2:introskHk;byrewriteentry_Build_Matrix.nrapplypath_ab_sum.introskHk.rhsnrapplyrng_sum_dist_r.nrapplypath_ab_sum.introslHl.applyassociativity.Defined.Matrix multiplication distributes over addition of matrices on the left.Definitionleft_distribute_matrix_mult(R:Ring) (mnp:nat):LeftHeteroDistribute(@matrix_multRmnp)matrix_plusmatrix_plus.Proof.introsMNP;applypath_matrix;introsijHiHj.rewrite!entry_Build_Matrix, !entry_Build_Vector.change(?x= ?y+ ?z)with(x=sg_opyz).rewrite<-ab_sum_plus.nrapplypath_ab_sum.introskHk.rewriteentry_Build_Matrix.applyrng_dist_l.Defined.Matrix multiplication distributes over addition of matrices on the right.Definitionright_distribute_matrix_mult(R:Ring) (mnp:nat):RightHeteroDistribute(@matrix_multRmnp)matrix_plusmatrix_plus.Proof.introsMNP;applypath_matrix;introsijHiHj.rewrite!entry_Build_Matrix, !entry_Build_Vector.change(?x= ?y+ ?z)with(x=sg_opyz).rewrite<-ab_sum_plus.nrapplypath_ab_sum.introskHk.rewriteentry_Build_Matrix.applyrng_dist_r.Defined.The identity matrix acts as a left identity for matrix multiplication.Definitionleft_identity_matrix_mult(R:Ring) (mn:nat):LeftIdentity(@matrix_multRmmn) (identity_matrixRm).Proof.introsM;applypath_matrix;introsijHiHj.rewriteentry_Build_Matrix.lhsnrapplypath_ab_sum.1:introskHk;byrewriteentry_Build_Matrix.nrapplyrng_sum_kronecker_delta_l.Defined.The identity matrix acts as a right identity for matrix multiplication.Definitionright_identity_matrix_mult(R:Ring) (mn:nat):RightIdentity(@matrix_multRmnn) (identity_matrixRn).Proof.introsM;applypath_matrix;introsijHiHj.rewriteentry_Build_Matrix.lhsnrapplypath_ab_sum.1:introskHk;byrewriteentry_Build_Matrix.nrapplyrng_sum_kronecker_delta_r'.Defined.TODO: define this as an R-algebra. What is an R-algebra over a non-commutative right however? (Here we have a bimodule which might be important)  Matrices over a ring form a (generally) non-commutative ring.Definitionmatrix_ring(R:Ring@{i}) (n:nat) :Ring.Proof.snrapplyBuild_Ring.-exact(abgroup_matrixRnn).-exactmatrix_mult.-exact(identity_matrixRn).-exact(associative_matrix_multRnnnn).-exact(left_distribute_matrix_multRnnn).-exact(right_distribute_matrix_multRnnn).-exact(left_identity_matrix_multRnn).-exact(right_identity_matrix_multRnn).Defined.Matrix multiplication on the right preserves scalar multiplication in the sense thatmatrix_lactr(matrix_multMN)=matrix_mult(matrix_lactrM)Nforra ring element andMandNmatrices of compatible sizes.Definitionmatrix_mult_lact_l{R:Ring} {mnp:nat}:HeteroAssociative(@matrix_lactRmp) (@matrix_multRmnp)(@matrix_multRmnp) (@matrix_lactRmn).Proof.introsrMN.snrapplypath_matrix.introsijHiHj.rewrite!entry_Build_Matrix, !entry_Build_Vector.lhsnrapplyrng_sum_dist_l.snrapplypath_ab_sum.introskHk;cbn.rewrite!entry_Build_Matrix.snrapplyrng_mult_assoc.Defined.The same doesn't hold for the right matrix, since the ring is not commutative. However we could say an analagous statement for the right action. We haven't yet stated a definition of right module yet though.In a commutative ring, matrix multiplication over the ring and the opposite ring agree.Definitionmatrix_mult_rng_op{R:CRing} {mnp}(M:MatrixRmn) (N:MatrixRnp):matrix_mult(R:=rng_opR)MN=matrix_multMN.Proof.applypath_matrix;introsijHiHj.rewrite2entry_Build_Matrix.applypath_ab_sum;introskHk.applyrng_mult_comm.Defined.TransposeThe transpose of a matrix is the matrix with the rows and columns swapped.Definitionmatrix_transpose{R:Type} {mn} :MatrixRmn->MatrixRnm:=funM=>Build_MatrixRnm(funijH1H2=>entryMji).Tranposing a matrix is involutive.Definitionmatrix_transpose_transpose{R:Type} {mn} (M:MatrixRmn):matrix_transpose(matrix_transposeM) =M.Proof.applypath_matrix.introsijHiHj.lhsnrapplyentry_Build_Matrix.nrapplyentry_Build_Matrix.Defined.Transpose distributes over addition.Definitionmatrix_transpose_plus{R:Ring} {mn} (MN:MatrixRmn):matrix_transpose(matrix_plusMN)=matrix_plus(matrix_transposeM) (matrix_transposeN).Proof.applypath_matrix.introsijHiHj.byrewrite!entry_Build_Matrix, !entry_Build_Vector.Defined.Transpose commutes with scalar multiplication.Definitionmatrix_transpose_lact{R:Ring} {mn} (r:R) (M:MatrixRmn):matrix_transpose(matrix_lactrM)=matrix_lactr(matrix_transposeM).Proof.applypath_matrix.introsijHiHj.byrewrite!entry_Build_Matrix, !entry_Build_Vector.Defined.The negation of a transposed matrix is the same as the transposed matrix of the negation.Definitionmatrix_transpose_negate{R:Ring} {mn} (M:MatrixRmn):matrix_transpose(matrix_negateM) =matrix_negate(matrix_transposeM).Proof.applypath_matrix.introsijHiHj.byrewrite!entry_Build_Matrix, !entry_Build_Vector.Defined.Transpose distributes over multiplication when you reverse the ring multiplication.Definitionmatrix_transpose_mult{R:Ring} {mnp}(M:MatrixRmn) (N:MatrixRnp):matrix_transpose(matrix_multMN)=matrix_mult(R:=rng_opR) (matrix_transposeN) (matrix_transposeM).Proof.applypath_matrix.introsijHiHj.rewrite3entry_Build_Matrix.applypath_ab_sum.introskHk.rewrite2entry_Build_Matrix.reflexivity.Defined.When the ring is commutative, there is no need to reverse the multiplication.Definitionmatrix_transpose_mult_comm{R:CRing} {mnp}(M:MatrixRmn) (N:MatrixRnp):matrix_transpose(matrix_multMN)=matrix_mult(matrix_transposeN) (matrix_transposeM).Proof.lhsnrapplymatrix_transpose_mult.applymatrix_mult_rng_op.Defined.The transpose of the zero matrix is the zero matrix.Definitionmatrix_transpose_zero{R:Ring} {mn}:matrix_transpose(matrix_zeroRmn) =matrix_zeroRnm.Proof.applypath_matrix.introsijHiHj.byrewrite!entry_Build_Matrix.Defined.The transpose of the identity matrix is the identity matrix.Definitionmatrix_transpose_identity@{i} {R:Ring@{i}} {n}:matrix_transpose(identity_matrixRn) =identity_matrixRn.Proof.applypath_matrix.introsijHiHj.rewrite3entry_Build_Matrix.applykronecker_delta_symm.Defined.Diagonal matricesA diagonal matrix is a matrix with zeros everywhere except on the diagonal. Its entries are given by a vector.Definitionmatrix_diag{R:Ring@{i}} {n:nat} (v:VectorRn):MatrixRnn.Proof.snrapplyBuild_Matrix.introsijH1H2.exact(kronecker_deltaij*Vector.entryvi).Defined.Addition of diagonal matrices is the same as addition of the corresponding vectors.Definitionmatrix_diag_plus{R:Ring@{i}} {n:nat} (vw:VectorRn):matrix_plus(matrix_diagv) (matrix_diagw) =matrix_diag(vector_plusvw).Proof.symmetry.snrapplypath_matrix.introsijHiHj.rewrite2entry_Build_Matrix, 5entry_Build_Vector.nrapplyrng_dist_l.Defined.Matrix multiplication of diagonal matrices is the same as multiplying the corresponding vectors pointwise.Definitionmatrix_diag_mult{R:Ring} {n:nat} (vw:VectorRn):matrix_mult(matrix_diagv) (matrix_diagw)=matrix_diag(vector_map2(.*.)vw).Proof.snrapplypath_matrix.introsijHiHj.rewrite2entry_Build_Matrix.lhssnrapplypath_ab_sum.{introskHk.rewrite2entry_Build_Matrix.rewriterng_mult_assoc.rewrite<- (rng_mult_assoc(kronecker_delta__)).rewritekronecker_delta_comm.rewrite<- 2rng_mult_assoc.reflexivity. }rewrite(rng_sum_kronecker_delta_l__Hi).byrewriteentry_Build_Vector.Defined.The transpose of a diagonal matrix is the same diagonal matrix.Definitionmatrix_transpose_diag{R:Ring@{i}} {n:nat} (v:VectorRn):matrix_transpose(matrix_diagv) =matrix_diagv.Proof.snrapplypath_matrix.introsijHiHj.rewrite3entry_Build_Matrix.rewritekronecker_delta_symm.unfoldkronecker_delta.destruct(dec(i=j))as[p|np].1:f_ap;symmetry;byapplypath_entry_vector.byrewrite!rng_mult_zero_l.Defined.The diagonal matrix construction is injective.Global Instanceisinj_matrix_diag{R:Ring@{i}} {n:nat}:IsInjective(@matrix_diagRn).Proof.introsv1v2p.snrapplypath_vector.introsiHi.apply(ap(funM=>entryMii))inp.rewrite2entry_Build_Matrixinp.rewritekronecker_delta_reflinp.byrewrite2rng_mult_one_linp.Defined.A matrix is diagonal if it is equal to a diagonal matrix.ClassIsDiagonal@{i} {R:Ring@{i}} {n:nat} (M:MatrixRnn) :Type@{i} := {isdiagonal_diag_vector:VectorRn;isdiagonal_diag:M=matrix_diagisdiagonal_diag_vector;}.Argumentsisdiagonal_diag_vector{Rn}M{_}.Argumentsisdiagonal_diag{Rn}M{_}.Definitionissig_IsDiagonal{R:Ring@{i}} {n:nat} {M:MatrixRnn}:_<~>IsDiagonalM:=ltac:(issig).A matrix is diagonal in a unique way.Global Instanceishprop_isdiagonal{R:Ring@{i}} {n:nat} (M:MatrixRnn):IsHProp(IsDiagonalM).Proof.snrapplyhprop_allpath.introsxy.snrapply((equiv_ap'issig_IsDiagonal^-1%equiv__)^-1%equiv).rapplypath_sigma_hprop;cbn.applyisinj_matrix_diag.exact((isdiagonal_diagM)^ @isdiagonal_diagM).Defined.The zero matrix is diagonal.Global Instanceisdiagonal_matrix_zero{R:Ring@{i}} {n:nat}:IsDiagonal(matrix_zeroRnn).Proof.exists(vector_zeroRn).snrapplypath_matrix.introsijHiHj.rewrite2entry_Build_Matrix,entry_Build_Vector.byrewriterng_mult_zero_r.Defined.The identity matrix is diagonal.Global Instanceisdiagonal_identity_matrix{R:Ring@{i}} {n:nat}:IsDiagonal(identity_matrixRn).Proof.exists(Build_VectorRn(fun__=> 1)).snrapplypath_matrix.introsijHiHj.rewrite2entry_Build_Matrix,entry_Build_Vector.byrewriterng_mult_one_r.Defined.The sum of two diagonal matrices is diagonal.Global Instanceisdiagonal_matrix_plus{R:Ring@{i}} {n:nat}(MN:MatrixRnn) `{IsDiagonalRnM} `{IsDiagonalRnN}:IsDiagonal(matrix_plusMN).Proof.exists(vector_plus(isdiagonal_diag_vectorM) (isdiagonal_diag_vectorN)).rewrite(isdiagonal_diagM), (isdiagonal_diagN).applymatrix_diag_plus.Defined.The negative of a diagonal matrix is diagonal.Global Instanceisdiagonal_matrix_negate{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{IsDiagonalRnM}:IsDiagonal(matrix_negateM).Proof.exists(vector_neg__(isdiagonal_diag_vectorM)).rewrite(isdiagonal_diagM).snrapplypath_matrix.introsijHiHj.rewrite!entry_Build_Matrix, !entry_Build_Vector.byrewriterng_mult_negate_r.Defined.The product of two diagonal matrices is diagonal.Global Instanceisdiagonal_matrix_mult{R:Ring@{i}} {n:nat}(MN:MatrixRnn) `{IsDiagonalRnM} `{IsDiagonalRnN}:IsDiagonal(matrix_multMN).Proof.exists(vector_map2(.*.) (isdiagonal_diag_vectorM) (isdiagonal_diag_vectorN)).rewrite(isdiagonal_diagM), (isdiagonal_diagN).applymatrix_diag_mult.Defined.The transpose of a diagonal matrix is diagonal.Global Instanceisdiagonal_matrix_transpose{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{IsDiagonalRnM}:IsDiagonal(matrix_transposeM).Proof.exists(isdiagonal_diag_vectorM).rewrite(isdiagonal_diagM).applymatrix_transpose_diag.Defined.Given a square matrix, we can extract the diagonal as a vector.Definitionmatrix_diag_vector{R:Ring} {n:nat} (M:MatrixRnn):VectorRn:=Build_VectorRn(funi_=>entryMii).Diagonal matrices form a subring of the ring of square matrices.Definitionmatrix_diag_ring@{i} (R:Ring@{i}) (n:nat):Subring@{ii} (matrix_ringRn).Proof.snrapply(Build_Subring'(funM:matrix_ringRn=>IsDiagonalM)_);hnf.-intros;exact_.-introsxydxdy.nrapplyisdiagonal_matrix_plus;trivial.bynrapplyisdiagonal_matrix_negate.-nrapplyisdiagonal_matrix_mult.-nrapplyisdiagonal_identity_matrix.Defined.TraceThe trace of a square matrix is the sum of the diagonal entries.Definitionmatrix_trace{R:Ring} {n} (M:MatrixRnn) :R:=ab_sumn(funiHi=>entryMii).The trace of a matrix preserves addition.Definitionmatrix_trace_plus{R:Ring} {n} (MN:MatrixRnn):matrix_trace(matrix_plusMN) = (matrix_traceM) + (matrix_traceN).Proof.unfoldmatrix_trace.lhsnrapplypath_ab_sum.{introsiHi.byrewriteentry_Build_Matrix. }byrewriteab_sum_plus.Defined.The trace of a matrix preserves scalar multiplication.Definitionmatrix_trace_lact{R:Ring} {n} (r:R) (M:MatrixRnn):matrix_trace(matrix_lactrM) =r*matrix_traceM.Proof.unfoldmatrix_trace.rewriterng_sum_dist_l.applypath_ab_sum.introsiHi.byrewriteentry_Build_Matrix.Defined.The trace of a matrix multiplication is the same as the trace of the reverse multiplication. This holds only in a commutative ring.Definitionmatrix_trace_mult{R:CRing} {mn:nat}(M:MatrixRmn) (N:MatrixRnm):matrix_trace(matrix_multMN) =matrix_trace(matrix_multNM).Proof.lhsnrapplypath_ab_sum.{introsiHi.lhsnrapplyentry_Build_Matrix.nrapplypath_ab_sum.introsjHj.applyrng_mult_comm. }lhsnrapplyab_sum_sum.applypath_ab_sum.introsiHi.rhsnrapplyentry_Build_Matrix.reflexivity.Defined.The trace of the transpose of a matrix is the same as the trace of the matrix.Definitiontrace_transpose{R:Ring} {n} (M:MatrixRnn):matrix_trace(matrix_transposeM) =matrix_traceM.Proof.applypath_ab_sum.introsiHi.nrapplyentry_Build_Matrix.Defined.Matrix minorsDefinitionskip(n:nat) :nat->nat:=funi=>ifdec(i<n)%natthenielsei.+1%nat.Global Instanceisinjective_skipn:IsInjective(skipn).Proof.hnf.introsxyp.unfoldskipinp.destruct(dec(x<n)%nat)as[H|H], (dec(y<n)%nat)as[H'|H'].-exactp.-destructp^.contradiction(H'(leq_trans_H)).-destructp.contradiction(H(leq_trans_H')).-byapplypath_nat_succ.Defined.Local Instancelt_n1_skipkin(H: (i<n.+1)%nat) (H': (k<n)%nat): (skipik<n.+1)%nat.Proof.unfoldskip.destruct(dec(k<i))%natas[H''|H''];exact_.Defined.Definitionmatrix_minor{R:Ring@{i}} {n:nat} (ij:nat){Hi: (i<n.+1)%nat} {Hj: (j<n.+1)%nat} (M:MatrixRn.+1n.+1):MatrixRnn:=Build_MatrixRnn(funkl__=>entryM(skipik) (skipjl)).A minor of the zero matrix is again the zero matrix.Definitionmatrix_minor_zero{R:Ring@{i}} {n:nat} (ij:nat)(Hi: (i<n.+1)%nat) (Hj: (j<n.+1)%nat):matrix_minorij(matrix_zeroRn.+1n.+1) =matrix_zeroRnn.Proof.applypath_matrix.introsklHkHl.byrewrite!entry_Build_Matrix.Defined.Definitionmatrix_minor_identity{R:Ring@{i}} {n:nat}(i:nat) (Hi: (i<n.+1)%nat):matrix_minorii(identity_matrixRn.+1) =identity_matrixRn.Proof.applypath_matrix.introsjkHjHk.rewrite3entry_Build_Matrix.rapplykronecker_delta_map_inj.Defined.Definitionmatrix_minor_plus{R:Ring@{i}} {n:nat} (ij:nat)(Hi: (i<n.+1)%nat) (Hj: (j<n.+1)%nat) (MN:MatrixRn.+1n.+1):matrix_minorij(matrix_plusMN)=matrix_plus(matrix_minorijM) (matrix_minorijN).Proof.applypath_matrix.introsklHkHl.byrewrite!entry_Build_Matrix, !entry_Build_Vector.Defined.Definitionmatrix_minor_scale{R:Ring@{i}} {n:nat} (ij:nat)(Hi: (i<n.+1)%nat) (Hj: (j<n.+1)%nat) (r:R) (M:MatrixRn.+1n.+1):matrix_minorij(matrix_lactrM) =matrix_lactr(matrix_minorijM).Proof.applypath_matrix.introsklHkHl.byrewrite!entry_Build_Matrix, !entry_Build_Vector.Defined.Definitionmatrix_minor_transpose{R:Ring@{i}} {n:nat} (ij:nat)(Hi: (i<n.+1)%nat) (Hj: (j<n.+1)%nat) (M:MatrixRn.+1n.+1):matrix_minorji(matrix_transposeM)=matrix_transpose(matrix_minorijM).Proof.applypath_matrix.introsklHkHl.byrewrite4entry_Build_Matrix.Defined.Triangular matricesA matrix is upper triangular if all the entries below the diagonal are zero.ClassIsUpperTriangular@{i} {R:Ring@{i}} {n:nat} (M:Matrix@{i}Rnn) :Type@{i}:=upper_triangular:merely@{i} (forallij(Hi: (i<n)%nat) (Hj: (j<n)%nat), (i<j)%nat->entryMij= 0).Global Instanceishprop_isuppertriangular@{i} {R:Ring@{i}} {n:nat} (M:MatrixRnn):IsHProp(IsUpperTriangularM).Proof.applyistrunc_truncation@{ii}.Defined.A matrix is lower triangular if all the entries above the diagonal are zero. We define it as the transpose being upper triangular.ClassIsLowerTriangular{R:Ring@{i}} {n:nat} (M:Matrix@{i}Rnn) :Type@{i}:=upper_triangular_transpose::IsUpperTriangular(matrix_transposeM).Global Instanceishprop_islowertriangular@{i} {R:Ring@{i}} {n:nat}(M:MatrixRnn):IsHProp(IsLowerTriangularM).Proof.applyistrunc_truncation@{ii}.Defined.The transpose of a matrix is lower triangular if and only if the matrix is upper triangular.Global Instancelower_triangular_transpose{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsUpperTriangularM}:IsLowerTriangular(matrix_transposeM).Proof.unfoldIsLowerTriangular.byrewritematrix_transpose_transpose.Defined.The sum of two upper triangular matrices is upper triangular.Global Instanceupper_triangular_plus@{i} {R:Ring@{i}} {n:nat} (MN:MatrixRnn){H1:IsUpperTriangularM} {H2:IsUpperTriangularN}:IsUpperTriangular(matrix_plusMN).Proof.unfoldIsUpperTriangular.(* We usestrip_reflectionsrather thanstrip_truncationshere and below because it generates fewer universe variables in some versions of Coq. *)strip_reflections;applytr.introsijHiHjlt_i_j.specialize(H1ijHiHjlt_i_j).specialize(H2ijHiHjlt_i_j).rewriteentry_Build_Matrix.change(Vector.entry(Vector.entry?M?i) ?j)with(entryMij).rewriteH1,H2.byrewriterng_plus_zero_l.Defined.The sum of two lower triangular matrices is lower triangular.Global Instancelower_triangular_plus{R:Ring@{i}} {n:nat}(MN:MatrixRnn) `{!IsLowerTriangularM} `{!IsLowerTriangularN}:IsLowerTriangular(matrix_plusMN).Proof.unfoldIsLowerTriangular.rewritematrix_transpose_plus.byapplyupper_triangular_plus.Defined.The negation of an upper triangular matrix is upper triangular.Global Instanceupper_triangular_negate@{i} {R:Ring@{i}} {n:nat} (M:MatrixRnn){H:IsUpperTriangularM}:IsUpperTriangular(matrix_negateM).Proof.unfoldIsUpperTriangular.strip_reflections;applytr.introsijHiHjlt_i_j.rewriteentry_Build_Matrix.rewrite<-rng_negate_zero;f_ap.bynrapplyH.Defined.The negation of a lower triangular matrix is lower triangular.Global Instancelower_triangular_negate{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsLowerTriangularM}:IsLowerTriangular(matrix_negateM).Proof.unfoldIsLowerTriangular.rewritematrix_transpose_negate.exact_.Defined.The product of two upper triangular matrices is upper triangular.Global Instanceupper_triangular_mult@{i} {R:Ring@{i}} {n:nat}(MN:MatrixRnn) {H1:IsUpperTriangularM} {H2:IsUpperTriangularN}:IsUpperTriangular(matrix_multMN).Proof.unfoldIsUpperTriangular.strip_reflections;applytr.introsijHiHjlt_i_j.rewriteentry_Build_Matrix.applyab_sum_zero.introskHk.destruct(dec(k<=i)%nat)as[leq_k_i|gt_k_i].{rewriteH2.1:byrewriterng_mult_zero_r.rapplylt_leq_lt_trans. }applygt_iff_not_leqingt_k_i.rewriteH1.1:byrewriterng_mult_zero_l.assumption.Defined.The product of two lower triangular matrices is lower triangular.Global Instancelower_triangular_mult{R:Ring@{i}} {n:nat}(MN:MatrixRnn) {H1:IsLowerTriangularM} {H2:IsLowerTriangularN}:IsLowerTriangular(matrix_multMN).Proof.unfoldIsLowerTriangular.rewritematrix_transpose_mult.nrapply(upper_triangular_mult(R:=rng_opR));assumption.Defined.The zero matrix is upper triangular.Global Instanceupper_triangular_zero{R:Ring@{i}} {n:nat}:IsUpperTriangular(matrix_zeroRnn).Proof.applytr.byhnf;intros;rewriteentry_Build_Matrix.Defined.The zero matrix is lower triangular.Global Instancelower_triangular_zero{R:Ring@{i}} {n:nat}:IsLowerTriangular(matrix_zeroRnn).Proof.unfoldIsLowerTriangular.rewritematrix_transpose_zero.exact_.Defined.The identity matrix is upper triangular.Global Instanceupper_triangular_identity@{i} {R:Ring@{i}} {n:nat}:IsUpperTriangular(identity_matrixRn).Proof.unfoldIsUpperTriangular.applytr@{i}.introsijHiHjlt_i_j.rewriteentry_Build_Matrix@{i}.byapplykronecker_delta_lt.Defined.The identity matrix is lower triangular.Global Instancelower_triangular_identity@{i} {R:Ring@{i}} {n:nat}:IsLowerTriangular(identity_matrixRn).Proof.unfoldIsLowerTriangular.rewritematrix_transpose_identity.exact_.Defined.A diagonal matrix is upper triangular.Global Instanceupper_triangular_diag{R:Ring@{i}} {n:nat} (v:VectorRn):IsUpperTriangular(matrix_diagv).Proof.unfoldIsUpperTriangular.applytr.introsijHiHjlt_i_j.rewriteentry_Build_Matrix.rewritekronecker_delta_lt.1:byrewriterng_mult_zero_l.exact_.Defined.A diagonal matrix is lower triangular.Global Instancelower_triangular_diag{R:Ring@{i}} {n:nat} (v:VectorRn):IsLowerTriangular(matrix_diagv).Proof.unfoldIsLowerTriangular.rewritematrix_transpose_diag.applyupper_triangular_diag.Defined.Upper triangular matrices are a subring of the ring of matrices.Definitionupper_triangular_matrix_ring@{i} (R:Ring@{i}) (n:nat):Subring@{ii} (matrix_ring@{i}Rn).Proof.nrapply(Build_Subring'(funM:matrix_ringRn=>IsUpperTriangularM)).-exact_.(* These can all be found by typeclass search, but being explicit makes this faster. *)-introsxy? ?;exact(upper_triangular_plusx(-y)).-exactupper_triangular_mult.-exactupper_triangular_identity.Defined.Lower triangular matrices are a subring of the ring of matrices.Definitionlower_triangular_matrix_ring@{i} (R:Ring@{i}) (n:nat):Subring@{ii} (matrix_ringRn).Proof.nrapply(Build_Subring'@{ii} (funM:matrix_ringRn=>IsLowerTriangularM)).-exact_.(* These can all be found by typeclass search, but being explicit makes this faster. *)-introsxy? ?;exact(lower_triangular_plusx(-y)).-exactlower_triangular_mult.-exactlower_triangular_identity.Defined.Symmetric MatricesA matrix is symmetric when it is equal to its transpose.ClassIsSymmetric{R:Ring@{i}} {n:nat} (M:Matrix@{i}Rnn) :Type@{i}:=matrix_transpose_issymmetric:matrix_transposeM=M.Argumentsmatrix_transpose_issymmetric{Rn}M{_}.The zero matrix is symmetric.Global Instanceissymmetric_matrix_zero{R:Ring@{i}} {n:nat}:IsSymmetric(matrix_zeroRnn):=matrix_transpose_zero.The identity matrix is symmetric.Global Instanceissymmetric_matrix_identity{R:Ring@{i}} {n:nat}:IsSymmetric(identity_matrixRn):=matrix_transpose_identity.The sum of two symmetric matrices is symmetric.Global Instanceissymmetric_matrix_plus{R:Ring@{i}} {n:nat}(MN:MatrixRnn) `{!IsSymmetricM} `{!IsSymmetricN}:IsSymmetric(matrix_plusMN).Proof.unfoldIsSymmetric.rewritematrix_transpose_plus.f_ap.Defined.The negation of a symmetric matrix is symmetric.Global Instanceissymmetric_matrix_negate{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsSymmetricM}:IsSymmetric(matrix_negateM).Proof.unfoldIsSymmetric.rewritematrix_transpose_negate.f_ap.Defined.A scalar multiple of a symmetric matrix is symmetric.Global Instanceissymmetric_matrix_scale{R:Ring@{i}} {n:nat}(r:R) (M:MatrixRnn) `{!IsSymmetricM}:IsSymmetric(matrix_lactrM).Proof.unfoldIsSymmetric.rewritematrix_transpose_lact.f_ap.Defined.The transpose of a symmetric matrix is symmetric.Global Instanceissymmetric_matrix_transpose{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsSymmetricM}:IsSymmetric(matrix_transposeM).Proof.unfoldIsSymmetric.rewritematrix_transpose_transpose.bysymmetry.Defined.A symmetric upper triangular matrix is diagonal.Global Instanceisdiagonal_upper_triangular_issymmetric{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsSymmetricM} {H:IsUpperTriangularM}:IsDiagonalM.Proof.exists(matrix_diag_vectorM).snrapplypath_matrix.introsijHiHj.rewriteentry_Build_Matrix,entry_Build_Vector.strip_truncations.destruct(dec(i=j))as[p|np].{destructp.rewritekronecker_delta_refl.rewriterng_mult_one_l.f_ap;applypath_ishprop. }applyneq_iff_lt_or_gtinnp.destructnpas[l|l].-rewrite(kronecker_delta_ltl).rewriterng_mult_zero_l.byrewriteH.-rewrite(kronecker_delta_gtl).rewriterng_mult_zero_l.rewrite<- (matrix_transpose_issymmetricM).rewriteentry_Build_Matrix.byrewriteH.Defined.A symmetric lower triangular matrix is diagonal.Global Instanceisdiagonal_lower_triangular_issymmetric{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsSymmetricM} `{!IsLowerTriangularM}:IsDiagonalM.Proof.rewrite<- (matrix_transpose_issymmetricM).rapplyisdiagonal_upper_triangular_issymmetric.Defined.Note that symmetric matrices do not form a subring (or subalgebra) but they do form a submodule of the module of matrices.Skew-symmetric MatricesA matrix is skew-symmetric when it is equal to the negation of its transpose.ClassIsSkewSymmetric{R:Ring@{i}} {n:nat} (M:Matrix@{i}Rnn) :Type@{i}:=matrix_transpose_isskewsymmetric:matrix_transposeM=matrix_negateM.Argumentsmatrix_transpose_isskewsymmetric{Rn}M{_}.The zero matrix is skew-symmetric.Global Instanceisskewsymmetric_matrix_zero{R:Ring@{i}} {n:nat}:IsSkewSymmetric(matrix_zeroRnn).Proof.unfoldIsSkewSymmetric.rewritematrix_transpose_zero.symmetry.nrapply(rng_negate_zero(A:=matrix_ringRn)).Defined.The negation of a skew-symmetric matrix is skew-symmetric.Global Instanceisskewsymmetric_matrix_negate{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsSkewSymmetricM}:IsSkewSymmetric(matrix_negateM).Proof.unfoldIsSkewSymmetric.rewritematrix_transpose_negate.f_ap.Defined.A scalar multiple of a skew-symmetric matrix is skew-symmetric.Global Instanceisskewsymmetric_matrix_scale{R:Ring@{i}} {n:nat}(r:R) (M:MatrixRnn) `{!IsSkewSymmetricM}:IsSkewSymmetric(matrix_lactrM).Proof.unfoldIsSkewSymmetric.rewritematrix_transpose_lact.rhs_Vnrapply(lm_neg(M:=Build_LeftModule_(abgroup_matrixRnn)_)rM).f_ap.Defined.The transpose of a skew-symmetric matrix is skew-symmetric.Global Instanceisskewsymmetric_matrix_transpose{R:Ring@{i}} {n:nat}(M:MatrixRnn) `{!IsSkewSymmetricM}:IsSkewSymmetric(matrix_transposeM).Proof.unfoldIsSkewSymmetric.rewrite<-matrix_transpose_negate.f_ap.Defined.The sum of two skew-symmetric matrices is skew-symmetric.Global Instanceisskewsymmetric_matrix_plus{R:Ring@{i}} {n:nat}(MN:MatrixRnn) `{!IsSkewSymmetricM} `{!IsSkewSymmetricN}:IsSkewSymmetric(matrix_plusMN).Proof.unfoldIsSkewSymmetric.rewritematrix_transpose_plus.rhsnrapply(grp_inv_op(G:=abgroup_matrixRnn)).rhs_Vnrapply(AbelianGroup.ab_comm(A:=abgroup_matrixRnn)).f_ap.Defined.Skew-symmetric matrices degenerate to symmetric matrices in rings with characteristic 2. In odd characteristic the module of matrices can be decomposed into the direct sum of symmetric and skew-symmetric matrices.SectionMatrixCat.The wild categoryMatrixCatRofR-valued matrices. This category has natural numbers as objects and m x n matrices as the arrows betweenmandn.DefinitionMatrixCat(R:Ring) :=nat.Global Instanceisgraph_matrixcat{R:Ring} :IsGraph(MatrixCatR):= {|Hom:=MatrixR|}.Global Instanceis01cat_matrixcat{R:Ring} :Is01Cat(MatrixCatR).Proof.snrapplyBuild_Is01Cat.-exact(identity_matrixR).-introslmnMN.exact(matrix_multNM).Defined.Global Instanceis2graph_matrixcat{R:Ring} :Is2Graph(MatrixCatR):=is2graph_paths_.MatrixCat R forms a strong 1-category.Global Instanceis1catstrong_matrixcat{R:Ring} :Is1Cat_Strong(MatrixCatR).Proof.snrapplyBuild_Is1Cat_Strong.(* Most of the structure comes from typeclasses in WildCat.Paths. *)1-4:exact_.-apply(associative_matrix_multR).-introsklmnMNP.applyinverse.apply(associative_matrix_multR).-applyright_identity_matrix_mult.-applyleft_identity_matrix_mult.Defined.TODO: Define HasEquivs for MatrixCat.EndMatrixCat.

--- Miscellaneous\Meet.html ---
MeetLibrary MeetRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensionsHFiberTruncationsNullHomotopyLimits.Pullback.RequireImportDescentLexSeparated.We construct "canonical" binary meets of reflective subuniverses (that is, whose underlying subuniverse is an intersection), without assuming accessibility.  In particular, we will show:1. Given two reflective subuniverses L and O, ifLOXisO-modal, then it is a reflection into the canonical meet.  In particular, this is always the case ifLpreservesO-modal types; this is Theorem 3.30 of RSS.1. If L and O are lex modalities satisfying an additional "composability" condition, then the composite functorLoOconverges to a reflection into the canonical meet after n+2 applications when applied to an n-type for some finite n.The latter gives in particular a synthetic approach to higher sheafification (stack completion).  As described at https://ncatlab.org/nlab/show/plus+construction+on+presheaves, for any site C the topos of presheaves on its Grothendieck topology is cohesive and even totally connected, so that its shape and sharp modalities are both lex.  Their canonical meet is the topos of sheaves for the given topology, and the composite functorshapeosharpis the usual "plus construction" on (higher) presheaves.  Thus, we recover synthetically the result that an n-truncated type can be stackified by (n+2) applications of the plus construction.  We also refer toLoOas a "plus construction" in the general case of reflective subuniverses.SectionRSUMeet.Context(LO:ReflectiveSubuniverse).The canonical meet of two subuniverses is their intersection.DefinitionMeet:Subuniverse.Proof.unshelveeconstructor.-introsX;exact(InLX*InOX).-intros?X;exact_.-introsTU[? ?]ffeq;split;apply(inO_equiv_inO_f).Defined.Global InstanceinO_inmeet_l(X:Type) `{im:InMeetX} :InLX:=fstim.Global InstanceinO_inmeet_r(X:Type) `{im:InMeetX} :InOX:=sndim.The basic tool in studying its reflectivity is the "plus construction" that applies the two reflectors in sequence.DefinitionPlus(X:Type) :=L(OX).Global InstanceinO_plus_l(X:Type) :InL(PlusX) :=_.This is not necessarily a reflector, but it is a well-pointed endofunctor.Definitionto_plus(X:Type) :X->PlusX:=toL(OX)otoOX.Definitionplus_functor{XY:Type} (f:X->Y) :PlusX->PlusY:=O_functorL(O_functorOf).Definitionto_plus_natural{XY:Type} (f:X->Y):plus_functorfoto_plusX==to_plusYof.Proof.introsx.unfoldplus_functor,to_plus.refine(to_O_naturalL(O_functorOf) (toOXx) @_).applyap.applyto_O_natural.Defined.Definitionwellpointed_plus(X:Type):to_plus(PlusX) ==plus_functor(to_plusX).Proof.rapply(@O_indpathsL).introsox.unfoldto_plus,plus_functor;cbn.refine(_@ (to_O_naturalL_ox)^).applyap.revertox;applyO_indpaths;introsx.exact((to_O_naturalO_x)^).Defined.Moreover, it has the desired factorization property of a reflector (though it may not belong to the meet subuniverse itself).Definitionooextendable_plus{XY:Type} `{InMeetY}:ooExtendableAlong(to_plusX) (fun_=>Y).Proof.apply(ooextendable_compose_(toOX) (toL(OX)));rapplyextendable_to_O.Defined.Definitionplus_rec{PQ:Type} `{InMeetQ} (f:P->Q):PlusP->Q:= (fst(ooextendable_plus1%nat)f).1.Definitionplus_rec_beta{PQ:Type} `{InMeetQ} (f:P->Q) (x:P):plus_recf(to_plusPx) =fx:= (fst(ooextendable_plus1%nat)f).2x.Definitionplus_indpaths{PQ:Type} `{InMeetQ} (gh:PlusP->Q)(p:goto_plusP==hoto_plusP):g==h:= (fst(snd(ooextendable_plus2%nat)gh)p).1.Definitionplus_indpaths_beta{PQ:Type} `{InMeetQ} (gh:PlusP->Q)(p:go(to_plusP) ==ho(to_plusP)) (x:P):plus_indpathsghp(to_plusPx) =px:= (fst(snd(ooextendable_plus2%nat)gh)p).2x.Moreover, its fixed points, as a pointed endofunctor, are the types in the meet.Definitionisequiv_plus_inmeet(X:Type) `{InMeetX} :IsEquiv(to_plusX).Proof.apply(@isequiv_compose__(toOX)__(toL(OX))).applyisequiv_to_O_inO.apply(inO_equiv_inOX(toOX)).Defined.Definitioninmeet_isequiv_plus(X:Type) `{IsEquiv__(to_plusX)} :InMeetX.Proof.split.-apply(inO_equiv_inO(PlusX) (to_plusX)^-1).-srapplyinO_to_O_retract.+exact((to_plusX)^-1o(toL(OX))).+introsx;apply(eissect(to_plusX)).Defined.It follows that ifPlusXever *does* lie in the meet, then it is a reflection.Global Instanceprereflects_plus_inO(X:Type) `{InO(PlusX)}:PreReflectsMeetX.Proof.unshelveeconstructor.-exact(PlusX).-split;exact_.-applyto_plus.Defined.Global Instancereflects_plus_inO(X:Type) `{InO(PlusX)}:ReflectsMeetX.Proof.constructor;intros;applyooextendable_plus.Defined.Recalling that a type is connected for a reflective subuniverse if and only if its reflector is nullhomotopic, we define a type to be "plus-connected" if its map to plus is nullhomotopic.  If the meet is reflective, this coincides with connectedness for that reflective subuniverse.DefinitionPlusConnected(X:Type) :=NullHomotopy(to_plusX).Definitionplusconnected_equiv{XY:Type} (f:X<~>Y):PlusConnectedX->PlusConnectedY.Proof.intros[pxe].exists(plus_functorfpx);introsy.refine(_@ap(plus_functorf) (e(f^-1y))).rewriteto_plus_natural.symmetry;applyap,eisretr.Defined.Similarly, we say a map is plus-connected if all of its fibers are.DefinitionPlusConnMap{XY:Type} (f:X->Y) :=forally,PlusConnected(hfiberfy).EndRSUMeet.Let's now assume we are trying to intersect two lex modalities.SectionLexMeet.Context(LO:Modality) `{LexL} `{LexO}.The plus construction, being a composite of two lex functors, is also lex.  Thus, it preserves path-types.Definitionplus_path{X:Type} (xy:X):PlusLO(x=y) <~> (to_plusLOXx=to_plusLOXy).Proof.refine(equiv_path_OL(toOXx) (toOXy)oE_).applyequiv_O_functor.rapplyequiv_path_O.Defined.Definitionplus_path_to_plus{X:Type} (xy:X):plus_pathxyoto_plusLO(x=y) == @ap__(to_plusLOX)xy.Proof.introsp;unfoldplus_path,to_plus,equiv_path_O,equiv_path_OO,path_OO.cbn.rewriteto_O_natural.rewriteO_rec_beta.rewrite(ap_compose(toOX) (toL(OX))).applyap.applyO_rec_beta.Defined.This implies that plus-connected types are closed under path-spaces.Definitionplusconnected_path{X:Type} (xy:X)(pc:PlusConnectedLOX) :PlusConnectedLO(x=y).Proof.unfoldPlusConnectedin*.apply(cancelL_nullhomotopy_equiv_(plus_pathxy)).apply(nullhomotopy_homotopic(funu=> (plus_path_to_plusxyu)^)).applynullhomotopy_ap;assumption.Defined.And hence plus-connected maps are closed under diagonals.Definitionplusconnmap_diagonal{XY:Type} (f:X->Y):PlusConnMapLOf->PlusConnMapLO(diagonalf).Proof.introspcp.refine(plusconnected_equivLO(hfiber_diagonalfp)^-1_).applyplusconnected_path,pc.Defined.The plus-construction also preserves fibers.Definitionplus_hfiber{XY:Type} (f:X->Y) (y:Y):PlusLO(hfiberfy) <~>hfiber(plus_functorLOf) (to_plusLOYy).Proof.refine(equiv_O_functor_hfiberL(O_functorOf) (toOYy)oE_).applyequiv_O_functor.rapplyequiv_O_functor_hfiber.Defined.Definitionplus_hfiber_to_plus{XY:Type} (f:X->Y) (y:Y):plus_hfiberfyoto_plusLO(hfiberfy)==functor_hfiber(funu=> (to_plus_naturalLOfu)^)y.Proof.intros[xq];unfoldplus_hfiber,to_plus.cbn.rewriteto_O_natural.rewriteO_functor_hfiber_natural.unfoldO_functor_hfiber,functor_hfiber,functor_sigma;cbn.rewriteO_rec_beta;cbn.applyap.unfoldto_plus_natural.rewrite!inv_V,ap_pp,concat_p_pp.applywhiskerL.rewrite<-ap_compose.reflexivity.Defined.And pullbacks.Definitionequiv_plus_pullback{ABC:Type} (f:B->A) (g:C->A):PlusLO(Pullbackfg) <~>Pullback(plus_functorLOf) (plus_functorLOg).Proof.refine(equiv_O_pullbackL(O_functorOf) (O_functorOg)oE_).applyequiv_O_functor.rapplyequiv_O_pullback.Defined.And diagonals.Definitiondiagonal_plus_functor{AB:Type} (f:A->B):diagonal(plus_functorLOf) ==equiv_plus_pullbackffoplus_functorLO(diagonalf).Proof.introsx.refine(diagonal_O_functorL(O_functorOf)x@_).apply(ap(equiv_O_pullbackL(O_functorOf) (O_functorOf))).refine(O_functor_homotopyL__(diagonal_O_functorOf)x@_).unfoldplus_functor.exact(O_functor_composeL__x).Defined.Recall that a modality is characterized by connectedness of the units.  Analogously, we can now prove that the plus-units are all plus-connected.  This is equivalently a sort of coherence axiom for the homotopywellpointed_plus, that when precomposed withto_plusit becomesto_plus_natural.Definitionplusconnmap_to_plus(X:Type) :PlusConnMapLO(to_plusLOX).Proof.introsy;unfoldPlusConnected.apply(cancelL_nullhomotopy_equiv_(plus_hfiber(to_plusLOX)y)).apply(nullhomotopy_homotopic(funu=> (plus_hfiber_to_plus(to_plusLOX)yu)^)).unfoldNullHomotopy,hfiber.unshelverefine((y;_) ;_).{symmetry;applywellpointed_plus. }intros[xp];destructp.unfoldfunctor_hfiber,functor_sigma;cbn.applyap.rewriteinv_V,concat_p1.unfoldwellpointed_plus.rewrite!O_indpaths_beta.rewriteinv_pp,ap_V, !inv_V.reflexivity.Defined.Recall also (fromnsep_iff_trunc_to_O) that a type is n-separated for a lex modalityOif and only if itsO-unit is an n-truncated map.  We can now prove the analogous fact for the plus-construction.  We state this usingMapIn(Trn)instead ofIsTruncnbecause we have more useful lemmas forMapIn.Definitionnsep_iff_trunc_plus(n:trunc_index) (X:Type):In(nSepn(MeetLO))X<->MapIn(Trn) (to_plusLOX).Proof.revertX;inductionnas[|nIHn];introsX;split;introsH.-applycontr_map_isequiv.rapplyisequiv_plus_inmeet.-applyinmeet_isequiv_plus.rapplyisequiv_contr_map.-applyistruncmap_from_ap;introsxy.applyistruncmap_mapinO_tr.pose(i:=fst(IHn_) (Hxy)).apply(mapinO_homotopic__(plus_path_to_plusxy)).-introsxy.apply(snd(IHn(x=y))).pose(i:=istruncmap_apn(to_plusLOX)xy).applymapinO_tr_istruncmapini.apply(mapinO_homotopic_((plus_pathxy)^-1o(@ap__(to_plusLOX)xy))).{introsp;applymoveR_equiv_V;symmetry;applyplus_path_to_plus. }rapplymapinO_compose.Defined.We now make one more assumption, that the plus-construction inverts plus-connected embeddings.  In the case of the plus-construction for stacks, this corresponds roughly to the "local character" condition on a Grothendieck topology.Context(composing:forall(XY:Type) (f:X->Y)(fe:IsEmbeddingf) (fc:PlusConnMapLOf),IsEquiv(plus_functorLOf)).This implies, by induction, that the plus-construction decreases the truncation-level of any finitely truncated plus-connected map.Definitionistruncmap_plus_functor{n:trunc_index} {XY:Type} (f:X->Y)`{MapIn(Trn.+1)__f} (pc:PlusConnMapLOf):MapIn(Trn) (plus_functorLOf).Proof.generalizedependentf;revertXY;inductionnas[|nIHn];introsXYf?pc.{applymapinO_tr_istruncmap,contr_map_isequiv,composing;assumption. }pose(O_eq_Trn).apply(mapinO_O_leq(Sep(Trn))_),mapinO_from_diagonal.nrapply(mapinO_homotopic(Trn)_(funu=> (diagonal_plus_functorfu)^)).applymapinO_compose.2:rapplymapinO_isequiv.applyIHn.-rapplymapinO_diagonal.pose(O_eq_Trn.+1).rapply(mapinO_O_leq_(Sep(Trn.+1))).-applyplusconnmap_diagonal;assumption.Defined.It follows, by applying this to the plus-unit and using well-pointedness, that the plus-construction on *types* decreases their plus-separatedness.Definitionnsep_plus(n:trunc_index) (X:Type) `{In(nSepn.+1 (MeetLO))X}:In(nSepn(MeetLO)) (PlusLOX).Proof.applynsep_iff_trunc_plus.nrefine(mapinO_homotopic__(funu=> (wellpointed_plusLOXu)^)).applymapinO_tr_istruncmap,istruncmap_plus_functor.-applyistruncmap_mapinO_tr,nsep_iff_trunc_plus;assumption.-applyplusconnmap_to_plus.Defined.Therefore, if a type starts out as n-plus-separated, then n+2 applications of the plus-construction suffice to make it (-2)-plus-separated, i.e. in the meet subuniverse.  Hence it has a reflection.Global Instanceprereflects_plus_nsep(n:trunc_index) (X:Type) `{In(nSepn(MeetLO))X}:PreReflects(MeetLO)X.Proof.generalizedependentX;inductionnas[|nIHn];introsX?.{rapplyprereflects_in. }specialize(IHn(PlusLOX) (nsep_plusnX)).unshelveeconstructor.-exact(O_reflector(MeetLO) (PlusLOX)).-exact_.-exact(to(MeetLO) (PlusLOX)oto_plusLOX).Defined.Global Instancereflects_plus_nsep(n:trunc_index) (X:Type) `{In(nSepn(MeetLO))X}:Reflects(MeetLO)X.Proof.generalizedependentX;inductionnas[|nIHn];introsX?.{rapplyreflects_in. }specialize(IHn(PlusLOX) (nsep_plusnX)).constructor;intros.apply(ooextendable_compose_(to_plusLOX) (to(MeetLO) (PlusLOX))).-apply(@extendable_to_O(MeetLO) (PlusLOX));assumption.-rapplyooextendable_plus.Defined.EndLexMeet.

--- Miscellaneous\Misc.html ---
MiscLibrary MiscMiscellaneous materialIf you have a lemma or group of lemmas that you can’t find a better home for, put them here.  However, big “Miscellaneous” files are sub-optimal to work with, so some caveats:do try to find a better home for things if possible!if there were any specific difficulties in placing your lemmas (eg dependency issues), please document that.generally, be extra-careful keeping this file well-organised and documented.any time you see a chance to move lemmas from this file to a better home, do so without hesitation!RequireImportHoTT.Types.Local OpenScopepath_scope.Currently there is nothing here.

--- Miscellaneous\Modality.html ---
ModalityLibrary ModalityRequireImportHoTT.BasicsHoTT.Types.RequireImportHFiberExtensionsFactorizationLimits.Pullback.RequireExportReflectiveSubuniverse.(*Exportbecause many of the lemmas and facts about reflective subuniverses are equally important for modalities. *)Local OpenScopepath_scope.ModalitiesDependent eliminatorsA dependent version of the reflection universal property.  For later use we generalize it to refer to different subuniverses in the reflection and the elimination target.ClassReflectsD@{i} (O'O:Subuniverse@{i}) (T:Type@{i})`{PreReflects@{i}O'T} :={extendable_to_OO:forall(Q:O_reflectorO'T->Type@{i}) {Q_inO:forallx,InO(Qx)},ooExtendableAlong(toO'T)Q}.In particular, from this we get a dependent eliminator.DefinitionOO_ind{O':Subuniverse} (O:Subuniverse){A:Type} `{ReflectsDO'OA}(B:O_reflectorO'A->Type) {B_inO:foralloa,InO(Boa)}(f:foralla,B(toO'Aa)) (oa:O_reflectorO'A):Boa:= (fst(extendable_to_OOB1%nat)f).1oa.DefinitionOO_ind_beta{O'O:Subuniverse} {A:Type} `{ReflectsDO'OA}(B:O_reflectorO'A->Type) {B_inO:foralloa,InO(Boa)}(f:foralla,B(toO'Aa)) (a:A):OO_indOBf(toO'Aa) =fa:= (fst(extendable_to_OOB1%nat)f).2a.Conversely, ifOis closed under path-types, a dependent eliminator suffices to prove the whole dependent universal property.DefinitionreflectsD_from_OO_ind@{i} {O'O:Subuniverse@{i}}{A:Type@{i}} `{PreReflectsO'A}(OO_ind':forall(B:O_reflectorO'A->Type@{i})(B_inO:foralloa,InO(Boa))(f:foralla,B(toO'Aa))oa,Boa)(OO_ind_beta':forall(B:O_reflectorO'A->Type@{i})(B_inO:foralloa,InO(Boa))(f:foralla,B(toO'Aa))a,OO_ind'BB_inOf(toO'Aa) =fa)(inO_paths':forall(B:Type@{i}) (B_inO:InOB)(zz':B),InO(z=z')):ReflectsDO'OA.Proof.constructor.introsQQ_inOn.revertQQ_inO.simple_inductionnnIHn;introsQQ_inO.1:exacttt.split.-introsg.exists(OO_ind'Q_g).rapplyOO_ind_beta'.-introshk.rapplyIHn.Defined.In particular, this is the case ifOis a reflective subuniverse.DefinitionreflectsD_from_RSU{O':Subuniverse} {O:ReflectiveSubuniverse}{A:Type} `{PreReflectsO'A}(OO_ind':forall(B:O_reflectorO'A->Type)(B_inO:foralloa,InO(Boa))(f:foralla,B(toO'Aa))oa,Boa)(OO_ind_beta':forall(B:O_reflectorO'A->Type)(B_inO:foralloa,InO(Boa))(f:foralla,B(toO'Aa))a,OO_ind'BB_inOf(toO'Aa) =fa):ReflectsDO'OA:=reflectsD_from_OO_indOO_ind'OO_ind_beta'_.Of course, with funext this becomes an actual equivalence.Definitionisequiv_oD_to_O{fs:Funext} (O'O:Subuniverse) {A:Type} `{ReflectsDO'OA}(B:O_reflectorO'A->Type) `{foralla,InO(Ba)}:IsEquiv(fun(h:foralloa,Boa) =>hoDtoO'A).Proof.applyisequiv_ooextendable,extendable_to_OO;assumption.Defined.The strong orderNote the reversal of the order:O1<<O2means thatO2has dependent eliminators intoO1.ClassO_strong_leq(O1O2:ReflectiveSubuniverse):=reflectsD_strong_leq:forallA,ReflectsDO2O1A.Global Existing InstancereflectsD_strong_leq.Infix"<<" :=O_strong_leq:subuniverse_scope.OpenScopesubuniverse_scope.The strong order implies the weak order.Global InstanceO_leq_strong_leq{O1O2:ReflectiveSubuniverse} `{O1<<O2}:O1<=O2.Proof.introsAA_inO1.srapplyinO_to_O_retract.-exact(OO_indO1(fun_:O2A=>A)idmap).-introsa.srapplyOO_ind_beta.Defined.The strong order is not obviously transitive, but it composes with the weak order on one side at least.DefinitionO_strong_leq_trans_l(O1O2O3:ReflectiveSubuniverse)`{O1<=O2} `{O2<<O3}:O1<<O3.Proof.introsA;constructor;introsBB_inO.apply(extendable_to_OO(O:=O2)).introsx.srapplyinO_leq;applyB_inO.Defined.ModalitiesA modality is a reflective subuniverse with a dependent universal property with respect to itself.NotationIsModalityO:= (O<<O).However, it's not clear what the best bundled definition of modality is.  The obvious one{O:ReflectiveSubuniverse&IsModalityO}has the advantage that bundling a reflective subuniverse into a modality and then unbundling it is definitionally the identity; but it is redundant, since the dependent universal property implies the non-dependent one, and in practice most modalities are constructed directly with a dependent eliminator.  Thus, for now at least, we take the following definition, which in RSS is called a "uniquely eliminating modality".RecordModality@{i} :=Build_Modality'{modality_subuniv:Subuniverse@{i} ;modality_prereflects:forall(T:Type@{i}),PreReflectsmodality_subunivT;modality_reflectsD:forall(T:Type@{i}),ReflectsDmodality_subunivmodality_subunivT;}.Global Existing Instancemodality_reflectsD.We don't declaremodality_subunivas a coercion ormodality_prereflectsas a global instance, because we want them only to be found by way of the following "unbundling" coercion to reflective subuniverses.Definitionmodality_to_reflective_subuniverse(O:Modality@{i}):ReflectiveSubuniverse@{i}.Proof.refine(Build_ReflectiveSubuniverse(modality_subunivO) (modality_prereflectsO)_).introsT;constructor.introsQQ_inO.srapplyextendable_to_OO.Defined.Coercionmodality_to_reflective_subuniverse:Modality>->ReflectiveSubuniverse.Unfortunately, sometimesmodality_subunivpops up anyway.  The following hint helps typeclass inference look through it.#[export]HintExtern0 (In(modality_subuniv_)_) =>progresschangemodality_subunivwith(rsu_subunivomodality_to_reflective_subuniverse)in* :typeclass_instances.Modalities are precisely the reflective subuniverses that are<<themselves.Global Instanceismodality_modality(O:Modality) :IsModalityO.Proof.introsA;exact_.Defined.Definitionmodality_ismodality(O:ReflectiveSubuniverse) `{IsModalityO} :Modality.Proof.rapplyBuild_Modality'.Defined.When combined withisequiv_oD_to_O, this yields Theorem 7.7.7 in the book.Definitionisequiv_oD_to_O_modality`{Funext} (O:Modality) {A:Type}(B:OA->Type) `{foralla,InO(Ba)}:IsEquiv(fun(h:foralloa,Boa) =>hoDtoOA).Proof.srapply(isequiv_oD_to_OOO).Defined.Of course, modalities have dependent eliminators.DefinitionO_ind{O:Subuniverse} {A:Type} `{ReflectsDOOA}:= @OO_indOOA__.ArgumentsO_ind{OA__}B{B_inO}foa.DefinitionO_ind_beta{O:Subuniverse} {A:Type} `{ReflectsDOOA}:= @OO_ind_betaOOA__.ArgumentsO_ind_beta{OA__}B{B_inO}fa.Conversely, as remarked above, we can build a modality from a dependent eliminator as long as we assume the modal types are closed under paths.  This is probably the most common way to define a modality, and one might argue that this would be a better definition of the bundled typeModality.  For now we simply respect that by dignifying it with the unprimed constructor nameBuild_Modality.DefinitionBuild_Modality(In':Type->Type)(hprop_inO':Funext->forallT:Type,IsHProp(In'T))(inO_equiv_inO':forallTU:Type,In'T->forallf:T->U,IsEquivf->In'U)(O_reflector':Type->Type)(O_inO':forallT,In'(O_reflector'T))(to':forallT,T->O_reflector'T)(O_ind':forall(A:Type) (B:O_reflector'A->Type)(B_inO:foralloa,In'(Boa))(f:foralla,B(to'Aa))(z:O_reflector'A),Bz)(O_ind_beta':forall(A:Type) (B:O_reflector'A->Type)(B_inO:foralloa,In'(Boa))(f:foralla,B(to'Aa)) (a:A),O_ind'ABB_inOf(to'Aa) =fa)(inO_paths':forall(A:Type) (A_inO:In'A) (zz':A),In'(z=z')):Modality.Proof.pose(O:=Build_SubuniverseIn'hprop_inO'inO_equiv_inO').simplerefine(Build_Modality'O__);introsT.-exact(Build_PreReflectsOT(O_reflector'T) (O_inO'T) (to'T)).-srapplyreflectsD_from_OO_ind.+rapplyO_ind'.+rapplyO_ind_beta'.+rapplyinO_paths'.Defined.A tactic that extendsstrip_reflectionsto modalities. It handles non-dependent elimination for reflective subuniverses and dependent elimination for modalities.strip_truncationsdoes the same for truncations, but introduces fewer universe variables, so tends to work better when removing truncations.Ltacstrip_modalities:=Search for hypotheses of typeOXfor someOsuch that the goal isO-local.progressrepeatmatchgoalwith| [T:_|-_]=>revert_opaqueT;Handle the non-dependent and dependent cases.  The last case requires thatObe a modality.refine(@O_rec_______) ||refine(@O_indpaths_________) ||refine(@O_ind_______);Ensure that we didn't generate more than one subgoal, i.e. that the goal was appropriately local.[];introTend.Dependent sumsA dependent elimination of a reflective subuniverseO'intoOimplies that the sum of a family ofO-modal types over anO'-modal type isO'-modal.  More specifically, for a particular such sum it suffices for theO'-reflection of that sum to dependently eliminate intoO.Global InstanceinO_sigma_reflectsD{O':ReflectiveSubuniverse} {O:Subuniverse}{A:Type} (B:A->Type) `{!ReflectsDO'O(sigB)}`{InO'A} `{foralla,InO(Ba)}:InO'{x:A&Bx}.Proof.pose(h:=funx=> @O_recO'({x:A&Bx})A___pr1x).assert(p:= (funz=>O_rec_betapr1z) :ho(toO'_) ==pr1).pose(g:=funz=> (transportB((pz)^)z.2)).simplin*.pose(f:=OO_indO(funx:O'(sigB) =>B(hx))g).pose(q:=OO_ind_beta(funx:O'(sigB) =>B(hx))g).applyinO_to_O_retractwith(mu:=funw=> (hw;fw)).intros[x1x2].simplerefine(path_sigmaB____);simpl.-applyp.-refine(ap_(q(x1;x2)) @_).unfoldg;simpl.exact(transport_pVB__).Defined.Specialized to a modality, this yields the implication (ii) => (i) from Theorem 7.7.4 of the book, and also Corollary 7.7.8, part 2.Global InstanceinO_sigma(O:Modality){A:Type} (B:A->Type) `{InOA} `{foralla,InO(Ba)}:InO{x:A&Bx}:=_.This implies that the composite of modal maps is modal.Global InstancemapinO_compose{O:Modality} {ABC:Type} (f:A->B) (g:B->C)`{MapInO__f} `{MapInO__g}:MapInO(gof).Proof.introsc.refine(inO_equiv_inO'_(hfiber_composefgc)^-1).Defined.It also implies Corollary 7.3.10 from the book, generalized to modalities.  (Theorem 7.3.9 is true for any reflective subuniverse; we called itequiv_O_sigma_O.)Corollaryequiv_sigma_inO_O{O:Modality} {A:Type} `{InOA} (P:A->Type): {x:A&O(Px)} <~>O{x:A&Px}.Proof.transitivity(O{x:A&O(Px)}).-rapplyequiv_to_O.-applyequiv_O_sigma_O.Defined.Conversely, if the sum of a particular family ofO-modal types over anO'-reflection is inO', then that family admits a dependent eliminator.Definitionextension_from_inO_sigma{O':Subuniverse} (O:Subuniverse){A:Type} `{ReflectsO'A} (B:O_reflectorO'A->Type){inO_sigma:InO'{z:O_reflectorO'A&Bz}}(g:forallx,B(toO'Ax)):ExtensionAlong(toO'A)Bg.Proof.set(Z:=sigB)in*.pose(g':= (funa:A=> (toO'Aa;ga)) :A->Z).pose(f':=O_rec(O:=O')g').pose(eqf:= (O_rec_betag')  :f'otoO'A==g').pose(eqid:=O_indpaths(pr1of')idmap(funx=>ap@{ki}pr1(eqfx))).exists(funz=>transportB(eqidz) ((f'z).2)).introsa.unfoldeqid.refine(_@pr2_path(O_rec_betag'a)).refine(ap(funp=>transportBp(O_recg'(toO'Aa)).2)_).srapplyO_indpaths_beta.Defined.And even a full equivalence of spaces of sections.  This is stated in CORS Proposition 2.8 (but our version avoids funext by usingooExtendableAlong, as usual).Definitionooextendable_from_inO_sigma{O':ReflectiveSubuniverse} (O:Subuniverse){A:Type} (B:O_reflectorO'A->Type){inO_sigma:InO'{z:O_reflectorO'A&Bz}}:ooExtendableAlong(toO'A)B.Proof.introsn;generalizedependentA.inductionnas[|nIHn];intros; [exacttt|cbn].refine(extension_from_inO_sigmaOB,_).introshk;nrapplyIHn.set(Z:=sigB)in*.pose(W:=sig(funa=>Ba*Ba)).nrefine(inO_equiv_inO'(Pullback(A:=W) (funa:O_reflectorO'A=> (a;(ha,ka)))(funz:Z=> (z.1;(z.2,z.2))))_).{refine(inO_pullbackO'__).exact(inO_equiv_inO'_(equiv_sigprod_pullbackBB)^-1). }unfoldPullback.The rest is just extracting paths from sigma- and product types and contracting a couple of based path spaces.applyequiv_functor_sigma_id;introsz;cbn.refine(_oEequiv_functor_sigma_id_).2:intros;symmetry;applyequiv_path_sigma.refine(_oEequiv_functor_sigma_id(funz=>equiv_functor_sigma_id(funp=>_))).2:symmetry;applyequiv_path_prod.cbn.make_equiv_contr_basedpaths.Defined.Thus, if this holds for all sigma-types, we get the dependent universal property.  Making this anInstancecauses typeclass search to spin.  Note the slightly different hypotheses, which mean that we can't just use the previous result: here we need only assume that theO'-reflection ofAexists rather than thatO'is fully reflective, at the cost of assuming thatOis fully reflective (although actually, closed under path-spaces would suffice).DefinitionreflectsD_from_inO_sigma{O':Subuniverse} (O:ReflectiveSubuniverse){A:Type} `{ReflectsO'A}(inO_sigma:forall(B:O_reflectorO'A->Type),(foralloa,InO(Boa)) ->InO'{z:O_reflectorO'A&Bz}):ReflectsDO'OA.Proof.constructor;introsBB_inO.introsn;generalizedependentA.inductionnas[|nIHn];intros; [exacttt|cbn].refine(extension_from_inO_sigmaOB,_).introshk;rapplyIHn.Defined.In particular, we get the converse implication (i) => (ii) from Theorem 7.7.4 of the book: a reflective subuniverse closed under sigmas is a modality.Definitionmodality_from_inO_sigma(O:ReflectiveSubuniverse)(H:forall(A:Type) (B:A->Type){A_inO:InOA} `{foralla,InO(Ba)},(InO{x:A&Bx})):Modality.Proof.refine(Build_Modality'O__).intros;srapplyreflectsD_from_inO_sigma.Defined.Connectedness of the unitsDependent reflection can also be characterized by connectedness of the unit maps.Global Instanceconn_map_to_O_reflectsD{O':Subuniverse} (O:ReflectiveSubuniverse){A:Type} `{ReflectsDO'OA}:IsConnMapO(toO'A).Proof.applyconn_map_from_extension_elim.introsPP_inOf.exact(fst(extendable_to_OO(O:=O)P1%nat)f).Defined.DefinitionreflectsD_from_conn_map_to_O{O':Subuniverse} (O:ReflectiveSubuniverse){A:Type} `{PreReflectsO'A} `{IsConnMapO__(toO'A)}:ReflectsDO'OA.Proof.constructor;rapplyooextendable_conn_map_inO.Defined.In particular, ifO1<<O2then everyO2-unit isO1-connected.Global Instanceconn_map_to_O_strong_leq{O1O2:ReflectiveSubuniverse} `{O1<<O2} (A:Type):IsConnMapO1(toO2A):=_.Thus, ifOis a modality, then everyO-unit isO-connected.  This is Corollary 7.5.8 in the book.Global Instanceconn_map_to_O{O:Modality} (A:Type):IsConnMapO(toOA):=_.WhenO1<<O2,O_functorO2preservesO1-connected maps.Propositionconn_map_O_functor_strong_leq{O1O2:ReflectiveSubuniverse} (leq:O1<<O2){XY:Type} (f:X->Y) `{IsConnMapO1__f}:IsConnMapO1(O_functorO2f).Proof.rapply(cancelR_conn_map_(toO2_)).nrapplyconn_map_homotopic.1:symmetry;applyto_O_natural.rapplyconn_map_compose.Defined.Easy modalitiesThe book uses yet a different definition of modality, which requires an induction principle only into families of the formfunoa=>O(Boa), and similarly only that path-spaces of typesOAare "modal" in the sense that the unit is an equivalence.  As shown in section 1 of RSS, this is equivalent, roughly since every modal typeA(in this sense) is equivalent toOA.Our definitions are more convenient in formalized applications because in some examples (such asTruncand closed modalities), there is a naturally occurringO_indinto all modal types that is not judgmentally equal to the one that can be constructed by passing throughOand back again.  Thus, when we apply general theorems about modalities to a particular modality such asTrunc, the proofs will reduce definitionally to "the way we would have proved them directly" if we didn't know about general modalities.On the other hand, in other examples (such as~~and open modalities) it is easier to construct the latter weaker induction principle.  Thus, we now show how to get from that to our definition of modality.SectionEasyModalities.Universei.Context(O_reflector:Type@{i} ->Type@{i})(to:forall(T:Type@{i}),T->O_reflectorT)(O_indO:forall(A:Type@{i})(B:O_reflectorA->Type@{i})(f:foralla,O_reflector(B(toAa)))(z:O_reflectorA),O_reflector(Bz))(O_indO_beta:forall(A:Type@{i})(B:O_reflectorA->Type@{i})(f:foralla,O_reflector(B(toAa))) (a:A),O_indOABf(toAa) =fa)(inO_pathsO:forall(A:Type@{i}) (zz':O_reflectorA),IsEquiv(to(z=z'))).Local DefinitionIn_easy:Type@{i} ->Type@{i}:=funA=>IsEquiv(toA).Local DefinitionO_ind_easy(A:Type) (B:O_reflectorA->Type)(B_inO:foralloa,In_easy(Boa)): (foralla,B(toAa)) ->foralloa,Boa.Proof.simpl;introsfoa.pose(H:=B_inOoa);unfoldIn_easyinH.apply((to(Boa))^-1).applyO_indO.introsa;applyto,f.Defined.Local DefinitionO_ind_easy_beta(A:Type) (B:O_reflectorA->Type)(B_inO:foralloa,In_easy(Boa))(f:foralla:A,B(toAa)) (a:A):O_ind_easyABB_inOf(toAa) =fa.Proof.unfoldO_ind_easy.applymoveR_equiv_V.apply@O_indO_betawith(f:=funx=>to_(fx)).Qed.Local DefinitionO_inO_easy(A:Type) :In_easy(O_reflectorA).Proof.refine(isequiv_adjointify(to(O_reflectorA))(O_indO(O_reflectorA) (fun_=>A)idmap)__).-introsx;patternx;applyO_ind_easy.+introsoa;applyinO_pathsO.+introsa;applyap.exact(O_indO_beta(O_reflectorA) (fun_=>A)idmapa).-introsa.exact(O_indO_beta(O_reflectorA) (fun_=>A)idmapa).Defined.It seems to be surprisingly hard to show repleteness (without univalence).  We basically have to manually develop enough functoriality ofOand naturality oftoO.Local DefinitioninO_equiv_inO_easy(AB:Type)(A_inO:In_easyA) (f:A->B) (feq:IsEquivf):In_easyB.Proof.simplerefine(isequiv_commsq(toA) (toB)f(O_ind_easyA(fun_=>O_reflectorB)_(funa=>toB(fa)))_).-intros;applyO_inO_easy.-introsa;refine(O_ind_easy_betaA(fun_=>O_reflectorB)__a).-applyA_inO.-simplerefine(isequiv_adjointify_(O_ind_easyB(fun_=>O_reflectorA)_(funb=>toA(f^-1b)))__);introsx.+applyO_inO_easy.+patternx;refine(O_ind_easyB___x);intros.*applyinO_pathsO.*simpl;abstract(repeatrewriteO_ind_easy_beta;applyap,eisretr).+patternx;refine(O_ind_easyA___x);intros.*applyinO_pathsO.*simpl;abstract(repeatrewriteO_ind_easy_beta;applyap,eissect).Defined.Local DefinitioninO_paths_easy(A:Type) (A_inO:In_easyA) (aa':A):In_easy(a=a').Proof.simplerefine(inO_equiv_inO_easy(toAa=toAa')__(@ap__(toA)aa')^-1_).-applyinO_pathsO.-refine(@isequiv_ap___A_inO__).-applyisequiv_inverse.Defined.Definitioneasy_modality:Modality:=Build_ModalityIn_easy_inO_equiv_inO_easyO_reflectorO_inO_easytoO_ind_easyO_ind_easy_betainO_paths_easy.EndEasyModalities.The modal factorization systemSectionModalFact.Context`{fs:Funext} (O:Modality).Lemma 7.6.4Definitionimage{AB:Type} (f:A->B):Factorization(@IsConnMapO) (@MapInO)f.Proof.posemapinO_pr1.Slightly speeds up next line.refine(Build_Factorization{b:B&O(hfiberfb)}(funa=> (fa;toO_(a;1)))pr1(funa=> 1)__).poseconn_map_functor_sigma.Slightly speeds up next line.exact(conn_map_composeO(equiv_fibration_replacementf)(functor_sigmaidmap(funb=>toO(hfiberfb)))).Defined.Global Instanceconn_map_factor1_image{AB:Type} (f:A->B):IsConnMapO(factor1(imagef)):=inclass1(imagef).Global InstanceinO_map_factor1_image{AB:Type} (f:A->B):MapInO(factor2(imagef)):=inclass2(imagef).This is the composite of the three displayed equivalences at the beginning of the proof of Lemma 7.6.5.  Note that it involves only a single factorization off.LemmaO_hfiber_O_fact{AB:Type} {f:A->B}(fact:Factorization(@IsConnMapO) (@MapInO)f) (b:B):O(hfiber(factor2factofactor1fact)b)<~>hfiber(factor2fact)b.Proof.refine(_oE(equiv_O_functorO(hfiber_compose(factor1fact) (factor2fact)b))).nrefine(equiv_sigma_contr(funw=>O(hfiber(factor1fact)w.1))oE_).-introsw;exact(inclass1factw.1).-nrefine((equiv_sigma_inO_O(funw=>hfiber(factor1fact)w.1))^-1)%equiv.exact(inclass2factb).Defined.This is the corresponding first three of the displayed "mapsto"s in proof of Lemma 7.6.5, and also the last three in reverse order, generalized to an arbitrary pathp.  Note that it is much harder to prove than in the book, because we are working in the extra generality of a modality whereO_ind_betais only propositional.LemmaO_hfiber_O_fact_inverse_beta{AB:Type} {f:A->B}(fact:Factorization(@IsConnMapO) (@MapInO)f)(a:A) (b:B) (p:factor2fact(factor1facta) =b): (O_hfiber_O_factfactb)^-1(factor1facta;p) =toO_(a;p).Proof.set(g:=factor1fact);set(h:=factor2fact).applymoveR_equiv_V.unfoldO_hfiber_O_fact.ev_equiv.applymoveL_equiv_M.transitivity(exist(fun(w:hfiberhb) =>O(hfibergw.1))(ga;p) (toO(hfiberg(ga)) (a; 1))).-applymoveR_equiv_V;reflexivity.-applymoveL_equiv_V.transitivity(toO_(exist(fun(w:hfiberhb) => (hfibergw.1))(ga;p) (a; 1))).+cbn;repeatrewriteO_rec_beta;reflexivity.+destructp;symmetry;applyto_O_natural.Qed.SectionTwoFactorizations.Context{AB:Type} (f:A->B)(factfact':Factorization(@IsConnMapO) (@MapInO)f).LetH:=funx=>fact_factorsfactx@ (fact_factorsfact'x)^.Lemma 7.6.5, part 1.Definitionequiv_O_factor_hfibers(b:B):hfiber(factor2fact)b<~>hfiber(factor2fact')b.Proof.refine(O_hfiber_O_factfact'boE_).refine(_oE(O_hfiber_O_factfactb)^-1).applyequiv_O_functor.applyequiv_hfiber_homotopic.exactH.Defined.Lemma 7.6.5, part 2.Definitionequiv_O_factor_hfibers_beta(a:A):equiv_O_factor_hfibers(factor2fact(factor1facta))(factor1facta; 1)= (factor1fact'a; (Ha)^).Proof.unfoldequiv_O_factor_hfibers.ev_equiv.applymoveR_equiv_M.do2rewriteO_hfiber_O_fact_inverse_beta.unfoldequiv_fun,equiv_O_functor.transitivity(toO_(equiv_hfiber_homotopic(factor2factofactor1fact)(factor2fact'ofactor1fact')H(factor2fact(factor1facta)) (a;1))).-refine(to_O_naturalO__).-applyap.simpl.applyap;autowithpath_hints.Qed.EndTwoFactorizations.Theorem 7.6.6.  Recall that a lot of hard work was done inFactorization.path_factorization.DefinitionO_factsys:FactorizationSystem.Proof.refine(Build_FactorizationSystem(@IsConnMapO)___(@MapInO)___(@image)_).introsABffactfact'.simplerefine(Build_PathFactorizationfactfact'____).-refine(_oEequiv_fibration_replacement(factor2fact)).refine((equiv_fibration_replacement(factor2fact'))^-1oE_).applyequiv_functor_sigma_id;introsb;simpl.applyequiv_O_factor_hfibers.-introsa;exact(pr1_path(equiv_O_factor_hfibers_betaffactfact'a)).-introsx.exact((equiv_O_factor_hfibersffactfact'(factor2factx) (x; 1)).2 ^).-introsa.applymoveR_pM.refine((inv_V_)^ @_@inv_V_);applyinverse2.refine(_@pr2_path(equiv_O_factor_hfibers_betaffactfact'a)).refine(_@ (transport_paths_Fl__)^).exact(inv_pp__@ (1 @@inv_V_)).Defined.EndModalFact.

--- Miscellaneous\Module.html ---
ModuleLibrary ModuleRequireImportWildCat.RequireImportSpaces.Nat.Core.(* Some of the material in abstract_algebra and canonical names could be selectively exported to the user, as is done in Groups/Group.v. *)RequireImportClasses.interfaces.canonical_names.RequireImportAlgebra.Groups.KernelAlgebra.Groups.ImageAlgebra.Groups.QuotientGroup.RequireImportAlgebra.AbGroups.AbelianGroupAlgebra.AbGroups.Biproduct.RequireImportRings.Ring.Declare Scopemodule_scope.Local OpenScopemodule_scope.Modules over a ring.Left ModulesAn abelian groupMis a leftR-module when equipped with the following data:ClassIsLeftModule(R:Ring) (M:AbGroup) := {A functionlact(left-action) that takes an elementr:Rand an elementm:Mand returns an elementlactrm:M, which we also denoter*Lm.lact:R->M->M;Actions distribute on the left over addition in the abelian group. That isr*L(m+n)=r*Lm+r*Ln.lact_left_dist::LeftHeteroDistributelact(+) (+);Actions distribute on the right over addition in the ring. That is(r+s)*Lm=r*Lm+s*Lm.lact_right_dist::RightHeteroDistributelact(+) (+);Actions are associative. That is(r*s)*Lm=r*L(s*Lm).lact_assoc::HeteroAssociativelactlactlact(.*.);Actions preserve the multiplicative identity. That is1*Lm=m.lact_unit::LeftIdentitylact1;}.Infix"*L" :=lact:module_scope.A left R-module is an abelian group equipped with a left R-module structure.RecordLeftModule(R:Ring) := {lm_carrier:>AbGroup;lm_lact::IsLeftModuleRlm_carrier;}.SectionLeftModuleAxioms.Context{R:Ring} {M:LeftModuleR} (rs:R) (mn:M).Here we state the module axioms in a readable form for direct use.Definitionlm_dist_l:r*L(m+n) =r*Lm+r*Ln:=lact_left_distrmn.Definitionlm_dist_r: (r+s) *Lm=r*Lm+s*Lm:=lact_right_distrsm.Definitionlm_assoc:r*L(s*Lm) = (r*s) *Lm:=lact_assocrsm.Definitionlm_unit: 1 *Lm=m:=lact_unitm.EndLeftModuleAxioms.Facts about left modulesSectionLeftModuleFacts.Context{R:Ring} {M:LeftModuleR} (r:R) (m:M).Here are some quick facts that hold in modules.The left action of zero is zero.Definitionlm_zero_l: 0 *Lm= 0.Proof.apply(grp_cancelL1(z:=lact0m)).lhs_Vnrapplylm_dist_r.f_ap.applyrng_plus_zero_r.Defined.The left action on zero is zero.Definitionlm_zero_r:r*L(0 :M) = 0.Proof.apply(grp_cancelL1(z:=lactr0)).lhs_Vnrapplylm_dist_l.f_ap.applygrp_unit_l.Defined.The left action of-1is the additive inverse.Definitionlm_minus_one: -1 *Lm= -m.Proof.applygrp_moveL_1V.lhsnrapply(ap(_+) (lm_unitm)^).lhs_Vnrapplylm_dist_r.rhs_Vnrapplylm_zero_l.f_ap.applygrp_inv_l.Defined.The left action ofron the additive inverse ofmis the additive inverse of the left action ofronm.Definitionlm_neg:r*L-m= - (r*Lm).Proof.applygrp_moveL_1V.lhs_Vnrapplylm_dist_l.rhs_Vnrapplylm_zero_r.f_ap.applygrp_inv_l.Defined.EndLeftModuleFacts.Every ringRis a leftR-module over itself.Global Instanceisleftmodule_ring(R:Ring) :IsLeftModuleRR.Proof.rapplyBuild_IsLeftModule.Defined.Right ModulesAn abelian groupMis a rightR-module when it is a leftR^op-module.ClassIsRightModule(R:Ring) (M:AbGroup):=isleftmodule_op_isrightmodule::IsLeftModule(rng_opR)M.ract(right-action) that takes an elementm:Mand an elementr:Rand returns an elementractmr:Mwhich we also denotem*Rr.Definitionract{R:Ring} {M:AbGroup} `{!IsRightModuleRM}:M->R->M:=funmr=>lact(R:=rng_opR)rm.Infix"*R" :=ract.A right module is a left module over the opposite ring.DefinitionRightModule(R:Ring) :=LeftModule(rng_opR).Right modules are right modules.Global Instancerm_ract{R:Ring} {M:RightModuleR} :IsRightModuleRM:=lm_lact(rng_opR)M.SectionRightModuleAxioms.Context{R:Ring} {M:RightModuleR} (mn:M) (rs:R).Here we state the module axioms in a readable form for direct use.Definitionrm_dist_r: (m+n) *Rr=m*Rr+n*Rr:=lm_dist_l(R:=rng_opR)rmn.Definitionrm_dist_l:m*R(r+s) =m*Rr+m*Rs:=lm_dist_r(R:=rng_opR)rsm.Definitionrm_assoc: (m*Rr) *Rs=m*R(r*s):=lm_assoc(R:=rng_opR)srm.Definitionrm_unit:m*R1 =m:=lm_unit(R:=rng_opR)m.EndRightModuleAxioms.Facts about right modulesSectionRightModuleFacts.Context{R:Ring} {M:RightModuleR} (m:M) (r:R).The right action on zero is zero.Definitionrm_zero_l: (0 :M) *Rr= 0:=lm_zero_r(R:=rng_opR)r.The right adtion of zero is zero.Definitionrm_zero_r:m*R0 = 0:=lm_zero_l(R:=rng_opR)m.The right action of-1is the additive inverse.Definitionrm_minus_one:m*R-1 = -m:=lm_minus_one(R:=rng_opR)m.The right action ofron the additive inverse ofmis the additive inverse of the right action ofronm.Definitionrm_neg: -m*Rr= - (m*Rr):=lm_neg(R:=rng_opR)rm.EndRightModuleFacts.Every ringRis a rightR-module over itself.Global Instanceisrightmodule_ring(R:Ring) :IsRightModuleRR:=isleftmodule_ring(rng_opR).SubmodulesA subgroup of a left R-module is a left submodule if it is closed under the action of R.ClassIsLeftSubmodule{R:Ring} {M:LeftModuleR} (N:M->Type) := {ils_issubgroup::IsSubgroupN;is_left_submodule:forallrm,Nm->N(r*Lm);}.A subgroup of a right R-module is a right submodule if it is a left submodule over the opposite ring.ClassIsRightSubmodule{R:Ring} {M:RightModuleR} (N:M->Type):=isleftsubmodule_op_isrightsubmodule::IsLeftSubmodule(R:=rng_opR)N.A left submodule is a subgroup of the abelian group closed under the left action of R.RecordLeftSubmodule{R:Ring} (M:LeftModuleR) := {lsm_carrier:>M->Type;lsm_submodule::IsLeftSubmodulelsm_carrier;}.A right submodule is a subgroup of the abelian group closed under the right action of R.DefinitionRightSubmodule{R:Ring} (M:RightModuleR):=LeftSubmodule(R:=rng_opR)M.Definitionsubgroup_leftsubmodule{R:Ring} {M:LeftModuleR}:LeftSubmoduleM->SubgroupM:=funN=>Build_SubgroupMN_.Coercionsubgroup_leftsubmodule:LeftSubmodule>->Subgroup.Definitionsubgroup_rightsubmodule{R:Ring} {M:RightModuleR}:RightSubmoduleM->SubgroupM:=idmap.Coercionsubgroup_rightsubmodule:RightSubmodule>->Subgroup.Left submodules inherit the left R-module structure of their parent.Global Instanceisleftmodule_leftsubmodule{R:Ring}{M:LeftModuleR} (N:LeftSubmoduleM):IsLeftModuleRN.Proof.snrapplyBuild_IsLeftModule.-introsr[nn_in_N].exists(r*Ln).byapplylsm_submodule.-introsr[n] [m];applypath_sigma_hprop.applylact_left_dist.-introsrs[n];applypath_sigma_hprop.applylact_right_dist.-introsrs[n];applypath_sigma_hprop.applylact_assoc.-intros[n];applypath_sigma_hprop.applylact_unit.Defined.Right submodules inherit the right R-module structure of their parent.Global Instanceisrightmodule_rightsubmodule{R:Ring}{M:RightModuleR} (N:RightSubmoduleM):IsRightModuleRN:=isleftmodule_leftsubmodule(R:=rng_opR)N.Any left submodule of a left R-module is a left R-module.Definitionleftmodule_leftsubmodule{R:Ring}{M:LeftModuleR} (N:LeftSubmoduleM):LeftModuleR:=Build_LeftModuleRN_.Coercionleftmodule_leftsubmodule:LeftSubmodule>->LeftModule.Any right submodule of a right R-module is a right R-module.Definitionrightmodule_rightsubmodule{R:Ring}{M:RightModuleR} (N:RightSubmoduleM):RightModuleR:=N.Coercionrightmodule_rightsubmodule:RightSubmodule>->RightModule.The submodule criterion. This is a convenient way to build submodules.DefinitionBuild_IsLeftSubmodule'{R:Ring} {M:LeftModuleR}(H:M->Type) `{forallx,IsHProp(Hx)}(z:Hzero)(c:forallrnm,Hn->Hm->H(n+r*Lm)):IsLeftSubmoduleH.Proof.snrapplyBuild_IsLeftSubmodule.-snrapplyBuild_IsSubgroup'.+exact_.+exactz.+introsxyhxhy.change(sg_op?x?y)with(x+y).poseproof(p:=c(-1)xyhxhy).rewritelm_minus_oneinp.exactp.-introsrmhm.rewrite<- (grp_unit_l).byapplyc.Defined.DefinitionBuild_IsRightSubmodule'{R:Ring} {M:RightModuleR}(H:M->Type) `{forallx,IsHProp(Hx)}(z:Hzero)(c:forallrnm,Hn->Hm->H(n+ractmr)):IsRightSubmoduleH:=Build_IsLeftSubmodule'(R:=rng_opR)Hzc.DefinitionBuild_LeftSubmodule'{R:Ring} {M:LeftModuleR}(H:M->Type) `{forallx,IsHProp(Hx)}(z:Hzero)(c:forallrnm,Hn->Hm->H(n+r*Lm)):LeftSubmoduleM.Proof.pose(p:=Build_IsLeftSubmodule'Hzc).snrapplyBuild_LeftSubmodule.1:snrapply(Build_Subgroup_H).2:exactp.rapplyils_issubgroup.Defined.DefinitionBuild_RightSubmodule{R:Ring} {M:RightModuleR}(H:M->Type) `{forallx,IsHProp(Hx)}(z:Hzero)(c:forallrnm,Hn->Hm->H(n+m*Rr)):RightSubmoduleM:=Build_LeftSubmodule'(R:=rng_opR)Hzc.R-module homomorphismsA left module homomorphism is a group homomorphism that commutes with the left action of R.RecordLeftModuleHomomorphism{R:Ring} (MN:LeftModuleR) := {lm_homo_map:>GroupHomomorphismMN;lm_homo_lact:forallrm,lm_homo_map(r*Lm) =r*Llm_homo_mapm;}.DefinitionRightModuleHomomorphism{R:Ring} (MN:RightModuleR):=LeftModuleHomomorphism(R:=rng_opR)MN.Definitionrm_homo_map{R:Ring} {MN:RightModuleR}:RightModuleHomomorphismMN->GroupHomomorphismMN:=lm_homo_map(R:=rng_opR)MN.Coercionrm_homo_map:RightModuleHomomorphism>->GroupHomomorphism.Definitionrm_homo_ract{R:Ring} {MN:RightModuleR}(f:RightModuleHomomorphismMN):forallmr,f(ractmr) =ract(fm)r:=funmr=>lm_homo_lact(R:=rng_opR)MNfrm.Definitionlm_homo_id{R:Ring} (M:LeftModuleR) :LeftModuleHomomorphismMM.Proof.snrapplyBuild_LeftModuleHomomorphism.-exactgrp_homo_id.-reflexivity.Defined.Definitionrm_homo_id{R:Ring} (M:RightModuleR) :RightModuleHomomorphismMM:=lm_homo_id(R:=rng_opR)M.Definitionlm_homo_compose{R:Ring} {MNL:LeftModuleR}:LeftModuleHomomorphismNL->LeftModuleHomomorphismMN->LeftModuleHomomorphismML.Proof.introsfg.snrapplyBuild_LeftModuleHomomorphism.-exact(grp_homo_composefg).-introsrm.rhs_Vnrapplylm_homo_lact.apply(apf).applylm_homo_lact.Defined.Definitionrm_homo_compose{R:Ring} {MNL:RightModuleR}:RightModuleHomomorphismNL->RightModuleHomomorphismMN->RightModuleHomomorphismML:=lm_homo_compose(R:=rng_opR).Smart constructor for building left module homomorphisms from a map.DefinitionBuild_LeftModuleHomomorphism'{R:Ring} {MN:LeftModuleR}(f:M->N) (p:forallrxy,f(r*Lx+y) =r*Lfx+fy):LeftModuleHomomorphismMN.Proof.snrapplyBuild_LeftModuleHomomorphism.-snrapplyBuild_GroupHomomorphism.+exactf.+introsxy.rewrite<- (lm_unit(fx)).set(lact1 (fx)).rewrite<- (lm_unitx).applyp.-introsrm.simpl.rewrite<- (grp_unit_r(lactrm)).rewritep.rhs_Vnrapplygrp_unit_r.applygrp_cancelL.specialize(p1 0 0).rewrite2lm_unitinp.apply(grp_cancelL1(z:=f0)).lhs_Vnrapplyp.applyap.applygrp_unit_l.Defined.DefinitionBuild_RightModuleHomomorphism'{R:Ring} {MN:RightModuleR}(f:M->N) (p:forallrxy,f(x*Rr+y) =fx*Rr+fy):RightModuleHomomorphismMN:=Build_LeftModuleHomomorphism'(R:=rng_opR)fp.RecordLeftModuleIsomorphism{R:Ring} (MN:LeftModuleR) := {lm_iso_map:>LeftModuleHomomorphismMN;isequiv_lm_iso_map::IsEquivlm_iso_map;}.DefinitionRightModuleIsomorphism{R:Ring} (MN:RightModuleR):=LeftModuleIsomorphism(R:=rng_opR)MN.DefinitionBuild_LeftModuleIsomorphism'{R:Ring} (MN:LeftModuleR)(f:GroupIsomorphismMN) (p:forallrx,f(r*Lx) =r*Lfx):LeftModuleIsomorphismMN.Proof.snrapplyBuild_LeftModuleIsomorphism.-snrapplyBuild_LeftModuleHomomorphism.+exactf.+exactp.-exact_.Defined.DefinitionBuild_RightModuleIsomorphism'{R:Ring} (MN:RightModuleR)(f:GroupIsomorphismMN) (p:forallrx,f(ractxr) =ract(fx)r):RightModuleIsomorphismMN:=Build_LeftModuleIsomorphism'(R:=rng_opR)MNfp.Definitionlm_iso_inverse{R:Ring} {MN:LeftModuleR}:LeftModuleIsomorphismMN->LeftModuleIsomorphismNM.Proof.introsf.snrapplyBuild_LeftModuleIsomorphism.-snrapplyBuild_LeftModuleHomomorphism'.+exactf^-1.+introsrmn.applymoveR_equiv_V.rhsnrapplygrp_homo_op.symmetry.f_ap.2:applyeisretr.lhsnrapplylm_homo_lact.applyap.applyeisretr.-exact_.Defined.Definitionrm_iso_inverse{R:Ring} {MN:RightModuleR}:RightModuleIsomorphismMN->RightModuleIsomorphismNM:=lm_iso_inverse(R:=rng_opR).Category of left and right R-modulesTODO: define as a displayed category over RingCategory of left R-modulesGlobal Instanceisgraph_leftmodule{R:Ring} :IsGraph(LeftModuleR):=Build_IsGraph_LeftModuleHomomorphism.Global Instanceis01cat_leftmodule{R:Ring} :Is01Cat(LeftModuleR):=Build_Is01Cat__lm_homo_id(@lm_homo_composeR).Global Instanceis2graph_leftmodule{R:Ring} :Is2Graph(LeftModuleR):=funMN=>isgraph_induced(@lm_homo_mapRMN).Global Instanceis1cat_leftmodule{R:Ring} :Is1Cat(LeftModuleR).Proof.snrapplyBuild_Is1Cat'.-introsMN;rapplyis01cat_induced.-introsMN;rapplyis0gpd_induced.-introsMNLh.snrapplyBuild_Is0Functor.introsfgpm.exact(aph(pm)).-introsMNLf.snrapplyBuild_Is0Functor.introsghpm.exact(p(fm)).-simpl;reflexivity.-simpl;reflexivity.-simpl;reflexivity.Defined.Global Instancehasequivs_leftmodule{R:Ring} :HasEquivs(LeftModuleR).Proof.snrapplyBuild_HasEquivs.-exactLeftModuleIsomorphism.-introsMN;exactIsEquiv.-introsMNf;exactf.-simpl;exact_.-applyBuild_LeftModuleIsomorphism.-reflexivity.-introsMN;applylm_iso_inverse.-introsMNf;applyeissect.-introsMNf;applyeisretr.-introsMNfgfggf.exact(isequiv_adjointifyfgfggf).Defined.Category of right R-modulesGlobal Instanceisgraph_rightmodule{R:Ring} :IsGraph(RightModuleR):=isgraph_leftmodule(R:=rng_opR).Global Instanceis01cat_rightmodule{R:Ring} :Is01Cat(RightModuleR):=is01cat_leftmodule(R:=rng_opR).Global Instanceis2graph_rightmodule{R:Ring} :Is2Graph(RightModuleR):=is2graph_leftmodule(R:=rng_opR).Global Instanceis1cat_rightmodule{R:Ring} :Is1Cat(RightModuleR):=is1cat_leftmodule(R:=rng_opR).Global Instancehasequivs_rightmodule{R:Ring} :HasEquivs(RightModuleR):=hasequivs_leftmodule(R:=rng_opR).Kernel of module homomorphismGlobal Instanceisleftsubmodule_grp_kernel{R:Ring}{MN:LeftModuleR} (f:M$->N):IsLeftSubmodule(grp_kernelf).Proof.srapplyBuild_IsLeftSubmodule.introsrmn.lhsnrapplylm_homo_lact.rhs_Vnrapply(lm_zero_rr).applyap.exactn.Defined.Global Instanceisrightsubmodule_grp_kernel{R:Ring}{MN:RightModuleR} (f:M$->N):IsRightSubmodule(grp_kernelf):=isleftsubmodule_grp_kernel(R:=rng_opR)f.Definitionlm_kernel{R:Ring} {MN:LeftModuleR} (f:M$->N):LeftSubmoduleM:=Build_LeftSubmodule__(grp_kernelf)_.Definitionrm_kernel{R:Ring} {MN:RightModuleR} (f:M$->N):RightSubmoduleM:=lm_kernel(R:=rng_opR)f.Image of module homomorphismGlobal Instanceisleftsubmodule_grp_image{R:Ring}{MN:LeftModuleR} (f:M$->N):IsLeftSubmodule(grp_imagef).Proof.srapplyBuild_IsLeftSubmodule.introsrm;applyTrunc_functor;intros[np].exists(r*Ln).lhsnrapplylm_homo_lact.applyap.exactp.Defined.Global Instanceisrightsubmodule_grp_image{R:Ring}{MN:RightModuleR} (f:M$->N):IsRightSubmodule(grp_imagef):=isleftsubmodule_grp_image(R:=rng_opR)f.Definitionlm_image{R:Ring} {MN:LeftModuleR} (f:M$->N):LeftSubmoduleN:=Build_LeftSubmodule__(grp_imagef)_.Definitionrm_image{R:Ring} {MN:RightModuleR} (f:M$->N):RightSubmoduleN:=lm_image(R:=rng_opR)f.Quotient ModulesThe quotient abelian group of a module and a submodule has a natural ring action.Global Instanceisleftmodule_quotientabgroup{R:Ring}(M:LeftModuleR) (N:LeftSubmoduleM):IsLeftModuleR(QuotientAbGroupMN).Proof.snrapplyBuild_IsLeftModule.-introsr.snrapplyquotient_abgroup_rec.+refine(grp_quotient_map$o_).snrapplyBuild_GroupHomomorphism.*exact(lactr).*introsxy.applylm_dist_l.+introsnNn;simpl.applyqglue.applyissubgroup_in_inv_op.2:applyissubgroup_in_unit.byapplyis_left_submodule.-introsrmn;revertm.snrapplyQuotient_ind_hprop; [exact_|introsm;revertn].snrapplyQuotient_ind_hprop; [exact_|introsn;simpl].rapplyap.applylm_dist_l.-introsrs.snrapplyQuotient_ind_hprop; [exact_|introsm;simpl].rapplyap.applylm_dist_r.-introsrs.snrapplyQuotient_ind_hprop; [exact_|introsm;simpl].rapplyap.applylm_assoc.-snrapplyQuotient_ind_hprop; [exact_|introsm;simpl].rapplyap.applylm_unit.Defined.Global Instanceisrightmodule_quotientabgroup{R:Ring}(M:RightModuleR) (N:RightSubmoduleM):IsRightModuleR(QuotientAbGroupMN):=isleftmodule_quotientabgroup(R:=rng_opR)MN.We can therefore form the quotient module of a module by its submodule.DefinitionQuotientLeftModule{R:Ring} (M:LeftModuleR) (N:LeftSubmoduleM):LeftModuleR:=Build_LeftModuleR(QuotientAbGroupMN)_.DefinitionQuotientRightModule{R:Ring} (M:RightModuleR) (N:RightSubmoduleM):RightModuleR:=QuotientLeftModule(R:=rng_opR)MN.Infix"/" :=QuotientLeftModule:module_scope.TODO: Notation for right module quotient?First Isomorphism TheoremLocal OpenScopemodule_scope.Local OpenScopewc_iso_scope.Definitionlm_first_iso`{Funext} {R:Ring} {MN:LeftModuleR} (f:M$->N):M/lm_kernelf≅lm_imagef.Proof.snrapplyBuild_LeftModuleIsomorphism'.1:rapplyabgroup_first_iso.introsr.srapplyQuotient_ind_hprop;introsm.applypath_sigma_hprop;simpl.applylm_homo_lact.Defined.Definitionrm_first_iso`{Funext} {R:Ring} {MN:RightModuleR} (f:M$->N):QuotientRightModuleM(rm_kernelf) ≅rm_imagef:=lm_first_iso(R:=rng_opR)f.Direct productsTODO: generalise to biproducts  The direct product of modulesDefinitionlm_prod{R:Ring} :LeftModuleR->LeftModuleR->LeftModuleR.Proof.introsMN.snrapply(Build_LeftModuleR(ab_biprodMN)).snrapplyBuild_IsLeftModule.-introsr.applyfunctor_prod;exact(lactr).-introsrmn.applypath_prod;applylm_dist_l.-introsrmn.applypath_prod;applylm_dist_r.-introsrsm.applypath_prod;applylm_assoc.-introsr.applypath_prod;applylm_unit.Defined.Definitionrm_prod{R:Ring} :RightModuleR->RightModuleR->RightModuleR:=lm_prod(R:=rng_opR).Definitionlm_prod_fst{R:Ring} {MN:LeftModuleR} :lm_prodMN$->M.Proof.snrapplyBuild_LeftModuleHomomorphism.-applygrp_prod_pr1.-reflexivity.Defined.Definitionrm_prod_fst{R:Ring} {MN:RightModuleR} :rm_prodMN$->M:=lm_prod_fst(R:=rng_opR).Definitionlm_prod_snd{R:Ring} {MN:LeftModuleR} :lm_prodMN$->N.Proof.snrapplyBuild_LeftModuleHomomorphism.-applygrp_prod_pr2.-reflexivity.Defined.Definitionrm_prod_snd{R:Ring} {MN:RightModuleR} :rm_prodMN$->N:=lm_prod_snd(R:=rng_opR).Definitionlm_prod_corec{R:Ring} {MN:LeftModuleR} (L:LeftModuleR)(f:L$->M) (g:L$->N):L$->lm_prodMN.Proof.snrapplyBuild_LeftModuleHomomorphism.-apply(grp_prod_corecfg).-introsrl.applypath_prod;applylm_homo_lact.Defined.Definitionrm_prod_corec{R:Ring} {MN:RightModuleR} (R':RightModuleR)(f:R'$->M) (g:R'$->N):R'$->rm_prodMN:=lm_prod_corec(R:=rng_opR)R'fg.Global Instancehasbinaryproducts_leftmodule{R:Ring}:HasBinaryProducts(LeftModuleR).Proof.introsMN.snrapplyBuild_BinaryProduct.-exact(lm_prodMN).-exactlm_prod_fst.-exactlm_prod_snd.-exactlm_prod_corec.-cbn;reflexivity.-cbn;reflexivity.-introsLfgpqa.exact(path_prod'(pa) (qa)).Defined.Global Instancehasbinaryproducts_rightmodule{R:Ring}:HasBinaryProducts(RightModuleR):=hasbinaryproducts_leftmodule(R:=rng_opR).Finite SumsLeft scalar multplication distributes over finite sums of left module elements.Definitionlm_sum_dist_l{R:Ring} (M:LeftModuleR) (n:nat)(f:forallk, (k<n)%nat->M) (r:R):r*Lab_sumnf=ab_sumn(funkHk=>r*LfkHk).Proof.inductionnas[|nIHn].1:applylm_zero_r.lhsnrapplylm_dist_l;simpl;f_ap.Defined.Right scalar multiplication distributes over finite sums of right module elements.Definitionrm_sum_dist_r{R:Ring} (M:RightModuleR) (n:nat)(f:forallk, (k<n)%nat->M) (r:R):ab_sumnf*Rr=ab_sumn(funkHk=>fkHk*Rr):=lm_sum_dist_l(R:=rng_opR)Mnfr.Left module elements distribute over finite sums of scalars.Definitionlm_sum_dist_r{R:Ring} (M:LeftModuleR) (n:nat)(f:forallk, (k<n)%nat->R) (x:M):ab_sumnf*Lx=ab_sumn(funkHk=>fkHk*Lx).Proof.inductionnas[|nIHn].1:applylm_zero_l.lhsnrapplylm_dist_r;simpl;f_ap.Defined.Right module elements distribute over finite sums of scalar.Definitionrm_sum_dist_l{R:Ring} (M:RightModuleR) (n:nat)(f:forallk, (k<n)%nat->R) (x:M):x*Rab_sumnf=ab_sumn(funkHk=>x*RfkHk):=lm_sum_dist_r(R:=rng_opR)Mnfx.

--- Miscellaneous\Moduli.html ---
ModuliLibrary ModuliRequireImportBasicsTypesHSpace.CoreHSpace.CoherentHSpace.PointwisePointedHomotopy.EvaluationFibration.Local OpenScopepointed_scope.Local OpenScopemc_mult_scope.The moduli type of coherent H-space structuresWhenAis a left-invertible coherent H-space, we construct an equivalence between the ("moduli") type of coherent H-space structures onAand the typeA->*(A->**A). By the smash-hom adjunction for pointed types, due to Floris van Doorn in HoTT, the latter is also equivalent to the typeSmashAA->*A.This equivalence generalizes a formula of Arkowitz--Curjel and Copeland for spaces, and appears as Theorem 2.27 in https://arxiv.org/abs/2301.02636v1Paths between H-space structuresPaths between H-space structures correspond to homotopies between the underlying binary operations which respect the identities. This is the type of the latter.Definitionpath_ishspace_type{X:pType} (munu:IsHSpaceX) :Type.Proof.destructmuas[mumu_lidmu_rid],nuas[nunu_lidnu_rid].refine{h:forallx0x1,mux0x1=nux0x1&prod(forallx:X,_) (forallx:X,_) }.-exact(mu_lidx=hptx@nu_lidx).-exact(mu_ridx=hxpt@nu_ridx).Defined.Transport of left and right identities of binary operations along paths between the underlying functions.Local Definitiontransport_binop_lr_id`{Funext} {X:Type} {x:X}{munu:X->X->X} `{mu_lid:forally,muxy=y}`{mu_rid:forally,muyx=y} (p:mu=nu):transport(funm:X->X->X=>(forally,mxy=y) * (forally,myx=y))p(mu_lid,mu_rid)= (funy=> (ap100p__)^ @mu_lidy,funy=> (ap100p__)^ @mu_ridy).Proof.inductionp;cbn.applypath_prod';funexty.all:exact(concat_1p_)^.Defined.Characterization of paths between H-space structures.Definitionequiv_path_ishspace`{Funext} {X:pType} (munu:IsHSpaceX):path_ishspace_typemunu<~> (mu=nu).Proof.destructmuas[mumu_lidmu_rid],nuas[nunu_lidnu_rid];unfoldpath_ishspace_type.nrefine(equiv_ap_inv'issig_ishspace__oE_).nrefine(equiv_path_sigma___oE_);cbn.apply(equiv_functor_sigma'(equiv_path_arrow2__));introh;cbn.nrefine(equiv_concat_l__oE_).1:applytransport_binop_lr_id.nrefine(equiv_path_prod__oE_);cbn.applyequiv_functor_prod';nrefine(equiv_path_forall__oE_);applyequiv_functor_forall_id;introx.all:nrefine(equiv_moveR_Vp___oE_);applyequiv_concat_r;applywhiskerR;symmetry;applyap100_path_arrow2.Defined.Sections of evaluation fibrationsWe first show that coherent H-space structures on a pointed type correspond to pointed sections of the evaluation fibrationevA.Definitionequiv_iscohhspace_psect`{Funext} (A:pType):IsCohHSpaceA<~>pSect(evA).Proof.refine(issig_psect(evA)oE_^-1%equivoE(issig_iscohhspaceA)^-1%equiv).unfoldSgOp,LeftIdentity,RightIdentity.applyequiv_functor_sigma_id;intromu.apply(equiv_functor_sigma'(equiv_apD10___));introH1;cbn.applyequiv_functor_sigma_id;introH2;cbn.refine(equiv_path_inverse__oE_).applyequiv_concat_r.applyconcat_p1.Defined.Our next goal is to see that whenAis a left-invertible H-space, then the fibrationevAis trivial.This lemma says that the familyfuna=>A->*[A,a]is trivial.Lemmaequiv_pmap_hspace`{Funext} {A:pType}(a:A) `{IsHSpaceA} `{!IsEquiv(hspace_opa)}: (A->*A) <~> (A->* [A,a]).Proof.nrapplypequiv_pequiv_postcompose.rapplypequiv_hspace_left_op.Defined.The lemma gives us an equivalence on the total spaces (domains) ofevAandpsnd(the projection out of the displayed product).Propositionequiv_map_pmap_hspace`{Funext} {A:pType}`{IsHSpaceA} `{foralla:A,IsEquiv(a*.)}: (A->*A) *A<~> (A->A).Proof.transitivity{a:A& {f:A->A&fpt=a}}.2:exact(equiv_sigma_contr_oE(equiv_sigma_symm_)^-1%equiv).refine(_oE(equiv_sigma_prod0__)^-1%equivoEequiv_prod_symm__).applyequiv_functor_sigma_id;introa.exact((issig_pmapA[A,a])^-1%equivoEequiv_pmap_hspacea).Defined.The above is a pointed equivalence.Propositionpequiv_map_pmap_hspace`{Funext} {A:pType}`{IsHSpaceA} `{foralla:A,IsEquiv(a*.)}: [(A->*A) *A, (pmap_idmap,pt)] <~>*selfmapsA.Proof.snrapplyBuild_pEquiv'.1:exactequiv_map_pmap_hspace.cbn.applypath_forall,hspace_left_identity.Defined.WhenAis coherent, the pointed equivalencepequiv_map_pmap_hspaceis a pointed equivalence overA, i.e., a trivialization ofevA.Propositionhspace_ev_trivialization`{Funext} {A:pType}`{IsCoherentA} `{foralla:A,IsEquiv(a*.)}:evAo*pequiv_map_pmap_hspace==*psnd(A:=[A->*A,pmap_idmap]).Proof.snrapplyBuild_pHomotopy.{intros[fx];cbn.exact(ap_(dpoint_eqf) @hspace_right_identity_). }cbn.refine(concat_1p_@_^).refine(concat_p1_@concat_p1_@_).refine(ap10_path_forall____@_).applyiscoherent.Defined.The equivalenceIsCohHSpaceA<~>(A->*(A->**A))Theoremequiv_cohhspace_ppmap`{Funext} {A:pType}`{IsCoherentA} `{foralla:A,IsEquiv(hspace_opa)}:IsCohHSpaceA<~> (A->* (A->**A)).Proof.refine(_oEequiv_iscohhspace_psectA).refine(_oE(equiv_pequiv_pslice_psect___hspace_ev_trivialization^*)^-1%equiv).refine(_oEequiv_psect_psnd(A:=[A->*A,pmap_idmap])).refine(pequiv_pequiv_postcompose_);symmetry.rapplypequiv_hspace_left_op.Defined.Here is a third characterization of the type of coherent H-space structures. It simply involves shuffling the data around and usingFunext.Definitionequiv_iscohhspace_ptd_action`{Funext} (A:pType):IsCohHSpaceA<~> {act:foralla,A->* [A,a] &actpt==*pmap_idmap}.Proof.refine(_oE(issig_iscohhspaceA)^-1).unfoldIsPointed.(* First we shuffle the data on the LHS to be of this form: *)equiv_via{s: {act:A-> (A->A) &foralla,actapt=a} & {h:s.1pt==idmap&hpt=s.2pt}}.1:make_equiv.(* Then we break up->*and==*on the RHS using issig lemmas, and handle a trailing@1. *)snrapplyequiv_functor_sigma'.-refine(equiv_functor_forall_id(funa=>issig_pmapA[A,a])oE_).unfoldIsPointed.nrapplyequiv_sig_coind.-cbn.intros[actp];simpl.refine(issig_phomotopy__oE_);cbn.applyequiv_functor_sigma_id;introq.applyequiv_concat_r;symmetry;applyconcat_p1.Defined.It follows that any homogeneous type is a coherent H-space.  This generalizesishspace_homogeneous.Definitioniscohhspace_homogeneous`{Funext} {A:pType} `{IsHomogeneousA}:IsCohHSpaceA.Proof.apply(equiv_iscohhspace_ptd_actionA)^-1.existshomogeneous_pt_id.applyhomogeneous_pt_id_beta.Defined.One can also show directly that the H-space structure defined byishspace_homogeneousis coherent. This also avoidsFunext.Definitioniscoherent_homogeneous{A:pType} `{IsHomogeneousA}: @IsCoherentA(ishspace_homogeneous).Proof.unfoldIsCoherent;cbn.set(f:=ishomogeneouspt).change(eisretrfpt=apf(moveR_equiv_Vptpt(point_eqf)^) @point_eqf).rewrite<- (point_eqf).unfoldmoveR_equiv_V;simpl.rhsnrapplyconcat_p1.lhsnrapply(eisadjf).applyap.symmetry;applyconcat_1p.Defined.Using either of these, we can "upgrade" any left-invertible H-space structure to a coherent one. This one has a prime because the direct proof below computes better.Definitioniscohhspace_hspace'(A:pType)`{IsHSpaceA} `{foralla,IsEquiv(a*.)}:IsCohHSpaceA.Proof.snrapplyBuild_IsCohHSpace.{nrapplyishspace_homogeneous.applyishomogeneous_hspace. }applyiscoherent_homogeneous.Defined.The new multiplication is homotopic to the original one.  Relative to this, we expect that one of the identity laws also agrees, but that the other does not.Definitioniscohhspace_hspace'_beta_mu`{Funext} (A:pType){m:IsHSpaceA} `{foralla,IsEquiv(a*.)}: @hspace_opA(@ishspace_cohhspaceA(iscohhspace_hspace'A)) = @hspace_opAm.Proof.cbn.(**,sg_opandhspace_opall denote the original operation. *)funextab.refine(ap(a*.)_).applymoveR_equiv_V.symmetry;applyleft_identity.Defined.Here's a different proof that directly upgrades an H-space structure, leaving the multiplication and left-identity definitionally the same, but changing the right-identity.Definitioniscohhspace_hspace(A:pType){m:IsHSpaceA} `{foralla,IsEquiv(a*.)}:IsCohHSpaceA.Proof.snrapplyBuild_IsCohHSpace.1:snrapplyBuild_IsHSpace.-exact(@hspace_opAm).-exact(@hspace_left_identityAm).-introa.lhsnrapply(ap(a*.) (hspace_right_identitypt))^.lhsnrapply(ap(a*.) (hspace_left_identitypt)).exact(hspace_right_identitya).-unfoldIsCoherent;cbn.applymoveL_Vp.lhsnrapplyconcat_A1p.refine(_@@ 1).apply(cancelR__(hspace_left_identitypt)).symmetry;applyconcat_A1p.Defined.

--- Miscellaneous\monad.html ---
monadLibrary monadRequireExportHoTT.Classes.interfaces.canonical_names.ClassMonad(M:Type->Type) {Mret:ReturnM} {Mbind:BindM} :={monad_ret_bind:forall{AB}a(f:A->MB),bind(reta)f=fa;monad_bind_ret:forall{A} (x:MA),bindxret=x;monad_bind_assoc:forall{ABC}x(f:A->MB) (g:B->MC),bind(bindxf)g=bindx(funa=>bind(fa)g) }.

--- Miscellaneous\Monoid.html ---
MonoidLibrary MonoidRequireImportBasics.OvertureBasics.TacticsBasics.EquivalencesBasics.Trunc.RequireImportTypes.SigmaTypes.ForallTypes.Prod.RequireImportWildCat.CoreWildCat.InducedWildCat.EquivWildCat.UniverseWildCat.Products.RequireImport(notations)Classes.interfaces.canonical_names.RequireExport(hints)Classes.interfaces.abstract_algebra.RequireExport(hints)Classes.interfaces.canonical_names.RequireExportClasses.interfaces.canonical_names(SgOp,sg_op,One,one,MonUnit,mon_unit,LeftIdentity,left_identity,RightIdentity,right_identity,Negate,negate,Associative,simple_associativity,associativity,LeftInverse,left_inverse,RightInverse,right_inverse,Commutative,commutativity).Exportcanonical_names.BinOpNotations.RequireExportClasses.interfaces.abstract_algebra(IsSemiGroup(..),sg_set,sg_ass,IsMonoid(..),monoid_left_id,monoid_right_id,monoid_semigroup,IsMonoidPreserving(..),monmor_unitmor,monmor_sgmor,IsSemiGroupPreserving,preserves_sg_op,IsUnitPreserving,preserves_mon_unit).LocalSetPolymorphicInductiveCumulativity.LocalSetUniverseMinimizationToSet.Local OpenScopemc_mult_scope.MonoidsDefinitionRecordMonoid:= {monoid_type:>Type;monoid_sgop::SgOpmonoid_type;monoid_unit::MonUnitmonoid_type;monoid_ismonoid::IsMonoidmonoid_type;}.Argumentsmonoid_sgop{_}.Argumentsmonoid_unit{_}.Argumentsmonoid_ismonoid{_}.Global Opaquemonoid_ismonoid.Definitionissig_monoid:_<~>Monoid:=ltac:(issig).SectionMonoidLaws.Context{M:Monoid} (xyz:M).Definitionmnd_assoc:=associativityxyz.Definitionmnd_unit_l:=left_identityx.Definitionmnd_unit_r:=right_identityx.EndMonoidLaws.Monoid homomorphismsRecordMonoidHomomorphism(MN:Monoid) := {mnd_homo_map:>monoid_typeM->monoid_typeN;ismonoidpreserving_mnd_homo::IsMonoidPreservingmnd_homo_map;}.Argumentsmnd_homo_map{MN}.ArgumentsBuild_MonoidHomomorphism{MN}__.Argumentsismonoidpreserving_mnd_homo{MN}f:rename.Definitionissig_MonoidHomomorphism(MN:Monoid):_<~>MonoidHomomorphismMN:=ltac:(issig).Basics properties of monoid homomorphismsDefinitionmnd_homo_op{MN:Monoid} (f:MonoidHomomorphismMN):forall(xy:M),f(x*y) =fx*fy:=monmor_sgmor.Definitionmnd_homo_unit{MN:Monoid} (f:MonoidHomomorphismMN):fmon_unit=mon_unit:=monmor_unitmor.Definitionequiv_path_monoidhomomorphism`{Funext} {MN:Monoid}{fg:MonoidHomomorphismMN}:f==g<~>f=g.Proof.refine((equiv_ap(issig_MonoidHomomorphismMN)^-1__)^-1oE_).refine(equiv_path_sigma_hprop__oE_).applyequiv_path_forall.Defined.Global Instanceishset_monoidhomomorphism`{Funext} {MN:Monoid}:IsHSet(MonoidHomomorphismMN).Proof.applyistrunc_S.introsfg;apply(istrunc_equiv_istrunc_equiv_path_monoidhomomorphism).Defined.Definitionmnd_homo_id{M:Monoid} :MonoidHomomorphismMM:=Build_MonoidHomomorphismidmap_.Definitionmnd_homo_compose{MNP:Monoid}:MonoidHomomorphismNP->MonoidHomomorphismMN->MonoidHomomorphismMP:=funfg=>Build_MonoidHomomorphism(fog)_.Monoid IsomorphismsRecordMonoidIsomorphism(MN:Monoid) := {mnd_iso_homo:>MonoidHomomorphismMN;isequiv_mnd_iso::IsEquivmnd_iso_homo;}.DefinitionBuild_MonoidIsomorphism'{MN:Monoid}(f:M<~>N) (h:IsMonoidPreservingf):MonoidHomomorphismMN.Proof.snrapplyBuild_MonoidIsomorphism.1:srapplyBuild_MonoidHomomorphism.exact_.Defined.Definitionissig_MonoidIsomorphism(MN:Monoid):_<~>MonoidIsomorphismMN:=ltac:(issig).Coercionequiv_mnd_iso{MN:Monoid}:MonoidIsomorphismMN->M<~>N:=funf=>Build_EquivMNf_.Definitionmnd_iso_id{M:Monoid} :MonoidIsomorphismMM:=Build_MonoidIsomorphism__mnd_homo_id_.Definitionmnd_iso_compose{MNP:Monoid}:MonoidIsomorphismNP->MonoidIsomorphismMN->MonoidIsomorphismMP:=fungf=>Build_MonoidIsomorphism__(mnd_homo_composegf)_.Definitionmnd_iso_inverse{MN:Monoid}:MonoidIsomorphismMN->MonoidIsomorphismNM:=funf=>Build_MonoidIsomorphism__(Build_MonoidHomomorphismf^-1_)_.Global Instancereflexive_monoidisomorphism:ReflexiveMonoidIsomorphism:=funM=>mnd_iso_id.Global Instancesymmetric_monoidisomorphism:SymmetricMonoidIsomorphism:=funMN=>mnd_iso_inverse.Global Instancetransitive_monoidisomorphism:TransitiveMonoidIsomorphism:=funMNPfg=>mnd_iso_composegf.The category of monoidsGlobal Instanceisgraph_monoid:IsGraphMonoid:=Build_IsGraphMonoidMonoidHomomorphism.Global Instanceis01cat_monoid:Is01CatMonoid:=Build_Is01CatMonoid_(@mnd_homo_id) (@mnd_homo_compose).Local Notationmnd_homo_map'MN:= (@mnd_homo_mapMN:_-> (monoid_typeM$->_)).Global Instanceis2graph_monoid:Is2GraphMonoid:=funMN=>isgraph_induced(mnd_homo_map'MN).Global Instanceisgraph_monoidhomomorphism{MN:Monoid} :IsGraph(M$->N):=isgraph_induced(mnd_homo_map'MN).Global Instanceis01cat_monoidhomomorphism{MN:Monoid} :Is01Cat(M$->N):=is01cat_induced(mnd_homo_map'MN).Global Instanceis0gpd_monoidhomomorphism{MN:Monoid} :Is0Gpd(M$->N):=is0gpd_induced(mnd_homo_map'MN).Global Instanceis0functor_postcomp_monoidhomomorphism{MNP:Monoid} (h:N$->P):Is0Functor(@cat_postcompMonoid__MNPh).Proof.applyBuild_Is0Functor.intros? ?pa;exact(aph(pa)).Defined.Global Instanceis0functor_precomp_monoidhomomorphism{MNP:Monoid} (h:M$->N):Is0Functor(@cat_precompMonoid__MNPh).Proof.applyBuild_Is0Functor.intros? ?p;exact(poh).Defined.Global Instanceis1cat_monoid:Is1CatMonoid.Proof.byrapplyBuild_Is1Cat.Defined.Global Instancehasequivs_monoid:HasEquivsMonoid.Proof.snrapplyBuild_HasEquivs.-exactMonoidIsomorphism.-exact(funMNf=>IsEquivf).-introsMNf;exactf.-cbn;exact_.-exactBuild_MonoidIsomorphism.-reflexivity.-introsMN;exactmnd_iso_inverse.-intros????;applyeissect.-intros????;applyeisretr.-introsMN;exactisequiv_adjointify.Defined.Global Instanceis0functor_monoid_type:Is0Functormonoid_type:=Build_Is0Functor____monoid_type(@mnd_homo_map).Global Instanceis1functor_monoid_type:Is1Functormonoid_type.Proof.byapplyBuild_Is1Functor.Defined.Direct product of monoidsDefinitionmnd_prod:Monoid->Monoid->Monoid.Proof.introsMN.snrapply(Build_Monoid(M*N)).3:repeatsplit.-intros[m1n1] [m2n2].exact(m1*m2,n1*n2).-exact(mon_unit,mon_unit).-exact_.-introsxyz;snrapplypath_prod;nrapplymnd_assoc.-introsx;snrapplypath_prod;nrapplymnd_unit_l.-introsx;snrapplypath_prod;nrapplymnd_unit_r.Defined.Definitionmnd_prod_pr1{MN:Monoid}:MonoidHomomorphism(mnd_prodMN)M.Proof.snrapplyBuild_MonoidHomomorphism.1:exactfst.split;hnf;reflexivity.Defined.Definitionmnd_prod_pr2{MN:Monoid}:MonoidHomomorphism(mnd_prodMN)N.Proof.snrapplyBuild_MonoidHomomorphism.1:exactsnd.split;hnf;reflexivity.Defined.Definitionmnd_prod_corec{MNP:Monoid}(f:MonoidHomomorphismPM)(g:MonoidHomomorphismPN):MonoidHomomorphismP(mnd_prodMN).Proof.snrapplyBuild_MonoidHomomorphism.2:split.-exact(funx=> (fx,gx)).-introsxy;snrapplypath_prod;nrapplymnd_homo_op.-snrapplypath_prod;nrapplymnd_homo_unit.Defined.Global Instancehasbinaryproducts_monoid:HasBinaryProductsMonoid.Proof.introsMN.snrapplyBuild_BinaryProduct.-exact(mnd_prodMN).-exactmnd_prod_pr1.-exactmnd_prod_pr2.-introsP;exactmnd_prod_corec.-introsPfg;exact(Id_).-introsPfg;exact(Id_).-introsPfgpqa;exact(path_prod'(pa) (qa)).Defined.

--- Miscellaneous\Monoidal.html ---
MonoidalLibrary MonoidalRequireImportBasics.OvertureBasics.TacticsTypes.Forall.RequireImportWildCat.CoreWildCat.BifunctorWildCat.ProdWildCat.Equiv.RequireImportWildCat.NatTransWildCat.Opposite.Monoidal CategoriesIn this file we define monoidal categories and symmetric monoidal categories.Typeclasses for common diagramsTODO: These should eventually be moved to a separate file in WildCat and used in other places. They can be thought of as a wildcat generalization of the classes in canonical_names.vAssociatorsClassAssociator{A:Type} `{HasEquivsA}(F:A->A->A) `{!Is0BifunctorF, !Is1BifunctorF}:=associator_uncurried:NatEquiv(fun'(a,b,c) =>Fa(Fbc)) (fun'(a,b,c) =>F(Fab)c).Argumentsassociator_uncurried{A_____F___}.Definitionassociator{A:Type} `{HasEquivsA} {F:A->A->A}`{!Is0BifunctorF, !Is1BifunctorF, !AssociatorF}:forallabc,Fa(Fbc) $<~>F(Fab)c:=funabc=>associator_uncurried(a,b,c).Coercionassociator:Associator>->Funclass.DefinitionBuild_Associator{A:Type} `{HasEquivsA} (F:A->A->A)`{!Is0BifunctorF, !Is1BifunctorF}(associator:forallabc,Fa(Fbc) $<~>F(Fab)c)(isnat_assoc:Is1Natural(fun'(a,b,c) =>Fa(Fbc))(fun'(a,b,c) =>F(Fab)c)(fun'(a,b,c) =>associatorabc)):AssociatorF.Proof.snrapplyBuild_NatEquiv.-intros[[ab]c].exact(associatorabc).-exactisnat_assoc.Defined.UnitorsClassLeftUnitor{A:Type} `{HasEquivsA}(F:A->A->A) `{!Is0BifunctorF, !Is1BifunctorF} (unit:A)A natural isomorphismleft_unitorwitnessing the left unit law ofF.:=left_unitor:NatEquiv(Funit)idmap.Coercionleft_unitor:LeftUnitor>->NatEquiv.Argumentsleft_unitor{A_____F__unit_}.ClassRightUnitor{A:Type} `{HasEquivsA}(F:A->A->A) `{!Is0BifunctorF, !Is1BifunctorF} (unit:A)A natural isomorphismright_unitorwitnessing the right unit law ofF.:=right_unitor:NatEquiv(flipFunit)idmap.Coercionright_unitor:RightUnitor>->NatEquiv.Argumentsright_unitor{A_____F__unit_}.Triangle and Pentagon identitiesClassTriangleIdentity{A:Type} `{HasEquivsA}(F:A->A->A) `{!Is0BifunctorF, !Is1BifunctorF, !AssociatorF}(unit:A) `{!LeftUnitorFunit, !RightUnitorFunit}The triangle identity for an associator and unitors.:=triangle_identityab:fmap01Fa(left_unitorb)$==fmap10F(right_unitora)b$o(associator(F:=F)aunitb).Coerciontriangle_identity:TriangleIdentity>->Funclass.Argumentstriangle_identity{A_____}F{___}unit{_}.ClassPentagonIdentity{A:Type} `{HasEquivsA}(F:A->A->A) `{!Is0BifunctorF, !Is1BifunctorF, !AssociatorF}The pentagon identity for an associator.:=pentagon_identityabcd:associator(Fab)cd$oassociatorab(Fcd)$==fmap10F(associatorabc)d$oassociatora(Fbc)d$ofmap01Fa(associatorbcd).Coercionpentagon_identity:PentagonIdentity>->Funclass.Argumentspentagon_identity{A_____}F{___}.BraidingClassBraiding{A:Type} `{Is1CatA}(F:A->A->A) `{!Is0BifunctorF, !Is1BifunctorF}:=braid_uncurried:NatTrans(uncurryF) (uncurry(flipF)).Argumentsbraid_uncurried{A____F___}.Definitionbraid{A:Type} `{Is1CatA} {F:A->A->A}`{!Is0BifunctorF, !Is1BifunctorF, !BraidingF}:forallab,Fab$->Fba:=funab=>braid_uncurried(a,b).Coercionbraid:Braiding>->Funclass.ClassSymmetricBraiding{A:Type} `{Is1CatA}(F:A->A->A) `{!Is0BifunctorF, !Is1BifunctorF} := {braiding_symmetricbraiding::BraidingF;braid_braid:forallab,braidab$obraidba$==Id(Fba);}.We could have used::>inbraiding_symmetricbraidinginstead however due to bug https://github.com/coq/coq/issues/18971 the coercion isn't registered, so we have to register it manually instead.Coercionbraiding_symmetricbraiding:SymmetricBraiding>->Braiding.Argumentsbraid_braid{A____F___}ab.Hexagon identityClassHexagonIdentity{A:Type} `{HasEquivsA}(F:A->A->A)`{!Is0BifunctorF, !Is1BifunctorF, !AssociatorF, !BraidingF}The hexagon identity for an associator and a braiding.:=hexagon_identityabc:fmap10F(braidba)c$oassociatorbac$ofmap01Fb(braidca)$==associatorabc$obraid(Fbc)a$oassociatorbca.Coercionhexagon_identity:HexagonIdentity>->Funclass.Argumentshexagon_identity{A_____}F{__}.Monoidal CategoriesA monoidal 1-category is a 1-category with equivalences together with the following:ClassIsMonoidal(A:Type) `{HasEquivsA}It has a binary operationcat_tensorcalled the tensor product.(cat_tensor:A->A->A)It has a unit objectcat_tensor_unitcalled the tensor unit.(cat_tensor_unit:A)These all satisfy the following properties::= {Acat_tensoris a 1-bifunctor.is0bifunctor_cat_tensor:Is0Bifunctorcat_tensor;is1bifunctor_cat_tensor:Is1Bifunctorcat_tensor;A natural isomorphismassociatorwitnessing the associativity of the tensor product.cat_tensor_associator::Associatorcat_tensor;A natural isomorphismleft_unitorwitnessing the left unit law.cat_tensor_left_unitor::LeftUnitorcat_tensorcat_tensor_unit;A natural isomorphismright_unitorwitnessing the right unit law.cat_tensor_right_unitor::RightUnitorcat_tensorcat_tensor_unit;The triangle identity.cat_tensor_triangle_identity::TriangleIdentitycat_tensorcat_tensor_unit;The pentagon identity.cat_tensor_pentagon_identity::PentagonIdentitycat_tensor;}.Existing Instanceis0bifunctor_cat_tensor| 10.Existing Instanceis1bifunctor_cat_tensor| 10.TODO: Braided monoidal categoriesSymmetric Monoidal CategoriesA symmetric monoidal 1-category is a 1-category with equivalences together with the following:ClassIsSymmetricMonoidal(A:Type) `{HasEquivsA}A binary operationcat_tensorcalled the tensor product.(cat_tensor:A->A->A)A unit objectcat_tensor_unitcalled the tensor unit.(cat_tensor_unit:A):= {A monoidal structure withcat_tensorandcat_tensor_unit.issymmetricmonoidal_ismonoidal::IsMonoidalAcat_tensorcat_tensor_unit;A natural transformationbraidwitnessing the symmetry of the tensor product such thatbraidis its own inverse.cat_symm_tensor_braiding::SymmetricBraidingcat_tensor;The hexagon identity.cat_symm_tensor_hexagon::HexagonIdentitycat_tensor;}.Theory aboutAssociatorSectionAssociator.Context{A:Type} `{HasEquivsA} {F:A->A->A}`{!Is0BifunctorF, !Is1BifunctorF,assoc: !AssociatorF}.Definitionassociator_nat{xx'yy'zz'}(f:x$->x') (g:y$->y') (h:z$->z'):associatorx'y'z'$ofmap11Ff(fmap11Fgh)$==fmap11F(fmap11Ffg)h$oassociatorxyz.Proof.destructassocas[assonat].exact(nat(x,y,z) (x',y',z') (f,g,h)).Defined.Definitionassociator_nat_l{xx':A} (f:x$->x') (yz:A):associatorx'yz$ofmap10Ff(Fyz)$==fmap10F(fmap10Ffy)z$oassociatorxyz.Proof.refine((_$@L_^$) $@_$@ (_$@R_)).2:rapply(associator_natf(Id_) (Id_)).-exact(fmap12__(fmap11_id___) $@fmap10_is_fmap11___).-exact(fmap21_(fmap10_is_fmap11___)_$@fmap10_is_fmap11___).Defined.Definitionassociator_nat_m(x:A) {yy':A} (g:y$->y') (z:A):associatorxy'z$ofmap01Fx(fmap10Fgz)$==fmap10F(fmap01Fxg)z$oassociatorxyz.Proof.refine((_$@L_^$) $@_$@ (_$@R_)).2:nrapply(associator_nat(Id_)g(Id_)).-exact(fmap12__(fmap10_is_fmap11___) $@fmap01_is_fmap11___).-exact(fmap21_(fmap01_is_fmap11___)_$@fmap10_is_fmap11___).Defined.Definitionassociator_nat_r(xy:A) {zz':A} (h:z$->z'):associatorxyz'$ofmap01Fx(fmap01Fyh)$==fmap01F(Fxy)h$oassociatorxyz.Proof.refine((_$@L_^$) $@_$@ (_$@R_)).2:nrapply(associator_nat(Id_) (Id_)h).-exact(fmap12__(fmap01_is_fmap11___) $@fmap01_is_fmap11___).-exact(fmap21_(fmap11_id___)_$@fmap01_is_fmap11F__).Defined.Global Instanceassociator_op:Associator(A:=A^op)F:=natequiv_inverse(natequiv_opassoc).EndAssociator.Definitionassociator_op'{A:Type} `{HasEquivsA} {F:A->A->A}`{!Is0BifunctorF, !Is1BifunctorF,assoc: !Associator(A:=A^op)F}:AssociatorF:=associator_op(A:=A^op) (assoc:=assoc).Theory aboutLeftUnitorandRightUnitorSectionLeftUnitor.Context{A:Type} `{HasEquivsA} {F:A->A->A} (unit:A)`{!Is0BifunctorF, !Is1BifunctorF, !LeftUnitorFunit, !RightUnitorFunit}.Global Instanceleft_unitor_op:LeftUnitor(A:=A^op)Funit:=natequiv_inverse(natequiv_opleft_unitor).Global Instanceright_unitor_op:RightUnitor(A:=A^op)Funit:=natequiv_inverse(natequiv_opright_unitor).EndLeftUnitor.Theory aboutBraidingGlobal Instancebraiding_op{A:Type} `{HasEquivsA} {F:A->A->A}`{!Is0BifunctorF, !Is1BifunctorF,braid: !BraidingF}:Braiding(A:=A^op)F:=nattrans_op(nattrans_flipbraid).Definitionbraiding_op'{A:Type} `{HasEquivsA} {F:A->A->A}`{!Is0BifunctorF, !Is1BifunctorF,braid: !Braiding(A:=A^op)F}:BraidingF:=braiding_op(A:=A^op) (braid:=braid).Theory aboutSymmetricBraidSectionSymmetricBraid.Context{A:Type} {F:A->A->A} `{SymmetricBraidingAF, !HasEquivsA}.braidis its own inverse and therefore an equivalence.Instancecatie_braidab:CatIsEquiv(braidab):=catie_adjointify(braidab) (braidba) (braid_braidab) (braid_braidba).braideis the bundled equivalence whose underlying map isbraid.Definitionbraideab:Fab$<~>Fba:=Build_CatEquiv(braidab).DefinitionmoveL_braidLabcf(g:c$->_):braidab$of$==g->f$==braidba$og.Proof.introsp.apply(cate_monic_equiv(braideab)).refine((cate_buildequiv_fun_$@R_) $@p$@_$@cat_assoc___).refine((cat_idl_)^$ $@ (_^$ $@R_)).refine((cate_buildequiv_fun_$@R_) $@_).applybraid_braid.Defined.DefinitionmoveL_braidRabcf(g:_$->c):f$obraidab$==g->f$==g$obraidba.Proof.introsp.apply(cate_epic_equiv(braideab)).refine(_$@ (cat_assoc___)^$).refine(_$@ (_$@L((_$@Lcate_buildequiv_fun_) $@_)^$)).2:applybraid_braid.refine((_$@L_) $@_$@ (cat_idr_)^$).1:applycate_buildequiv_fun.exactp.Defined.DefinitionmoveR_braidLabcf(g:c$->_):f$==braidba$og->braidab$of$==g.Proof.introsp;symmetry;applymoveL_braidL;symmetry;exactp.Defined.DefinitionmoveR_braidRabcf(g:_$->c):f$==g$obraidba->f$obraidab$==g.Proof.introsp;symmetry;applymoveL_braidR;symmetry;exactp.Defined.DefinitionmoveL_fmap01_braidLabcdf(g:d$->_):fmap01Fa(braidbc) $of$==g->f$==fmap01Fa(braidcb) $og.Proof.introsp.apply(cate_monic_equiv(emap01Fa(braidebc))).refine(_$@cat_assoc___).refine(_$@ (_$@R_)).2: {refine(_$@ (_^$ $@R_)).2:applycate_buildequiv_fun.refine((fmap_id__)^$ $@fmap2__$@fmap_comp___).refine((_$@R_) $@_)^$.1:applycate_buildequiv_fun.applybraid_braid. }refine((_$@R_) $@p$@ (cat_idl_)^$).refine(_$@fmap2__);applycate_buildequiv_fun.Defined.DefinitionmoveL_fmap01_braidRabcdf(g:_$->d):f$ofmap01Fa(braidbc) $==g->f$==g$ofmap01Fa(braidcb).Proof.introsp.apply(cate_epic_equiv(emap01Fa(braidebc))).refine(_$@ (cat_assoc___)^$).refine(_$@ (_$@L_)).2: {refine(_^$ $@ (_$@L_^$)).2:applycate_buildequiv_fun.refine((fmap_comp___)^$ $@fmap2__$@fmap_id__).refine((_$@L_) $@_).1:applycate_buildequiv_fun.applybraid_braid. }refine((_$@L_) $@p$@ (cat_idr_)^$).refine(_$@fmap2__);applycate_buildequiv_fun.Defined.DefinitionmoveR_fmap01_braidLabcdf(g:d$->_):f$==fmap01Fa(braidcb) $og->fmap01Fa(braidbc) $of$==g.Proof.introsp;symmetry;applymoveL_fmap01_braidL;symmetry;exactp.Defined.DefinitionmoveR_fmap01_braidRabcdf(g:_$->d):f$==g$ofmap01Fa(braidcb)->f$ofmap01Fa(braidbc) $==g.Proof.introsp;symmetry;applymoveL_fmap01_braidR;symmetry;exactp.Defined.DefinitionmoveL_fmap01_fmap01_braidLabcdef(g:e$->_):fmap01Fa(fmap01Fb(braidcd)) $of$==g->f$==fmap01Fa(fmap01Fb(braiddc)) $og.Proof.introsp.apply(cate_monic_equiv(emap01Fa(emap01Fb(braidecd)))).refine(_$@cat_assoc___).refine(_$@ (_$@R_)).2: {refine(_$@ (_^$ $@R_)).2:applycate_buildequiv_fun.refine((fmap_id__)^$ $@fmap2__$@fmap_comp___).refine(_$@ (_^$ $@R_)).2:applycate_buildequiv_fun.refine((fmap_id__)^$ $@fmap2__$@fmap_comp___).refine((_$@R_) $@_)^$.1:applycate_buildequiv_fun.applybraid_braid. }refine((_$@R_) $@p$@ (cat_idl_)^$).refine(cate_buildequiv_fun_$@fmap02___).refine(cate_buildequiv_fun_$@fmap02___).applycate_buildequiv_fun.Defined.DefinitionmoveL_fmap01_fmap01_braidRabcdef(g:_$->e):f$ofmap01Fa(fmap01Fb(braidcd)) $==g->f$==g$ofmap01Fa(fmap01Fb(braiddc)).Proof.introsp.apply(cate_epic_equiv(emap01Fa(emap01Fb(braidecd)))).refine(_$@ (cat_assoc___)^$).refine(_$@ (_$@L_)).2: {refine(_^$ $@ (_$@L_^$)).2:applycate_buildequiv_fun.refine((fmap_comp___)^$ $@fmap2__$@fmap_id__).refine((_$@L_) $@_).1:applycate_buildequiv_fun.refine((fmap_comp___)^$ $@fmap2__$@fmap_id__).refine((_$@L_) $@_).1:applycate_buildequiv_fun.applybraid_braid. }refine((_$@L_) $@p$@ (cat_idr_)^$).refine(cate_buildequiv_fun_$@fmap02___).refine(cate_buildequiv_fun_$@fmap02___).applycate_buildequiv_fun.Defined.DefinitionmoveR_fmap01_fmap01_braidLabcdef(g:e$->_):f$==fmap01Fa(fmap01Fb(braiddc)) $og->fmap01Fa(fmap01Fb(braidcd)) $of$==g.Proof.introsp;symmetry;applymoveL_fmap01_fmap01_braidL;symmetry;exactp.Defined.DefinitionmoveR_fmap01_fmap01_braidRabcdef(g:_$->e):f$==g$ofmap01Fa(fmap01Fb(braiddc))->f$ofmap01Fa(fmap01Fb(braidcd)) $==g.Proof.introsp;symmetry;applymoveL_fmap01_fmap01_braidR;symmetry;exactp.Defined.Definitionbraid_nat{abcd} (f:a$->c) (g:b$->d):braidcd$ofmap11Ffg$==fmap11Fgf$obraidab.Proof.exact(isnatbraid_uncurried(a:= (a,b)) (a':= (c,d)) (f,g)).Defined.Definitionbraid_nat_l{abc} (f:a$->b):braidbc$ofmap10Ffc$==fmap01Fcf$obraidac.Proof.refine((_$@L(fmap10_is_fmap11___)^$) $@_$@ (fmap01_is_fmap11___$@R_)).exact(isnatbraid_uncurried(a:= (a,c)) (a':= (b,c)) (f,Id_)).Defined.This is just the inverse of above.Definitionbraid_nat_r{abc} (g:b$->c):braidac$ofmap01Fag$==fmap10Fga$obraidab.Proof.refine((_$@L(fmap01_is_fmap11___)^$) $@_$@ (fmap10_is_fmap11___$@R_)).exact(isnatbraid_uncurried(a:= (a,b)) (a':= (a,c)) (Id_,g)).Defined.Global Instancesymmetricbraiding_op:SymmetricBraiding(A:=A^op)F.Proof.snrapplyBuild_SymmetricBraiding.-exact_.-introsab.rapplybraid_braid.Defined.EndSymmetricBraid.Definitionsymmetricbraiding_op'{A:Type} {F:A->A->A}`{HasEquivsA, !Is0BifunctorF, !Is1BifunctorF,H': !SymmetricBraiding(A:=A^op)F}:SymmetricBraidingF:=symmetricbraiding_op(A:=A^op) (F:=F).Opposite Monoidal CategoriesGlobal Instanceismonoidal_op{A:Type} (tensor:A->A->A) (unit:A)`{IsMonoidalAtensorunit}:IsMonoidalA^optensorunit.Proof.snrapplyBuild_IsMonoidal.1-5:exact_.-introsab;unfoldopina,b;simpl.refine(_^$ $@_$@ (_$@L_)).1,3:exact(emap_inv__$@cate_buildequiv_fun_).nrefine(cate_inv2_$@cate_inv_compose'__).refine(cate_buildequiv_fun_$@_$@ ((cate_buildequiv_fun_)^$ $@R_)$@ (cate_buildequiv_fun_)^$).rapplycat_tensor_triangle_identity.-introsabcd;unfoldopina,b,c,d;simpl.refine(_$@ ((_$@L_) $@@_)).2,3:exact(emap_inv__$@cate_buildequiv_fun_).refine((cate_inv_compose'__)^$ $@cate_inv2_$@cate_inv_compose'__$@ (_$@Lcate_inv_compose'__)).refine(cate_buildequiv_fun_$@_$@ ((cate_buildequiv_fun_)^$ $@R_)$@ (cate_buildequiv_fun_)^$).refine(_$@ (cate_buildequiv_fun_$@@ (cate_buildequiv_fun_$@R_))^$).rapplycat_tensor_pentagon_identity.Defined.Definitionismonoidal_op'{A:Type} (tensor:A->A->A) (unit:A)`{HasEquivsA} `{!IsMonoidalA^optensorunit}:IsMonoidalAtensorunit:=ismonoidal_op(A:=A^op)tensorunit.Global Instanceissymmetricmonoidal_op{A:Type} (tensor:A->A->A) (unit:A)`{IsSymmetricMonoidalAtensorunit}:IsSymmetricMonoidalA^optensorunit.Proof.snrapplyBuild_IsSymmetricMonoidal.-rapplyismonoidal_op.-rapplysymmetricbraiding_op.-introsabc;unfoldopina,b,c;simpl.snrefine(_$@ (_$@L(_$@R_))).2:exact((braide__)^-1$).2: {nrapplycate_moveR_V1.symmetry.nrefine((_$@R_) $@_).1:nrapplycate_buildequiv_fun.rapplybraid_braid. }snrefine((_$@R_) $@_).{refine(emap__)^-1$.rapplybraide. }{symmetry.refine(cate_inv_adjointify____$@fmap2__).nrapplycate_inv_adjointify. }snrefine((_$@L(_$@L_)) $@_).{refine(emap(fliptensorc)_)^-1$.rapplybraide. }{symmetry.refine(cate_inv_adjointify____$@fmap2__).nrapplycate_inv_adjointify. }refine((_$@L_)^$ $@_^$ $@cate_inv2_$@_$@ (_$@L_)).1,2,4,5:rapplycate_inv_compose'.refine(_$@ (_$@@_) $@_$@ (_$@R_)^$ $@_^$).1-3,5-6:rapplycate_buildequiv_fun.refine((fmap02___$@@ ((_$@fmap20___) $@R_)) $@cat_symm_tensor_hexagonabc$@ ((_$@L_^$) $@R_)).1-4:nrapplycate_buildequiv_fun.Defined.Definitionissymmetricmonoidal_op'{A:Type} (tensor:A->A->A) (unit:A)`{HasEquivsA} `{H': !IsSymmetricMonoidalA^optensorunit}:IsSymmetricMonoidalAtensorunit:=issymmetricmonoidal_op(A:=A^op)tensorunit.Further Coherence ConditionsIn MacLane's original axiomatisation of a monoidal category, 3 extra coherence conditions were given in addition to the pentagon and triangle identities. It was later shown by Kelly that these axioms are redundant and follow from the rest. We reproduce these arguments here.The left unitor of a tensor can be decomposed as an associator and a functorial action of the tensor on a left unitor.Definitionleft_unitor_associator{A} (tensor:A->A->A) (unit:A)`{IsMonoidalAtensorunit} (xy:A): (left_unitor(tensorxy) :_$->_)$==fmap10tensor(left_unitorx)y$oassociatorunitxy.Proof.refine((cate_moveR_eV___(isnat_natequivleft_unitor_))^$$@ ((_$@L_) $@R_) $@cate_moveR_eV___(isnat_natequivleft_unitor_)).refine(_$@ (fmap01_comp____)^$).refine(_$@ (cate_moveR_Ve___(associator_nat_m___)^$ $@R_)).nrefine(_$@cat_assoc_opp___).change(fmap(tensor?x) ?f)with(fmap01tensorxf).change(cate_fun'__(cat_tensor_left_unitor?x))with(cate_fun(cat_tensor_left_unitorx)).applycate_moveL_Ve.refine((_$@Ltriangle_identity______) $@_).nrefine(cat_assoc_opp___$@_$@cat_assoc_opp___).refine(_$@ ((fmap20_(triangle_identity______)_$@fmap10_comp____)^$ $@R_)).refine(_$@cat_assoc_opp___).refine(_$@ (_$@L(pentagon_identity______$@cat_assoc___))).refine((_$@R_) $@cat_assoc___).exact(associator_nat_l___).Defined.The right unitor of a tensor can be decomposed as an inverted associator and a functorial action of the tensor on a right unitor.Definitionright_unitor_associator{A} (tensor:A->A->A) (unit:A)`{IsMonoidalAtensorunit} (xy:A): (fmap01tensorx(right_unitory) :_$->_)$==right_unitor(tensorxy) $oassociatorxyunit.Proof.refine((cate_moveR_eV___(isnat_natequivright_unitor_))^$$@ ((_$@L_) $@R_) $@cate_moveR_eV___(isnat_natequivright_unitor_)).refine(_$@ (fmap10_comptensor___)^$).refine((cate_moveR_eV___(associator_nat_m___))^$ $@_).refine(_$@ (cate_moveR_eV___(triangle_identity______) $@R_)).applycate_moveR_eV.refine((_$@L(fmap02__(cate_moveR_eV___(triangle_identity______))^$$@fmap01_comp____)) $@_).refine(cat_assoc_opp___$@_).nrefine((associator_nat_r___$@R_) $@cat_assoc___$@_).do2nrefine(_$@cat_assoc_opp___).refine(_$@L_).refine((_$@L(emap_inv'__)^$) $@_).applycate_moveR_eV.refine(_$@ (_$@Lcate_buildequiv_fun_)^$).nrefine(_$@cat_assoc_opp___).applycate_moveL_Ve.rapplypentagon_identity.Defined.The left unitor at the unit is the right unitor at the unit.Definitionleft_unitor_unit_right_unitor_unit{A} (tensor:A->A->A) (unit:A)`{IsMonoidalAtensorunit}: (left_unitorunit:tensorunitunit$->_) $==right_unitorunit.Proof.refine((cate_moveR_eV___(isnat_natequivleft_unitor(left_unitorunit)))^$$@_).applycate_moveR_eV.refine(_$@ (_$@Lleft_unitor_associator____)^$).nrefine(_$@ (_$@R_) $@cat_assoc___).2:rapply(isnat_natequivright_unitor_)^$.nrefine((_$@L_) $@cat_assoc_opp___).refine(triangle_identity______$@_).nrefine(_$@R_).nrapplycate_monic_equiv.exact(isnat_natequivright_unitor(right_unitorunit)).Defined.TODO: Kelly also shows that there are redundant coherence conditions for symmetric monoidal categories also, but we leave these out for now.Monoidal functorsA (lax) monoidal functorFbetween two monoidal categoriesAandBis a functorF:A->Btogether with:ClassIsMonoidalFunctor{AB:Type}{tensorA:A->A->A} {tensorB:B->B->B} {IA:A} {IB:B}`{IsMonoidalAtensorAIA,IsMonoidalBtensorBIB}(F:A->B) `{!Is0FunctorF, !Is1FunctorF} := {A natural transformationfmap_tensorfromFa⊗FbtoF(a⊗b).fmap_tensor:NatTrans(uncurry(funab=>tensorB(Fa) (Fb)))(uncurry(funab=>F(tensorAab)));A morphismfmap_unitrelating the two unit objects.fmap_unit:IB$->F(IA);Such that the following coherence conditions hold:Fpreserves theassociators in a suitable way.fmap_tensor_assocabc:fmapF(associatorabc)$ofmap_tensor(a,tensorAbc)$ofmap01tensorB(Fa) (fmap_tensor(b,c))$==fmap_tensor(tensorAab,c)$ofmap10tensorB(fmap_tensor(a,b)) (Fc)$oassociator(Fa) (Fb) (Fc);Fpreserves theleft_unitors in a suitable way.fmap_tensor_left_unitora:trans_nattransleft_unitor(Fa)$==fmapF(left_unitora)$ofmap_tensor(IA,a)$ofmap10tensorBfmap_unit(Fa);Fpreserves theright_unitorss in a suitable way.fmap_tensor_right_unitora:trans_nattransright_unitor(Fa)$==fmapF(right_unitora)$ofmap_tensor(a,IA)$ofmap01tensorB(Fa)fmap_unit;}.Argumentsfmap_tensor{ABtensorAtensorBIAIB____________}F{___}.Definitionfmap_tensor_nat{AB:Type}{tensorA:A->A->A} {tensorB:B->B->B} {IA:A} {IB:B}(F:A->B) `{IsMonoidalFunctorABtensorAtensorBIAIBF}{xx'yy':A} (f:x$->x') (g:y$->y'):fmap_tensorF(x',y') $ofmap11tensorB(fmapFf) (fmapFg)$==fmapF(fmap11tensorAfg) $ofmap_tensorF(x,y).Proof.destruct(fmap_tensorF)as[fmap_tensor_Fnat].exact(nat(x,y) (x',y') (f,g)).Defined.Definitionfmap_tensor_nat_l{AB:Type}{tensorA:A->A->A} {tensorB:B->B->B} {IA:A} {IB:B}(F:A->B) `{IsMonoidalFunctorABtensorAtensorBIAIBF}{xx'y:A} (f:x$->x'):fmap_tensorF(x',y) $ofmap10tensorB(fmapFf) (Fy)$==fmapF(fmap10tensorAfy) $ofmap_tensorF(x,y).Proof.refine((_$@L(fmap12tensorB_(fmap_id__)$@fmap10_is_fmap11___)^$) $@_).refine(_$@ (fmap2F(fmap10_is_fmap11___) $@R_)).snrapplyfmap_tensor_nat.Defined.Definitionfmap_tensor_nat_r{AB:Type}{tensorA:A->A->A} {tensorB:B->B->B} {IA:A} {IB:B}(F:A->B) `{IsMonoidalFunctorABtensorAtensorBIAIBF}{xyy':A} (g:y$->y'):fmap_tensorF(x,y') $ofmap01tensorB(Fx) (fmapFg)$==fmapF(fmap01tensorAxg) $ofmap_tensorF(x,y).Proof.refine((_$@L(fmap21tensorB(fmap_id__)_$@fmap01_is_fmap11___)^$) $@_).refine(_$@ (fmap2F(fmap01_is_fmap11___) $@R_)).snrapplyfmap_tensor_nat.Defined.

--- Miscellaneous\MonoidalCategory.html ---
MonoidalCategoryLibrary MonoidalCategoryRequireImportBasics.Utf8.RequireImportCategory.CoreCategory.Morphisms.RequireImportFunctor.CoreFunctor.Utf8.RequireImportNaturalTransformation.Core.RequireImportFunctorCategory.CoreFunctorCategory.Morphisms.RequireImportProductLaws.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.SectionMonoidalStructure.Context`{Funext}.Local Notation"x --> y" := (morphism_xy).SectionMonoidalCategoryConcepts.VariableC:PreCategory.Variabletensor: ((C*C) ->C)%category.VariableI:C.Local Notation"A ⊗ B" := (tensor(Basics.Overture.pairAB)).Local OpenScopefunctor_scope.Definitionright_assoc:= (tensor∘ (Functor.Prod.pair1tensor) )%functor.Definitionleft_assoc:=tensor∘(Functor.Prod.pairtensor1) ∘(Associativity.functor___).Definitionassociator:=NaturalIsomorphismright_assocleft_assoc.(* Orientation  (A ⊗ B) ⊗ C -> A ⊗ (B ⊗ C) *)Definitionpretensor(A:C) :=Core.induced_sndtensorA.DefinitionI_pretensor:=pretensorI.Definitionposttensor(A:C) :=Core.induced_fsttensorA.DefinitionI_posttensor:=posttensorI.Definitionleft_unitor:=NaturalIsomorphismI_pretensor1.Definitionright_unitor:=NaturalIsomorphismI_posttensor1.CloseScopefunctor_scope.Variablealpha:associator.Variablelambda:left_unitor.Variablerho:right_unitor.Notationalpha_nat_trans:= ((@morphism_isomorphic(C* (C*C) ->C)%categoryright_assocleft_assoc)alpha).Notationlambda_nat_trans:= ((@morphism_isomorphic___)lambda).Notationrho_nat_trans:= ((@morphism_isomorphic___)rho).Sectioncoherence_laws.Variableabcd:C.Local DefinitionP1: (a⊗ (b⊗ (c⊗d))) --> (a⊗ ((b⊗c) ⊗d)).Proof.apply(morphism_oftensor);split;simpl.-exact(Core.identitya).-exact(alpha_nat_trans(b, (c,d))).Defined.Local DefinitionP2:a⊗ ((b⊗c) ⊗d) --> (a⊗ (b⊗c)) ⊗d:=alpha_nat_trans(a, (b⊗c,d)).Local DefinitionP3: (a⊗ (b⊗c)) ⊗d--> ((a⊗b) ⊗c) ⊗d.Proof.apply(morphism_oftensor);split;simpl.-exact(alpha_nat_trans(a,_)).-exact(Core.identityd).Defined.Local DefinitionP4:a⊗ (b⊗ (c⊗d)) --> (a⊗b) ⊗ (c⊗d):=alpha_nat_trans(a, (b, (c⊗d))).Local DefinitionP5: (a⊗b) ⊗ (c⊗d) --> ((a⊗b) ⊗c) ⊗d:=alpha_nat_trans(a⊗b,(c,d)).Local OpenScopemorphism_scope.Definitionpentagon_eq:=P3oP2oP1=P5oP4.CloseScopemorphism_scope.Local DefinitionQ1: (a⊗ (I⊗b)) -->a⊗b.Proof.apply(morphism_oftensor);split;simpl.-exact(Core.identitya).-exact(lambda_nat_trans_).Defined.Local DefinitionQ2: (a⊗ (I⊗b)) -->a⊗b.Proof.refine(@Category.Core.compose__((a⊗I) ⊗b)___).-apply(morphism_oftensor);split;simpl.+exact(rho_nat_transa).+exact(Core.identityb).-exact(alpha_nat_trans(a,(I,b))).Defined.Definitiontriangle_eq:=Q1=Q2.Endcoherence_laws.EndMonoidalCategoryConcepts.ClassMonoidalStructure(C:PreCategory) :=Build_MonoidalStructure{tensor: (C*C->C)%category;I:C;alpha:associatortensor;lambda:left_unitortensorI;rho:right_unitortensorI;pentagon_eq_holds:forallabcd:C,pentagon_eqalphaabcd;triangle_eq_holds:forallab:C,triangle_eqalphalambdarhoab;}.EndMonoidalStructure.

--- Miscellaneous\MonoidalTwistConstruction.html ---
MonoidalTwistConstructionLibrary MonoidalTwistConstructionRequireImportBasics.OvertureBasics.TacticsTypes.ForallWildCat.Monoidal.RequireImportWildCat.CoreWildCat.BifunctorWildCat.ProdWildCat.Equiv.RequireImportWildCat.NatTransWildCat.SquareWildCat.Opposite.Building Symmetric Monoidal CategoriesThe following construction is what we call the "twist construction". It is a way to build a symmetric monoidal category from simpler pieces than the axioms ask for.The core observation is that the associator can be broken up into abraidand what we call atwistmap. The twist map takes a right associated triple(A,(B,C))and swaps the first two factors(B,(A,C). Together with functoriality of the tensor and the braiding, here termedbraidwe can simplify the axioms we ask for.For instance, the hexagon identity is about associators, but if we unfold the definition and simplify the diagram, we get a diagram about only twists and braids.This means in practice, you can show a category has a symmetric monoidal structure by proving some simpler axioms. This idea has been used in TriJoin.v to show the associativity of join for example.SectionTwistConstruction.The aim of this section is to build a symmetric monoidal category. We do this piecewise so that the separate steps are useful in and of themselves.Our basic starting assumption is that we have a category with equivalences, a bifunctor called the tensor product, and a unit object.Context(A:Type) `{HasEquivsA}(cat_tensor:A->A->A) (cat_tensor_unit:A)`{!Is0Bifunctorcat_tensor, !Is1Bifunctorcat_tensor}Next we postulate the existence of abraidmap. This takes a tensor pair and swaps the factors. We also postulate thatbraidis natural in both factors and self-inverse.(braid:SymmetricBraidingcat_tensor)We postulate the existence of atwistmap. This takes a right associated triple(A,(B,C))and swaps the first two factors(B,(A,C). We also postulate thattwistis natural in all three factors and self-inverse.(twist:forallabc,cat_tensora(cat_tensorbc) $->cat_tensorb(cat_tensorac))(twist_twist:forallabc,twistabc$otwistbac$==Id_)(twist_nat:forallaa'bb'cc'(f:a$->a') (g:b$->b') (h:c$->c'),twista'b'c'$ofmap11cat_tensorf(fmap11cat_tensorgh)$==fmap11cat_tensorg(fmap11cat_tensorfh) $otwistabc)We assume that there is a natural isomorphismright_unitorwitnessing the right unit law. The left unit law will be derived from this one. We also assume a coherence calledtwist_unitorwhich determines how the right_unitor interacts withbraidandtwist. This is the basis of the triangle axiom.(right_unitor:RightUnitorcat_tensorcat_tensor_unit)(twist_unitor:forallab,fmap01cat_tensora(right_unitorb)$==braidba$ofmap01cat_tensorb(right_unitora) $otwistabcat_tensor_unit)The hexagon identity is about the interaction of associators and braids. We will derive this axiom from an analogous one for twists and braids.(twist_hexagon:forallabc,fmap01cat_tensorc(braidba) $otwistbca$ofmap01cat_tensorb(braidac)$==twistacb$ofmap01cat_tensora(braidbc) $otwistbac)The 9-gon identity. TODO: explain this(twist_9_gon:forallabcd,fmap01cat_tensorc(braid(cat_tensorab)d)$otwist(cat_tensorab)cd$obraid(cat_tensorcd) (cat_tensorab)$otwista(cat_tensorcd)b$ofmap01cat_tensora(braidb(cat_tensorcd))$==fmap01cat_tensorc(twistadb)$ofmap01cat_tensorc(fmap01cat_tensora(braidbd))$otwistac(cat_tensorbd)$ofmap01cat_tensora(twistbcd)).SetupBefore starting the proofs, we need to setup some useful definitions and helpful lemmas for working with diagrams.We give notations and abbreviations to the morphisms that will appear in diagrams. This helps us read the goal and understand what is happening, otherwise it is too verbose.Declare Scopemonoidal_scope.Local Infix"⊗" :=cat_tensor(atlevel40) :monoidal_scope.Local Infix"⊗R" := (fmap01cat_tensor) (atlevel40) :monoidal_scope.Local Infix"⊗L" := (fmap10cat_tensor) (atlevel40) :monoidal_scope.Local Notation"f ∘ g" := (f$og) (atlevel61,leftassociativity,format"f  '/' '∘'  g") :monoidal_scope.TODO: in 8.19 this notation causes issues, when updating to 8.20 we should uncomment this.(* Local Notation "f == '/'  'v'g''  '/' :>  ''A'' ']'"): long_path_scope. *)Local OpenScopemonoidal_scope.twistis an equivalence which we will calltwiste.Local Definitiontwisteabc:cat_tensora(cat_tensorbc) $<~>cat_tensorb(cat_tensorac):=cate_adjointify(twistabc) (twistbac)(twist_twistabc) (twist_twistbac).Finer naturalityThe naturality postulates we have fortwistare natural in all their arguments similtaneously. We show the finer naturality oftwistin each argument separately as this becomes more useful in practice.Definitiontwist_nat_l{aa'} (f:a$->a')bc:twista'bc$ofmap10cat_tensorf(cat_tensorbc)$==fmap01cat_tensorb(fmap10cat_tensorfc) $otwistabc.Proof.refine((_$@L_^$) $@twist_nataa'bbccf(Id_) (Id_) $@ (_$@R_)).-refine(fmap12___$@fmap10_is_fmap11___).rapplyfmap11_id.-refine(fmap12___$@fmap01_is_fmap11___).rapplyfmap10_is_fmap11.Defined.Definitiontwist_nat_ma{bb'} (g:b$->b')c:twistab'c$ofmap01cat_tensora(fmap10cat_tensorgc)$==fmap10cat_tensorg(cat_tensorac) $otwistabc.Proof.refine((_$@L_^$) $@twist_nataabb'cc(Id_)g(Id_) $@ (_$@R_)).-refine(fmap12___$@fmap01_is_fmap11___).rapplyfmap10_is_fmap11.-refine(fmap12___$@fmap10_is_fmap11___).rapplyfmap11_id.Defined.Definitiontwist_nat_rab{cc'} (h:c$->c'):twistabc'$ofmap01cat_tensora(fmap01cat_tensorbh)$==fmap01cat_tensorb(fmap01cat_tensorah) $otwistabc.Proof.refine((_$@L_^$) $@twist_nataabbcc'(Id_) (Id_)h$@ (_$@R_)).-refine(fmap12___$@fmap01_is_fmap11___).rapplyfmap01_is_fmap11.-refine(fmap12___$@fmap01_is_fmap11___).rapplyfmap01_is_fmap11.Defined.Movement lemmasHere we collect lemmas about moving morphisms around in a diagram. We could have createdcate_moveL_eM-style lemmas forCatIsEquivbut this leads to a lot of unnecessary unfolding and duplication. It is typically easier to use a hand crafted lemma for each situation.TODO: A lot of these proofs are copy and pasted between lemmas. We need to work out an efficient way of proving them.MovingtwistDefinitionmoveL_twistLabcdf(g:d$->_):twistabc$of$==g->f$==twistbac$og.Proof.introsp.apply(cate_monic_equiv(twisteabc)).nrefine((cate_buildequiv_fun_$@R_) $@p$@_$@cat_assoc___).refine((cat_idl_)^$ $@ (_^$ $@R_)).refine((cate_buildequiv_fun_$@R_) $@_).applytwist_twist.Defined.DefinitionmoveL_twistRabcdf(g:_$->d):f$otwistabc$==g->f$==g$otwistbac.Proof.introsp.apply(cate_epic_equiv(twisteabc)).refine(_$@ (cat_assoc___)^$).refine(_$@ (_$@L((_$@Lcate_buildequiv_fun_) $@_)^$)).2:applytwist_twist.refine((_$@L_) $@_$@ (cat_idr_)^$).1:applycate_buildequiv_fun.exactp.Defined.DefinitionmoveR_twistLabcdf(g:d$->_):f$==twistbac$og->twistabc$of$==g.Proof.introsp;symmetry;applymoveL_twistL;symmetry;exactp.Defined.DefinitionmoveR_twistRabcdf(g:_$->d):f$==g$otwistbac->f$otwistabc$==g.Proof.introsp;symmetry;applymoveL_twistR;symmetry;exactp.Defined.DefinitionmoveL_fmap01_twistLabcdef(g:e$->_):fmap01cat_tensora(twistbcd) $of$==g->f$==fmap01cat_tensora(twistcbd) $og.Proof.introsp.apply(cate_monic_equiv(emap01cat_tensora(twistebcd))).refine(_$@cat_assoc___).refine(_$@ (_$@R_)).2: {refine(_$@ (_^$ $@R_)).2:applycate_buildequiv_fun.refine((fmap_id__)^$ $@fmap2__$@fmap_comp___).refine(_^$ $@ (_^$ $@R_)).2:applycate_buildequiv_fun.applytwist_twist. }refine((_$@R_) $@p$@ (cat_idl_)^$).refine(cate_buildequiv_fun_$@fmap02___).applycate_buildequiv_fun.Defined.DefinitionmoveL_fmap01_twistRabcdef(g:_$->e):f$ofmap01cat_tensora(twistbcd) $==g->f$==g$ofmap01cat_tensora(twistcbd).Proof.introsp.apply(cate_epic_equiv(emap01cat_tensora(twistebcd))).refine(_$@ (cat_assoc___)^$).refine(_$@ (_$@L_)).2: {refine(_^$ $@ (_$@L_^$)).2:applycate_buildequiv_fun.refine((fmap_comp___)^$ $@fmap2__$@fmap_id__).refine((_$@L_) $@_).1:applycate_buildequiv_fun.applytwist_twist. }refine((_$@L_) $@p$@ (cat_idr_)^$).refine(cate_buildequiv_fun_$@fmap02___).applycate_buildequiv_fun.Defined.DefinitionmoveR_fmap01_twistLabcdef(g:e$->_):f$==fmap01cat_tensora(twistcbd) $og->fmap01cat_tensora(twistbcd) $of$==g.Proof.introsp;symmetry;applymoveL_fmap01_twistL;symmetry;exactp.Defined.DefinitionmoveR_fmap01_twistRabcdef(g:_$->e):f$==g$ofmap01cat_tensora(twistcbd)->f$ofmap01cat_tensora(twistbcd) $==g.Proof.introsp;symmetry;applymoveL_fmap01_twistR;symmetry;exactp.Defined.The associatorUsingbraideandtwistewe can build an associator.Definitionassociator_twist'abc:cat_tensora(cat_tensorbc) $<~>cat_tensor(cat_tensorab)c.Proof.We can build the associator out ofbraideandtwiste.refine(braide__$oE_).nrefine(twiste___$oE_).exact(emap01cat_tensora(braide__)).Defined.We would like to be able to unfoldassociator_twist'to the underlying morphisms. We use this lemma to make that process easier.Definitionassociator_twist'_unfoldabc:cate_fun(associator_twist'abc)$==braidc(cat_tensorab) $o(twistacb$ofmap01cat_tensora(braidbc)).Proof.refine(cate_buildequiv_fun_$@ (_$@@cate_buildequiv_fun_)).nrefine(cate_buildequiv_fun_$@ (_$@@cate_buildequiv_fun_)).refine(cate_buildequiv_fun_$@fmap2__).applycate_buildequiv_fun.Defined.Now we can useassociator_twist'and show that it is a natural equivalence in each variable.Instanceassociator_twist:Associatorcat_tensor.Proof.snrapplyBuild_Associator.-exactassociator_twist'.-snrapplyBuild_Is1Natural.simpl;intros[[ab]c] [[a'b']c'] [[fg]h];simplinf,g,h.To prove naturality it will be easier to reason about squares.change(?w$o?x$== ?y$o?z)with(Squarezwxy).First we remove all the equivalences from the equation.nrapplyhconcatL.1:applyassociator_twist'_unfold.nrapplyhconcatR.2:applyassociator_twist'_unfold.The first square involvingbraidon its own is a naturality square.nrapplyvconcat.2:rapplybraid_nat.The second square is just the naturality of twist.nrapplyvconcat.2:applytwist_nat.nrapplyhconcatL.2:nrapplyhconcatR.1,3:symmetry;rapplyfmap01_is_fmap11.Leaving us with a square with a functor application.rapplyfmap11_square.1:rapplyvrefl.We are finally left with the naturality of braid.applybraid_nat.Defined.We abbreviate the associator toαfor the remainder of the section.Local Notationα:=associator_twist.UnitorsSince we assume theright_unitorexists, we can derive theleft_unitorfrom it together withbraid.Instanceleft_unitor_twist:LeftUnitorcat_tensorcat_tensor_unit.Proof.snrapplyBuild_NatEquiv'.-snrapplyBuild_NatTrans.+exact(funa=>right_unitora$obraidcat_tensor_unita).+snrapplyBuild_Is1Natural.introsabf.change(?w$o?x$== ?y$o?z)with(Squarezwxy).nrapplyvconcat.2:rapply(isnatright_unitorf).rapplybraid_nat_r.-introsa.rapplycompose_catie'.rapplycatie_braid.Defined.TriangleThe triangle identity can easily be proven by rearranging the diagram, cancelling and using naturality ofbraid.Instancetriangle_twist:TriangleIdentitycat_tensorcat_tensor_unit.Proof.introsab.refine(_$@ (_$@L_)^$).2:applyassociator_twist'_unfold.refine(fmap02_a(cate_buildequiv_fun_) $@_);cbn.refine(fmap01_comp____$@_).do2refine(_$@cat_assoc___).refine((twist_unitor__$@ (_$@R_)) $@R_).applybraid_nat_r.Defined.PentagonLocal OpenScopelong_path_scope.Instancepentagon_twist:PentagonIdentitycat_tensor.Proof.cleartwist_unitorright_unitorcat_tensor_unit.introsabcd.refine((_$@@_) $@_$@ ((fmap02___$@_)^$ $@@ (_$@@ (fmap20___$@_))^$)).1,2,4,6,7:applyassociator_twist'_unfold.2:refine(fmap01_comp____$@ (_$@L(fmap01_comp____))).2:refine(fmap10_comp____$@ (_$@L(fmap10_comp____))).We use a notation defined above that shows the base type of the groupoid hom and formats the equation in a way that is easier to read.  Normalize brackets on LHSrefine(cat_assoc___$@_).refine(_$@L(cat_assoc___) $@_).do4refine((cat_assoc___)^$ $@_).Normalize brackets on RHSrefine(_$@ (((cat_assoc___) $@R_) $@R_)).do2refine(_$@ ((cat_assoc___) $@R_)).do2refine(_$@cat_assoc___).Cancel two braids next to eachother.applymoveL_fmap01_fmap01_braidR.applymoveL_fmap01_twistR.refine(_$@ (cat_assoc___)^$).refine(_$@ ((_$@L_) $@cat_idr_)^$).2:refine((fmap01_comp____)^$ $@fmap02___$@fmap01_id___).2:applybraid_braid.applymoveL_twistR.refine(_$@ (cat_assoc___)^$).refine(_$@ (_$@L_)).2:applybraid_nat_r.refine(_$@cat_assoc___).applymoveL_fmap01_fmap01_braidR.refine(_$@ (cat_assoc___)^$).refine(_$@ (_$@L_)).2:applybraid_nat_r.refine(_$@cat_assoc___).applymoveL_fmap01_twistR.refine(_$@_).2:applybraid_nat_r.Putting things back.applymoveR_fmap01_twistR.applymoveR_fmap01_fmap01_braidR.applymoveR_twistR.applymoveR_fmap01_twistR.There are two braids on the RHS of the LHS that can be swapped.refine(cat_assoc___$@_).refine((_$@L_) $@_).1:refine((fmap01_comp____)^$ $@fmap02___$@fmap01_comp____).1:applybraid_nat_r.refine((cat_assoc___)^$ $@_).applymoveR_fmap01_braidR.Naturality of twist on the RHS of the LHS.refine(cat_assoc___$@_).refine((_$@L_) $@_).1:applytwist_nat_m.refine((cat_assoc___)^$ $@_).Moving some things to the RHS so that we can braid and cancel on the LHS.applymoveR_twistR.refine(cat_assoc___$@_).refine((_$@L_) $@_).1:applybraid_nat_l.refine((cat_assoc___)^$ $@_).applymoveR_braidR.refine(cat_assoc___$@_).refine((_$@L_) $@cat_idr_$@_).1:refine((fmap01_comp____)^$ $@fmap02___$@fmap01_id___).1:applybraid_braid.applymoveL_braidR.applymoveL_twistR.applymoveL_fmap01_braidR.We are almost at the desired 9-gon. Now we cancel the inner braid on the LHS.do4refine(_$@ (cat_assoc___)^$).do3refine(cat_assoc___$@_).refine(_$@L_).applymoveR_twistL.do4refine(_$@cat_assoc___).refine((cat_assoc___)^$ $@_).Now we move terms around in order to get a homotopy ina⊗(b⊗(d⊗c))$->d⊗(c⊗(a⊗b)).applymoveL_fmap01_twistR.applymoveL_twistR.do2refine(_$@ (cat_assoc___)^$).do3refine(cat_assoc___$@_).applymoveL_twistL.refine(_$@cat_assoc___).do4refine((cat_assoc___)^$ $@_).applymoveR_twistR.applymoveR_fmap01_twistR.do3refine(_$@ (cat_assoc___)^$).do2refine(cat_assoc___$@_).applymoveL_fmap01_braidL.do2refine(_$@cat_assoc___).do3refine((cat_assoc___)^$ $@_).And finally, this is the 9-gon we asked for.applytwist_9_gon.Defined.Local CloseScopelong_path_scope.HexagonInstancehexagon_twist:HexagonIdentitycat_tensor.Proof.introsabc;simpl.refine(((_$@L_) $@R_) $@_$@ (_$@@ (_$@R_))^$).1,3,4:applyassociator_twist'_unfold.do2refine(((cat_assoc___)^$ $@R_) $@_).refine(cat_assoc___$@ (_$@L_) $@_).{refine((fmap_comp___)^$ $@fmap2__$@fmap_id__).applybraid_braid. }refine(cat_idr_$@_).refine(_$@cat_assoc___).refine(_$@ ((cat_assoc___)^$ $@R_)).refine(_$@ (((cat_idr_)^$ $@ (_$@L_^$)) $@R_)).2:applybraid_braid.refine(((braid_nat_r_)^$ $@R_) $@_).refine(cat_assoc___$@ (_$@L_) $@ (cat_assoc___)^$).refine(_$@cat_assoc___).applymoveL_fmap01_braidR.applytwist_hexagon.Defined.ConclusionIn conclusion, we have proven the following:There is a monoidal structure onA.Instanceismonoidal_twist:IsMonoidalAcat_tensorcat_tensor_unit:= {}.There is a symmetric monoidal category onA.Instanceissymmetricmonoidal_twist:IsSymmetricMonoidalAcat_tensorcat_tensor_unit:= {}.TODO: WIPHere is a hexagon involving only twistDefinitiontwist_hex'abcd:fmap01cat_tensorc(twistabd)$otwistac(cat_tensorbd)$ofmap01cat_tensora(twistbcd)$==twistbc(cat_tensorad)$ofmap01cat_tensorb(twistacd)$otwistab(cat_tensorcd).Proof.poseproof(twist_hexagoncad$@cat_assoc___)asp.applymoveR_twistLinp.applymoveR_fmap01_braidLinp.apply(fmap02cat_tensorb)inp.refine(_$@ ((_$@Lp) $@R_));clearp.applymoveL_twistR.applymoveL_twistL.refine(_$@ (fmap01_comp____)^$).TODO simplifyapplymoveR_twistL.refine(_$@cat_assoc___).Abort.EndTwistConstruction.

--- Miscellaneous\MonoidObject.html ---
MonoidObjectLibrary MonoidObjectRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.CoreWildCat.EquivWildCat.MonoidalWildCat.BifunctorWildCat.NatTransWildCat.OppositeWildCat.Products.RequireImportabstract_algebra.Monoids and ComonoidsHere we define a monoid internal to a monoidal category. Note that we don't actually need the full monoidal structure so we assume only the parts we need. This allows us to keep the definitions general between various flavours of monoidal category.Many algebraic theories such as groups and rings may also be internalized, however these specifically require a cartesian monoidal structure. The theory of monoids however has no such requirement and can therefore be developed in much greater generality. This can be used to define a range of objects such as R-algebras, H-spaces, Hopf algebras and more.Monoid objectsSectionMonoidObject.Context{A:Type} {tensor:A->A->A} {unit:A}`{HasEquivsA, !Is0Bifunctortensor, !Is1Bifunctortensor}`{!Associatortensor, !LeftUnitortensorunit, !RightUnitortensorunit}.An objectxofAis a monoid object if it comes with the following data:ClassIsMonoidObject(x:A) := {A multiplication map from the tensor product ofxwith itself tox.mo_mult:tensorxx$->x;A unit of the multplication.mo_unit:unit$->x;The multiplication map is associative.mo_assoc:mo_mult$ofmap10tensormo_multx$oassociatorxxx$==mo_mult$ofmap01tensorxmo_mult;The multiplication map is left unital.mo_left_unit:mo_mult$ofmap10tensormo_unitx$==left_unitorx;The multiplication map is right unital.mo_right_unit:mo_mult$ofmap01tensorxmo_unit$==right_unitorx;}.Context`{!Braidingtensor}.An objectxofAis a commutative monoid object if:ClassIsCommutativeMonoidObject(x:A) := {It is a monoid object.cmo_mo::IsMonoidObjectx;The multiplication map is commutative.cmo_comm:mo_mult$obraidxx$==mo_mult;}.EndMonoidObject.ArgumentsIsMonoidObject{A}tensorunit{__________}x.ArgumentsIsCommutativeMonoidObject{A}tensorunit{___________}x.SectionComonoidObject.Context{A:Type} (tensor:A->A->A) (unit:A)`{HasEquivsA, !Is0Bifunctortensor, !Is1Bifunctortensor}`{!Associatortensor, !LeftUnitortensorunit, !RightUnitortensorunit}.A comonoid object is a monoid object in the opposite category.ClassIsComonoidObject(x:A):=ismonoid_comonoid_op::IsMonoidObject(A:=A^op)tensorunitx.We can build comonoid objects from the following data:DefinitionBuild_IsComonoidObject(x:A)A comultplication map.(co_comult:x$->tensorxx)A counit.(co_counit:x$->unit)The comultiplication is coassociative.(co_coassoc:associatorxxx$ofmap01tensorxco_comult$oco_comult$==fmap10tensorco_comultx$oco_comult)The comultiplication is left counital.(co_left_counit:left_unitorx$ofmap10tensorco_counitx$oco_comult$==Idx)The comultiplication is right counital.(co_right_counit:right_unitorx$ofmap01tensorxco_counit$oco_comult$==Idx):IsComonoidObjectx.Proof.snrapplyBuild_IsMonoidObject.-exactco_comult.-exactco_counit.-nrapplycate_moveR_eV.symmetry.nrefine(cat_assoc___$@_).rapplyco_coassoc.-simpl;nrefine(_$@cat_idr_).nrapplycate_moveL_Ve.nrefine(cat_assoc_opp___$@_).exactco_left_counit.-simpl;nrefine(_$@cat_idr_).nrapplycate_moveL_Ve.nrefine(cat_assoc_opp___$@_).exactco_right_counit.Defined.ComultiplicationDefinitionco_comult{x:A} `{!IsComonoidObjectx} :x$->tensorxx:=mo_mult(A:=A^op) (tensor:=tensor) (unit:=unit) (x:=x).CounitDefinitionco_counit{x:A} `{!IsComonoidObjectx} :x$->unit:=mo_unit(A:=A^op) (tensor:=tensor) (unit:=unit) (x:=x).CoassociativityDefinitionco_coassoc{x:A} `{!IsComonoidObjectx}:associatorxxx$ofmap01tensorxco_comult$oco_comult$==fmap10tensorco_comultx$oco_comult.Proof.refine(cat_assoc___$@_).applycate_moveR_Me.symmetry.exact(mo_assoc(A:=A^op) (tensor:=tensor) (unit:=unit) (x:=x)).Defined.Left counitalityDefinitionco_left_counit{x:A} `{!IsComonoidObjectx}:left_unitorx$ofmap10tensorco_counitx$oco_comult$==Idx.Proof.refine(cat_assoc___$@_).applycate_moveR_Me.refine(_$@ (cat_idr_)^$).exact(mo_left_unit(A:=A^op) (tensor:=tensor) (unit:=unit) (x:=x)).Defined.Right counitalityDefinitionco_right_counit{x:A} `{!IsComonoidObjectx}:right_unitorx$ofmap01tensorxco_counit$oco_comult$==Idx.Proof.refine(cat_assoc___$@_).applycate_moveR_Me.refine(_$@ (cat_idr_)^$).exact(mo_right_unit(A:=A^op) (tensor:=tensor) (unit:=unit) (x:=x)).Defined.Context`{!Braidingtensor}.A cocommutative comonoid objects is a commutative monoid object in the opposite category.ClassIsCocommutativeComonoidObject(x:A):=iscommuatativemonoid_cocomutativemonoid_op::IsCommutativeMonoidObject(A:=A^op)tensorunitx.We can build cocommutative comonoid objects from the following data:DefinitionBuild_IsCocommutativeComonoidObject(x:A)A comonoid.`{!IsComonoidObjectx}Together with a proof of cocommutativity.(cco_cocomm:braidxx$oco_comult$==co_comult):IsCocommutativeComonoidObjectx.Proof.snrapplyBuild_IsCommutativeMonoidObject.-exact_.-exactcco_cocomm.Defined.Global Instanceco_cco{x:A} `{!IsCocommutativeComonoidObjectx}:IsComonoidObjectx.Proof.applycmo_mo.Defined.CocommutativityDefinitioncco_cocomm{x:A} `{!IsCocommutativeComonoidObjectx}:braidxx$oco_comult$==co_comult.Proof.exact(cmo_comm(A:=A^op) (tensor:=tensor) (unit:=unit) (x:=x)).Defined.EndComonoidObject.A comonoid object inA^opis a monoid object inA.Definitionmo_co_op{A:Type} {tensor:A->A->A} {unit:A}`{HasEquivsA, !Is0Bifunctortensor, !Is1Bifunctortensor}`{!Associatortensor, !LeftUnitortensorunit, !RightUnitortensorunit}{x:A} `{C: !IsComonoidObject(A:=A^op)tensorunitx}:IsMonoidObjecttensorunitx.Proof.snrapplyBuild_IsMonoidObject.-exact(co_comult(A:=A^op)tensorunit).-exact(co_counit(A:=A^op)tensorunit).-applycate_moveR_eM.symmetry.exact(cat_assoc___$@co_coassoc(A:=A^op)tensorunit(x:=x)).-simpl;nrefine(_$@cat_idl_).applycate_moveL_eM.refine(cat_assoc___$@_).exact(co_left_counit(A:=A^op)tensorunit(x:=x)).-simpl;nrefine(_$@cat_idl_).applycate_moveL_eM.refine(cat_assoc___$@_).exact(co_right_counit(A:=A^op)tensorunit(x:=x)).Defined.A cocommutative cocomonoid object inA^opis a commutative monoid object inA.Definitioncmo_coco_op{A:Type} {tensor:A->A->A} {unit:A}`{HasEquivsA, !Is0Bifunctortensor, !Is1Bifunctortensor}`{!Associatortensor, !LeftUnitortensorunit, !RightUnitortensorunit,!Braidingtensor}{x:A} `{C: !IsCocommutativeComonoidObject(A:=A^op)tensorunitx}:IsCommutativeMonoidObjecttensorunitx.Proof.snrapplyBuild_IsCommutativeMonoidObject.-nrapplymo_co_op.rapplyco_cco.-exact(cco_cocomm(A:=A^op)tensorunit).Defined.Monoid enrichmentA homx$->yin a cartesian category whereyis a monoid object has the structure of a monoid. Equivalently, a homx$->yin a cartesian category wherexis a comonoid object has the structure of a monoid.SectionMonoidEnriched.Context{A:Type} `{HasEquivsA} `{!HasBinaryProductsA}(unit:A) `{!IsTerminalunit} {xy:A}`{!HasMorExtA} `{forallxy,IsHSet(x$->y)}.SectionMonoid.Context`{!IsMonoidObject__y}.Local Instancesgop_hom:SgOp(x$->y):=funfg=>mo_mult$ocat_binprod_corecfg.Local Instancemonunit_hom:MonUnit(x$->y) :=mo_unit$omor_terminal__.Local Instanceassociative_hom:Associativesgop_hom.Proof.introsfgh.unfoldsgop_hom.rapplypath_hom.refine((_$@Lcat_binprod_fmap01_corec___)^$ $@_).nrefine(cat_assoc_opp___$@_).refine((mo_assoc$@R_)^$ $@_).nrefine(_$@ (_$@Lcat_binprod_fmap10_corec___)).refine(cat_assoc___$@ (_$@L_) $@cat_assoc___).nrapplycat_binprod_associator_corec.Defined.Local Instanceleftidentity_hom:LeftIdentitysgop_hommon_unit.Proof.introsf.unfoldsgop_hom,mon_unit.rapplypath_hom.refine((_$@L(cat_binprod_fmap10_corec___)^$) $@cat_assoc_opp___$@_).nrefine(((mo_left_unit$@_) $@R_) $@_).1:nrapplycate_buildequiv_fun.unfoldtrans_nattrans.nrefine((((_$@R_) $@_) $@R_) $@_).1:nrapplycate_buildequiv_fun.1:nrapplycat_binprod_beta_pr1.nrapplycat_binprod_beta_pr2.Defined.Local Instancerightidentity_hom:RightIdentitysgop_hommon_unit.Proof.introsf.unfoldsgop_hom,mon_unit.rapplypath_hom.refine((_$@L(cat_binprod_fmap01_corec___)^$) $@cat_assoc_opp___$@_).nrefine(((mo_right_unit$@_) $@R_) $@_).1:nrapplycate_buildequiv_fun.nrapplycat_binprod_beta_pr1.Defined.Local Instanceissemigroup_hom:IsSemiGroup(x$->y) := {}.Local Instanceismonoid_hom:IsMonoid(x$->y) := {}.EndMonoid.Context`{!IsCommutativeMonoidObject__y}.Local Existing Instancessgop_hommonunit_homismonoid_hom.Local Instancecommutative_hom:Commutativesgop_hom.Proof.introsfg.unfoldsgop_hom.rapplypath_hom.refine((_$@L_^$) $@cat_assoc_opp___$@ (cmo_comm$@R_)).nrapplycat_binprod_swap_corec.Defined.Local Instanceiscommutativemonoid_hom:IsCommutativeMonoid(x$->y) := {}.EndMonoidEnriched.Preservation of monoid objects by lax monoidal functorsDefinitionmo_preserved{AB:Type}{tensorA:A->A->A} {tensorB:B->B->B} {IA:A} {IB:B}(F:A->B) `{IsMonoidalFunctorABtensorAtensorBIAIBF} (x:A):IsMonoidObjecttensorAIAx->IsMonoidObjecttensorBIB(Fx).Proof.introsmo_x.snrapplyBuild_IsMonoidObject.-exact(fmapFmo_mult$ofmap_tensorF(x,x)).-exact(fmapFmo_unit$ofmap_unit).-refine(((_$@L(fmap10_comptensorB___)) $@R_)$@_$@ (_$@L(fmap01_comptensorB___)^$)).refine(_$@ (((_$@L_^$) $@cat_assoc_opp___) $@R_)$@cat_assoc___).2:snrapplyfmap_tensor_nat_r.refine(_$@ ((fmap2_mo_assoc$@fmap_comp___) $@R_)$@cat_assoc_opp___$@ (cat_assoc___$@R_)).refine(_$@ ((fmap_comp___$@ (fmap_comp___$@R_))^$ $@R_)).nrefine(cat_assoc___$@cat_assoc___$@ (_$@L_)$@cat_assoc_opp___$@cat_assoc_opp___).refine(_$@ (_$@L(_^$ $@cat_assoc___))).2:snrapplyfmap_tensor_assoc.nrefine(cat_assoc_opp___$@ (cat_assoc_opp___$@R_)$@ (((_$@R_) $@cat_assoc___) $@R_) $@cat_assoc___).snrapplyfmap_tensor_nat_l.-refine((_$@Lfmap10_comp____) $@cat_assoc___$@ (_$@L(cat_assoc_opp___$@ (_$@R_))) $@_).1:snrapplyfmap_tensor_nat_l.refine(cat_assoc_opp___$@ ((cat_assoc_opp___$@(((fmap_comp___)^$ $@fmap2_mo_left_unit) $@R_)) $@R_) $@_^$).snrapplyfmap_tensor_left_unitor.-refine((_$@Lfmap01_comp____) $@cat_assoc___$@ (_$@L(cat_assoc_opp___$@ (_$@R_))) $@_).1:snrapplyfmap_tensor_nat_r.refine(cat_assoc_opp___$@ ((cat_assoc_opp___$@(((fmap_comp___)^$ $@fmap2_mo_right_unit) $@R_)) $@R_) $@_^$).snrapplyfmap_tensor_right_unitor.Defined.

--- Miscellaneous\Morphisms.html ---
MorphismsLibrary MorphismsMorphisms inset_catRequireImportCategory.CoreNaturalTransformation.Core.RequireImportCategory.MorphismsNaturalTransformation.Paths.RequireImportCategory.Univalent.RequireImportSetCategory.Core.RequireImportHoTT.BasicsHoTT.TypesTruncType.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopepath_scope.Local OpenScopemorphism_scope.Local OpenScopecategory_scope.Lemmaisisomorphism_set_cat_natural_transformation_paths`{fs:Funext} (X:set_cat)CDFG(T1T2:morphismset_catX(Build_HSet(@NaturalTransformationCDFG)))(H:forallxy,T1xy=T2xy)`{@IsIsomorphismset_cat__T1}: @IsIsomorphismset_cat__T2.Proof.exists(T1^-1)%morphism;abstract(first[apply@iso_moveR_Vp|apply@iso_moveR_pV];repeatfirst[intro|solve[auto|symmetry;auto]|apply@path_forall|path_natural_transformation]).Defined.Sectionequiv_iso_set_cat.Isomorphisms inset_catare eqivalent to equivalences.Context`{Funext}.Definitionisiso_isequivsd(m:morphismset_catsd)`{IsEquiv__m}:IsIsomorphismm:=Build_IsIsomorphismset_catsdmm^-1%function(path_forall__(eissectm))(path_forall__(eisretrm)).Definitionisequiv_isisosd(m:morphismset_catsd)`{IsIsomorphism___m}:IsEquivm:=Build_IsEquiv__mm^-1%morphism(ap10right_inverse)(ap10left_inverse)(fun_=>path_ishprop__).Definitioniso_equiv(sd:set_cat) (m:s<~>d):s<~=~>d:=Build_Isomorphic(@isiso_isequivsdm_).Global Instanceisequiv_isiso_isequivsd:IsEquiv(@iso_equivsd) | 0.Proof.refine(isequiv_adjointify(@iso_equivsd)(funm=>Build_Equiv___(@isequiv_isisosdmm))__);simplin*;clear;abstract(intros[? ?];simpl;unfoldiso_equiv;simpl;applyap;applypath_ishprop).Defined.Lemmapath_idtoequiv_idtoiso(sd:set_cat) (p:s=d):iso_equivsd(equiv_path__(aptrunctype_typep)) =idtoisoset_catp.Proof.applypath_isomorphic.casep.reflexivity.Defined.Endequiv_iso_set_cat.Sectionequiv_iso_prop_cat.Isomorphisms inprop_catare eqivalent to equivalences.Context`{Funext}.Definitionisiso_isequiv_propsd(m:morphismprop_catsd)`{IsEquiv__m}:IsIsomorphismm:=Build_IsIsomorphismprop_catsdmm^-1%function(path_forall__(eissectm))(path_forall__(eisretrm)).Definitionisequiv_isiso_propsd(m:morphismprop_catsd)`{IsIsomorphism___m}:IsEquivm:=Build_IsEquiv__mm^-1%morphism(ap10right_inverse)(ap10left_inverse)(fun_=>path_ishprop__).Definitioniso_equiv_prop(sd:prop_cat) (m:s<~>d):s<~=~>d:=Build_Isomorphic(@isiso_isequiv_propsdm_).Global Instanceisequiv_isiso_isequiv_propsd:IsEquiv(@iso_equiv_propsd) | 0.Proof.refine(isequiv_adjointify(@iso_equiv_propsd)(funm=>Build_Equiv___(@isequiv_isiso_propsdm_))__);simplin*;clear;abstract(intros[? ?];simpl;unfoldiso_equiv_prop;simpl;applyap;applypath_ishprop).Defined.Lemmapath_idtoequiv_idtoiso_prop(sd:prop_cat) (p:s=d):iso_equiv_propsd(equiv_path__(aptrunctype_typep)) =idtoisoprop_catp.Proof.applypath_isomorphic.casep.reflexivity.Defined.Endequiv_iso_prop_cat.Local CloseScopemorphism_scope.Global Instanceiscategory_set_cat`{Univalence}:IsCategoryset_cat.Proof.introsCD.eapply@isequiv_homotopic; [ |intro;applypath_idtoequiv_idtoiso].change(IsEquiv(iso_equivCDoequiv_pathCDo@ap__trunctype_typeCD)).typeclasseseauto.Defined.Global Instanceiscategory_prop_cat`{Univalence}:IsCategoryprop_cat.Proof.introsCD.eapply@isequiv_homotopic; [ |intro;applypath_idtoequiv_idtoiso_prop].change(IsEquiv(iso_equiv_propCDoequiv_pathCDo@ap__trunctype_typeCD)).typeclasseseauto.Defined.

--- Miscellaneous\Nameless.html ---
NamelessLibrary NamelessRequireImportBasics.Overture.Building blocks for a globally nameless style of tactic reasoninghypreturns any hypothesis, with subsequent failures backtracking through all hypothesesLtachyp:=multimatchgoalwithH:_|-_=>constr:(H)end.enforcefooensures thatfoois well-typedTactic Notation"enforce"open_constr(term) :=idtac.syntax_enforce[H:=body]ensures thatHhas a body which is syntactically equal tobodyTactic Notation"syntax_enforce" "["constr(H) ":="open_constr(body) "]" :=letH':= (evalunfoldHinH)inconstr_eqH'body.enforce[x=y]ensures that two terms, possibly containing holes, are judgmentally equalTactic Notation"enforce" "["open_constr(x) "="open_constr(y) "]" :=unifyxy.An exampleGoalEmpty->letX0:=ttinEmpty->Unit.Proof.intros.letH:=hypinenforce(H:Unit);syntax_enforce[H:=tt];enforce[H=_];enforce[_=H];enforce[H=tt].Abort.

--- Miscellaneous\Nat.html ---
NatLibrary NatNat.Paths has many dependencies, so if you do not need it, it is better to explicitly require only those files that you need.RequireExportNat.Core.RequireExportNat.Arithmetic.RequireExportNat.Paths.

--- Miscellaneous\NatCategory.html ---
NatCategoryLibrary NatCategoryDiscrete categories onnobjectsRequireImportCategory.CoreDiscreteCategoryIndiscreteCategory.RequireImportTypes.UnitTruncTypes.SumTypes.Empty.RequireImportBasics.Nat.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopenat_scope.ModuleExportCore.Finntypes, orCardinalityRepresentativeWe useEmptyfor0andUnitfor1so that we get nice judgmental behavior.
      TODO: this should be unified withSpaces.Finite.Fin.FixpointCardinalityRepresentative(n:nat) :Type0:=matchnwith| 0 =>Empty| 1 =>Unit|Sn'=>CardinalityRepresentativen'+Unitend.CoercionCardinalityRepresentative:nat>->Sortclass.Finnis an hSetGlobal Instancetrunc_cardinality_representative(n:nat):IsHSet(CardinalityRepresentativen).Proof.inductionn; [typeclasseseauto|].inductionn; [typeclasseseauto|].applyistrunc_S.intros[x|x] [y|y];typeclasseseauto.Qed.Define the categoriesnDefinitionnat_category(n:nat) :=matchnwith| 0 =>indiscrete_category0| 1 =>indiscrete_category1|S(Sn') =>discrete_category(S(Sn'))end.ModuleExportNatCategoryCoreNotations.Notation"0" := (nat_category0) :category_scope.Notation"1" := (nat_category1) :category_scope.Notation"2" := (nat_category2) :category_scope.Notation"3" := (nat_category3) :category_scope.Notation"4" := (nat_category4) :category_scope.Notation"5" := (nat_category5) :category_scope.Notation"6" := (nat_category6) :category_scope.Notation"7" := (nat_category7) :category_scope.Notation"8" := (nat_category8) :category_scope.Notation"9" := (nat_category9) :category_scope.EndNatCategoryCoreNotations.#[export]TypeclassesTransparentnat_category.#[export]HintUnfoldnat_category:core.Argumentsnat_category/ .EndCore.ModuleNotations.IncludeCore.NatCategoryCoreNotations.EndNotations.

--- Miscellaneous\natpair_integers.html ---
natpair_integersLibrary natpair_integersRequireImportHoTT.HIT.quotientHoTT.Universes.TruncType.RequireImportHoTT.Classes.implementations.peano_naturalsHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.interfaces.integersHoTT.Classes.theory.ringsHoTT.Classes.theory.groupsHoTT.Classes.theory.apartnessHoTT.Classes.orders.sumHoTT.Classes.orders.ringsHoTT.Classes.tactics.ring_tacHoTT.Classes.theory.naturals.Generalizable VariablesB.Importring_quote.Quoting.Instances.LocalSetUniverseMinimizationToSet.ModuleNatPair.ModuleImportPairT.RecordT(N:Type) :=C{pos:N;neg:N}.ArgumentsC{N}__.Argumentspos{N}_.Argumentsneg{N}_.Sectioncontents.UniverseUNUNalt.Context(N:Type@{UN}) `{Naturals@{UNUNUNUNUNUNUNUNalt}N}.Global InstanceT_set:IsHSet(TN).Proof.assert(E:sig(fun_:N=>N) <~> (TN)).-issig.-apply(istrunc_equiv_istrunc_E).Qed.Global Instanceinject:CastN(TN) :=funx=>Cx0.Definitionequiv:=funxy=>posx+negy=posy+negx.Global Instanceequiv_is_equiv_rel@{} :EquivRelequiv.Proof.split.-hnf.reflexivity.-hnf.unfoldequiv.intros??;applysymmetry.-hnf.unfoldequiv.introsabcE1E2.apply(left_cancellation(+) (negb)).rewrite(plus_assoc(negb) (posa)).rewrite(plus_comm(negb) (posa)),E1.rewrite(plus_comm(posb)).rewrite<-plus_assoc.rewriteE2.rewrite(plus_comm(posc) (negb)).rewriteplus_assoc.rewrite(plus_comm(nega)).rewrite<-plus_assoc.rewrite(plus_comm(nega)).reflexivity.Qed.Instancepl:Plus(TN) :=funxy=>C(posx+posy) (negx+negy).Instanceml:Mult(TN) :=funxy=>C(posx*posy+negx*negy) (posx*negy+negx*posy).Instanceopp:Negate(TN) :=funx=>C(negx) (posx).InstanceSR0:Zero(TN) :=C0 0.InstanceSR1:One(TN) :=C1 0.Lemmapl_respects:forallq1q2,equivq1q2->forallr1r2,equivr1r2->equiv(q1+r1) (q2+r2).Proof.unfoldequiv;simpl.introsq1q2Eqr1r2Er.rewrite(plus_assoc_(negq2)).rewrite<-(plus_assoc(posq1)).rewrite(plus_comm(posr1)).rewrite(plus_assoc(posq1)).rewriteEq.rewrite<-(plus_assoc_(posr1)).rewriteEr.rewriteplus_assoc.rewrite<-(plus_assoc(posq2)).rewrite(plus_comm(negq1)).rewrite!plus_assoc.reflexivity.Qed.Lemmaml_respects:forallq1q2,equivq1q2->forallr1r2,equivr1r2->equiv(q1*r1) (q2*r2).Proof.introsq1q2Eqr1r2Er.transitivity(q1*r2);unfoldequivin*;simpl.-transitivity(posq1* (posr1+negr2) +negq1* (negr1+posr2)).+rewrite2!plus_mult_distr_l.rewrite<-2!plus_assoc.applyap.rewrite2!plus_assoc.rewrite(plus_comm(negq1*negr1)).reflexivity.+rewriteEr.rewriteplus_mult_distr_l.rewrite(plus_comm(negr1)).rewrite<-Er.rewriteplus_mult_distr_l.rewrite<-2!plus_assoc.applyap.rewrite(plus_comm(negq1*posr1)).rewrite2!plus_assoc.rewrite(plus_comm(posq1*negr1)).reflexivity.-transitivity((posq1+negq2) *posr2+ (negq1+posq2) *negr2).+rewrite2!plus_mult_distr_r.rewrite<-2!plus_assoc;applyap.rewrite(plus_comm(posq2*negr2)).rewrite2!plus_assoc.rewrite(plus_comm(negq1*negr2)).reflexivity.+rewriteEq,plus_mult_distr_r.rewrite(plus_comm(negq1)),<-Eq,plus_mult_distr_r.rewrite<-2!plus_assoc.applyap.rewriteplus_assoc,(plus_comm(negq1*posr2)).applyplus_comm.Qed.Lemmaopp_respects:forallq1q2,equivq1q2->equiv(oppq1) (oppq2).Proof.unfoldequiv;simpl.introsq1q2E.rewrite!(plus_comm(neg_)).symmetry.applyE.Qed.DefinitionTle:Le(TN):=funab=>posa+negb<=posb+nega.DefinitionTlt:Lt(TN):=funab=>posa+negb<posb+nega.DefinitionTapart:Apart(TN):=funab=>apart(posa+negb) (posb+nega).Global InstanceTle_hprop@{}:is_mere_relation(TN)Tle.Proof.intros;unfoldTle.applyfull_pseudo_srorder_le_hprop.Qed.Global InstanceTlt_hprop@{}:is_mere_relation(TN)Tlt.Proof.intros;unfoldTlt;apply_.Qed.Local Existing Instancepseudo_order_apart.Global InstanceTapart_hprop@{} :is_mere_relation(TN)Tapart.Proof.intros;unfoldTapart;apply_.Qed.Lemmale_respects_aux@{} :forallq1q2,equivq1q2->forallr1r2,equivr1r2->Tleq1r1->Tleq2r2.Proof.unfoldequiv,Tle;intros[pana] [pbnb]Eq[pcnc] [pdnd]ErE;simplin*.apply(order_reflecting(+ (pc+na))).assert(Erw:pb+nd+ (pc+na)= (pb+na) + (pc+nd))byring_with_nat.rewriteErw,<-Eq,Er;clearErw.assert(Erw:pa+nb+ (pd+nc) =pd+nb+ (pa+nc))byring_with_nat.rewriteErw.apply(order_preserving_),E.Qed.Lemmale_respects@{} :forallq1q2,equivq1q2->forallr1r2,equivr1r2->Tleq1r1<~>Tleq2r2.Proof.intros.applyequiv_iff_hprop_uncurried.split;applyle_respects_aux;trivial;applysymmetry;trivial.Qed.Lemmalt_respects_aux@{} :forallq1q2,equivq1q2->forallr1r2,equivr1r2->Tltq1r1->Tltq2r2.Proof.unfoldequiv,Tlt;intros[pana] [pbnb]Eq[pcnc] [pdnd]ErE;simplin*.apply(strictly_order_reflecting(+ (pc+na))).assert(Erw:pb+nd+ (pc+na)= (pb+na) + (pc+nd))byring_with_nat.rewriteErw,<-Eq,Er;clearErw.assert(Erw:pa+nb+ (pd+nc) =pd+nb+ (pa+nc))byring_with_nat.rewriteErw.apply(strictly_order_preserving_),E.Qed.Lemmalt_respects@{} :forallq1q2,equivq1q2->forallr1r2,equivr1r2->Tltq1r1<~>Tltq2r2.Proof.intros.applyequiv_iff_hprop_uncurried.split;applylt_respects_aux;trivial;applysymmetry;trivial.Qed.Lemmaapart_cotrans@{} :CoTransitiveTapart.Proof.hnf.unfoldTapart.introsq1q2Eqr.apply(strong_left_cancellation(+) (negr))inEq.apply(merely_destruct(cotransitiveEq(posr+negq1+negq2)));intros[E|E];applytr.-left.apply(strong_extensionality(+ (negq2))).assert(Hrw:posq1+negr+negq2=negr+ (posq1+negq2))byring_with_nat.rewriteHrw;clearHrw.trivial.-right.apply(strong_extensionality(+ (negq1))).assert(Hrw:posr+negq2+negq1=posr+negq1+negq2)byring_with_nat.rewriteHrw;clearHrw.assert(Hrw:posq2+negr+negq1=negr+ (posq2+negq1))byring_with_nat.rewriteHrw;clearHrw.trivial.Qed.Existing Instanceapart_cotrans.Instance:SymmetricTapart.Proof.hnf.unfoldTapart.intros??;applysymmetry.Qed.Lemmaapart_respects_aux@{}:forallq1q2,equivq1q2->forallr1r2,equivr1r2->Tapartq1r1->Tapartq2r2.Proof.assert(forallq1q2,equivq1q2->forallr,Tapartq1r->Tapartq2r)asE.-introsq1q2EqrEr.unfoldTapart,equivin*.apply(strong_extensionality(+ (negq1))).assert(Hrw:posq2+negr+negq1= (posq2+negq1) +negr)byring_with_nat.rewriteHrw;clearHrw.rewrite<-Eq.assert(Hrw:posq1+negq2+negr=negq2+ (posq1+negr))byring_with_nat.rewriteHrw;clearHrw.assert(Hrw:posr+negq2+negq1=negq2+ (posr+negq1))byring_with_nat;rewriteHrw;clearHrw.apply(strong_left_cancellation__),Er.-intros??Eq??ErE'.applyEwithq1;trivial.applysymmetry;applyEwithr1;applysymmetry;trivial.applysymmetry;trivial.Qed.Lemmaapart_respects:forallq1q2,equivq1q2->forallr1r2,equivr1r2->Tapartq1r1<~>Tapartq2r2.Proof.intros??Eq??Er.applyequiv_iff_hprop_uncurried.split;applyapart_respects_aux;trivial;applysymmetry;trivial.Qed.Sectionto_ring.Context{B:Type@{UNalt} } `{IsCRing@{UNalt}B}.Definitionto_ring@{} :TN->B.Proof.introsp.exact(naturals_to_semiringNB(posp) -naturals_to_semiringNB(negp)).Defined.Lemmato_ring_respects@{} :forallab,equivab->to_ringa=to_ringb.Proof.unfoldequiv;intros[pana] [pbnb]E.unfoldto_ring;simplin*.apply(left_cancellation(+)(naturals_to_semiringNBna+naturals_to_semiringNBnb)).path_via(naturals_to_semiringNBpa+naturals_to_semiringNBnb+ 0);[rewrite<-(plus_negate_r(naturals_to_semiringNBna));ring_with_nat|rewriteplus_0_r].path_via(naturals_to_semiringNBpb+naturals_to_semiringNBna+ 0);[rewriteplus_0_r|rewrite<-(plus_negate_r(naturals_to_semiringNBnb));ring_with_nat].rewrite<-2!preserves_plus.applyap,E.Qed.Endto_ring.Endcontents.Argumentsequiv{__}__.ArgumentsTle{___}__.ArgumentsTlt{___}__.ArgumentsTapart{___}__.Argumentsto_ringN{_}B{______} /_.EndPairT.Sectioncontents.UniverseUNUNalt.Context`{Funext} `{Univalence} (N:Type@{UN})`{Naturals@{UNUNUNUNUNUNUNUNalt}N}.(* Add Ring SR : (rings.stdlib_semiring_theory SR). *)InstanceN_fullpartial:FullPartialOrderAleAlt:=fullpseudo_fullpartial@{UNUNUNUNUNUNUNUlarge}.DefinitionZ@{} :Type@{UN} := @quotient_PairT.equiv@{UNUNalt}_.Global InstanceZ_of_pair:Cast(PairT.TN)Z:=class_of_.Global InstanceZ_of_N:CastNZ:=ComposeZ_of_pair(PairT.inject@{UNUNalt}_).DefinitionZ_path{xy} :PairT.equivxy->Z_of_pairx=Z_of_pairy:=related_classes_eq_.Definitionrelated_path{xy} :Z_of_pairx=Z_of_pairy->PairT.equivxy:=classes_eq_related@{UNUNUlargeUNUlarge}___.DefinitionZ_rect@{i} (P:Z->Type@{i}) {sP:forallx,IsHSet(Px)}(dclass:forallx:PairT.TN,P('x))(dequiv:forallxyE, (Z_pathE) # (dclassx) = (dclassy)):forallq,Pq:=quotient_indPairT.equivPdclassdequiv.DefinitionZ_computeP{sP}dclassdequivx: @Z_rectPsPdclassdequiv(Z_of_pairx) =dclassx:= 1.DefinitionZ_compute_pathP{sP}dclassdequivqr(E:PairT.equivqr):apD(@Z_rectPsPdclassdequiv) (Z_pathE) =dequivqrE:=quotient_ind_compute_path________.DefinitionZ_ind@{i} (P:Z->Type@{i}) {sP:forallx:Z,IsHProp(Px)}(dclass:forallx:PairT.TN,P(cast(PairT.TN)Zx)) :forallx:Z,Px.Proof.apply(Z_rect@{i}Pdclass).intros;applypath_ishprop@{i}.Defined.DefinitionZ_ind2(P:Z->Z->Type) {sP:forallxy,IsHProp(Pxy)}(dclass:forallxy:PairT.TN,P('x) ('y)) :forallxy,Pxy.Proof.apply(Z_ind(funx=>forally,_));introsx.apply(Z_ind_);introsy.applydclass.Defined.DefinitionZ_ind3@{ij} (P:Z->Z->Z->Type@{i}){sP:forallxyz:Z,IsHProp(Pxyz)}(dclass:forallxyz:PairT.TN,P('x) ('y) ('z)):forallxyz:Z,Pxyz.Proof.apply(@Z_ind(funx=>forallyz,_));introsx.2:apply(Z_ind2@{ij}_);auto.apply(@istrunc_forall@{UNjj}_).intros.applyistrunc_forall@{UNij}.Defined.DefinitionZ_rec@{i} {T:Type@{i} } {sT:IsHSetT}:forall(dclass:PairT.TN->T)(dequiv:forallxy,PairT.equivxy->dclassx=dclassy),Z->T:=quotient_rec_.DefinitionZ_rec_computeTsTdclassdequivx: @Z_recTsTdclassdequiv('x) =dclassx:= 1.DefinitionZ_rec2@{ij} {T:Type@{i} } {sT:IsHSetT}:forall(dclass:PairT.TN->PairT.TN->T)(dequiv:forallx1x2,PairT.equivx1x2->forally1y2,PairT.equivy1y2->dclassx1y1=dclassx2y2),Z->Z->T:= @quotient_rec2@{UNUNUNji}_____(Build_HSet_).DefinitionZ_rec2_compute{TsT}dclassdequivxy: @Z_rec2TsTdclassdequiv('x) ('y) =dclassxy:= 1.Lemmadec_Z_of_pair`{DecidablePathsN} :forallqr:PairT.TN,Decidable('q= 'r).Proof.introsqr.destruct(dec(PairT.equivqr))as[E|E].-left.applyZ_path,E.-right.introsE'.applyE.apply(related_pathE').Defined.Global InstanceR_dec`{DecidablePathsN}:DecidablePathsZ.Proof.hnf.apply(Z_ind2_).applydec_Z_of_pair.Defined.(* Relations, operations and constants *)Global InstanceZ0:ZeroZ:= ' 0.Global InstanceZ1:OneZ:= ' 1.Global InstanceZ_plus@{} :PlusZ.Proof.refine(Z_rec2(funxy=> ' (PairT.pl@{UNUNalt}_xy))_).intros;applyZ_path;eapplyPairT.pl_respects;trivial.Defined.DefinitionZ_plus_computeqr: ('q) + ('r) = ' (PairT.pl_qr):= 1.Global InstanceZ_mult@{} :MultZ.Proof.refine(Z_rec2(funxy=> ' (PairT.ml@{UNUNalt}_xy))_).intros;applyZ_path;eapplyPairT.ml_respects;trivial.Defined.(* Without this, typeclass resolution for e.g.MonoidZZ_plustries to get it fromSemiRingZZ_plus?multand fills the evar with the unfolded value, which does case analysis on quotient. *)Global Typeclasses OpaqueZ_plusZ_mult.DefinitionZ_mult_computeqr: ('q) * ('r) = ' (PairT.ml_qr):= 1.Global InstanceZ_negate@{} :NegateZ.Proof.red.apply(Z_rec(funx=> ' (PairT.opp@{UNUNalt}_x))).intros;applyZ_path;eapplyPairT.opp_respects;trivial.Defined.DefinitionZ_negate_computeq: - ('q) = ' (PairT.opp_q):= 1.LemmaZ_ring@{} :IsCRingZ.Proof.repeatsplit.1,8:exact_.all:first[changesg_opwithmult;changemon_unitwith1 |changesg_opwithplus;changemon_unitwith0];hnf.-apply(Z_ind3_).introsabc;applyZ_path;red;simpl.rewrite!plus_assoc.reflexivity.-apply(Z_ind_).introsa;applyZ_path;red;simpl.rewrite!plus_0_l.reflexivity.-apply(Z_ind_).introsa;applyZ_path;red;simpl.rewrite!plus_0_r.reflexivity.-apply(Z_ind_).introsa;applyZ_path;red;simpl.rewriteplus_0_l,plus_0_r.applyplus_comm.-apply(Z_ind_).introsa;applyZ_path;red;simpl.rewriteplus_0_l,plus_0_r.applyplus_comm.-apply(Z_ind2_).introsab;applyZ_path;red;simpl.applyap011;applyplus_comm.-apply(Z_ind3_).intros[pana] [pbnb] [pcnc];applyZ_path;red;simpl.ring_with_nat.-apply(Z_ind_).intros;applyZ_path;red;simpl.ring_with_nat.-apply(Z_ind_).intros;applyZ_path;red;simpl.ring_with_nat.-apply(Z_ind2_).intros;applyZ_path;red;simpl.ring_with_nat.-apply(Z_ind3_).intros[pana] [pbnb] [pcnc];applyZ_path;red;simpl.ring_with_nat.Qed.(* A final word about inject *)LemmaZ_of_N_morphism@{} :IsSemiRingPreserving(castNZ).Proof.repeat(constructor;tryapply_).-introsxy.applyZ_path.red.simpl.ring_with_nat.-introsxy.applyZ_path.red;simpl.ring_with_nat.Qed.Global Existing InstanceZ_of_N_morphism.Global InstanceZ_of_N_injective@{} :IsInjective(castNZ).Proof.introsxyE.applyrelated_pathinE.redinE.simplinE.rewrite2!plus_0_rinE.trivial.Qed.LemmaNpair_splits@{} :forallnm:N, ' (PairT.Cnm) = 'n+ - 'm.Proof.intros.applyZ_path;red;simpl.ring_with_nat.Qed.DefinitionZle_HProp@{} :Z->Z->HProp@{UN}.Proof.apply(@Z_rec2@{UlargeUlarge}_(@trunctype_istrunc@{Ularge}__)(funqr=>Build_HProp(PairT.Tleqr))).intros.applypath_hprop.simpl.apply(PairT.le_respects_);trivial.Defined.Global InstanceZle@{} :LeZ:=funxy=>Zle_HPropxy.Global Instanceishprop_Zle:is_mere_relation_Zle.Proof.unfoldZle;exact_.Qed.LemmaZle_def@{} :forallab:PairT.TN,@paths@{Uhuge}Type@{UN} ('a<= 'b) (PairT.Tle@{UNUNalt}ab).Proof.intros;exactidpath.Qed.LemmaZ_partial_order':PartialOrderZle.Proof.split;[apply_|apply_|split|].-hnf.apply(Z_ind_).intros.change(PairT.Tlexx).red.reflexivity.-hnf.apply(Z_ind3(fun___=>_->_->_)).intros[pana] [pbnb] [pcnc].rewrite!Zle_def;unfoldPairT.Tle;simpl.introsE1E2.apply(order_reflecting(+ (nb+pb))).assert(Hrw:pa+nc+ (nb+pb) = (pa+nb) + (pb+nc))byabstractring_with_nat.rewriteHrw;clearHrw.assert(Hrw:pc+na+ (nb+pb) = (pb+na) + (pc+nb))byabstractring_with_nat.rewriteHrw;clearHrw.applyplus_le_compat;trivial.-hnf.apply(Z_ind2(fun__=>_->_->_)).intros[pana] [pbnb];rewrite!Zle_def;unfoldPairT.Tle;simpl.introsE1E2;applyZ_path;red;simpl.apply(antisymmetryle);trivial.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)InstanceZ_partial_order@{} :PartialOrderZle:=ltac:(first[exactZ_partial_order'@{UlargeUlargeUlargeUlargeUlarge}|exactZ_partial_order']).LemmaZle_cast_embedding':OrderEmbedding(castNZ).Proof.split;red.-intros.rewriteZle_def.unfoldPairT.Tle.simpl.rewrite2!plus_0_r;trivial.-intros??.rewriteZle_def.unfoldPairT.Tle.simpl.rewrite2!plus_0_r;trivial.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)Global InstanceZle_cast_embedding@{} :OrderEmbedding(castNZ):=ltac:(first[exactZle_cast_embedding'@{UlargeUlarge}|exactZle_cast_embedding']).LemmaZle_plus_preserving_l':forallz:Z,OrderPreserving((+)z).Proof.red.apply(Z_ind3(fun___=>_->_)).intros[pcnc] [pana] [pbnb].rewrite!Zle_def;unfoldPairT.Tle;simpl.introsE.assert(Hrw:pc+pa+ (nc+nb) = (pc+nc) + (pa+nb))byring_with_nat.rewriteHrw;clearHrw.assert(Hrw:pc+pb+ (nc+na) = (pc+nc) + (pb+na))byring_with_nat.rewriteHrw;clearHrw.apply(order_preserving_),E.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)InstanceZle_plus_preserving_l@{} :forallz:Z,OrderPreserving((+)z):=ltac:(first[exactZle_plus_preserving_l'@{UlargeUlarge}|exactZle_plus_preserving_l']).LemmaZmult_nonneg':forallxy:Z,PropHolds(0 ≤x) ->PropHolds(0 ≤y) ->PropHolds(0 ≤x*y).Proof.unfoldPropHolds.apply(Z_ind2(fun__=>_->_->_)).intros[pana] [pbnb].rewrite!Zle_def;unfoldPairT.Tle;simpl.rewrite!plus_0_l,!plus_0_r.introsE1E2.destruct(decompose_leE1)as[a[Ea1Ea2]], (decompose_leE2)as[b[Eb1Eb2]].rewriteEa2,Eb2.applycompose_lewith(a*b).-applynonneg_mult_compat;trivial.-ring_with_nat.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)InstanceZmult_nonneg@{} :forallxy:Z,PropHolds(0 ≤x) ->PropHolds(0 ≤y) ->PropHolds(0 ≤x*y):=ltac:(first[exactZmult_nonneg'@{UlargeUlargeUlarge}|exactZmult_nonneg']).Global InstanceZ_order@{} :SemiRingOrderZle.Proof.poseproofZ_ring;applyrings.from_ring_order;apply_.Qed.(* Make this computable? Would need to compute through Z_ind2. *)Global InstanceZle_dec`{forallxy:N,Decidable(x<=y)}:forallxy:Z,Decidable(x<=y).Proof.apply(Z_ind2_).introsab.change(Decidable(PairT.Tleab)).unfoldPairT.Tle.apply_.Qed.DefinitionZlt_HProp@{} :Z->Z->HProp@{UN}.Proof.apply(@Z_rec2@{UlargeUlarge}_(@trunctype_istrunc@{Ularge}__)(funqr=>Build_HProp(PairT.Tltqr))).intros.applypath_hprop.simpl.apply(PairT.lt_respects_);trivial.Defined.Global InstanceZlt@{} :LtZ:=funxy=>Zlt_HPropxy.Global Instanceishprop_Zlt:is_mere_relation_Zlt.Proof.unfoldZlt;exact_.Qed.LemmaZlt_def':forallab, 'a< 'b=PairT.Tltab.Proof.reflexivity.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)DefinitionZlt_def@{i} :=ltac:(first[exactZlt_def'@{Uhugei}|exactZlt_def'@{i}]).LemmaZlt_strict':StrictOrderZlt.Proof.split.-apply_.-(* we need to change so that it sees Empty,needed to figure out IsHProp (using Funext) *)change(forallx,x<x->Empty).apply(Z_ind(fun_=>_->_)).intros[pana];rewriteZlt_def;unfoldPairT.Tlt;simpl.applyirreflexivity,_.-hnf.apply(Z_ind3(fun___=>_->_->_)).intros[pana] [pbnb] [pcnc];rewrite!Zlt_def;unfoldPairT.Tlt;simpl.introsE1E2.apply(strictly_order_reflecting(+ (nb+pb))).assert(Hrw:pa+nc+ (nb+pb) = (pa+nb) + (pb+nc))byring_with_nat.rewriteHrw;clearHrw.assert(Hrw:pc+na+ (nb+pb) = (pb+na) + (pc+nb))byring_with_nat.rewriteHrw;clearHrw.applyplus_lt_compat;trivial.Qed.InstanceZlt_strict@{} :StrictOrderZlt:=ltac:(first[exactZlt_strict'@{UlargeUlargeUlargeUlargeUlarge}|exactZlt_strict'@{}]).Lemmaplus_strict_order_preserving_l':forallz:Z,StrictlyOrderPreserving((+)z).Proof.red;apply(Z_ind3(fun___=>_->_)).intros[pana] [pbnb] [pcnc].rewrite!Zlt_def;unfoldPairT.Tlt;simpl.introsE.assert(Hrw:pa+pb+ (na+nc) = (pa+na) + (pb+nc))byring_with_nat.rewriteHrw;clearHrw.assert(Hrw:pa+pc+ (na+nb) = (pa+na) + (pc+nb))byring_with_nat.rewriteHrw;clearHrw.apply(strictly_order_preserving_),E.Qed.InstanceZplus_strict_order_preserving_l@{}:forallz:Z,StrictlyOrderPreserving((+)z):=ltac:(first[exactplus_strict_order_preserving_l'@{UlargeUlarge}|exactplus_strict_order_preserving_l'@{}]).LemmaZmult_pos':forallxy:Z,PropHolds(0 <x) ->PropHolds(0 <y) ->PropHolds(0 <x*y).Proof.unfoldPropHolds.apply(Z_ind2(fun__=>_->_->_)).intros[pana] [pbnb].rewrite!Zlt_def;unfoldPairT.Tlt;simpl.rewrite!plus_0_l,!plus_0_r.introsE1E2.destruct(decompose_ltE1)as[a[Ea1Ea2]], (decompose_ltE2)as[b[Eb1Eb2]].rewriteEa2,Eb2.applycompose_ltwith(a*b).-applypos_mult_compat;trivial.-ring_with_nat.Qed.InstanceZmult_pos@{} :forallxy:Z,PropHolds(0 <x) ->PropHolds(0 <y) ->PropHolds(0 <x*y):=ltac:(first[exactZmult_pos'@{UlargeUlargeUlarge}|exactZmult_pos'@{}]).Global InstanceZ_strict_srorder:StrictSemiRingOrderZlt.Proof.poseproofZ_ring;applyfrom_strict_ring_order;apply_.Qed.Global InstanceZlt_dec`{forallxy:N,Decidable(x<y)}:forallxy:Z,Decidable(x<y).Proof.apply(Z_ind2_).introsab.change(Decidable(PairT.Tltab)).unfoldPairT.Tlt.apply_.Qed.Local Existing Instancepseudo_order_apart.DefinitionZapart_HProp@{} :Z->Z->HProp@{UN}.Proof.apply(@Z_rec2@{UlargeUlarge}__(funqr=>Build_HProp(PairT.Tapartqr))).intros.applypath_hprop.simpl.apply(PairT.apart_respects_);trivial.Defined.Global InstanceZapart@{} :ApartZ:=funxy=>Zapart_HPropxy.LemmaZapart_def':forallab,apart('a) ('b) =PairT.Tapartab.Proof.reflexivity.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)DefinitionZapart_def@{i} :=ltac:(first[exactZapart_def'@{Uhugei}|exactZapart_def'@{i}]).Global Instanceishprop_Zapart:is_mere_relation_Zapart.Proof.unfoldZapart;exact_.Qed.LemmaZ_trivial_apart'`{!TrivialApartN}:TrivialApartZ.Proof.split;[exact_|idtac].apply(Z_ind2_).intros[pana] [pbnb];rewriteZapart_def;unfoldPairT.Tapart;simpl.split;introsE1.-introsE2.applyrelated_pathinE2.redinE2;simplinE2.applytrivial_apartinE1.auto.-applytrivial_apart.introsE2.applyE1,Z_path.red;simpl.trivial.Qed.Global InstanceZ_trivial_apart@{} `{!TrivialApartN}:TrivialApartZ:=ltac:(first[exactZ_trivial_apart'@{Ularge}|exactZ_trivial_apart'@{}]).LemmaZ_is_apart':IsApartZ.Proof.split.-apply_.-apply_.-hnf.apply(Z_ind2(fun__=>_->_)).intros[pana] [pbnb];rewrite!Zapart_def;unfoldPairT.Tapart;simpl.applysymmetry.-hnf.introsxyEz;revertxyzE.apply(Z_ind3(fun___=>_->_)).introsabc;rewrite!Zapart_def;unfoldPairT.Tapart;simpl.introsE1.apply(strong_left_cancellation(+) (PairT.negc))inE1.eapply(merely_destruct(cotransitiveE1_));intros[E2|E2];applytr.+left.apply(strong_extensionality(+ (PairT.negb))).assert(Hrw:PairT.posa+PairT.negc+PairT.negb=PairT.negc+ (PairT.posa+PairT.negb))byring_with_nat;rewriteHrw;exactE2.+right.apply(strong_extensionality(+ (PairT.nega))).assert(Hrw:PairT.posc+PairT.negb+PairT.nega=PairT.posc+PairT.nega+PairT.negb)byring_with_nat;rewriteHrw;clearHrw.assert(Hrw:PairT.posb+PairT.negc+PairT.nega=PairT.negc+ (PairT.posb+PairT.nega))byring_with_nat;rewriteHrw;clearHrw.trivial.-apply(Z_ind2_).introsab;rewriteZapart_def;unfoldPairT.Tapart.split;introsE.+applyZ_path;red.applytight_apart,E.+applyrelated_pathinE.applytight_apart,E.Qed.InstanceZ_is_apart@{} :IsApartZ:=ltac:(first[exactZ_is_apart'@{UlargeUlargeUlargeUlargeUlargeUlarge}|exactZ_is_apart'@{}]).LemmaZ_full_psorder':FullPseudoOrderZleZlt.Proof.split;[apply_|split;tryapply_|].-apply(Z_ind2_).introsab;rewrite!Zlt_def;unfoldPairT.Tlt.applypseudo_order_antisym.-hnf.introsabEc;revertabcE.apply(Z_ind3(fun___=>_->_)).intros[pana] [pbnb] [pcnc];rewrite!Zlt_def;unfoldPairT.Tlt.introsE1.apply(strictly_order_preserving(+nc))inE1.eapply(merely_destruct(cotransitiveE1_));intros[E2|E2];applytr.+left.apply(strictly_order_reflecting((nb) +)).assert(Hrw:nb+ (pa+nc) =pa+nb+nc)byring_with_nat;rewriteHrw;exactE2.+right.apply(strictly_order_reflecting((na) +)).assert(Hrw:na+ (pc+nb) =nb+ (pc+na))byring_with_nat;rewriteHrw;clearHrw.assert(Hrw:na+ (pb+nc) =pb+na+nc)byring_with_nat;rewriteHrw;clearHrw.trivial.-apply@Z_ind2.+introsab.apply@istrunc_prod;[|apply_].apply(@istrunc_arrow_).applyishprop_sum;tryapply_.introsE1E2;apply(irreflexivitylta).transitivityb;trivial.+introsab;rewriteZapart_def,!Zlt_def;unfoldPairT.Tapart,PairT.Tlt.applyapart_iff_total_lt.-apply(Z_ind2_).introsab;rewriteZle_def,Zlt_def;unfoldPairT.Tlt,PairT.Tle.applyle_iff_not_lt_flip.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)InstanceZ_full_psorder@{} :FullPseudoOrderZleZlt:=ltac:(first[exactZ_full_psorder'@{UlargeUlargeUlargeUlargeUlargeUlargeUlargeUlargeUlarge}|exactZ_full_psorder'@{UlargeUlargeUlargeUlargeUlargeUlargeUlargeUlargeUlargeUlarge}|exactZ_full_psorder'@{}]).LemmaZmult_strong_ext_l':forallz:Z,StrongExtensionality(z*.).Proof.red;apply(Z_ind3(fun___=>_->_)).intros[zpzn] [xpxn] [ypyn];rewrite!Zapart_def;unfoldPairT.Tapart;simpl.introsE1.refine(merely_destruct(strong_binary_extensionality(+)(zp* (xp+yn)) (zn* (yp+xn)) (zp* (yp+xn)) (zn* (xp+yn))_)_).-assert(Hrw:zp* (xp+yn) +zn* (yp+xn)=zp*xp+zn*xn+ (zp*yn+zn*yp))byring_with_nat;rewriteHrw;clearHrw.assert(Hrw:zp* (yp+xn) +zn* (xp+yn)=zp*yp+zn*yn+ (zp*xn+zn*xp))byring_with_nat;rewriteHrw;exactE1.-intros[E2|E2].+apply(strong_extensionality(zp*.)).trivial.+applysymmetry;apply(strong_extensionality(zn*.)).trivial.Qed.InstanceZmult_strong_ext_l@{} :forallz:Z,StrongExtensionality(z*.):=ltac:(first[exactZmult_strong_ext_l'@{UlargeUlarge}|exactZmult_strong_ext_l'@{}]).InstanceZ_full_pseudo_srorder@{}:FullPseudoSemiRingOrderZleZlt.Proof.poseproofZ_ring.first[applyfrom_full_pseudo_ring_order@{UNUNUNUNUNUNUNUlarge}|applyfrom_full_pseudo_ring_order];tryapply_.applyapartness.strong_binary_setoid_morphism_commutative.Qed.GoalFullPseudoSemiRingOrderZleZlt.Proof.FailexactZ_full_pseudo_srorder@{i}.Abort.Global InstanceZ_to_ring@{} :IntegersToRing@{UNUNalt}Z.Proof.red.introsR??????.eapplyZ_rec.apply(PairT.to_ring_respectsN).Defined.LemmaZ_to_ring_morphism'`{IsCRingB} :IsSemiRingPreserving(integers_to_ringZB).Proof.split;split;red.-change(@sg_opB_)with(@plusB_);change(@sg_opZ_)with(@plusZ_).apply(Z_ind2_).intros[pana] [pbnb].unfoldintegers_to_ring;simpl.rewrite!(preserves_plus(f:=naturals_to_semiringNB)).rewritenegate_plus_distr.ring_with_nat.-change(@mon_unitB_)with(@zeroB_);change(@mon_unitZ_)with(@zeroZ_).unfoldintegers_to_ring;simpl.rewrite(preserves_0(f:=naturals_to_semiringNB)).rewritenegate_0,plus_0_r;trivial.-change(@sg_opB_)with(@multB_);change(@sg_opZ_)with(@multZ_).apply(Z_ind2_).intros[pana] [pbnb].unfoldintegers_to_ring;simpl.rewrite!(preserves_plus(f:=naturals_to_semiringNB)).rewrite!(preserves_mult(f:=naturals_to_semiringNB)).rewrite(preserves_plus(f:=naturals_to_semiringNB)).rewrite!(preserves_mult(f:=naturals_to_semiringNB)).rewritenegate_plus_distr.rewritenegate_mult_distr_r,negate_mult_distr_l.rewrite<-(negate_mult_negate(naturals_to_semiringNBna)(naturals_to_semiringNBnb)).ring_with_nat.-change(@mon_unitB_)with(@oneB_);change(@mon_unitZ_)with(@oneZ_).unfoldintegers_to_ring;simpl.rewrite(preserves_1(f:=naturals_to_semiringNB)).rewrite(preserves_0(f:=naturals_to_semiringNB)).rewritenegate_0,plus_0_r;trivial.Qed.InstanceZ_to_ring_morphism@{} `{IsCRingB} :IsSemiRingPreserving(integers_to_ringZB):=ltac:(first[exactZ_to_ring_morphism'@{Ularge}|exactZ_to_ring_morphism'@{}]).LemmaZ_to_ring_unique@{} `{IsCRingB} (h:Z->B) `{!IsSemiRingPreservingh}:forallx:Z,integers_to_ringZBx=hx.Proof.poseproofZ_ring.apply(Z_ind_).intros[pana];unfoldintegers_to_ring;simpl.rewriteNpair_splits.rewrite(preserves_plus(f:=h)),(preserves_negate(f:=h)).change(h('pa))with(Composeh(castNZ)pa).change(h('na))with(Composeh(castNZ)na).rewrite2!(naturals_initial(h:=Composeh(castNZ))).trivial.Qed.Global InstanceZ_integers@{} :IntegersZ.Proof.split;tryapply_.-applyZ_ring.-apply@Z_to_ring_unique.Qed.Context`{!NatDistanceN}.LemmaZ_abs_aux_0@{} :forallabz:N,a+z=b->z= 0 ->naturals_to_semiringNZ0 = ' {|PairT.pos:=a;PairT.neg:=b|}.Proof.introsabzEE'.rewrite(preserves_0(A:=N)).rewriteE',plus_0_rinE.rewriteE.applyZ_path.red;simpl.applyplus_comm.Qed.LemmaZ_abs_aux_neg@{} :forallabz:N,a+z=b->naturals_to_semiringNZz= - ' {|PairT.pos:=a;PairT.neg:=b|}.Proof.introsabzE.rewrite<-(naturals.to_semiring_unique(castNZ)).applyZ_path.red;simpl.rewriteplus_0_r,plus_comm;trivial.Qed.LemmaZ_abs_aux_pos@{} :forallabz:N,b+z=a->naturals_to_semiringNZz= ' {|PairT.pos:=a;PairT.neg:=b|}.Proof.introsabzE.rewrite<-(naturals.to_semiring_unique(castNZ)).applyZ_path;red;simpl.rewriteplus_0_r,plus_comm;trivial.Qed.(* We use decidability of equality on Nto make sure we always go left when the inputs are equal.Otherwise we would have to truncate IntAbs. *)DefinitionZ_abs_def@{} :forallx:PairT.TN,(existsn:N,naturals_to_semiringNZn= 'x)|_| (existsn:N,naturals_to_semiringNZn= - 'x).Proof.intros[ab].destruct(nat_distance_sigab)as[[zE]|[zE]].-destruct(dec(z= 0))as[E'|_].+left.exists0.applyZ_abs_aux_0withz;trivial.+right.existsz.applyZ_abs_aux_neg;trivial.-left.existsz.applyZ_abs_aux_pos;trivial.Defined.LemmaZ_abs_respects':forall(xy:PairT.TN) (E:PairT.equivxy),transport(funq:Z=>(existsn:N,naturals_to_semiringNZn=q)|_| (existsn:N,naturals_to_semiringNZn= -q)) (Z_pathE) (Z_abs_defx)=Z_abs_defy.Proof.intros[papb] [nanb]E.redinE;simplinE.unfoldZ_abs_def.destruct(nat_distance_sigpapb)as[[z1E1] | [z1E1]];simpl.-destruct(dec(z1= 0))as[E2|E2].+rewriteSum.transport_sum.rewriteSigma.transport_sigma.destruct(nat_distance_signanb)as[[z2E3] | [z2E3]];[destruct(dec(z2= 0))as[E4|E4]|];simpl.*applyap.applySigma.path_sigma_hprop;simpl.applyPathGroupoids.transport_const.*destructE4.rewrite<-E1,<-E3,E2,plus_0_r,<-(plus_0_r(na+pa))inE.rewriteplus_assoc,(plus_commpa)inE.apply(left_cancellationplus_)inE.trivial.*applyap.applySigma.path_sigma_hprop.simpl.rewritePathGroupoids.transport_const.rewriteE2,plus_0_rinE1.rewrite<-E3,E1inE.apply(left_cancellationplus(pb+nb)).rewriteplus_0_r.etransitivity;[applyE|].ring_with_nat.+rewriteSum.transport_sum,Sigma.transport_sigma.destruct(nat_distance_signanb)as[[z2E3] | [z2E3]];[destruct(dec(z2= 0))as[E4|E4]|];simpl.*destructE2.rewriteE4,plus_0_rinE3;rewrite<-E1,<-E3inE.apply(left_cancellationplus(pa+na)).rewrite(plus_commpana),plus_0_r,<-plus_assoc.rewrite(plus_commnapa).symmetry;trivial.*applyap.applySigma.path_sigma_hprop.simpl.rewritePathGroupoids.transport_const.rewrite<-E1,<-E3inE.apply(left_cancellationplus(pa+na)).rewrite<-(plus_assocpanaz2),(plus_commpana),<-plus_assoc.symmetry;trivial.*destructE2.rewrite<-E1,<-E3inE.assert(Erw:nb+z2+ (pa+z1) = (pa+nb) + (z2+z1))byring_with_nat.rewrite<-(plus_0_r(pa+nb)),ErwinE.apply(left_cancellationplus_),symmetry,naturals.zero_suminE.applyE.-rewriteSum.transport_sum,Sigma.transport_sigma.simpl.destruct(nat_distance_signanb)as[[z2E3] | [z2E3]];[destruct(dec(z2= 0))as[E4|E4]|];simpl.+applyap.applySigma.path_sigma_hprop.simpl.rewritePathGroupoids.transport_const.rewrite<-E1,<-E3,E4,plus_0_rinE.apply(left_cancellationplus(na+pb)).rewriteplus_0_r.path_via(pb+z1+na).ring_with_nat.+destructE4.rewrite<-E1,<-E3inE.assert(Hrw:pb+z1+ (na+z2) = (na+pb) + (z1+z2))byring_with_nat.rewrite<-(plus_0_r(na+pb)),HrwinE.apply(left_cancellation__),naturals.zero_suminE.applyE.+applyap,Sigma.path_sigma_hprop.simpl.rewritePathGroupoids.transport_const.rewrite<-E1,<-E3inE.apply(left_cancellationplus(pb+nb)).path_via(pb+z1+nb);[|path_via(nb+z2+pb)];ring_with_nat.Qed.LemmaZ_abs':IntAbsZN.Proof.red.apply(Z_rect_Z_abs_def).exactZ_abs_respects'.Qed.Global InstanceZ_abs@{} :IntAbs@{UNUNUNUNUNUNUNUNUNUNUNUNUNUNUNUNUN}ZN:=Z_abs'.Notationn_to_z:= (naturals_to_semiringNZ).Definitionzero_product_auxab:n_to_za*n_to_zb= 0 ->n_to_za= 0 |_|n_to_zb= 0.Proof.rewrite<-rings.preserves_mult.rewrite<-!(naturals.to_semiring_unique(castNZ)).introsE.change0with(' 0)inE.apply(injective_)inE.applyzero_productinE.destructEas[E|E];rewriteE;[left|right];applypreserves_0.Qed.LemmaZ_zero_product':ZeroProductZ.Proof.introsxyE.destruct(int_abs_sigZNx)as[[aEa]|[aEa]],(int_abs_sigZNy)as[[bEb]|[bEb]].-rewrite<-Ea,<-EbinE.applyzero_product_auxinE.rewrite<-Ea,<-Eb.trivial.-apply(apnegate)inE.rewritenegate_mult_distr_rinE.rewrite<-Ea,<-EbinE.rewritenegate_0inE.applyzero_product_auxinE.destructEas[E|E].+left;rewrite<-Ea;trivial.+right.apply(injectivenegate).rewritenegate_0,<-Eb;trivial.-apply(apnegate)inE.rewritenegate_mult_distr_linE.rewrite<-Ea,<-EbinE.rewritenegate_0inE.applyzero_product_auxinE.destructEas[E|E].+left.apply(injectivenegate).rewritenegate_0,<-Ea;trivial.+right;rewrite<-Eb;trivial.-rewrite<-negate_mult_negate,<-Ea,<-EbinE.applyzero_product_auxinE.destructEas[E|E].+left.apply(injectivenegate).rewritenegate_0,<-Ea;trivial.+right.apply(injectivenegate).rewritenegate_0,<-Eb;trivial.Qed.Global InstanceZ_zero_product@{} :ZeroProductZ:=ltac:(first[exactZ_zero_product'@{UlargeUlarge}|exactZ_zero_product'@{}]).Endcontents.ModuleInstances.Global Existing InstancesT_setinjectTle_hpropTlt_hpropTapart_hpropZ_of_pairZ_of_NR_decZ0Z1Z_plusZ_multZ_negateZ_of_N_injectiveZleishprop_ZleZle_cast_embeddingZ_orderZle_decZltishprop_ZltZ_strict_srorderZlt_decZapartishprop_ZapartZ_trivial_apartZ_to_ringZ_integersZ_absZ_zero_productZ_of_N_morphism.EndInstances.EndNatPair.

--- Miscellaneous\NatTrans.html ---
NatTransLibrary NatTransRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.RequireImportWildCat.Equiv.RequireImportWildCat.Square.RequireImportWildCat.Opposite.Wild Natural TransformationsTransformationsDefinitionA transformation is simply a family of 1-cells over some base typeAbetween the sections of two dependent functionsFandG. In most casesFandGwill be non-dependent functors.DefinitionTransformation{A:Type} {B:A->Type} `{forallx,IsGraph(Bx)}(FG:forall(x:A),Bx):=forall(a:A),Fa$->Ga.This lets us apply transformations to things. Identity Coercion tells coq that this coercion is in fact definitionally the identity map so it doesn't need to insert it, but merely rewrite definitionally when typechecking.IdentityCoercionfun_trans:Transformation>->Funclass.Notation"F $=> G" := (TransformationFG).The identity transformation between a functor and itself is the identity function at the section.Definitiontrans_id{AB:Type} `{Is01CatB} (F:A->B):F$=>F:=funa=>Id(Fa).Transformations can be composed pointwise.Definitiontrans_comp{AB:Type} `{Is01CatB}{FGK:A->B} (gamma:G$=>K) (alpha:F$=>G):F$=>K:=funa=>gammaa$oalphaa.Transformations can be prewhiskered by a function. This means we precompose both sides of the transformation with a function.Definitiontrans_prewhisker{AB:Type} {C:B->Type} {FG:forallx,Cx}`{Is01CatB} `{!forallx,IsGraph(Cx)}`{!forallx,Is01Cat(Cx)} (gamma:F$=>G) (K:A->B):FoK$=>GoK:=gammaoK.Transformations can be postwhiskered by a function. This means we postcompose both sides of the transformation with a function.Definitiontrans_postwhisker{ABC:Type} {FG:A->B}(K:B->C) `{Is01CatB,Is01CatC, !Is0FunctorK} (gamma:F$=>G):KoF$=>KoG:=funa=>fmapK(gammaa).A transformation in the opposite category is simply a transformation in the original category with the direction swapped.Definitiontrans_op{A} {B} `{Is01CatB}(F:A->B) (G:A->B) (alpha:F$=>G):Transformation(A:=A^op) (B:=fun_=>B^op)G(F:A^op->B^op):=alpha.NaturalityA transformation is 1-natural if there exists a 2-cell witnessing the naturality square. The codomain of the transformation must be a wild 1-category.ClassIs1Natural{AB:Type} `{IsGraphA,Is1CatB}(F:A->B) `{!Is0FunctorF} (G:A->B) `{!Is0FunctorG}(alpha:F$=>G) :=Build_Is1Natural'{isnat{aa'} (f:a$->a') :alphaa'$ofmapFf$==fmapGf$oalphaa;We also include the transposed naturality square in the definition so that opposite natural transformations are definitionally involutive. In most cases, this will be constructed to be the inverse of theisnatfield.isnat_tr{aa'} (f:a$->a') :fmapGf$oalphaa$==alphaa'$ofmapFf;}.ArgumentsIs1Natural{AB} {isgraph_A}{isgraph_B} {is2graph_B} {is01cat_B} {is1cat_B}F{is0functor_F}G{is0functor_G}alpha:rename.Argumentsisnat{___________}alpha{alnat__}f:rename.Argumentsisnat_tr{___________}alpha{alnat__}f:rename.We coerce naturality proofs to their naturality square as theisnatprojection can be unwieldy in certain situations where the transformation is difficult to write down. This allows for the naturality proof to be used directly.Coercionisnat:Is1Natural>->Funclass.DefinitionBuild_Is1Natural{AB:Type} `{IsGraphA} `{Is1CatB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG} (alpha:F$=>G)(isnat:forallaa'(f:a$->a'),alphaa'$ofmapFf$==fmapGf$oalphaa):Is1NaturalFGalpha.Proof.snrapplyBuild_Is1Natural'.-exactisnat.-introsaa'f.exact(isnataa'f)^$.Defined.The identity transformation is 1-natural.Global Instanceis1natural_id{AB:Type} `{IsGraphA} `{Is1CatB}(F:A->B) `{!Is0FunctorF}:Is1NaturalFF(trans_idF).Proof.snrapplyBuild_Is1Natural.introsabf;cbn.refine(cat_idl_$@ (cat_idr_)^$).Defined.The composite of 1-natural transformations is 1-natural.Global Instanceis1natural_comp{AB:Type} `{IsGraphA} `{Is1CatB}{FGK:A->B} `{!Is0FunctorF} `{!Is0FunctorG} `{!Is0FunctorK}(gamma:G$=>K) `{!Is1NaturalGKgamma}(alpha:F$=>G) `{!Is1NaturalFGalpha}:Is1NaturalFK(trans_compgammaalpha).Proof.snrapplyBuild_Is1Natural.introsabf;unfoldtrans_comp;cbn.refine(cat_assoc___$@ (_$@Lisnatalphaf) $@_).refine(cat_assoc_opp___$@ (isnatgammaf$@R_) $@_).applycat_assoc.Defined.Prewhiskering a transformation preserves naturality.Global Instanceis1natural_prewhisker{ABC:Type} {FG:B->C} (K:A->B)`{IsGraphA,Is01CatB,Is1CatC, !Is0FunctorF, !Is0FunctorG, !Is0FunctorK}(gamma:F$=>G) `{L: !Is1NaturalFGgamma}:Is1Natural(FoK) (GoK) (trans_prewhiskergammaK).Proof.snrapplyBuild_Is1Natural.introsxyf;unfoldtrans_prewhisker;cbn.exact(isnatgamma_).Defined.Postwhiskering a transformation preserves naturality.Global Instanceis1natural_postwhisker{ABC:Type} {FG:A->B} (K:B->C)`{IsGraphA,Is1CatB,Is1CatC, !Is0FunctorF, !Is0FunctorG,!Is0FunctorK, !Is1FunctorK}(gamma:F$=>G) `{L: !Is1NaturalFGgamma}:Is1Natural(KoF) (KoG) (trans_postwhiskerKgamma).Proof.snrapplyBuild_Is1Natural.introsxyf;unfoldtrans_postwhisker;cbn.refine(_^$ $@_$@_).1,3:rapplyfmap_comp.rapplyfmap2.exact(isnatgamma_).Defined.Modifying a transformation to something pointwise equal preserves naturality.Definitionis1natural_homotopic{AB:Type} `{Is01CatA} `{Is1CatB}{F:A->B} `{!Is0FunctorF} {G:A->B} `{!Is0FunctorG}{alpha:F$=>G} (gamma:F$=>G) `{!Is1NaturalFGgamma}(p:foralla,alphaa$==gammaa):Is1NaturalFGalpha.Proof.snrapplyBuild_Is1Natural.introsabf.exact((pb$@R_) $@isnatgammaf$@ (_$@L(pa)^$)).Defined.The opposite of a natural transformation is natural.Global Instanceis1natural_opAB`{Is01CatA} `{Is1CatB}(F:A->B) `{!Is0FunctorF} (G:A->B) `{!Is0FunctorG}(alpha:F$=>G) `{!Is1NaturalFGalpha}:Is1Natural(G:A^op->B^op) (F:A^op->B^op) (trans_opFGalpha).Proof.unfoldop.snrapplyBuild_Is1Natural'.-introsab.exact(isnat_tralpha).-introsab.exact(isnatalpha).Defined.Natural transformationsHere we give the bundled definition of a natural transformation which can be more convenient to work with in certain situations. It forms the Hom type of the functor category.RecordNatTrans{AB:Type} `{IsGraphA} `{Is1CatB} {FG:A->B}{ff:Is0FunctorF} {fg:Is0FunctorG} := {#[reversible=no]trans_nattrans:>F$=>G;is1natural_nattrans:Is1NaturalFGtrans_nattrans;}.ArgumentsNatTrans{AB} {isgraph_A}{isgraph_B} {is2graph_B} {is01cat_B} {is1cat_B}FG{is0functor_F} {is0functor_G} :rename.ArgumentsBuild_NatTrans{ABisgraph_Aisgraph_Bis2graph_Bis01cat_Bis1cat_BFGis0functor_Fis0functor_G}alphaisnat_alpha:rename.Global Existing Instanceis1natural_nattrans.Definitionissig_NatTrans{AB:Type} `{IsGraphA} `{Is1CatB} (FG:A->B){ff:Is0FunctorF} {fg:Is0FunctorG}:_<~>NatTransFG:=ltac:(issig).Definitionnattrans_id{AB:Type} (F:A->B)`{IsGraphA,Is1CatB, !Is0FunctorF}:NatTransFF:=Build_NatTrans(trans_idF)_.Definitionnattrans_comp{AB:Type} {FGK:A->B}`{IsGraphA,Is1CatB, !Is0FunctorF, !Is0FunctorG, !Is0FunctorK}:NatTransGK->NatTransFG->NatTransFK:=funalphabeta=>Build_NatTrans(trans_compalphabeta)_.Definitionnattrans_prewhisker{ABC:Type} {FG:B->C}`{IsGraphA,Is1CatB,Is1CatC, !Is0FunctorF, !Is0FunctorG}(alpha:NatTransFG) (K:A->B) `{!Is0FunctorK}:NatTrans(FoK) (GoK):=Build_NatTrans(trans_prewhiskeralphaK)_.Definitionnattrans_postwhisker{ABC:Type} {FG:A->B} (K:B->C)`{IsGraphA,Is1CatB,Is1CatC, !Is0FunctorF, !Is0FunctorG,!Is0FunctorK, !Is1FunctorK}:NatTransFG->NatTrans(KoF) (KoG):=funalpha=>Build_NatTrans(trans_postwhiskerKalpha)_.Definitionnattrans_op{AB:Type} `{Is01CatA} `{Is1CatB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG}:NatTransFG->NatTrans(A:=A^op) (B:=B^op) (G:A^op->B^op) (F:A^op->B^op):=funalpha=>Build_NatTrans(trans_opFGalpha)_.Natural equivalencesNatural equivalences are families of equivalences that are natural.RecordNatEquiv{AB:Type} `{IsGraphA} `{HasEquivsB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG} := {#[reversible=no]cat_equiv_natequiv:>foralla,Fa$<~>Ga;is1natural_natequiv::Is1NaturalFG(funa=>cat_equiv_natequiva) ;}.ArgumentsNatEquiv{AB} {isgraph_A}{isgraph_B} {is2graph_B} {is01cat_B} {is1cat_B} {hasequivs_B}FG{is0functor_F} {is0functor_G} :rename.ArgumentsBuild_NatEquiv{AB} {isgraph_A}{isgraph_B} {is2graph_B} {is01cat_B} {is1cat_B} {hasequivs_B}FG{is0functor_F} {is0functor_G}eisnat_e:rename.Definitionissig_NatEquiv{AB:Type} `{IsGraphA} `{HasEquivsB}(FG:A->B) `{!Is0FunctorF, !Is0FunctorG}:_<~>NatEquivFG:=ltac:(issig).From a given natural equivalence, we can get the underlying natural transformation.Lemmanattrans_natequiv{AB:Type} `{IsGraphA} `{HasEquivsB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG}:NatEquivFG->NatTransFG.Proof.introsalpha.nrapplyBuild_NatTrans.rapply(is1natural_natequivalpha).Defined.Throws a warning, but can probably be ignored.GlobalSetWarnings"-ambiguous-paths".Coercionnattrans_natequiv:NatEquiv>->NatTrans.The above coercion sometimes doesn't trigger when it should, so we add the following.Definitionisnat_natequiv{AB:Type} `{IsGraphA} `{HasEquivsB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG} (alpha:NatEquivFG){aa':A} (f:a$->a'):=isnat(nattrans_natequivalpha)f.Often we wish to build a natural equivalence from a natural transformation and a pointwise proof that it is an equivalence.DefinitionBuild_NatEquiv'{AB:Type} `{IsGraphA} `{HasEquivsB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG}(alpha:NatTransFG) `{foralla,CatIsEquiv(alphaa)}:NatEquivFG.Proof.snrapplyBuild_NatEquiv.-introa.refine(Build_CatEquiv(alphaa)).-snrapplyBuild_Is1Natural'.+introsaa'f.refine((cate_buildequiv_fun_$@R_) $@_$@ (_$@Lcate_buildequiv_fun_)^$).apply(isnatalpha).+introsaa'f.refine((_$@Lcate_buildequiv_fun_) $@_$@ (cate_buildequiv_fun_$@R_)^$).apply(isnat_tralpha).Defined.Definitionnatequiv_id{AB:Type} `{IsGraphA} `{HasEquivsB}{F:A->B} `{!Is0FunctorF}:NatEquivFF:=Build_NatEquiv'(nattrans_idF).Definitionnatequiv_compose{AB} {FGH:A->B} `{IsGraphA} `{HasEquivsB}`{!Is0FunctorF, !Is0FunctorG, !Is0FunctorH}(alpha:NatEquivGH) (beta:NatEquivFG):NatEquivFH:=Build_NatEquiv'(nattrans_compalphabeta).Definitionnatequiv_prewhisker{ABC} {HK:B->C}`{IsGraphA,HasEquivsB,HasEquivsC, !Is0FunctorH, !Is0FunctorK}(alpha:NatEquivHK) (F:A->B) `{!Is0FunctorF}:NatEquiv(HoF) (KoF):=Build_NatEquiv'(nattrans_prewhiskeralphaF).Definitionnatequiv_postwhisker{ABC} {FG:A->B}`{IsGraphA,HasEquivsB,HasEquivsC, !Is0FunctorF, !Is0FunctorG}(K:B->C) (alpha:NatEquivFG) `{!Is0FunctorK, !Is1FunctorK}:NatEquiv(KoF) (KoG).Proof.srefine(Build_NatEquiv'(nattrans_postwhiskerKalpha)).2:unfoldnattrans_postwhisker,trans_postwhisker;cbn.all:exact_.Defined.Lemmanatequiv_op{AB:Type} `{Is01CatA} `{HasEquivsB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG}:NatEquivFG->NatEquiv(G:A^op->B^op)F.Proof.intros[an].snrapplyBuild_NatEquiv.1:exacta.byrapplyis1natural_op.Defined.We can form the inverse natural equivalence by inverting each map in the family. The naturality proof follows from standard lemmas about inverses.Definitionnatequiv_inverse{AB:Type} `{IsGraphA} `{HasEquivsB}{FG:A->B} `{!Is0FunctorF, !Is0FunctorG}:NatEquivFG->NatEquivGF.Proof.intros[alphaI].snrapplyBuild_NatEquiv.1:exact(funa=> (alphaa)^-1$).snrapplyBuild_Is1Natural'.+introsXYf.applyvinverse,I.+introsXYf.applyhinverse,I.Defined.This lemma might seem unnecessery since as functions ((F o G) o K) and (F o (G o K)) are definitionally equal. But the functor instances of both sides are different. This can be a nasty trap since you cannot see this difference clearly.Definitionnatequiv_functor_assoc_ff_f{ABCD:Type}`{IsGraphA,HasEquivsB,HasEquivsC,HasEquivsD}(F:C->D) (G:B->C) (K:A->B)`{!Is0FunctorF, !Is0FunctorG, !Is0FunctorK}:NatEquiv((FoG)oK) (Fo(GoK)).Proof.snrapplyBuild_NatEquiv.1:intro;reflexivity.snrapplyBuild_Is1Natural.introsXYf.refine(cat_prewhisker(id_cate_fun_)_$@cat_idl_$@_^$).refine(cat_postwhisker_(id_cate_fun_) $@cat_idr_).Defined.Pointed natural transformationsDefinitionPointedTransformation{BC:Type} `{Is1CatB,Is1GpdC}`{IsPointedB,IsPointedC} (FG:B-->*C):= {eta:F$=>G&eta(point_) $==bp_pointedF$@ (bp_pointedG)^$}.Notation"F $=>* G" := (PointedTransformationFG) (atlevel70).Definitionptransformation_inverse{BC:Type} `{Is1CatB,Is1GpdC}`{IsPointedB,IsPointedC} (FG:B-->*C): (F$=>*G) -> (G$=>*F).Proof.intros[hp].exists(funx=> (hx)^$).refine(gpd_rev2p$@_).refine(gpd_rev_pp__$@_).refine(_$@L_).applygpd_rev_rev.Defined.Notation"h ^*$" := (ptransformation_inverse__h) (atlevel5).Definitionptransformation_compose{BC:Type} `{Is1CatB,Is1GpdC}`{IsPointedB,IsPointedC} {F0F1F2:B-->*C}: (F0$=>*F1) -> (F1$=>*F2) -> (F0$=>*F2).Proof.intros[h0p0] [h1p1].exists(trans_comph1h0).refine((p1$@R_) $@ (_$@Lp0) $@_);unfoldgpd_comp;cbn.refine(cat_assoc___$@_).rapply(fmap_).applygpd_h_Vh.Defined.Notation"h $@* k" := (ptransformation_composehk) (atlevel40).(* TODO: *)(* Morphisms of natural transformations - Modifications *)(* SinceTransformationis dependent, we can define a modification to be a transformation together with a cylinder condition. This doesn't seem to be too useful as of yet however. We would also need better ways to write down cylinders. *)

--- Miscellaneous\naturals.html ---
naturalsLibrary naturalsRequireImportHoTT.Basics.Decidable.RequireImportHoTT.Classes.interfaces.ordersHoTT.Classes.implementations.peano_naturalsHoTT.Classes.theory.ringsHoTT.Classes.isomorphisms.rings.RequireExportHoTT.Classes.interfaces.naturals.Generalizable VariablesANRSRf.(* This grabs a coercion. *)ImportSemiRings.Lemmato_semiring_unique`{NaturalsN} `{IsSemiCRingSR} (f:N->SR)`{!IsSemiRingPreservingf}x:fx=naturals_to_semiringNSRx.Proof.symmetry.applynaturals_initial.Qed.Lemmato_semiring_unique_alt`{NaturalsN} `{IsSemiCRingSR} (fg:N->SR)`{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg}x:fx=gx.Proof.rewrite(to_semiring_uniquef), (to_semiring_uniqueg);reflexivity.Qed.Lemmato_semiring_involutiveN`{NaturalsN}N2`{NaturalsN2}x:naturals_to_semiringN2N(naturals_to_semiringNN2x) =x.Proof.change(Compose(naturals_to_semiringN2N) (naturals_to_semiringNN2)x=idx).applyto_semiring_unique_alt;apply_.Qed.Lemmamorphisms_involutive`{NaturalsN} `{IsSemiCRingR} (f:R->N) (g:N->R)`{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg}x:f(gx) =x.Proof.exact(to_semiring_unique_alt(f∘g)id_).Qed.Lemmato_semiring_twice`{NaturalsN} `{IsSemiCRingR1} `{IsSemiCRingR2}(f:R1->R2) (g:N->R1) (h:N->R2)`{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg} `{!IsSemiRingPreservingh}x:f(gx) =hx.Proof.exact(to_semiring_unique_alt(f∘g)h_).Qed.Lemmato_semiring_self`{NaturalsN} (f:N->N) `{!IsSemiRingPreservingf}x:fx=x.Proof.exact(to_semiring_unique_altfid_).Qed.Lemmato_semiring_injective`{NaturalsN} `{IsSemiCRingA}(f:A->N) (g:N->A) `{!IsSemiRingPreservingf} `{!IsSemiRingPreservingg}:IsInjectiveg.Proof.introsxyE.change(idx=idy).rewrite<-(to_semiring_twicefgidx), <-(to_semiring_twicefgidy).applyap,E.Qed.Global Instancenaturals_to_naturals_injective`{NaturalsN} `{NaturalsN2}(f:N->N2) `{!IsSemiRingPreservingf}:IsInjectivef| 15.Proof.exact(to_semiring_injective(naturals_to_semiringN2N)_).Qed.Sectionretract_is_nat.Context`{NaturalsN} `{IsSemiCRingSR}{SRap:ApartSR} {SRleSRlt} `{!FullPseudoSemiRingOrder(A:=SR)SRleSRlt}.Context(f:N->SR) `{!IsEquivf}`{!IsSemiRingPreservingf} `{!IsSemiRingPreserving(f^-1)}.(* If we make this an instance, instance resolution will loop *)Definitionretract_is_nat_to_sr:NaturalsToSemiRingSR:=funR_____=>naturals_to_semiringNR∘f^-1.Sectionfor_another_semirings.Context`{IsSemiCRingR}.Instance:IsSemiRingPreserving(naturals_to_semiringNR∘f^-1) := {}.Context(h:SR->R) `{!IsSemiRingPreservingh}.Lemmasame_morphismx: (naturals_to_semiringNR∘f^-1)x=hx.Proof.transitivity((h∘ (f∘f^-1))x).-symmetry.apply(to_semiring_unique(h∘f)).-unfoldCompose.applyap,eisretr.Qed.Endfor_another_semirings.(* If we make this an instance, instance resolution will loop *)Lemmaretract_is_nat:NaturalsSR(U:=retract_is_nat_to_sr).Proof.split;tryapply_.-unfoldnaturals_to_semiring,retract_is_nat_to_sr.apply_.-intros;applysame_morphism;apply_.Qed.Endretract_is_nat.Sectionnat_to_nat_iso.Context`{NaturalsN1} `{NaturalsN2}.Global Instancenat_to_nat_equiv:IsEquiv(naturals_to_semiringN1N2).Proof.applyEquivalences.isequiv_adjointifywith(naturals_to_semiringN2N1);red;apply(to_semiring_involutive__).Defined.Endnat_to_nat_iso.Sectioncontents.UniverseU.(* {U U} because we do forall n : N, {id} n = nat_to_sr N N n *)Context`{Funext} `{Univalence} {N:Type@{U} } `{Naturals@{UUUUUUUU}N}.Lemmafrom_nat_stmt(N':Type@{U}) `{Naturals@{UUUUUUUU}N'}:forall(P:SemiRings.Operations->Type),P(SemiRings.BuildOperationsN') ->P(SemiRings.BuildOperationsN).Proof.applySemiRings.iso_leibnitzwith(naturals_to_semiringN'N);apply_.Qed.Sectionborrowed_from_nat.Lemmainduction:forall(P:N->Type),P0 -> (foralln,Pn->P(1 +n)) ->foralln,Pn.Proof.pose(Q:=funs:SemiRings.Operations=>forallP:s->Type,P0 -> (foralln,Pn->P(1 +n)) ->foralln,Pn).change(Q(SemiRings.BuildOperationsN)).apply(from_nat_stmtnat).unfoldQ;clearQ.simpl.exactnat_induction.Qed.Lemmacase:forallx:N,x= 0 |_|existsy:N, (x= 1 +y)%mc.Proof.refine(from_nat_stmtnat(funs=>forallx:s,x= 0 |_|existsy:s, (x= 1 +y)%mc)_).simpl.intros[|x];eauto.Qed.Global Instance:BiinductionN.Proof.hnf.introsPE0ES.applyinduction;trivial.applyES.Qed.Global Instancenat_plus_cancel_l:forallz:N,LeftCancellation(+)z.Proof.refine(from_nat_stmt@{iU}nat(funs=>forallz:s,LeftCancellationplusz)_).simpl.first[exactnat_plus_cancel_l@{Ui}|exactnat_plus_cancel_l@{U}].Qed.Global Instance:forallz:N,RightCancellation(+)z.Proof.intro.apply(right_cancel_from_left(+)).Qed.Global Instance:forallz:N,PropHolds(z<> 0) ->LeftCancellation(.*.)z.Proof.refine(from_nat_stmtnat(funs=>forallz:s,PropHolds(z<> 0) ->LeftCancellationmultz)_).simpl.applynat_mult_cancel_l.Qed.Global Instance:forallz:N,PropHolds(z<> 0) ->RightCancellation(.*.)z.Proof.intros? ?.apply(right_cancel_from_left(.*.)).Qed.Instancenat_nontrivial:PropHolds((1:N) <> 0).Proof.refine(from_nat_stmtnat(funs=>PropHolds((1:s) <> 0))_).apply_.Qed.Instancenat_nontrivial_apart`{ApartN} `{!TrivialApartN} :PropHolds((1:N) ≶ 0).Proof.applyapartness.ne_apart.solve_propholds.Qed.Lemmazero_sum:forall(xy:N),x+y= 0 ->x= 0 /\y= 0.Proof.refine(from_nat_stmtnat(funs=>forallxy:s,x+y= 0 ->x= 0 /\y= 0)_).simpl.applyplus_eq_zero.Qed.Lemmaone_sum:forall(xy:N),x+y= 1 -> (x= 1 /\y= 0) |_| (x= 0 /\y= 1).Proof.refine(from_nat_stmtnat(funs=>forall(xy:s),x+y= 1 -> (x= 1 /\y= 0) |_| (x= 0 /\y= 1))_).simpl.intros[|x] [|y];auto.-introsE.rewriteadd_S_l,add_0_rinE.applyS_injinE.rewriteE.auto.-introsE.rewriteadd_S_l,add_S_rinE.applyS_injinE.destruct(S_neq_0_E).Qed.Global Instance:ZeroProductN.Proof.refine(from_nat_stmtnat(funs=>ZeroProducts)_).simpl.red.applymult_eq_zero.Qed.Endborrowed_from_nat.Lemmanat_1_plus_ne_0x: 1 +x<> 0.Proof.introE.destruct(zero_sum1xE).applynat_nontrivial.trivial.Qed.Global Instanceslow_naturals_dec:DecidablePathsN.Proof.applydecidablepaths_equivwithnat(naturals_to_semiringnatN);apply_.Qed.Sectionwith_a_ring.Context`{IsCRingR} `{!IsSemiRingPreserving(f:N->R)} `{!IsInjectivef}.Lemmato_ring_zero_sumxy:-fx=fy->x= 0 /\y= 0.Proof.introsE.applyzero_sum, (injectivef).rewriterings.preserves_0,rings.preserves_plus, <-E.applyplus_negate_r.Qed.Lemmanegate_to_ringxy:-fx=fy->fx=fy.Proof.introsE.destruct(to_ring_zero_sumxyE)as[E2E3].rewriteE2,E3.reflexivity.Qed.Endwith_a_ring.Endcontents.(* Due to bug 2528 *)#[export]HintExtern6 (PropHolds(1 <> 0)) =>eapply@nat_nontrivial:typeclass_instances.#[export]HintExtern6 (PropHolds(1 ≶ 0)) =>eapply@nat_nontrivial_apart:typeclass_instances.

--- Miscellaneous\NaturalTransformation.html ---
NaturalTransformationLibrary NaturalTransformationNatural TransformationsSince there are only notations inNaturalTransformation.Notations, we can just export those.RequireExportNaturalTransformation.Notations.Definition of natural transformationRequireNaturalTransformation.Core.Composition of natural transformationsRequireNaturalTransformation.Composition.Core.Dual natural transformationsRequireNaturalTransformation.Dual.Identity natural transformationRequireNaturalTransformation.Identity.Natural isomorphismsRequireNaturalTransformation.Isomorphisms.Path space of natural transformation typeRequireNaturalTransformation.Paths.Pointwise natural transformationsRequireNaturalTransformation.Pointwise.Sums of natural transformationsRequireNaturalTransformation.Sum.Products of natural transformationsRequireNaturalTransformation.Prod.IncludeNaturalTransformation.Core.IncludeNaturalTransformation.Composition.Core.IncludeNaturalTransformation.Dual.IncludeNaturalTransformation.Identity.IncludeNaturalTransformation.Isomorphisms.IncludeNaturalTransformation.Paths.IncludeNaturalTransformation.Pointwise.IncludeNaturalTransformation.Sum.IncludeNaturalTransformation.Prod.We don't want to make utf-8 notations the default, so we don't export them.SinceCompositionis a separate sub-directory, we need to re-create the module structure  We want to have the following as subdirectories/modules, not at top level.  Unfortunately, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.RequireNaturalTransformation.Composition.

--- Miscellaneous\NaturalTransformations.html ---
NaturalTransformationsLibrary NaturalTransformationsNatural transformations between functors from initial categories and to terminal categoriesRequireImportCategory.CoreFunctor.CoreNaturalTransformation.CoreNaturalTransformation.Paths.RequireImportInitialTerminalCategory.CoreInitialTerminalCategory.Functors.RequireImportContractible.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.SectionNaturalTransformations.VariableC:PreCategory.Definitionfrom_initial`{@IsInitialCategoryzero} (FG:FunctorzeroC):NaturalTransformationFG:=Build_NaturalTransformationFG(funx=>initial_category_ind_x)(funx__=>initial_category_ind_x).Global Instancetrunc_from_initial`{Funext}`{@IsInitialCategoryzero} (FG:FunctorzeroC):Contr(NaturalTransformationFG).Proof.refine(Build_Contr_(from_initialFG)_).abstract(intros;applypath_natural_transformation;introx;exact(initial_category_ind_x)).Defined.Local Existing InstanceFunctors.to_initial_category_empty.Global Instancetrunc_to_initial`{Funext}`{@IsInitialCategoryzero}(FG:FunctorzeroC):Contr(NaturalTransformationFG):=trunc_from_initialFG.Definitionto_terminal`{@IsTerminalCategoryoneH1H2} (FG:FunctorCone):NaturalTransformationFG:=Build_NaturalTransformationFG(funx=>center_)(fun___=>path_contr__).Global Instancetrunc_to_terminal`{Funext}`{@IsTerminalCategoryoneH1H2} (FG:FunctorCone):Contr(NaturalTransformationFG).Proof.refine(Build_Contr_(to_terminalFG)_).abstract(path_natural_transformation;exact(contr_)).Defined.EndNaturalTransformations.

--- Miscellaneous\nat_distance.html ---
nat_distanceLibrary nat_distanceRequireImportHoTT.Classes.orders.naturalsHoTT.Classes.implementations.peano_naturals.RequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.theory.naturals.Generalizable VariablesN.Sectioncontents.Context`{Funext} `{Univalence}.Context`{NaturalsN}.(* Add Ring N : (rings.stdlib_semiring_theory N). *)(* NatDistance instances are all equivalent, because their behavior is fullydetermined by the specification. *)Lemmanat_distance_unique{ab:NatDistanceN}:forallxy, @nat_distance__axy= @nat_distance__bxy.Proof.intros.unfoldnat_distance.destruct(@nat_distance_sig__axy)as[[z1E1]|[z1E1]],(@nat_distance_sig__bxy)as[[z2E2]|[z2E2]];simpl.-apply(left_cancellationplusx).path_viay.-rewrite<-(rings.plus_0_ry),<-E2,<-rings.plus_associnE1.apply(left_cancellationplusy)inE1.applynaturals.zero_suminE1.destructE1;path_via0.-rewrite<-(rings.plus_0_rx),<-E2,<-rings.plus_associnE1.apply(left_cancellationplusx)inE1.applynaturals.zero_suminE1.destructE1;path_via0.-apply(left_cancellationplusy);path_viax.Qed.Endcontents.(* An existing instance ofCutMinusallows to create an instance ofNatDistance*)Global Instancenatdistance_cut_minus`{NaturalsN} `{!TrivialApartN}{cm} `{!CutMinusSpecNcm} `{forallxy,Decidable(x≤y)} :NatDistanceN.Proof.red.intros.destruct(decide_rel(<=)xy)as[E|E].-left.exists(y∸x).rewriterings.plus_comm;applycut_minus_le;trivial.-right.exists(x∸y).rewriterings.plus_comm;applycut_minus_le,orders.le_flip;trivial.Defined.(* Using the preceding instance we can make an instancefor arbitrary models of the naturalsby translation intonaton which we already have aCutMinusinstance. *)Global Instancenatdistance_default`{NaturalsN} :NatDistanceN| 10.Proof.introsxy.destruct(nat_distance_sig(naturals_to_semiringNnatx)(naturals_to_semiringNnaty))as[[nE]|[nE]].-left.exists(naturals_to_semiringnatNn).rewrite<-(naturals.to_semiring_involutiveNnaty), <-E.rewrite(rings.preserves_plus(A:=nat)), (naturals.to_semiring_involutive__).split.-right.exists(naturals_to_semiringnatNn).rewrite<-(naturals.to_semiring_involutiveNnatx), <-E.rewrite(rings.preserves_plus(A:=nat)), (naturals.to_semiring_involutive__).split.Defined.

--- Miscellaneous\nat_int.html ---
nat_intLibrary nat_intRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.theory.naturalsHoTT.Classes.theory.rings.RequireExportHoTT.Classes.orders.semirings.Generalizable VariablesNRf.SectionUniv.Context`{Funext} `{Univalence}.(*We axiomatize the order on the naturals and the integers as a non trivialpseudo semiring order that satisfies the biinduction principle. We provesome results that hold for the order on the naturals and the integers.In particular, we show that given another non trivial pseudo semiring order(that not necessarily has to satisfy the biinduction principle, for examplethe rationals or the reals), any morphism to it is an order embedding.*)Lemmato_semiring_nonneg`{FullPseudoSemiRingOrderN}`{!NaturalsToSemiRingN} `{!NaturalsN} `{FullPseudoSemiRingOrderR}`{!IsSemiCRingR}`{!IsSemiRingPreserving(f:N->R)}n: 0 ≤fn.Proof.revertn.applynaturals.induction.-rewrite(preserves_0(f:=f)).reflexivity.-introsnE.rewrite(preserves_plus(f:=f)), (preserves_1(f:=f)).applynonneg_plus_compat.+solve_propholds.+trivial.Qed.Sectionnat_int_order.Context`{NaturalsN} `{ApartN} `{LeN} `{LtN} `{!FullPseudoSemiRingOrderlelt}`{FullPseudoSemiRingOrderR} `{!IsSemiCRingR}`{!BiinductionR} `{PropHolds(1 ≶ 0)}.(* Add Ring R : (stdlib_semiring_theory R). *)Lemmanat_int_to_semiring:forallx:R,existsz,x=naturals_to_semiringNRz|_|(x+naturals_to_semiringNRz)%mc= 0.Proof.applybiinduction.-exists0.left.symmetry.applypreserves_0.-intros.split;introsE.+destructEas[z[E|E]].*exists(1+z).left.rewriteE.rewrite(preserves_plus(f:=naturals_to_semiringNR)),(preserves_1(f:=naturals_to_semiringNR)).reflexivity.*destruct(naturals.casez)as[Ez|[z'Ez]].**rewriteEzin*.rewrite(preserves_0(A:=N)),plus_0_rinE.rewriteE.exists1.left.rewrite(preserves_1(A:=N)),plus_0_r.reflexivity.**rewriteEzin*;clearzEz.existsz';right.path_via(n+naturals_to_semiringNR(1 +z')).clearE.rewrite(preserves_plus(A:=N)),(preserves_1(A:=N)).rewriteplus_assoc,(plus_commn);reflexivity.+destructEas[z[E|E]].*destruct(naturals.casez)as[Ez|[z'Ez]];rewriteEzin*;clearzEz.**exists1;right.rewrite(preserves_1(A:=N)),plus_comm,E.applypreserves_0.**existsz';left.rewrite(preserves_plus(A:=N)),(preserves_1(A:=N))inE.apply(left_cancellationplus1).trivial.*exists(1+z).right.rewrite(preserves_plus(A:=N)), (preserves_1(A:=N)),<-E.rewriteplus_assoc,(plus_commn);reflexivity.Qed.Lemmanat_int_nonneg_decomposex: 0 ≤x->existsz,x=naturals_to_semiringNRz.Proof.destruct(nat_int_to_semiringx)as[z[Ez1|Ez2]].-existsz.trivial.-introsE.exists0.rewrite(preserves_0(A:=N)).apply(antisymmetry(≤));trivial.rewrite<-Ez2.applynonneg_plus_le_compat_r.applyto_semiring_nonneg.Qed.Lemmanat_int_le_plusxy:x≤y<->existsz,y=x+naturals_to_semiringNRz.Proof.split.-introsE.destruct(decompose_leE)as[z[Ez1Ez2]].destruct(nat_int_nonneg_decompose_Ez1)as[uEu].existsu.rewrite<-Eu.trivial.-intros[zEz].rewriteEz.applynonneg_plus_le_compat_r,to_semiring_nonneg.Qed.Lemmanat_int_lt_plusxy:x<y<->existsz,y=x+ 1 +naturals_to_semiringNRz.Proof.split.-introsE.destruct((fst(nat_int_le_plusxy) (lt_le__E)))as[z0Ez].destruct(naturals.casez0)as[E1|[zE1]];rewriteE1in*;clearz0E1.+rewritepreserves_0,plus_0_rinEz.destruct(lt_ne_flipxy);trivial.+existsz.rewrite(preserves_plus(A:=N)),preserves_1,plus_associnEz.trivial.-intros[zEz].rewriteEz.applynonneg_plus_lt_compat_r.+applyto_semiring_nonneg.+applypos_plus_lt_compat_r;solve_propholds.Qed.Lemmalt_iff_plus_1_lexy:x<y<->x+ 1 ≤y.Proof.etransitivity.-applynat_int_lt_plus.-applysymmetry,nat_int_le_plus.Qed.Lemmalt_iff_S_lexy:x<y<-> 1 +x≤y.Proof.rewriteplus_comm.applylt_iff_plus_1_le.Qed.Lemmapos_ge_1x: 0 <x<-> 1 ≤x.Proof.split;introsE.-rewrite<-(plus_0_l1).applylt_iff_plus_1_le.trivial.-applylt_le_transwith1; [solve_propholds|trivial].Qed.Lemmale_iff_lt_plus_1xy:x≤y<->x<y+ 1.Proof.split;introsE.-applylt_iff_plus_1_le.apply(order_preserving(+1)).trivial.-apply(order_reflecting(+1)),lt_iff_plus_1_le.trivial.Qed.Lemmale_iff_lt_Sxy:x≤y<->x< 1 +y.Proof.rewriteplus_comm.applyle_iff_lt_plus_1.Qed.Sectionanother_semiring.Context`{FullPseudoSemiRingOrderR2} `{!IsSemiCRingR2}`{PropHolds((1 :R2) ≶ 0)}`{!IsSemiRingPreserving(f:R->R2)}.Instance:OrderPreservingf.Proof.repeat(split;tryapply_).introsxyE.applynat_int_le_plusinE.destructEas[zE].rewriteE, (preserves_plus(f:=f)), (naturals.to_semiring_twicef__).applynonneg_plus_le_compat_r.applyto_semiring_nonneg.Qed.Global Instance:StrictlyOrderPreservingf| 50.Proof.repeat(split;tryapply_).introsxyE.applynat_int_lt_plusinE.destructEas[zE].rewriteE, !(preserves_plus(f:=f)),preserves_1,(naturals.to_semiring_twicef__).applynonneg_plus_lt_compat_r.-applyto_semiring_nonneg.-applypos_plus_lt_compat_r;solve_propholds.Qed.Global Instancenat_morphism_order_embedding:OrderEmbeddingf| 50.Proof.split;tryapply_.applyfull_pseudo_order_reflecting.Qed.Endanother_semiring.Endnat_int_order.EndUniv.

--- Miscellaneous\Negation.html ---
NegationLibrary NegationRequireImportHoTT.Basics.RequireImportHoTT.Spaces.No.Core.Local OpenScopepath_scope.Local OpenScopesurreal_scope.Negation of surreal numbersNegation requires the option sorts to be symmetric.ClassHasNegation(S:OptionSort):=symmetric_options:forallLR,InSortSLR->InSortSRL.Global Existing Instancesymmetric_options.Global Instancehasnegation_maxsort:HasNegationMaxSort:=fun___=>tt.Global Instancehasnegation_decsort:HasNegationDecSort.Proof.introsLR[? ?];split;assumption.Qed.SectionHasNegation.Universei.Context{S:OptionSort@{i}} `{HasNegationS}.LetNo:=GenNoS.Definitionnegate:No->No.Proof.simplerefine(No_recNo(funxy=>y<=x) (funxy=>y<x)_____);intros.-exact{{fxR|fxL//funrl=>fxcutlr}}.-applypath_No;assumption.-cbnin*.applyle_lr;intros; [applydq|applydp].-cbnin*.applylt_rwithl;intros;assumption.-cbnin*.applylt_lwithr;intros;assumption.Defined.More useful is the following rewriting lemma.Definitionnegate_cut{LR:Type@{i} } {Sx:InSortSLR}(xL:L->No) (xR:R->No)(xcut:forall(l:L) (r:R),xLl<xRr): {nxcut:forallrl,negate(xRr) <negate(xLl) &negate{{xL|xR//xcut}} ={{ (funr=>negate(xRr)) | (funl=>negate(xLl)) //nxcut}} }.Proof.eexists.unfoldnegateat1;rewriteNo_rec_cut.reflexivity.Defined.The following proof verifies thatNo_recapplied to a cut reduces definitionally to a cut with the expected options (although it does produce quite a large term).Context`{InSortSEmptyEmpty} `{InSortSUnitEmpty}.Goalnegateone=minusone.Proof.unfoldone;rewrite(negate_cut___).2.applypath_No;applyle_lr;intros.Sincele_lronly proves inequality of cuts, this would not work ifnegatedidn't compute to a cut when applied to a cut.-eliml.-applylt_rwithr.unfoldzero;rewrite(negate_cut___).2.applyle_lr;applyEmpty_ind.-eliml.-unfoldzero;rewrite(negate_cut___).2.applylt_rwithr.applyle_lr;applyEmpty_ind.Qed.EndHasNegation.

--- Miscellaneous\ne_list.html ---
ne_listLibrary ne_listRequireImportHoTT.Utf8MinimalHoTT.Spaces.List.CoreHoTT.Basics.OvertureBasics.TacticsHoTT.Spaces.Nat.Core.Local OpenScopenat_scope.Local OpenScopetype_scope.Declare Scopene_list_scope.DelimitScopene_list_scopewithne_list.OpenScopene_list_scope.Nonempty list implementationne_list.ne_list.Modulene_list.Sectionwith_type.Context{T:Type}.A nonempty list. Below there is an implicit coercionne_list>->list.Inductivene_list:Type:=one:T→ne_list|cons:T→ne_list→ne_list.Fixpointapp(ab:ne_list):ne_list:=matchawith|onex=>consxb|consxy=>consx(appyb)end.Fixpointfoldr{R} (u:T→R) (f:T→R→R) (a:ne_list):R:=matchawith|onex=>ux|consxy=>fx(foldrufy)end.Fixpointfoldr1(f:T→T→T) (a:ne_list):T:=matchawith|onex=>x|consxy=>fx(foldr1fy)end.Definitionhead(l:ne_list):T:=matchlwithonex=>x|consx_=>xend.Fixpointto_list(l:ne_list):listT:=matchlwith|onex=>x::nil|consxxs=>x::to_listxsend.Fixpointfrom_list(x:T) (xs:listT):ne_list:=matchxswith|nil=>onex|List.Core.consht=>consx(from_listht)end.Definitiontail(l:ne_list):listT:=matchlwithone_=>nil|cons_x=>to_listxend.Lemmadecomp_eq(l:ne_list):l=from_list(headl) (taill).Proofwithauto.inductionl...destructl...cbnin*.rewriteIHl...Qed.Definitionlast:ne_list→T:=foldr1(funxy=>y).Fixpointreplicate_Sn(x:T) (n:nat):ne_list:=matchnwith| 0 =>onex|Sn'=>consx(replicate_Snxn')end.Fixpointtake(n:nat) (l:ne_list):ne_list:=matchl,nwith|consxxs,Sn'=>taken'xs|_,_=>one(headl)end.Fixpointfront(l:ne_list) :listT:=matchlwith|one_=>nil|consxxs=>x::frontxsend.Lemmatwo_level_rect(P:ne_list→Type)(Pone: ∀x,P(onex))(Ptwo: ∀xy,P(consx(oney)))(Pmore: ∀xyz,Pz→ (∀y',P(consy'z)) →P(consx(consyz))): ∀l,Pl.Proofwithauto.cut(∀l,Pl* ∀x,P(consxl)).-intros.applyX.-destructl...revertt.inductionl...intros.split.+applyIHl.+intro.applyPmore;intros;applyIHl.Qed.Lemmatail_length(l:ne_list):S(length(List.Core.tail(to_listl))) =length(to_listl).Proof.destructl;reflexivity.Qed.Endwith_type.Argumentsne_list:clearimplicits.Fixpointtails{T} (l:ne_listT):ne_list(ne_listT) :=matchlwith|onex=>one(onex)|consxy=>consl(tailsy)end.Lemmatails_are_shorter{T} (yx:ne_listT):InListx(to_list(tailsy)) →leq(length(to_listx)) (length(to_listy)).Proof.inductiony;cbn.-intros[[] |C].+constructor.+elimC.-intros[[] |C].+exact_.+byapplyleq_succ_r,IHy.Qed.Fixpointmap{AB} (f:A→B) (l:ne_listA):ne_listB:=matchlwith|onex=>one(fx)|consht=>cons(fh) (mapft)end.Lemmalist_map{AB} (f:A→B) (l:ne_listA):to_list(mapfl) =List.Core.list_mapf(to_listl).Proof.inductionl.-reflexivity.-cbn.rewrite<-IHl.reflexivity.Qed.Fixpointinits{A} (l:ne_listA):ne_list(ne_listA) :=matchlwith|onex=>one(onex)|consht=>cons(oneh) (map(consh) (initst))end.Fixpointzip{AB:Type} (l:ne_listA) (m:ne_listB):ne_list(A*B) :=matchlwith|onea=>one(a,headm)|consal=>matchmwith|oneb=>one(a,b)|consbm=>cons(a,b) (ziplm)endend.Modulenotations.Global Notationne_list:=ne_list.Global Notation"[: x :]" := (onex) :ne_list_scope.Global Notation"[: x ; .. ; y ; z :]":= (consx.. (consy(onez)) ..) :ne_list_scope.Global Infix":::" :=cons:ne_list_scope.Endnotations.Endne_list.Global Coercionne_list.to_list:ne_list.ne_list>->list.

--- Miscellaneous\No.html ---
NoLibrary NoRequireHoTT.Spaces.No.Core.IncludeHoTT.Spaces.No.Core.RequireExportHoTT.Spaces.No.Negation.RequireExportHoTT.Spaces.No.Addition.

--- Miscellaneous\Notations.html ---
NotationsLibrary NotationsNotations for structuresRequireStructure.Core.IncludeStructure.Core.StructureCoreNotations.

--- Miscellaneous\Notnot.html ---
NotnotLibrary NotnotRequireImportHoTT.BasicsHoTT.Types.RequireImportModality.Local OpenScopepath_scope.The double negation modalityThis is Exercise 7.12 in the book.  Note that it is (apparently) *not* accessible unless we assume propositional resizing.DefinitionNotNot`{Funext} :Modality.Proof.snrapplyeasy_modality.-introsX;exact(~ (~X)).-introsTxnx;exact(nxx).-introsABfznBz.applyz;introsa.exact(fa(transport(funx=> ~ (Bx))(path_ishprop__)nBz)).-introsABfa.applypath_ishprop.-introsAzz'.refine(isequiv_iff_hprop__).intros;applypath_ishprop.Defined.

--- Miscellaneous\NullHomotopy.html ---
NullHomotopyLibrary NullHomotopyRequireImportHoTT.Basics.RequireImportTypes.Sigma.Local OpenScopepath_scope.Null homotopies of mapsSectionNullHomotopy.Context`{Funext}.Geometrically, a nullhomotopy of a mapf:X->Yis an extension offto a mapConeX->Y.  One might more simply call it e.g.Constantf, but that is a little ambiguous: it could also reasonably mean e.g. a factorisation offthroughTrunc-1X.  (Should the unique map0->Ybe constant in one way, or inY-many ways?)DefinitionNullHomotopy{XY:Type} (f:X->Y):= {y:Y&forallx:X,fx=y}.Lemmaistrunc_nullhomotopy{n:trunc_index}{XY:Type} (f:X->Y) `{IsTruncnY}:IsTruncn(NullHomotopyf).Proof.apply@istrunc_sigma;auto.introsy.apply(@istrunc_forall_).introsx.applyistrunc_paths'.Defined.Definitionnullhomotopy_homotopic{XY:Type} {fg:X->Y} (p:f==g):NullHomotopyf->NullHomotopyg.Proof.intros[ye].existsy.introsx;exact((px)^ @ex).Defined.Definitionnullhomotopy_composeR{XYZ:Type} (f:X->Y) (g:Y->Z):NullHomotopyg->NullHomotopy(gof).Proof.intros[ze].existsz.introsx;exact(e(fx)).Defined.Definitionnullhomotopy_composeL{XYZ:Type} (f:X->Y) (g:Y->Z):NullHomotopyf->NullHomotopy(gof).Proof.intros[ye].exists(gy).introsx;exact(apg(ex)).Defined.DefinitioncancelL_nullhomotopy_equiv{XYZ:Type} (f:X->Y) (g:Y->Z) `{IsEquiv__g}:NullHomotopy(gof) ->NullHomotopyf.Proof.intros[ze].exists(g^-1z).introsx;applymoveL_equiv_V,e.Defined.DefinitioncancelR_nullhomotopy_equiv{XYZ:Type} (f:X->Y) (g:Y->Z) `{IsEquiv__f}:NullHomotopy(gof) ->NullHomotopyg.Proof.intros[ze].existsz.introsy;transitivity(g(f(f^-1y))).-symmetry;applyap,eisretr.-applye.Defined.Definitionnullhomotopy_ap{XY:Type} (f:X->Y) (x1x2:X):NullHomotopyf->NullHomotopy(@ap__fx1x2).Proof.intros[ye].unshelveeexists.-exact(ex1@ (ex2)^).-introsp.applymoveL_pV.refine(concat_Apep@_).refine(_@concat_p1_);applyap.applyap_const.Defined.EndNullHomotopy.

--- Miscellaneous\Nullification.html ---
NullificationLibrary NullificationNullificationRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensions.RequireImportModalityAccessible.RequireExportModalities.Localization.Nullification is a special case of localizationLocal OpenScopepath_scope.Nullification is the special case of localization where the codomains of the generating maps are allUnit.  In this case, we get a modality and not just a reflective subuniverse.The hypotheses of this lemma may look slightly odd (why are we bothering to talk about type families dependent overUnit?), but they seem to be the most convenient to make the induction go through.Definitionextendable_over_unit(n:nat)(A:Type@{a}) (C:Unit->Type@{i}) (D:forallu,Cu->Type@{j})(ext:ExtendableAlong@{aaik}n(const_ttA)C)(ext':forall(c:forallu,Cu),ExtendableAlong@{aajk}n(const_ttA) (funu=> (Du(cu)))):ExtendableAlong_Over@{aaijk}n(const_ttA)CDext.Proof.generalizedependentC;simple_inductionnnIH;introsCDextext'; [exacttt|split].-introsgg'.exists((fst(ext'(fstextg).1)(funa=> ((fstextg).2a)^ # (g'a))).1);introsa;simpl.applymoveR_transport_p.exact((fst(ext'(fstextg).1)(funa=> ((fstextg).2a)^ # (g'a))).2a).-introshkh'k'.applyIH;introsg.exact(snd(ext'k) (funu=>gu#h'u)k').Defined.Definitionooextendable_over_unit@{ijklm}(A:Type@{i}) (C:Unit->Type@{j}) (D:forallu,Cu->Type@{k})(ext:ooExtendableAlong@{lljm} (const_ttA)C)(ext':forall(c:forallu,Cu),ooExtendableAlong(const_ttA) (funu=> (Du(cu)))):ooExtendableAlong_Over(const_ttA)CDext:=funn=>extendable_over_unitnACD(extn) (func=>ext'cn).#[local]HintExtern4 =>progress(cbvbetaiota) :typeclass_instances.DefinitionNul@{ai} (S:NullGenerators@{a}) :Modality@{i}.Proof.We use the localization reflective subuniverses for most of the necessary data.simplerefine(Build_Modality'(Loc(null_to_local_generatorsS))__).-exact_.-introsA.We take care with universes.snrefine(reflectsD_from_OO_ind@{i}___).+introsBB_inOg.refine(Localize_ind@{aiii} (null_to_local_generatorsS)ABg_);introsi.applyooextendable_over_unit;introsc.refine(ooextendable_postcompose@{aaiiiiiiii}(fun(_:Unit) =>B(ctt))__(funu=>transportB(ap@{Set_}c(path_unitttu)))_).refine(ooextendable_islocal_i).+reflexivity.+applyinO_paths@{ii}.Defined.And here is the "real" definition of the notationIsNull.NotationIsNullf:= (In(Nulf)).Nullification and AccessibilityNullification modalities are accessible, essentially by definition.Global Instanceaccmodality_nul(S:NullGenerators) :IsAccModality(NulS).Proof.unshelveeconstructor.-exactS.-intros;reflexivity.Defined.And accessible modalities can be lifted to other universes.Definitionlift_accmodality@{aij} (O:Subuniverse@{i}) `{IsAccModality@{ai}O}:Modality@{j}:=Nul@{aj} (acc_ngenO).Global InstanceO_eq_lift_accmodality(O:Subuniverse@{i}) `{IsAccModality@{ai}O}:O<=>lift_accmodalityO.Proof.split;introsA;applyinO_iff_isnull.Defined.

--- Miscellaneous\Numeral.html ---
NumeralLibrary NumeralRequireImportBasics.OvertureBasics.Numerals.DecimalBasics.Numerals.Hexadecimal.Decimal or Hexadecimal numbersVariantuint:Type0:=UIntDec(u:Decimal.uint) |UIntHex(u:Hexadecimal.uint).Variantint:Type0:=IntDec(i:Decimal.int) |IntHex(i:Hexadecimal.int).Variantnumeral:Type0:=Dec(d:Decimal.decimal) |Hex(h:Hexadecimal.hexadecimal).Registeruintasnum.num_uint.type.Registerintasnum.num_int.type.Registernumeralasnum.numeral.type.Registernumeralasnum.number.type.Pseudo-conversion functions used when declaring
    Numeral Notations onuintandint.Definitionuint_of_uint(i:uint) :=i.Definitionint_of_int(i:int) :=i.(* Parsing / printing of decimal numbers *)Number Notationuintuint_of_uintuint_of_uint:dec_uint_scope.Number Notationintint_of_intint_of_int:dec_int_scope.

--- Miscellaneous\ObjectClassifier.html ---
ObjectClassifierLibrary ObjectClassifierRequireImportHoTT.BasicsHoTT.TypesHFiberLimits.PullbackPointedTruncations.Local OpenScopepointed_scope.The object classifierWe prove that type families correspond to fibrationsequiv_sigma_fibration(Theorem 4.8.3) and the projectionpointed_type:pType->Typeis an object classifierispullback_square_objectclassifier(Theorem 4.8.4).We denote the type of all maps into a typeYas follows, and refer to them "bundles over Y".DefinitionSlice(Y:Type@{u}) := {X:Type@{u} &X->Y}.DefinitionpSlice(Y:pType@{u}) := {X:pType@{u} &X->*Y}.Definitionsigma_fibration@{uv} {Y:Type@{u}} (P:Y->Type@{u}) :Slice@{uv}Y:= (sig@{uu}P;pr1).Definitionsigma_fibration_inverse{Y:Type@{u}} (p:SliceY) :Y->Type@{u}:=hfiberp.2.Theoremisequiv_sigma_fibration`{Univalence} {Y:Type}:IsEquiv(@sigma_fibrationY).Proof.srapplyisequiv_adjointify.-exactsigma_fibration_inverse.-intros[Xp].srapplypath_sigma;cbn.+exact(path_universe(equiv_fibration_replacement_)^-1%equiv).+applytransport_arrow_toconst_path_universe.-introP.funexty;cbn.exact((path_universe(@hfiber_fibration_yP))^).Defined.Theorem 4.8.3.Definitionequiv_sigma_fibration`{Univalence} {Y:Type@{u}}: (Y->Type@{u}) <~> {X:Type@{u} &X->Y}:=Build_Equiv___isequiv_sigma_fibration.The universal map is the forgetful mappointed_type:pType->Type.We construct the universal square for the object classifier.Local Definitiontopmap{A:Type} (P:A->Type) (e:sigP) :pType:= [Pe.1,e.2].The square commutes definitionally.Definitionobjectclassifier_square{A:Type} (P:A->Type):Popr1==pointed_typeo(topmapP):=fune:sigP=>idpath(Pe.1).Theorem 4.8.4.Theoremispullback_objectclassifier_square{A:Type} (P:A->Type):IsPullback(objectclassifier_squareP).Proof.srapplyisequiv_adjointify.-intros[a[Fp]].exact(a;transportidmapp^ (pointF)).-intros[a[[Tt]p]];cbninp.refine(path_sigma'_(idpatha)_).byinductionp.-reflexivity.Defined.Classifying bundles with specified fiberBundles overBwith fiberFcorrespond to pointed maps into the universe pointed atF.Propositionequiv_sigma_fibration_p@{uv+} `{Univalence} {Y:pType@{u}} {F:Type@{u}}: (Y->* [Type@{u},F]) <~> {p:Slice@{uv}Y&hfiberp.2 (pointY) <~>F}.Proof.refine(_oE(issig_pmap__)^-1).srapply(equiv_functor_sigma'equiv_sigma_fibration);introP;cbn.refine(_oE(equiv_path_universe@{uuv}__)^-1%equiv).refine(equiv_functor_equiv_equiv_idmap).applyhfiber_fibration.Defined.If the fiberFis pointed we may upgrade the right-hand side to pointed fiber sequences.Lemmaequiv_pfiber_fibration_pfibration@{uv} {YF:pType@{u}}: {p:Slice@{uv}Y&hfiberp.2 (pointY) <~>F}<~> {p:pSlice@{uv}Y&pfiberp.2 <~>*F}.Proof.equiv_via(sig@{vu} (funX:Type@{u} =>{x:X&{p:X->Y&{eq:px=pointY&{e:hfiberp(pointY) <~>F&e^-1 (pointF) = (x;eq) } } } })).-refine(_oE_).+do5 (rapplyequiv_functor_sigma_id;intro).applyequiv_path_sigma.+cbn;make_equiv_contr_basedpaths.-refine(_oE_).2: {do5 (rapplyequiv_functor_sigma_id;intro).exact(equiv_path_inverse__oEequiv_moveL_equiv_M__). }make_equiv.Defined.Definitionequiv_sigma_pfibration@{uv+} `{Univalence} {YF:pType@{u}}: (Y->* [Type@{u},F]) <~> {p:pSlice@{uv}Y&pfiberp.2 <~>*F}:=equiv_pfiber_fibration_pfibrationoEequiv_sigma_fibration_p.The classifier for O-local typesFamilies of O-local types correspond to bundles with O-local fibers.Theoremequiv_sigma_fibration_O@{uv} `{Univalence} {O:Subuniverse} {Y:Type@{u}}: (Y->Type_@{uv}O) <~> {p: {X:Type@{u} &X->Y} &MapInOp.2 }.Proof.refine(_oE(equiv_sig_coind@{uvuvvvu}__)^-1).apply(equiv_functor_sigma'@{vuvvvv}equiv_sigma_fibration@{uv});introP;cbn.rapplyequiv_forall_inO_mapinO_pr1.Defined.Classifying O-local bundles with specified fiberWe consider a pointed baseY, and the universe of O-local typesType_Opointed at some O-local typeF.Pointed maps intoType_Ocorrespond to O-local bundles with fiberFover the base point ofY.Propositionequiv_sigma_fibration_Op@{uv+} `{Univalence} {O:Subuniverse}{Y:pType@{u}} {F:Type@{u}} `{inO:InOF}: (Y->* [Type_O, (F;inO)])<~> {p: {q:Slice@{uv}Y&MapInOq.2 } &hfiberp.1.2 (pointY) <~>F}.Proof.refine(_oE(issig_pmap__)^-1);cbn.srapply(equiv_functor_sigma'equiv_sigma_fibration_O);introP;cbn.refine(_oE(equiv_path_sigma_hprop__)^-1%equiv);cbn.refine(_oE(equiv_path_universe__)^-1%equiv).refine(equiv_functor_equiv_equiv_idmap).exact(hfiber_fibration(pointY)_).Defined.When the baseYis connected, the fibers being O-local follow from the fact that the fiberFover the base point is.Propositionequiv_sigma_fibration_Op_connected@{uv+} `{Univalence} {O:Subuniverse}{Y:pType@{u}} `{IsConnected0Y} {F:Type@{u}} `{inO:InOF}: (Y->* [Type_O, (F;inO)])<~> {p:Slice@{uv}Y&hfiberp.2 (pointY) <~>F}.Proof.refine(_oEequiv_sigma_fibration_Op).refine(_oE(equiv_sigma_assoc'_(funp_=>hfiberp.2 (pointY) <~>F))^-1%equiv).srapplyequiv_functor_sigma_id;intro;cbn.refine(_oEequiv_sigma_symm0__).applyequiv_sigma_contr;introe.rapplycontr_inhabited_hprop.rapplyconn_point_elim.apply(inO_equiv_inOFe^-1).Defined.Classifying O-local bundles with specified pointed fiberWhen the fiberFis pointed, the right-hand side can be upgraded to pointed fiber sequences with O-local fibers.Propositionequiv_sigma_pfibration_O`{Univalence} (O:Subuniverse){YF:pType} `{inO:InOF}: (Y->* [Type_O, (pointed_typeF;inO)])<~> {p: {q:pSliceY&MapInOq.2 } &pfiberp.1.2 <~>*F}.Proof.refine(_oEequiv_sigma_fibration_Op).refine(_oEequiv_sigma_symm'_(funq=>hfiberq.2 (pointY) <~>F)).refine(equiv_sigma_symm'(funq=>pfiberq.2 <~>*F)_oE_).byrapply(equiv_functor_sigma'equiv_pfiber_fibration_pfibration).Defined.When moreover the baseYis connected, the right-hand side is exactly the type of pointed fiber sequences, since the fibers being O-local follow fromFbeing O-local andYconnected.Definitionequiv_sigma_pfibration_O_connected@{uv+} `{Univalence} (O:Subuniverse){YF:pType@{u}} `{IsConnected0Y} `{inO:InOF}: (Y->* [Type_O, (pointed_typeF;inO)])<~> {p:pSlice@{uv}Y&pfiberp.2 <~>*F}:=equiv_pfiber_fibration_pfibrationoEequiv_sigma_fibration_Op_connected.As a corollary, pointed maps into the unverse of O-local types are just pointed maps into the universe, when the baseYis connected.Definitionequiv_pmap_typeO_type_connected`{Univalence} {O:Subuniverse}{Y:pType@{u}} `{IsConnected0Y} {F:Type@{u}} `{inO:InOF}: (Y->* [Type_O, (F;inO)]) <~> (Y->* [Type@{u},F]):=equiv_sigma_fibration_p^-1oEequiv_sigma_fibration_Op_connected.

--- Miscellaneous\Objects.html ---
ObjectsLibrary ObjectsUniversal objectsRequireImportCategory.CoreCategory.Morphisms.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Local OpenScopemorphism_scope.Definition of "unique up to unique isomorphism"Definitionunique_up_to_unique_isomorphism(C:PreCategory) (P:C->Type) :=forallx(_:Px)x'(_:Px'),{c:Contr(morphismCxx')|IsIsomorphism(center(morphismCxx')) }.Terminal objectsA terminal object is an object with a unique morphism from every
    other object.NotationIsTerminalObjectCx:=(forallx':objectC,Contr(morphismCx'x)).RecordTerminalObject(C:PreCategory) :={object_terminal:>C;isterminal_object_terminal:>IsTerminalObjectCobject_terminal}.Global Existing Instanceisterminal_object_terminal.Initial objectsAn initial object is an object with a unique morphism from every
    other object.NotationIsInitialObjectCx:=(forallx':objectC,Contr(morphismCxx')).RecordInitialObject(C:PreCategory) :={object_initial:>C;isinitial_object_initial:>IsInitialObjectCobject_initial}.Global Existing Instanceisinitial_object_initial.Argumentsunique_up_to_unique_isomorphism[C]P.Initial and terminal objects are unique up to unique isomorphismSectionCategoryObjectsTheorems.VariableC:PreCategory.Local Ltacunique:=repeatfirst[intro|exists_|exists(center(morphismC__))|etransitivity; [symmetry| ];applycontr].The terminal object is unique up to unique isomorphism.Theoremterminal_object_unique:unique_up_to_unique_isomorphism(funx=>IsTerminalObjectCx).Proof.unique.Qed.The initial object is unique up to unique isomorphism.Theoreminitial_object_unique:unique_up_to_unique_isomorphism(funx=>IsInitialObjectCx).Proof.unique.Qed.EndCategoryObjectsTheorems.

--- Miscellaneous\OnMorphisms.html ---
OnMorphismsLibrary OnMorphisms∑-categories on morphisms - a category with the same objects, but a ∑ type for morphismsRequireImportHoTT.TacticsTypes.ForallTypes.SigmaBasics.Trunc.RequireImportCategory.CoreFunctor.CoreCategory.Sigma.Core.RequireFunctor.Composition.CoreFunctor.Identity.RequireImportFunctor.Paths.ImportFunctor.Identity.FunctorIdentityNotations.ImportFunctor.Composition.Core.FunctorCompositionCoreNotations.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local Notationsig_type:=Overture.sig.Local Notationpr1_type:=Overture.pr1.Local OpenScopemorphism_scope.Local OpenScopefunctor_scope.Sectionsig_mor.VariableA:PreCategory.VariablePmor:forallsd,morphismAsd->Type.Local Notationmorsd:= (sig_type(Pmorsd)).Context`(HPmor:forallsd,IsHSet(morsd)).VariablePidentity:forallx, @Pmorxx(@identityA_).VariablePcompose:forallsdd'm1m2,@Pmordd'm1-> @Pmorsdm2-> @Pmorsd'(m1om2).Local Notationidentityx:= (@identityAx; @Pidentityx).Local Notationcomposem1m2:= (m1.1om2.1; @Pcompose___m1.1m2.1m1.2m2.2)%morphism.HypothesisP_associativity:forallx1x2x3x4(m1:morx1x2) (m2:morx2x3) (m3:morx3x4),compose(composem3m2)m1=composem3(composem2m1).HypothesisP_left_identity:forallab(f:morab),compose(identityb)f=f.HypothesisP_right_identity:forallab(f:morab),composef(identitya) =f.Definition ofsig_mor-precategoryDefinitionsig_mor':PreCategory.Proof.refine(@Build_PreCategory(objectA)(funsd=>morsd)(funx=>identityx)(funsdd'm1m2=>composem1m2)____);assumption.Defined.First projection functorDefinitionpr1_mor:Functorsig_mor'A:=Build_Functorsig_mor'Aidmap(fun__=> @pr1_type__)(fun_____=>idpath)(fun_=>idpath).Definitionsig_mor_as_sig:PreCategory.Proof.refine(@sig'A(fun_=>Unit) (funsd=> @Pmor(pr1_types) (pr1_typed))_(fun_=>Pidentity_) (fun_____m1m2=>Pcomposem1m2)___);intros;trivial.Defined.Definitionsig_functor_mor:Functorsig_mor_as_sigsig_mor':=Build_Functorsig_mor_as_sigsig_mor'(@pr1_type__)(fun__=>idmap)(fun_____=>idpath)(fun_=>idpath).Definitionsig_functor_mor_inv:Functorsig_mor'sig_mor_as_sig:=Build_Functorsig_mor'sig_mor_as_sig(funx=>exist_xtt)(fun__=>idmap)(fun_____=>idpath)(fun_=>idpath).Local OpenScopefunctor_scope.Lemmasig_mor_eq`{Funext}:sig_functor_morosig_functor_mor_inv= 1/\sig_functor_mor_invosig_functor_mor= 1.Proof.split;path_functor;simpl;trivial.refine(exist_(path_forall__(funx=>matchxasxreturn(x.1;tt) =xwith| (_;tt) =>idpathend))_).repeat(applypath_forall;intro).destruct_head@sig_type.destruct_headUnit.rewrite!transport_forall_constant.transport_path_forall_hammer.reflexivity.Qed.Definitionsig_mor_compat:pr1_morosig_functor_mor=pr1':=idpath.Endsig_mor.Argumentspr1_mor{APmor_PidentityPcomposeP_associativityP_left_identityP_right_identity}.Sectionsig_mor_hProp.VariableA:PreCategory.VariablePmor:forallsd,morphismAsd->Type.Local Notationmorsd:= (sig_type(Pmorsd)).Context`(HPmor:forallsdm,IsHProp(Pmorsdm)).VariablePidentity:forallx, @Pmorxx(@identityA_).VariablePcompose:forallsdd'm1m2,@Pmordd'm1-> @Pmorsdm2-> @Pmorsd'(m1om2).Local Notationidentityx:= (@identityAx; @Pidentityx).Local Notationcomposem1m2:= (m1.1om2.1; @Pcompose___m1.1m2.1m1.2m2.2)%morphism.Local Ltactex_tac:=intros;simpl;applypath_sigma_uncurried;simpl;ex_tac;applypath_ishprop.LetP_associativity:forallx1x2x3x4(m1:morx1x2) (m2:morx2x3) (m3:morx3x4),compose(composem3m2)m1=composem3(composem2m1).Proof.abstracttltac:(exists(associativity________))usingP_associativity_on_morphisms_subproof.Defined.LetP_left_identity:forallab(f:morab),compose(identityb)f=f.Proof.clearP_associativity.abstracttltac:(exists(left_identity____))usingP_left_identity_on_morphisms_subproof.Defined.LetP_right_identity:forallab(f:morab),composef(identitya) =f.Proof.clearP_associativityP_left_identity.abstracttltac:(exists(right_identity____))usingP_right_identity_on_morphisms_subproof.Defined.Definition ofsig_mor-precategoryDefinitionsig_mor:PreCategory:=Evalcbvdelta[P_associativityP_left_identityP_right_identity]in@sig_mor'APmor_PidentityPcomposeP_associativityP_left_identityP_right_identity.First projection functorDefinitionproj1_sig_mor:Functorsig_morA:=pr1_mor.Endsig_mor_hProp.Argumentsproj1_sig_mor{APmorHPmorPidentityPcompose}.

--- Miscellaneous\OnObjects.html ---
OnObjectsLibrary OnObjects∑-categories on objects - a generalization of subcategoriesRequireImportHoTT.BasicsHoTT.Types.RequireImportCategory.CoreFunctor.CoreCategory.Sigma.Core.RequireFunctor.Composition.CoreFunctor.Identity.RequireImportFunctor.Paths.ImportFunctor.Identity.FunctorIdentityNotations.ImportFunctor.Composition.Core.FunctorCompositionCoreNotations.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local Notationsig_type:=Overture.sig.Local Notationpr1_type:=Overture.pr1.Local OpenScopemorphism_scope.Local OpenScopefunctor_scope.Sectionsig_obj.VariableA:PreCategory.VariablePobj:A->Type.Definition ofsig_obj-precategoryDefinitionsig_obj:PreCategory:= @Build_PreCategory(sig_typePobj)(funsd=>morphismA(pr1_types) (pr1_typed))(funx=> @identityA(pr1_typex))(funsdd'm1m2=>m1om2)%morphism(fun____=>associativityA____)(fun__=>left_identityA__)(fun__=>right_identityA__)_.First projection functorDefinitionpr1_obj:Functorsig_objA:=Build_Functorsig_objA(@pr1_type__)(funsdm=>m)(fun_____=>idpath)(fun_=>idpath).Definitionsig_obj_as_sig:PreCategory:= @sigAPobj(fun___=>Unit)_(fun_=>tt) (fun_______=>tt).Definitionsig_functor_obj:Functorsig_obj_as_sigsig_obj:=Build_Functorsig_obj_as_sigsig_obj(funx=>x)(fun__=> @pr1_type__)(fun_____=>idpath)(fun_=>idpath).Definitionsig_functor_obj_inv:Functorsig_objsig_obj_as_sig:=Build_Functorsig_objsig_obj_as_sig(funx=>x)(fun__m=>exist_mtt)(fun_____=>idpath)(fun_=>idpath).Local OpenScopefunctor_scope.Lemmasig_obj_eq`{Funext}:sig_functor_objosig_functor_obj_inv= 1/\sig_functor_obj_invosig_functor_obj= 1.Proof.split;path_functor;trivial.applypath_forall;intros[].applypath_forall;intros[].applypath_forall;intros[? []].reflexivity.Qed.Definitionsig_obj_compat:pr1_objosig_functor_obj=pr1':=idpath.Endsig_obj.Argumentspr1_obj{APobj}.ModuleExportCategorySigmaOnObjectsNotations.Notation"{ x : A | P }" := (sig_objA(funx=>P)) :category_scope.EndCategorySigmaOnObjectsNotations.

--- Miscellaneous\ooAction.html ---
ooActionLibrary ooActionRequireImportBasics.RequireImportAlgebra.ooGroup.Local OpenScopepath_scope.Actions of oo-GroupsDefinitionooAction(G:ooGroup):=classifying_spaceG->Type.Definitionaction_space{G} :ooActionG->Type:=funX=>X(point_).Coercionaction_space:ooAction>->Sortclass.

--- Miscellaneous\ooGroup.html ---
ooGroupLibrary ooGroupRequireImportBasicsTypes.RequireImportPointed.RequireImportTruncations.CoreTruncations.Connectedness.RequireImportHomotopy.ClassifyingSpace.RequireImportAlgebra.Groups.RequireImportWildCat.Local OpenScopetrunc_scope.Local OpenScopepath_scope.Local OpenScopepointed_scope.Keyed unification makesrewrite!loops_functor_grouptake a really long time.  See https://coq.inria.fr/bugs/show_bug.cgi?id=4544 for more discussion.LocalUnsetKeyedUnification.oo-GroupsWe want a workable definition of "oo-group" (what a classical homotopy theorist would call a "grouplike Aoo-space"). The classical definitions using operads or Segal spaces involve infinitely much data, which we don't know how to handle in HoTT. But instead, we can invoke the theorem (which is a theorem in classical homotopy theory, and also in any oo-topos) that every oo-group is the loop space of some pointed connected object, and use it instead as a definition: we define an oo-group to be a pointed connected type (its classifying space or delooping). Then we make subsidiary definitions to allow us to treat such an object in the way we would expect, e.g. an oo-group homomorphism is a pointed map between classifying spaces.DefinitionRecordooGroup:={classifying_space:pType;isconn_classifying_space:IsConnected0classifying_space}.Global Existing Instanceisconn_classifying_space.Local NotationB:=classifying_space.Definitiongroup_type(G:ooGroup) :Type:=point(BG) =point(BG).The following is fundamental: we declare a coercion from oo-groups to types which takes a pointed connected type not to its underlying type, but to its loop space. Thus, ifG:ooGroup, theng:Gmeans thatgis an element of the oo-group thatGis intended to denote, which is the loop space of the pointed connected type that is technically the data of whichG:ooGroupconsists. This makes it easier to really think ofGas "really being" an oo-group rather than its classifying space.This is also convenient because elements of oo-groups are, definitionally, loops in some type. Thus, the oo-group operations like multiplication, inverse, associativity, higher associativity, etc. are simply special cases of the corresponding operations for paths.Coerciongroup_type:ooGroup>->Sortclass.Every pointed type has a loop space that is an oo-group.Definitiongroup_loops(X:pType):ooGroup.Proof.pose(BG:= [{x:X&merely(x=pt) },exist(funx:X=>merely(x=pt))pt(tr1)]).Usingcutprevents Coq from looking for these facts with typeclass search, which is slow and (for some reason) introduces scads of extra universes.cut(IsConnected0BG).{exact(Build_ooGroupBG). }cut(IsSurjection(unit_name(pointBG))).{intros;refine(conn_pointed_typept). }applyBuildIsSurjection;simpl;intros[xp].strip_truncations;applytr;existstt.applypath_sigma_hprop;simpl.exact(p^).Defined.Unfortunately, the underlying type of that oo-group is not *definitionally* the same as the ordinary loop space, but it is equivalent to it.Definitionloops_group(X:pType):loopsX<~>group_loopsX.Proof.unfoldloops,group_type.simpl.exact(equiv_path_sigma_hprop(pointX;tr1) (pointX;tr1)).Defined.HomomorphismsDefinitionDefinitionooGroupHom(GH:ooGroup):=BG->*BH.Definitiongrouphom_fun{GH} (phi:ooGroupHomGH) :G->H:=fmaploopsphi.Coerciongrouphom_fun:ooGroupHom>->Funclass.The loop group functor takes values in oo-group homomorphisms.Definitiongroup_loops_functor{XY:pType} (f:X->*Y):ooGroupHom(group_loopsX) (group_loopsY).Proof.simplerefine(Build_pMap____);simpl.-intros[xp].exists(fx).strip_truncations;applytr.exact(apfp@point_eqf).-applypath_sigma_hprop;simpl.applypoint_eq.Defined.And this functor "is" the same as the ordinary loop space functor.Definitionloops_functor_group{XY:pType} (f:X->*Y):fmaploops(group_loops_functorf)oloops_groupX==loops_groupYofmaploopsf.Proof.introsx.apply(equiv_inj(equiv_path_sigma_hprop__)^-1).simpl.unfoldpr1_path;rewrite!ap_pp.rewriteap_V, !ap_pr1_path_sigma_hprop.applywhiskerL,whiskerR.transitivity(ap(funX0: {x0:X&merely(x0=pointX)} =>fX0.1)(path_sigma_hprop(pointX;tr1) (pointX;tr1)x)).-matchgoalwith|-ap?f(ap?g?p) = ?z=>symmetry;refine(ap_composegfp)end.-rewriteap_compose;applyap.applyap_pr1_path_sigma_hprop.Qed.Definitiongrouphom_compose{GHK:ooGroup}(psi:ooGroupHomHK) (phi:ooGroupHomGH):ooGroupHomGK:=pmap_composepsiphi.FunctorialityDefinitiongroup_loops_functor_compose{XYZ:pType}(psi:Y->*Z) (phi:X->*Y):grouphom_compose(group_loops_functorpsi) (group_loops_functorphi)==group_loops_functor(pmap_composepsiphi).Proof.introsg.unfoldgrouphom_fun,grouphom_compose.refine(pointed_htpy(fmap_comploops__)g@_).pose(p:=eisretr(loops_groupX)g).change(fmaploops(group_loops_functorpsi)(fmaploops(group_loops_functorphi)g)=fmaploops(group_loops_functor(pmap_composepsiphi))g).rewrite<-p.rewrite!loops_functor_group.applyap.symmetry;rapply(fmap_comploops).Qed.Definitiongrouphom_idmap(G:ooGroup) :ooGroupHomGG:=pmap_idmap.Definitiongroup_loops_functor_idmap{X:pType}:grouphom_idmap(group_loopsX)==group_loops_functor(Id(A:=pType)_).Proof.introsg.refine(fmap_idloops_g@_).rewrite<- (eisretr(loops_groupX)g).unfoldgrouphom_fun,grouphom_idmap.rewrite!loops_functor_group.exact(ap(loops_groupX) (fmap_idloops__)^).Qed.Homomorphic propertiesThe following tactic often allows us to "pretend" that phi preserves basepoints strictly.  This is basically a simple extension ofpointed_reduce_rewrite(see Pointed.v).Ltacgrouphom_reduce:=unfoldgrouphom_fun;cbn;repeatmatchgoalwith| [G:ooGroup|-_] =>destructGas[G?]| [phi:ooGroupHom?G?H|-_] =>destructphias[phi?]end;pointed_reduce_rewrite.Definitioncompose_grouphom{GHK:ooGroup}(psi:ooGroupHomHK) (phi:ooGroupHomGH):grouphom_composepsiphi==psiophi.Proof.introsg;grouphom_reduce.exact(ap_composephipsig).Qed.Definitionidmap_grouphom(G:ooGroup):grouphom_idmapG==idmap.Proof.introsg;grouphom_reduce.exact(ap_idmapg).Qed.Definitiongrouphom_pp{GH} (phi:ooGroupHomGH) (g1g2:G):phi(g1@g2) =phig1@phig2.Proof.grouphom_reduce.exact(ap_ppphig1g2).Qed.Definitiongrouphom_V{GH} (phi:ooGroupHomGH) (g:G):phig^ = (phig)^.Proof.grouphom_reduce.exact(ap_Vphig).Qed.Definitiongrouphom_1{GH} (phi:ooGroupHomGH):phi1 = 1.Proof.grouphom_reduce.reflexivity.Qed.Definitiongrouphom_pp_p{GH} (phi:ooGroupHomGH) (g1g2g3:G):grouphom_ppphi(g1@g2)g3@whiskerR(grouphom_ppphig1g2) (phig3)@concat_pp_p(phig1) (phig2) (phig3)=apphi(concat_pp_pg1g2g3)@grouphom_ppphig1(g2@g3)@whiskerL(phig1) (grouphom_ppphig2g3).Proof.grouphom_reduce.Abort.SubgroupsSectionSubgroups.Context{GH:ooGroup} (incl:ooGroupHomHG) `{IsEmbeddingincl}.A subgroup induces an equivalence relation on the ambient group, whose equivalence classes are called "cosets".Definitionin_coset:G->G->Type:=fung1g2=>hfiberincl(g1@g2^).Global Instanceishprop_in_coset:is_mere_relationGin_coset.Proof.exact_.Defined.Global Instancereflexive_coset:Reflexivein_coset.Proof.introsg.exact(1 ;grouphom_1incl@ (concat_pVg)^).Defined.Global Instancesymmetric_coset:Symmetricin_coset.Proof.introsg1g2[hp].exists(h^).refine(grouphom_Vinclh@inverse2p@inv_pp__@whiskerR(inv_V_)_).Defined.Global Instancetransitive_coset:Transitivein_coset.Proof.introsg1g2g3[h1p1] [h2p2].exists(h1@h2).refine(grouphom_ppinclh1h2@ (p1@@p2)@concat_p_pp___@whiskerR(concat_pV_p__)_).Defined.Every coset is equivalent (as a type) to the subgroup itself.Definitionequiv_coset_subgroup(g:G): {g':G&in_cosetgg'} <~>H.Proof.simplerefine(equiv_adjointify____).-intros[? [h?]];exacth.-introsh;exists(inclh^ @g);existsh;simpl.abstract(rewriteinv_pp,grouphom_V,inv_V,concat_p_Vp;reflexivity).-introsh;reflexivity.-intros[g'[hp]].applypath_sigma_hprop;simpl.refine((grouphom_Vinclh@@ 1) @_).applymoveR_Vp,moveL_pM.exact(p^).Defined.Definitioncosets:=Quotientin_coset.EndSubgroups.The wild category of oo-groups is induced by the wild category of pTypesGlobal Instanceisgraph_oogroup:IsGraphooGroup:=Build_IsGraph_ooGroupHom.Global Instanceis01cat_oogroup:Is01CatooGroup:=Build_Is01Cat__grouphom_idmap(@grouphom_compose).Global Instanceis2graph_oogroup:Is2GraphooGroup:=is2graph_inducedclassifying_space.Global Instanceis1cat_oogroup:Is1CatooGroup:=is1cat_inducedclassifying_space.1-groups as oo-groupsDefinitiongroup_to_oogroup:Group->ooGroup:=funG=>Build_ooGroup(pClassifyingSpaceG)_.Global Instanceis0functor_group_to_oogroup:Is0Functorgroup_to_oogroup.Proof.snrapplyBuild_Is0Functor.introsGHf.byrapply(fmappClassifyingSpace).Defined.Global Instanceis1functor_group_to_oogroup:Is1Functorgroup_to_oogroup.Proof.snrapplyBuild_Is1Functor;hnf;intros.1:byrapply(fmap2pClassifyingSpace).1:byrapply(fmap_idpClassifyingSpace).byrapply(fmap_comppClassifyingSpace).Defined.

--- Miscellaneous\Open.html ---
OpenLibrary OpenRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensions.RequireImportModalityAccessibleNullificationLex.Local OpenScopepath_scope.Open modalitiesDefinitionDefinitionOp`{Funext} (U:HProp) :Modality.Proof.snrapplyeasy_modality.-introsX;exact(U->X).-introsTx;cbn.exact(fun_=>x).-cbn;introsABfzu.refine(transportB_(f(zu)u)).applypath_arrow;introsu'.applyap;applypath_ishprop.-cbn;introsABfa.applypath_arrow;introsu.transitivity(transportB1 (fau));autowithpath_hints.apply(ap(funp=>transportBp(fau))).transitivity(path_arrow(fun_=>a) (fun_=>a) (@ap10U___1));autowithpath_hints.*applyap.applypath_forall;introsu'.applyap_const.*applyeta_path_arrow.-introsAzz'.srefine(isequiv_adjointify____).*introsf;applypath_arrow;introsu.exact(ap10(fu)u).*introsf;applypath_arrow;introsu.transitivity(path_arrowzz'(ap10(fu))).+unfoldto;applyap.applypath_forall;introsu'.apply(ap(funu0=>ap10(fu0)u')).applypath_ishprop.+applyeta_path_arrow.*introsp.refine(eta_path_arrow___).Defined.The open modality is lexNote that unlike most other cases, we can prove this without univalence (though we do of course need funext).Global Instancelex_open`{Funext} (U:HProp):Lex(OpU).Proof.applylex_from_isconnected_paths.introsAAcxy.nrapplycontr_forall.introu.pose(contr_inhabited_hpropUu).rapplycontr_paths_contr.refine(contr_equiv(U->A) (equiv_contr_forall_)).exactAc.Defined.The open modality is accessible.Global Instanceacc_open`{Funext} (U:HProp):IsAccModality(OpU).Proof.unshelveeconstructor.-econstructor.exact(unit_nameU).-introsX;split.+introsX_inOu.apply(equiv_inverse(equiv_ooextendable_isequiv__)).refine(cancelR_isequiv(funx(u:Unit) =>x)).applyX_inO.+introsext;specialize(exttt).refine(isequiv_compose(f:= (funx=>unit_namex))(g:= (funh=>hoconst_ttU))).refine(isequiv_ooextendable(fun_=>X) (const_ttU)ext).Defined.Thus, arguably a better definition ofOpwould be as a nullification modality, as it would not requireFunextand would have a judgmental computation rule.  However, the above definition is also nice to know, as it doesn't use HITs.  We name the other versionOp'.DefinitionOp'(U:HProp) :Modality:=Nul(Build_NullGeneratorsUnit(fun_=>U)).

--- Miscellaneous\Operation.html ---
OperationLibrary OperationThis file continues the development of algebraOperation. It
    gives a way to construct operations using (conventional) curried
    functions, and shows that such curried operations are equivalent
    to the uncurried operationsOperation.RequireExportHoTT.Algebra.Universal.Algebra.RequireImportHoTT.TypesHoTT.Spaces.FiniteHoTT.Spaces.Nat.Core.Local OpenScopeAlgebra_scope.Local OpenScopenat_scope.Functionshead_dom'andhead_domare used to get the first
    element of a nonempty operation domaina:foralli,A(ssi).Monomorphic Definitionhead_dom'{σ} (A:Carriersσ) (n:nat):forall(N:n> 0) (ss:FinSeqn(Sortσ)) (a:foralli,A(ssi)),A(fshead'nNss):=matchnwith| 0 =>funNss_=>Empty_rec(lt_irrefl_N)|n'.+1 =>funNssa=>afin_zeroend.Monomorphic Definitionhead_dom{σ} (A:Carriersσ) {n:nat}(ss:FinSeqn.+1 (Sortσ)) (a:foralli,A(ssi)):A(fsheadss):=head_dom'An.+1_ssa.Functionstail_dom'andtail_domare used to obtain the tail
    of an operation domaina:foralli,A(ssi).Monomorphic Definitiontail_dom'{σ} (A:Carriersσ) (n:nat):forall(ss:FinSeqn(Sortσ)) (a:foralli,A(ssi)) (i:Fin(nat_predn)),A(fstail'nssi):=matchnwith| 0 =>funss_i=>Empty_reci|n'.+1 =>funssai=>a(fsucci)end.Monomorphic Definitiontail_dom{σ} (A:Carriersσ) {n:nat}(ss:FinSeqn.+1 (Sortσ)) (a:foralli,A(ssi)):foralli,A(fstailssi):=tail_dom'An.+1ssa.Functionscons_dom'andcons_domto add an element to
    the front of a given domaina:foralli,A(ssi).Monomorphic Definitioncons_dom'{σ} (A:Carriersσ) {n:nat}:forall(i:Finn) (ss:FinSeqn(Sortσ)) (N:n> 0),A(fshead'nNss) -> (foralli,A(fstail'nssi)) ->A(ssi):=fin_ind(funni=>forall(ss:Finn->Sortσ) (N:n> 0),A(fshead'nNss) -> (foralli,A(fstail'nssi)) ->A(ssi))(funn'_zx_=>x)(funn'i'_=>fun___xs=>xsi').Definitioncons_dom{σ} (A:Carriersσ){n:nat} (ss:FinSeqn.+1 (Sortσ))(x:A(fsheadss)) (xs:foralli,A(fstailssi)):foralli:Finn.+1,A(ssi):=funi=>cons_dom'Aiss_xxs.The empty domain:Definitionnil_dom{σ} (A:Carriersσ) (ss:FinSeq0 (Sortσ)):foralli:Fin0,A(ssi):=Empty_ind(Aoss).A specialization ofOperationto finiteFinnarity.DefinitionFiniteOperation{σ :Signature} (A:Carriersσ){n:nat} (ss:FinSeqn(Sortσ)) (t:Sortσ) :Type:=OperationA{|Arity:=Finn;sorts_dom:=ss;sort_cod:=t|}.A type of curried operationsCurriedOperation A [s1, ..., sn] t := A s1 -> ... -> A sn -> A t.FixpointCurriedOperation{σ} (A:Carriersσ) {n:nat}: (FinSeqn(Sortσ)) ->Sortσ ->Type:=matchnwith| 0 =>funsst=>At|n'.+1 =>funsst=>A(fsheadss) ->CurriedOperationA(fstailss)tend.Functionoperation_uncurryis used to uncurry an operationoperation_uncurry A [s1, ..., sn] t (op : CurriedOperation A [s1, ..., sn] t)
  : FiniteOperation A [s1, ..., sn] t
  := fun (x1 : A s1, ..., xn : A xn) => op x1 ... xnSeeequiv_operation_currybelow.Fixpointoperation_uncurry{σ} (A:Carriersσ) {n:nat}:forall(ss:FinSeqn(Sortσ)) (t:Sortσ),CurriedOperationAsst->FiniteOperationAsst:=matchnwith| 0 =>funsstop_=>op|n'.+1 =>funsstopa=>operation_uncurryA(fstailss)t(op(afin_zero)) (aofsucc)end.Local Examplecomputation_example_operation_uncurry:forall(σ :Signature) (A:Carriersσ) (n:nat) (s1s2t:Sortσ)(ss:= (fsconss1(fsconss2fsnil)))(op:CurriedOperationAsst) (a:foralli,A(ssi)),operation_uncurryAsstop=funa=>op(afin_zero) (a(fsuccfin_zero)).Proof.reflexivity.Qed.Functionoperation_curryis used to curry an operationoperation_curry A [s1, ..., sn] t (op : FiniteOperation A [s1, ..., sn] t)
  : CurriedOperation A [s1, ..., sn] t
  := fun (x1 : A s1) ... (xn : A xn) => op (x1, ..., xn)Seeequiv_operation_currybelow.Fixpointoperation_curry{σ} (A:Carriersσ) {n:nat}:forall(ss:FinSeqn(Sortσ)) (t:Sortσ),FiniteOperationAsst->CurriedOperationAsst:=matchnwith| 0 =>funsstop=>op(Empty_ind_)|n'.+1 =>funsstopx=>operation_curryA(fstailss)t(opocons_domAssx)end.Local Examplecomputation_example_operation_curry:forall(σ :Signature) (A:Carriersσ) (n:nat) (s1s2t:Sortσ)(ss:= (fsconss1(fsconss2fsnil)))(op:FiniteOperationAsst)(x1:As1) (x2:As2),operation_curryAsstop=funx1x2=>op(cons_domAssx1(cons_domA_x2(nil_domA_))).Proof.reflexivity.Qed.Lemmaexpand_cons_dom'{σ} (A:Carriersσ) (n:nat):forall(i:Finn) (ss:FinSeqn(Sortσ)) (N:n> 0)(a:foralli,A(ssi)),cons_dom'AissN(head_dom'AnNssa) (tail_dom'Anssa) =ai.Proof.introi.inductioniusingfin_ind;introsssNa.-unfoldcons_dom'.rewritefin_ind_beta_zero.reflexivity.-unfoldcons_dom'.byrewritefin_ind_beta_fsucc.Qed.Lemmaexpand_cons_dom`{Funext} {σ} (A:Carriersσ){n:nat} (ss:FinSeqn.+1 (Sortσ)) (a:foralli,A(ssi)):cons_domAss(head_domAssa) (tail_domAssa) =a.Proof.funexti.applyexpand_cons_dom'.Defined.Lemmapath_operation_curry_to_cunurry`{Funext} {σ} (A:Carriersσ){n:nat} (ss:FinSeqn(Sortσ)) (t:Sortσ):operation_uncurryAsstooperation_curryAsst==idmap.Proof.introa.inductionnas[|nIHn].-funextd.refine(apa_).applypath_contr.-funexta'.refine(ap(funx=>x_) (IHn__) @_).refine(apa_).applyexpand_cons_dom.Qed.Lemmapath_operation_uncurry_to_curry`{Funext} {σ} (A:Carriersσ){n:nat} (ss:FinSeqn(Sortσ)) (t:Sortσ):operation_curryAsstooperation_uncurryAsst==idmap.Proof.introa.inductionn; [reflexivity|].funextx.refine(_@IHn(fstailss) (ax)).refine(ap(operation_curryA(fstailss)t)_).funexta'.simpl.unfoldcons_dom,cons_dom'.rewritefin_ind_beta_zero.refine(ap(operation_uncurryA(fstailss)t(ax))_).funexti'.byrewritefin_ind_beta_fsucc.Qed.Global Instanceisequiv_operation_curry`{Funext} {σ} (A:Carriersσ){n:nat} (ss:FinSeqn(Sortσ)) (t:Sortσ):IsEquiv(operation_curryAsst).Proof.srapplyisequiv_adjointify.-applyoperation_uncurry.-applypath_operation_uncurry_to_curry.-applypath_operation_curry_to_cunurry.Defined.Definitionequiv_operation_curry`{Funext} {σ} (A:Carriersσ){n:nat} (ss:FinSeqn(Sortσ)) (t:Sortσ):FiniteOperationAsst<~>CurriedOperationAsst:=Build_Equiv__(operation_curryAsst)_.

--- Miscellaneous\Opposite.html ---
OppositeLibrary OppositeRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.Opposite categoriesDefinitionop(A:Type) :=A.Notation"A ^op" := (opA).This stops typeclass search from trying to unfold op.#[global]TypeclassesOpaqueop.Global Instanceisgraph_op{A:Type} `{IsGraphA}:IsGraphA^op.Proof.applyBuild_IsGraph.unfoldop;exact(funab=>b$->a).Defined.Global Instanceis01cat_op{A:Type} `{Is01CatA} :Is01CatA^op.Proof.applyBuild_Is01Cat.+cbv;exactId.+cbv;exact(funabcgf=>f$og).Defined.We don't invert 2-cells as this is op on the first level.Global Instanceis2graph_op{A:Type} `{Is2GraphA} :Is2GraphA^op.Proof.introsab;unfoldopin*;cbn;exact_.Defined.Global Instanceis1cat_op{A:Type} `{Is1CatA} :Is1CatA^op.Proof.snrapplyBuild_Is1Cat;unfoldopin*;cbvin*.-introsab.applyis01cat_hom.-introsab.applyis0gpd_hom.-introsabch.srapplyBuild_Is0Functor.introsfgp.cbnin*.exact(p$@Rh).-introsabch.srapplyBuild_Is0Functor.introsfgp.cbnin*.exact(h$@Lp).-introsabcdfgh;exact(cat_assoc_opphgf).-introsabcdfgh;exact(cat_assochgf).-introsabf;exact(cat_idrf).-introsabf;exact(cat_idlf).Defined.Global Instanceis1cat_strong_opA`{Is1Cat_StrongA}:Is1Cat_Strong(A^op).Proof.snrapplyBuild_Is1Cat_Strong.1-4:exact_.all:cbn.-introsabcdfgh;exact(cat_assoc_opp_stronghgf).-introsabcdfgh;exact(cat_assoc_stronghgf).-introsabf.applycat_idr_strong.-introsabf.applycat_idl_strong.Defined.Opposite groupoidsGlobal Instanceis0gpd_opA`{Is0GpdA} :Is0Gpd(A^op).Proof.srapplyBuild_Is0Gpd;unfoldopin*;cbnin*.introsab.applygpd_rev.Defined.Global Instanceop0gpd_funA`{Is0GpdA} :Is0Functor( (funx=>x) :A^op->A).Proof.srapplyBuild_Is0Functor;unfoldopin*;cbn.introsab.exact(funf=>f^$).Defined.Opposite functorsGlobal Instanceis0functor_opAB(F:A->B)`{IsGraphA,IsGraphB,x: !Is0FunctorF}:Is0Functor(F:A^op->B^op).Proof.applyBuild_Is0Functor.introsab;cbn.applyfmap.assumption.Defined.Global Instanceis1functor_opAB(F:A->B)`{Is1CatA,Is1CatB, !Is0FunctorF, !Is1FunctorF}:Is1Functor(F:A^op->B^op).Proof.applyBuild_Is1Functor;cbn.-introsab;rapplyfmap2.-exact(fmap_idF).-introsabcfg;exact(fmap_compFgf).Defined.SinceIs01Catstructures are definitionally involutive (see test/WildCat/Opposite.v), we can useis0functor_opto transform in the reverse direction as well.  This result makes that much easier to use in practice.Global Instanceis0functor_op'AB(F:A^op->B^op)`{IsGraphA,IsGraphB,Fop: !Is0Functor(F:A^op->B^op)}:Is0Functor(F:A->B):=is0functor_opA^opB^opF.Is1Catstructures are also definitionally involutive.Global Instanceis1functor_op'AB(F:A^op->B^op)`{Is1CatA,Is1CatB, !Is0Functor(F:A^op->B^op),Fop2: !Is1Functor(F:A^op->B^op)}:Is1Functor(F:A->B):=is1functor_opA^opB^opF.Global Instancehasmorext_op{A:Type} `{H0:HasMorExtA}:HasMorExtA^op.Proof.snrapplyBuild_HasMorExt.introsabfg.refine(@isequiv_Htpy_path_____H0bafg).Defined.Global Instanceisinitial_op_isterminal{A:Type} `{Is1CatA} (x:A){t:IsTerminalx} :IsInitial(A:=A^op)x:=t.Global Instanceisterminal_op_isinitial{A:Type} `{Is1CatA} (x:A){i:IsInitialx} :IsTerminal(A:=A^op)x:=i.

--- Miscellaneous\Option.html ---
OptionLibrary OptionRequireImportBasics.Overture.Option typesOption types are a simple way to represent a value that may or may not be present. They are also known as the Maybe monad in functional programming.optionis functorial.Definitionfunctor_option{AB} (f:A->B) (x:optionA) :optionB:=matchxwith|None=>None|Somea=>Some(fa)end.TheSomeconstructor is injective.Definitionisinj_some{A} {xy:A} (p:Somex=Somey):x=y.Proof.injectionp.exactidmap.Defined.

--- Miscellaneous\orders.html ---
ordersLibrary ordersRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.theory.apartness.Generalizable VariablesA.Lemmairrefl_neq`{R:RelationA} `{!IrreflexiveR}:forallxy,Rxy->x<>y.Proof.intros??Ee;rewriteeinE.apply(irreflexivity__E).Qed.Lemmale_flip`{LeA} `{!TotalRelation(≤)}xy: ~(y≤x) ->x≤y.Proof.introsnle.destruct(total_xy)as[?|le];auto.destruct(nlele).Qed.Sectionpartial_order.Context`{PartialOrderA}.Lemmaeq_lexy:x=y->x≤y.Proof.introsE.rewriteE.applyreflexivity.Qed.Lemmaeq_le_flipxy:x=y->y≤x.Proof.introsE.rewriteE.applyreflexivity.Qed.Lemmanot_le_nexy: ~(x≤y) ->x<>y.Proof.introsE1E2.applyE1.rewriteE2.applyreflexivity.Qed.Lemmaeq_iff_lexy:x=y<->x≤y/\y≤x.Proof.split;introsE.-rewriteE.split;applyreflexivity.-apply(antisymmetry(≤)xy);applyE.Qed.Endpartial_order.Sectionstrict_order.Context`{StrictOrderA}.Lemmalt_flipxy:x<y-> ~(y<x).Proof.introsE1E2.apply(irreflexivity(<)x).transitivityy;assumption.Qed.Lemmalt_antisymxy: ~(x<y<x).Proof.intros[E1E2].destruct(lt_flipxy);assumption.Qed.Lemmalt_nexy:x<y->x<>y.Proof.introsE1E2.rewriteE2inE1.apply(irreflexivity(<)y).assumption.Qed.Lemmalt_ne_flipxy:x<y->y<>x.Proof.intro.applysymmetric_neq,lt_ne.assumption.Qed.Lemmaeq_not_ltxy:x=y-> ~(x<y).Proof.introsE.rewriteE.apply(irreflexivity(<)).Qed.Endstrict_order.Sectionpseudo_order.Context`{PseudoOrderA}.Local Existing Instancepseudo_order_apart.Lemmaapart_total_ltxy:x≶y->x<y|_|y<x.Proof.intros.applyapart_iff_total_lt.assumption.Qed.Lemmapseudo_order_lt_apartxy:x<y->x≶y.Proof.intros.applyapart_iff_total_lt.auto.Qed.Lemmapseudo_order_lt_apart_flipxy:x<y->y≶x.Proof.intros.applyapart_iff_total_lt.auto.Qed.Lemmanot_lt_apart_lt_flipxy: ~(x<y) ->x≶y->y<x.Proof.introsnltneq.applyapart_iff_total_ltinneq.destructneq.-destructnlt;auto.-auto.Qed.Lemmapseudo_order_cotrans_twicex₁y₁x₂y₂:x₁<y₁->merely(x₂<y₂|_|x₁<x₂|_|y₂<y₁).Proof.introsE1.apply(merely_destruct(cotransitiveE1x₂));intros[?|E2];trysolve[applytr;auto].apply(merely_destruct(cotransitiveE2y₂));intros[?|?];applytr;auto.Qed.Lemmapseudo_order_lt_extx₁y₁x₂y₂:x₁<y₁->merely(x₂<y₂|_|x₁≶x₂|_|y₂≶y₁).Proof.introsE.apply(merely_destruct(pseudo_order_cotrans_twicex₁y₁x₂y₂E));intros[?|[?|?]];applytr;autousingpseudo_order_lt_apart.Qed.Global Instancepseudoorder_strictorder:StrictOrder(_:LtA).Proof.split.-apply_.-introsxE.destruct(pseudo_order_antisymxx);auto.-introsxyzE1E2.apply(merely_destruct(cotransitiveE1z));intros[?|?];trivial.destruct(pseudo_order_antisymyz);auto.Qed.Global Instancenlt_trans:Transitive(complement(<)).Proof.introsxyz.introsE1E2E3.apply(merely_destruct(cotransitiveE3y));intros[?|?];contradiction.Qed.Global Instancenlt_antisymm:AntiSymmetric(complement(<)).Proof.introsxyH1H2.applytight_apart.introsnap.applyapart_iff_total_ltinnap.destructnap;auto.Qed.Lemmane_total_lt`{!TrivialApartA}xy:x<>y->x<y|_|y<x.Proof.introsneq;applytrivial_apartinneq.applyapart_total_lt.assumption.Qed.Global Instancelt_trichotomy`{!TrivialApartA} `{DecidablePathsA}:Trichotomy(<).Proof.introsxy.destruct(dec(x=y))as[?|?];tryauto.destruct(ne_total_ltxy);auto.Qed.Endpseudo_order.Sectionfull_partial_order.Context`{FullPartialOrderA}.Local Existing Instancestrict_po_apart.(* Duplicate of strong_setoids.apart_ne. This is useful because aStrongSetoid is not defined as a substructure of a FullPartialOrder *)Instancestrict_po_apart_nexy:PropHolds(x≶y) ->PropHolds(x<>y).Proof.intros;apply_.Qed.Global Instancefullpartialorder_strictorder:StrictOrder(<).Proof.split;tryapply_.-applystrict_po_mere_lt.-introsx.red.introsE;applylt_iff_le_apartinE.destructEas[_?].apply(irreflexivity(≶)x).assumption.Qed.Lemmalt_lexy:PropHolds(x<y) ->PropHolds(x≤y).Proof.intro.applylt_iff_le_apart.assumption.Qed.Lemmanot_le_not_ltxy: ~(x≤y) -> ~(x<y).Proof.introsE1E2.applyE1.applylt_le.assumption.Qed.Lemmalt_apartxy:x<y->x≶y.Proof.intro.applylt_iff_le_apart.assumption.Qed.Lemmalt_apart_flipxy:x<y->y≶x.Proof.intro.applysymmetry,lt_iff_le_apart.assumption.Qed.Lemmale_not_lt_flipxy:y≤x-> ~(x<y).Proof.introsE1E2;applylt_iff_le_apartinE2.destructE2as[E2aE2b].revertE2b.applytight_apart.apply(antisymmetry(≤));assumption.Qed.Lemmalt_not_le_flipxy:y<x-> ~(x≤y).Proof.introsE1E2.apply(le_not_lt_flipyx);assumption.Qed.Lemmalt_le_transxyz:x<y->y≤z->x<z.Proof.introsE1E2.applylt_iff_le_apart.applylt_iff_le_apartinE1.destructE1as[E1aE1b].split.-transitivityy;assumption.-apply(merely_destruct(cotransitiveE1bz));intros[E3|E3];trivial.applylt_apart.applysymmetryinE3.transitivityy;applylt_iff_le_apart;auto.Qed.Lemmale_lt_transxyz:x≤y->y<z->x<z.Proof.introsE2E1.applylt_iff_le_apart.applylt_iff_le_apartinE1.destructE1as[E1aE1b].split.-transitivityy;auto.-apply(merely_destruct(cotransitiveE1bx));intros[E3|E3];trivial.applylt_apart.applysymmetryinE3.transitivityy;applylt_iff_le_apart;auto.Qed.Lemmalt_iff_le_ne`{!TrivialApartA}xy:x<y<->x≤y/\x<>y.Proof.transitivity(x<=y/\apartxy).-applylt_iff_le_apart.-split;intros[E1E2];split;trivial;applytrivial_apart;trivial.Qed.Lemmale_equiv_lt`{!TrivialApartA} `{forallxy:A,Decidable(x=y)}xy:x≤y->x=y|_|x<y.Proof.intros.destruct(dec(x=y));tryauto.right.applylt_iff_le_ne;auto.Qed.Instancedec_from_lt_dec`{!TrivialApartA} `{forallxy,Decidable(x≤y)}:DecidablePathsA.Proof.introsxy.destruct(decide_rel(<=)xy)as[E1|E1];[destruct(decide_rel(<=)yx)as[E2|E2]|].-left.apply(antisymmetry(<=));assumption.-right.introsE3;applyE2.patterny.apply(transport_E3).applyreflexivity.-right.introsE3;applyE1.patterny;apply(transport_E3).applyreflexivity.Defined.Definitionlt_dec_slow`{!TrivialApartA} `{forallxy,Decidable(x≤y)} :forallxy,Decidable(x<y).Proof.introsxy.destruct(dec(x≤y));[destruct(dec(x=y))|].-right.applyeq_not_lt.assumption.-left.applylt_iff_le_ne.auto.-right.applynot_le_not_lt.assumption.Defined.Endfull_partial_order.(* Due to bug 2528 *)#[export]HintExtern5 (PropHolds(_<>_)) =>eapply@strict_po_apart_ne:typeclass_instances.#[export]HintExtern10 (PropHolds(_≤_)) =>eapply@lt_le:typeclass_instances.#[export]HintExtern20 (Decidable(_<_)) =>eapply@lt_dec_slow:typeclass_instances.Sectionfull_pseudo_order.Context`{FullPseudoOrderA}.Local Existing Instancepseudo_order_apart.Lemmanot_lt_le_flipxy: ~(y<x) ->x≤y.Proof.intros.applyle_iff_not_lt_flip.assumption.Qed.Instancefullpseudo_partial:PartialOrder(≤) | 10.Proof.repeatsplit.-apply_.-apply_.-introsx.applynot_lt_le_flip, (irreflexivity(<)).-introsxyzE1E2.applyle_iff_not_lt_flip;applyle_iff_not_lt_flipinE1;applyle_iff_not_lt_flipinE2.change(complement(<)zx).transitivityy;assumption.-introsxyE1E2.applyle_iff_not_lt_flipinE1;applyle_iff_not_lt_flipinE2.apply(antisymmetry(complement(<)));assumption.Qed.Lemmafullpseudo_fullpartial':FullPartialOrderAleAlt.Proof.split;tryapply_.introsxy.split.-introsE.split.+applynot_lt_le_flip.applylt_flip;assumption.+applypseudo_order_lt_apart.assumption.-intros[?E].applynot_lt_apart_lt_flip;[|symmetry;trivial].applyle_iff_not_lt_flip.trivial.Qed.Global Instancefullpseudo_fullpartial@{i} :FullPartialOrderAleAlt:=ltac:(first[exactfullpseudo_fullpartial'@{iiSetSetSet}|exactfullpseudo_fullpartial'@{ii}]).Global Instancele_stable:forallxy,Stable(x≤y).Proof.introsxy.unfoldStable.introsdn.applyle_iff_not_lt_flip.introsE.applydn.introsE';applyle_iff_not_lt_flipinE';auto.Qed.Lemmale_or_lt`{!TrivialApartA} `{DecidablePathsA}xy:x≤y|_|y<x.Proof.destruct(trichotomy(<)xy)as[|[|]];tryauto.-left.applylt_le;trivial.-left.applyeq_le;trivial.Qed.Global Instancele_total`{!TrivialApartA} `{DecidablePathsA}:TotalOrder(≤).Proof.split;tryapply_.introsxy.destruct(le_or_ltxy);auto.right.applylt_le.trivial.Qed.Lemmanot_le_lt_flip`{!TrivialApartA} `{DecidablePathsA}xy: ~(y≤x) ->x<y.Proof.intros.destruct(le_or_ltyx);auto.contradiction.Qed.Existing Instancedec_from_lt_dec.Definitionlt_dec`{!TrivialApartA} `{forallxy,Decidable(x≤y)}:forallxy,Decidable(x<y).Proof.intros.destruct(decide_rel(<=)yx).-right;applyle_not_lt_flip;assumption.-left;applynot_le_lt_flip;assumption.Defined.Endfull_pseudo_order.#[export]HintExtern8 (Decidable(_<_)) =>eapply@lt_dec:typeclass_instances.(*The following instances would be tempting, but turn out to be a bad idea.[export]
Hint Extern 10 (PropHolds (_ <> _)) => eapply @le_ne : typeclass_instances.exportHint Extern 10 (PropHolds (_ <> _)) => eapply @le_ne_flip : typeclass_instances.It will then loop like:semirings.lt_0_1 -> lt_ne_flip -> ...*)Sectiondec_strict_setoid_order.Context`{StrictOrderA} `{ApartA} `{!TrivialApartA} `{DecidablePathsA}.Instance:IsApartA:=dec_strong_setoid.Context`{!Trichotomy(<)}.Instancedec_strict_pseudo_order:PseudoOrder(<).Proof.split;tryapply_.-introsxy[??].destruct(lt_antisymxy);auto.-introsxyExyz.destruct(trichotomy(<)xz)as[? | [Exz|Exz]];applytr;tryauto.right.rewrite<-Exz.assumption.-introsxy.transitivity(x<>y);[split;applytrivial_apart|].split.+destruct(trichotomy(<)xy)as[?|[?|?]];auto.introsE;contradictionE.+intros[?|?];[applylt_ne|applylt_ne_flip];trivial.Qed.Enddec_strict_setoid_order.Sectiondec_partial_order.Context`{PartialOrderA} `{DecidablePathsA}.Definitiondec_lt:LtA:=funxy=>x≤y/\x<>y.Context`{Alt:LtA} `{is_mere_relationAlt}(lt_correct:forallxy,x<y<->x≤y/\x<>y).Instancedec_order:StrictOrder(<).Proof.split.-apply_.-introsxE.applylt_correctinE.destructEas[_[]];trivial.-introsxyzE1E2.applylt_correct;applylt_correctinE1;applylt_correctinE2.destructE1as[E1aE1b],E2as[E2aE2b].split.+transitivityy;trivial.+introsE3.destructE2b.apply(antisymmetry(≤));trivial.rewrite<-E3.assumption.Qed.Context`{ApartA} `{!TrivialApartA}.Instance:IsApartA:=dec_strong_setoid.Instancedec_full_partial_order:FullPartialOrder(≤) (<).Proof.split;tryapply_.intros.transitivity(x<=y/\x<>y);[|split;intros[? ?];split;trivial;applytrivial_apart;trivial].applylt_correct.Qed.Context`{!TotalRelation(≤)}.Instance:Trichotomy(<).Proof.introsxy.destruct(dec(x=y));tryauto.destruct(total(≤)xy);[left|right;right];applylt_correct;auto.split;auto.introE;applysymmetryinE;auto.Qed.Instancedec_pseudo_order:PseudoOrder(<) :=dec_strict_pseudo_order.Instancedec_full_pseudo_order:FullPseudoOrder(≤) (<).Proof.split;tryapply_.introsxy.split.-intros?E.applylt_correctinE;destructEas[? []].apply(antisymmetry(≤));assumption.-introsE1.destruct(total(≤)xy);trivial.destruct(dec(x=y))as[E2|E2].+rewriteE2.applyreflexivity.+destructE1.applylt_correct;split;auto.applysymmetric_neq;assumption.Qed.Enddec_partial_order.Lemmalt_eq_trans`{LtA} :forallxyz,x<y->y=z->x<z.Proof.intros???? [];trivial.Qed.Sectionpseudo.Context{A:Type}.Context`{PseudoOrderA}.Lemmanlt_lt_trans{xyz:A} : ~ (y<x) ->y<z->x<z.Proof.introsnltyxltyz.assert(disj:=cotransitiveltyzx).strip_truncations.destructdisjas[ltyx|ltxz].-destruct(nltyxltyx).-exactltxz.Qed.Lemmalt_nlt_trans{xyz:A} :x<y-> ~ (z<y) ->x<z.Proof.introsltxynltzy.assert(disj:=cotransitiveltxyz).strip_truncations.destructdisjas[ltxz|ltzy].-exactltxz.-destruct(nltzyltzy).Qed.Lemmalt_transitive:Transitive(_:LtA).Proof.introsxyzltxyltyz.assert(ltxyz:=cotransitiveltxyz).strip_truncations.destructltxyzas[ltxz|ltzy].-assumption.-destruct(pseudo_order_antisymyz(ltyz,ltzy)).Qed.Global Existing Instancelt_transitive.Endpseudo.

--- Miscellaneous\Ordinals.html ---
OrdinalsLibrary OrdinalsFromHoTTRequireImportTruncTypeExcludedMiddleModalities.ReflectiveSubuniverseabstract_algebra.FromHoTTRequireImportUniverses.Smallness.FromHoTTRequireImportColimits.Quotient.FromHoTTRequireImportHSet.Local CloseScopetrunc_scope.Local OpenScopehprop_scope.This file contains a definition of ordinals and some fundamental results,
    roughly following the presentation in the HoTT book.Well-foundednessInductiveAccessible{A} (R:LtA) (a:A) :=acc: (forallb,b<a->AccessibleRb) ->AccessibleRa.Global Instanceishprop_Accessible`{Funext} {A} (R:LtA) (a:A) :IsHProp(AccessibleRa).Proof.applyhprop_allpath.introsacc1.inductionacc1as[aacc1'IH].intros[acc2'].applyap.applypath_forall;introsb.applypath_forall;introsHb.applyIH.Qed.ClassWellFounded{A} (R:RelationA) :=well_foundedness:foralla:A,AccessibleRa.Global Instanceishprop_WellFounded`{Funext} {A} (R:RelationA) :IsHProp(WellFoundedR).Proof.applyhprop_allpath;introsH1H2.applypath_forall;introsa.applypath_ishprop.Qed.ExtensionalityClassExtensional{A} (R:LtA) :=extensionality:forallab:A, (forallc:A,c<a<->c<b) ->a=b.Global Instanceishprop_Extensional`{Funext} {A} `{IsHSetA} (R:RelationA):IsHProp(ExtensionalR).Proof.unfoldExtensional.exact_.Qed.OrdinalsClassIsOrdinal@{carrierrelation} (A:Type@{carrier}) (R:Relation@{carrierrelation}A) := {ordinal_is_hset:IsHSetA;ordinal_relation_is_mere:is_mere_relationAR;ordinal_extensionality:ExtensionalR;ordinal_well_foundedness:WellFoundedR;ordinal_transitivity:TransitiveR;}.#[export]ExistingInstancesordinal_is_hsetordinal_relation_is_mereordinal_extensionalityordinal_well_foundednessordinal_transitivity.Global Instanceishprop_IsOrdinal`{Funext}AR:IsHProp(IsOrdinalAR).Proof.eapplyistrunc_equiv_istrunc. {issig.}unfoldTransitive.exact_.Qed.RecordOrdinal@{carrierrelation+} :={ordinal_carrier:Type@{carrier};ordinal_relation:Lt@{carrierrelation}ordinal_carrier;ordinal_property:IsOrdinal@{carrierrelation}ordinal_carrier(<)}.Global Existing Instancesordinal_relationordinal_property.Coercionordinal_as_hset(A:Ordinal) :HSet:=Build_HSet(ordinal_carrierA).Global Instanceirreflexive_ordinal_relationAR:IsOrdinalAR->IrreflexiveR.Proof.introsis_ordinalaH.induction(well_foundednessa)as[a_IH].apply(IHa);assumption.Qed.DefinitionTypeWithRelation:= {A:Type&RelationA}.Coercionordinal_as_type_with_relation(A:Ordinal) :TypeWithRelation:= (A:Type; (<)).Paths in OrdinalDefinitionequiv_Ordinal_to_sig:Ordinal<~> {R: {A:Type&RelationA} &IsOrdinal_R.2 }.Proof.transitivity{A:Type& {R:RelationA&IsOrdinalAR} }. {symmetry.issig.}applyequiv_sigma_assoc'.Defined.DefinitionIsomorphism:TypeWithRelation->TypeWithRelation->Type:=fun'(A;R__A) '(B;R__B) =>{f:A<~>B&forallaa',R__Aaa'<->R__B(fa) (fa') }.Global Instanceisomorphism_id:ReflexiveIsomorphism.Proof.introsA.existsequiv_idmap.cbn.introsaa'.reflexivity.Qed.Lemmaisomorphism_inverse:forallAB,IsomorphismAB->IsomorphismBA.Proof.intros[AR__A] [BR__B] [fH].exists(equiv_inversef).introsbb'.cbn.rewrite<- (eisretrfb).set(a:=f^-1b).rewriteeissect.rewrite<- (eisretrfb').set(a':=f^-1b').rewriteeissect.(* We don't apply the symmetry tactic because that would introduce bad universe constraints *)split;applyH.Defined.We state this first without usingTransitiveto allow more general universe variables.Lemmatransitive_Isomorphism:forallABC,IsomorphismAB->IsomorphismBC->IsomorphismAC.Proof.intros[AR__A] [BR__B] [CR__C].intros[fHf] [gHg].exists(equiv_compose'gf).introsaa'.split.-introsa_a'.applyHg.applyHf.exacta_a'.-introsgfa_gfa'.applyHf.applyHg.exactgfa_gfa'.Defined.Global Instanceisomorphism_compose_backwards:TransitiveIsomorphism:=transitive_Isomorphism.Definitionequiv_path_Ordinal`{Univalence} (AB:Ordinal):IsomorphismAB<~>A=B.Proof.unfoldIsomorphism.rapplysymmetric_equiv.transitivity(equiv_Ordinal_to_sigA=equiv_Ordinal_to_sigB). {applyequiv_ap'.}transitivity((equiv_Ordinal_to_sigA).1 = (equiv_Ordinal_to_sigB).1). {existspr1_path.exact(isequiv_pr1_path_hprop__).}transitivity(existRelationA(<) =existRelationB(<)). {reflexivity.}transitivity{p:A=B:>Type&p# (<) = (<) }. {symmetry.exact(equiv_path_sigmaRelation(existRelationA(<))(existRelationB(<))).}srapplyequiv_functor_sigma'.-exact(equiv_equiv_pathAB).-cbn.introsp.nrapplyequiv_iff_hprop.+apply(istrunc_equiv_istrunc(forallbb':B, (p# (<))bb'= (b<b'))). {transitivity(forallb:B, (p#lt)b=ltb). {applyequiv_functor_forall_id;introsb.applyequiv_path_arrow.}applyequiv_path_arrow.}exact_.+exact_.+intros<-aa'.rewritetransport_arrow.rewritetransport_arrow_toconst.repeatrewritetransport_Vp.reflexivity.+introsH0.by_extensionalityb.by_extensionalityb'.rewritetransport_arrow.rewritetransport_arrow_toconst.applypath_iff_ishprop_uncurried.specialize(H0(transportidmapp^b) (transportidmapp^b')).repeatrewritetransport_pVinH0.exactH0.Qed.Lemmapath_Ordinal`{Univalence} (AB:Ordinal):forallf:A<~>B,(forallaa':A,a<a'<->fa<fa')->A=B.Proof.introsfH0.applyequiv_path_Ordinal.existsf.exactH0.Qed.Lemmatrichotomy_ordinal`{ExcludedMiddle} {A:Ordinal} (ab:A):a<b\/a=b\/b<a.Proof.revertb.induction(well_foundednessa)as[a_IHa].introsb.induction(well_foundednessb)as[b_IHb].destruct(LEM(merely(existsb',b'<b/\ (a=b'\/a<b'))))as[H1|H1];tryexact_.-revertH1.rapplyTrunc_rec.intros[b'[b'_bHb']].revertHb'.rapplyTrunc_rec.intros[a_b'|b'_a].+applytr.left.rewritea_b'.exactb'_b.+applytr.left.transitivityb';assumption.-destruct(LEM(merely(existsa',a'<a/\ (a'=b\/b<a'))))as[H2|H2];tryexact_.+revertH2.rapplyTrunc_rec.intros[a'[a'_aHa']].revertHa'.rapplyTrunc_rec.intros[a'_b|b_a'].*applytr.right.applytr.right.rewrite<-a'_b.exacta'_a.*applytr.right.applytr.right.transitivitya';assumption.+applytr.right.applytr.left.applyextensionality.introsc.split.*introsc_a.applyLEM_to_DNE;tryexact_.introsnot_c_b.applyH2.applytr.existsc.split.--exactc_a.--refine(Trunc_rec_(IHacc_ab)).intros[c_b|H3].++applyEmpty_rec.exact(not_c_bc_b).++exactH3.*introsc_b.applyLEM_to_DNE;tryexact_.introsnot_c_a.applyH1.applytr.existsc.split.--exactc_b.--refine(Trunc_rec_(IHbcc_b)).intros[a_c|H3].++applytr.right.exacta_c.++refine(Trunc_rec_H3).intros[a_c|c_a].**applytr.left.exacta_c.**applytr.right.applyEmpty_rec.exact(not_c_ac_a).Qed.Lemmaordinal_has_minimal_hsolutions{lem:ExcludedMiddle} (A:Ordinal) (P:A->HProp):merely(existsa,Pa) ->merely(existsa,Pa/\forallb,Pb->a<b\/a=b).Proof.introsH'.eapplymerely_destruct;tryapplyH'.intros[aHa].induction(well_foundednessa)as[a_IH].destruct(LEM(merely(existsb,Pb/\b<a))_)as[H|H].-eapplymerely_destruct;tryapplyH.intros[bHb].apply(IHb);applyHb.-applytr.existsa.split;tryapplyHa.introsbHb.specialize(trichotomy_ordinalab).introsH1.eapplymerely_destruct;tryapplyH1.intros[H2|H2]. {applytr.byleft. }eapplymerely_destruct;tryapplyH2.intros[H3|H3]. {applytr.byright. }applyEmpty_rec,H,tr.existsb.bysplit.Qed.Simulations(* We define the notion of simulations between arbitrary relations. For simplicity, most lemmas about simulations are formulated for ordinals only, even if they do not need all properties of ordinals. The only exception is isordinal_simulation which can be used to prove that a relation is an ordinal. *)ClassIsSimulation{AB:Type} {R__A:LtA} {R__B:LtB} (f:A->B) :={simulation_is_hom{aa'}:a<a'->fa<fa';simulation_is_merely_minimal{ab}:b<fa->hexists(funa'=>a'<a/\fa'=b)}.Argumentssimulation_is_hom{____}_{___}.Global Instanceishprop_IsSimulation`{Funext}{AB:Ordinal} (f:A->B) :IsHProp(IsSimulationf).Proof.eapplyistrunc_equiv_istrunc.-issig.-exact_.Qed.Global Instanceisinjective_simulation{A:Type} {R:LtA} `{IsOrdinalAR}{B:Type} {Q:LtB} `{IsOrdinalBQ}(f:A->B) {is_simulation:IsSimulationf}:IsInjectivef.Proof.introsa.induction(well_foundednessa)as[a_IHa].introsb.revertaIHa.induction(well_foundednessb)as[b_IHb].introsaIHa.introsfa_fb.applyextensionality;introsc.split.-introsc_a.assert(fc_fa:fc<fa)byexact(simulation_is_homfc_a).assert(fc_fb:fc<fb)by(rewrite<-fa_fb;exactfc_fa).assert(H1:hexists(func'=>c'<b/\fc'=fc))byexact(simulation_is_merely_minimalfc_fb).refine(Trunc_rec_H1).intros(c'&c'_b&fc'_fc).assert(c=c')as->. {applyIHa.+exactc_a.+symmetry.exactfc'_fc.}exactc'_b.-introsc_b.assert(fc_fb:fc<fb)byexact(simulation_is_homfc_b).assert(fc_fa:fc<fa)by(rewritefa_fb;exactfc_fb).assert(H1:hexists(func'=>c'<a/\fc'=fc))byexact(simulation_is_merely_minimalfc_fa).refine(Trunc_rec_H1).intros(c'&c'_a&fc'_fc).assert(c'=c)as<-.+applyIHb.*exactc_b.*introsa'a'_c'.applyIHa.exact(transitivitya'_c'c'_a).*exactfc'_fc.+exactc'_a.Qed.Lemmasimulation_is_minimal{A:Type} {R:LtA} `{IsOrdinalAR}{B:Type} {Q:LtB} `{IsOrdinalBQ}(f:A->B) {is_simulation:IsSimulationf}:forall{ab},b<fa->existsa',a'<a/\fa'=b.Proof.introsabH1.refine(Trunc_rec_(simulation_is_merely_minimalH1)). {applyhprop_allpath.intros(a1& ? &p) (a2& ? & <-).applypath_sigma_hprop;cbn.apply(injectivef).exactp.}exactidmap.Qed.Lemmapath_simulation`{Funext}{AB:Ordinal}(f:A->B) {is_simulation_f:IsSimulationf}(g:A->B) {is_simulation_g:IsSimulationg}:f=g.Proof.applypath_forall;introsa.induction(well_foundednessa)as[a_IH].apply(extensionality(fa) (ga)).introsb.split.-introsb_fa.destruct(simulation_is_minimalfb_fa)as(a'&a'_a& <-).rewrite(IH_a'_a).apply(simulation_is_homg).exacta'_a.-introsb_ga.destruct(simulation_is_minimalgb_ga)as(a'&a'_a& <-).rewrite<- (IH_a'_a).apply(simulation_is_homf).exacta'_a.Qed.Global Instanceis_simulation_isomorphism{A:Type} {R__A:LtA}{B:Type} {R__B:LtB}(f:Isomorphism(A;R__A) (B;R__B)):IsSimulationf.1.Proof.constructor.-introsaa'a_a'.applyf.2.exacta_a'.-introsabb_fa.applytr.exists(f.1^-1b).split.+applyf.2.rewriteeisretr.exactb_fa.+applyeisretr.Qed.Global Instanceishprop_Isomorphism`{Funext} (AB:Ordinal):IsHProp(IsomorphismAB).Proof.applyhprop_allpath;introsfg.applypath_sigma_hprop;cbn.applypath_equiv.applypath_simulation;exact_.Qed.Global Instanceishset_Ordinal`{Univalence}:IsHSetOrdinal.Proof.applyistrunc_S.introsAB.apply(istrunc_equiv_istrunc(IsomorphismAB)). {applyequiv_path_Ordinal.}exact_.Qed.Lemmaisordinal_simulation{A:Type}`{IsHSetA}{R:LtA}{mere:is_mere_relation_R}{B:Type}{Q:LtB}`{IsOrdinalBQ}(f:A->B)`{IsInjective__f}{is_simulation:IsSimulationf}:IsOrdinalAR.Proof.constructor.-exact_.-exact_.-introsaa'H1.apply(injectivef).applyextensionality.introsb.split.+introsb_fa.refine(Trunc_rec_(simulation_is_merely_minimalb_fa)).intros[a0[a0_a<-]].apply(simulation_is_homf).applyH1.exacta0_a.+introsb_fa'.refine(Trunc_rec_(simulation_is_merely_minimalb_fa')).intros[a0[a0_a'<-]].apply(simulation_is_homf).applyH1.exacta0_a'.-introsa.remember(fa)asbeqn:fa_b.revertafa_b.induction(well_foundednessb)as[b_IH].introsa<-.constructor;introsa'a'_a.apply(IH(fa')).+apply(simulation_is_homf).exacta'_a.+reflexivity.-introsabca_bb_c.assert(fa_fc:fa<fc). {transitivity(fb). {apply(simulation_is_homf).exacta_b.}apply(simulation_is_homf).exactb_c.}refine(Trunc_rec_(simulation_is_merely_minimalfa_fc)).intros[a'[a'_cfa'_fa]].apply(injectivef)infa'_fa.substa'.exacta'_c.Qed.Initial segmentsDefinitioninitial_segment`{PropResizing}{A:Type} {R:LtA} `{IsOrdinalAR} (a:A):Ordinal.Proof.srefine{|ordinal_carrier:= {b:A&smalltype(b<a)};ordinal_relation:=funxy=>x.1 <y.1|};tryexact_.srapply(isordinal_simulationpr1).-unfoldlt.exact_.-exact_.-exact_.-constructor.+introsxyx_y.exactx_y.+introsba'a'_b;cbnin*.applytr.assert(b_a:b.1 <a). {exact((equiv_smalltype_)b.2).}srapplyexist. {existsa'.applyequiv_smalltype.exact(transitivitya'_bb_a).}cbn.split.*exacta'_b.*reflexivity.Defined.Declare ScopeOrdinals.OpenScopeOrdinals.Notation"↓ a" := (initial_segmenta) (atlevel4,format"↓ a") :Ordinals.(* 3 is the level of most unary postfix operators in the standard lib, e.g. f^-1 *)Definitionin_`{PropResizing}{A:Ordinal} {a:A}(x:A) (H:x<a): ↓a:= (x; (equiv_smalltype_)^-1H).Definitionout`{PropResizing}{A:Ordinal} {a:A}: ↓a->A:=pr1.Definitioninitial_segment_property`{PropResizing}{A:Ordinal} {a:A}:forallx: ↓a,outx<a.Proof.introsx.exact(equiv_smalltype_(proj2x)).Defined.Global Instanceis_simulation_out`{PropResizing}{A:Ordinal} (a:A):IsSimulation(out: ↓a->A).Proof.unfoldout.constructor.-auto.-introsxa'a'_x.applytr.assert(a'_a:a'<a). {transitivity(outx). {assumption.}applyinitial_segment_property.(* TODO: Rename? *)}exists(in_a'a'_a);cbn.auto.Qed.Global Instanceisinjective_initial_segment`{Funext} `{PropResizing}(A:Ordinal):IsInjective(initial_segment:A->Ordinal).Proof.enough(H1:foralla1a2:A, ↓a1= ↓a2->forallb: ↓a1,outb<a2). {introsa1a2p.applyextensionality;introsb.split.-introsb_a1.exact(H1a1a2p(in_bb_a1)).-introsb_a2.exact(H1a2a1p^ (in_bb_a2)).}introsa1a2pb.assert(out=transport(funB:Ordinal=>B->A)p^out)as->. {applypath_simulation.-exact_.-applytransportD.exact_.}rewritetransport_arrow_toconst.rewriteinv_V.applyinitial_segment_property.Qed.Lemmaequiv_initial_segment_simulation`{PropResizing}{A:Type@{A}} {R:Lt@{_R}A} `{IsOrdinalAR}{B:Type@{B}} {Q:Lt@{_Q}B} `{IsOrdinalBQ}(f:A->B) {is_simulation:IsSimulationf} (a:A):Isomorphism↓(fa) ↓a.Proof.applyisomorphism_inverse.srapplyexist.-srapplyequiv_adjointify.+introsx.exists(fx.1).apply(equiv_smalltype_)^-1.rapplysimulation_is_hom.apply(equiv_smalltype_).exactx.2.+introsx.assert(x_fa:x.1 <fa). {exact((equiv_smalltype_)x.2).}destruct(simulation_is_minimalfx_fa)as(a'&a'_a&_).exact(a'; (equiv_smalltype_)^-1a'_a).+cbn.introsx.applypath_sigma_hprop;cbn.transparentassert(x_fa: (x.1 <fa)). {exact(equiv_smalltype_x.2).}exact(snd(simulation_is_minimalfx_fa).2).+cbn.introsx.applypath_sigma_hprop;cbn.transparentassert(x_a: (x.1 <a)). {exact(equiv_smalltype_x.2).}apply(injectivef).cbn.unfoldinitial_segment_property.cbn.rewriteeisretr.exact(snd(simulation_is_minimalf(simulation_is_homfx_a)).2).-cbn.intros[xx_a] [yy_a];cbn.split.+apply(simulation_is_homf).+introsfx_fy.destruct(simulation_is_minimalffx_fy)as(a'&a'_y&p).applyinjectiveinp;tryexact_.substa'.exacta'_y.Qed.Lemmapath_initial_segment_simulation`{Univalence}`{PropResizing}{A:Type} {R:LtA} `{IsOrdinalAR}{B:Type} {Q:LtB} `{IsOrdinalBQ}(f:A->B) {is_simulation:IsSimulationf} (a:A): ↓(fa) = ↓a.Proof.applyequiv_path_Ordinal.apply(equiv_initial_segment_simulationf).Qed.`Ordinal` is an ordinalGlobal Instancelt_Ordinal@{carrierrelation+} `{PropResizing}:LtOrdinal@{carrierrelation}:=funAB=>existsb:B,A= ↓b.Global Instanceis_mere_relation_lt_on_Ordinal`{Univalence} `{PropResizing}:is_mere_relationOrdinallt_Ordinal.Proof.introsAB.applyishprop_sigma_disjoint.introsbb'->p.apply(injectiveinitial_segment).exactp.Qed.Definitionbound`{PropResizing}{AB:Ordinal} (H:A<B):B:=H.1.(* We use this notation to hide the proof of A < B that `bound` takes as an argument *)Notation"A ◁ B" := (@boundAB_) (atlevel70) :Ordinals.Definitionbound_property`{PropResizing}{AB:Ordinal} (H:A<B):A= ↓(boundH):=H.2.Lemmaisembedding_initial_segment`{PropResizing} `{Univalence}{A:Ordinal} (ab:A):a<b<-> ↓a< ↓b.Proof.split.-introsa_b.exists(in_aa_b).exact(path_initial_segment_simulationout(in_aa_b)).-introsa_b.assert(a=out(bounda_b))as->. {apply(injectiveinitial_segment).rewrite(path_initial_segment_simulationout).applybound_property.}applyinitial_segment_property.Qed.Global InstanceOrdinal_is_ordinal`{PropResizing} `{Univalence}:IsOrdinalOrdinal(<).Proof.constructor.-exact_.-exactis_mere_relation_lt_on_Ordinal.-introsABH1.srapplypath_Ordinal.+srapplyequiv_adjointify.*assert(lt_B:foralla:A, ↓a<B). {introsa.applyH1.existsa.reflexivity.}exact(funa=>bound(lt_Ba)).*assert(lt_A:forallb:B, ↓b<A). {introsb.applyH1.existsb.reflexivity.}exact(funb=>bound(lt_Ab)).*cbn.introsb.apply(injectiveinitial_segment).repeatrewrite<-bound_property.reflexivity.*cbn.introsa.apply(injectiveinitial_segment).repeatrewrite<-bound_property.reflexivity.+cbn.introsaa'.split.*introsa_a'.applyisembedding_initial_segment.repeatrewrite<-bound_property.applyisembedding_initial_segment.assumption.*introsa_a'.applyisembedding_initial_segmentina_a'.repeatrewrite<-bound_propertyina_a'.applyisembedding_initial_segmentina_a'.assumption.-introsA.constructor.intros? [a->].induction(well_foundednessa)as[a_IH].constructor.intros? [x->].rewrite<- (path_initial_segment_simulationout).applyIH.applyinitial_segment_property.-intros? ?A[x->] [a->].exists(outx).rewrite(path_initial_segment_simulationout).reflexivity.Qed.(* This is analogous to the set-theoretic statement that an ordinal is the set of all smaller ordinals. *)Lemmaisomorphism_to_initial_segment`{PropResizing} `{Univalence}(B:Ordinal@{A_}):IsomorphismB↓B.Proof.srapplyexist.-srapplyequiv_adjointify.+introsb.exists↓b.applyequiv_smalltype.existsb.reflexivity.+intros[CHC].eapplyequiv_smalltypeinHC.exact(boundHC).+cbn.intros[CHC].applypath_sigma_hprop;cbn.symmetry.applybound_property.+cbn.introsx.rewriteeisretr.reflexivity.-cbn.introsbb'.applyisembedding_initial_segment.Qed.But an ordinal isn't isomorphic to any initial segment of itself.Lemmaordinal_initial`{PropResizing} `{Univalence} (O:Ordinal) (a:O):IsomorphismO↓a->Empty.Proof.introsp%equiv_path_Ordinal.enough(HO:O<O)byapply(irreflexive_ordinal_relation____HO).existsa.applyp.Qed.Ordinal successorDefinitionsuccessor(A:Ordinal) :Ordinal.Proof.set(carrier:= (A+Unit)%type).set(relation(xy:carrier) :=matchx,ywith|inlx,inly=>x<y|inlx,inr_=>Unit|inr_,inly=>Empty|inr_,inr_=>Emptyend).existscarrierrelation.constructor.-exact_.-intros[x| ?] [y| ?];cbn;exact_.-intros[x| []] [y| []]H.+f_ap.applyextensionality.introsz.exact(H(inlz)).+enough(H0:relation(inlx) (inlx)). {cbninH0.destruct(irreflexivity__H0).}applyH.cbn.exacttt.+enough(H0:relation(inly) (inly)). {cbninH0.destruct(irreflexivity__H0).}applyH.cbn.exacttt.+reflexivity.-assert(H:foralla,Accessiblerelation(inla)). {introsa.induction(well_foundednessa)as[a_IH].constructor;intros[b| []];cbn;introsH.+applyIH.exactH.+destructH.}intros[x| []].+applyH.+constructor;intros[b| []];cbn;introsH0.*applyH.*destructH0.-intros[x| []] [y| []] [z| []];cbn;auto.intros_[].Defined.Lemmalt_successor`{PropResizing} `{Univalence} (A:Ordinal):A<successorA.Proof.exists(inrtt).srapplypath_Ordinal.-srapplyequiv_adjointify.+introsa.srapplyin_.*exact(inla).*exacttt.+intros[[a| []]Ha];cbnin*.*exacta.*applyequiv_smalltypeinHa.destructHa.+intros[[a| []]Ha].*unfoldin_.cbn.f_ap.assert(IsHProp(smalltypeUnit))byexact_.applypath_ishprop.*destruct(equiv_smalltype_Ha).+introsa.reflexivity.-cbn.introsaa'.reflexivity.Qed.Ordinal limitSectionImage.Universesij.In the following, there are no constraints betweeniandj.Context`{PropResizing} `{Funext} {A:Type@{i}} {B:HSet@{j}} (f:A->B).Local Definitionqkfs:=quotient_kernel_factor_smallf.Local Definitionimage:Type@{i} :=qkfs.1.Local Definitionfactor1:A->image:=qkfs.2.1.Local Definitionfactor2:image->B:=qkfs.2.2.1.Local Definitionisinjective_factor2:IsInjectivefactor2:=isinj_embedding_(snd(fstqkfs.2.2.2)).Local Definitionimage_ind_prop(P:image->Type@{k}) `{forallx,IsHProp(Px)}(step:foralla:A,P(factor1a)):forallx:image,Px:=Quotient_ind_hprop_Pstep.factor2ofactor1==fis definitional, so we don't state that.EndImage.Definitionlimit`{Univalence} `{PropResizing}{X:Type} (F:X->Ordinal) :Ordinal.Proof.set(f:=funx: {i:X&Fi} => ↓x.2).set(carrier:=imagef:Type@{i}).set(relation:=funAB:carrier=>smalltype(factor2fA<factor2fB):Type@{i}).existscarrierrelation.snrapply(isordinal_simulation(factor2f)).1-4:exact_.-applyisinjective_factor2.-constructor.+introsxx'x_x'.unfoldlt,relation.applyequiv_smalltypeinx_x'.exactx_x'.+nrefine(image_ind_propf__). 1:exact_.introsa.change(factor2f(class_of_a))with(fa).introsBB_fa.applytr.exists(factor1f(a.1;out(boundB_fa))).unfoldlt,relation.change(factor2f(factor1f?A))with(fA).unfoldf.assert(↓(out(boundB_fa)) =B)as->. {rewrite(path_initial_segment_simulationout).symmetry.applybound_property.}split.*applyequiv_smalltype.exactB_fa.*reflexivity.Defined.Global Instancele_on_Ordinal:LeOrdinal:=funAB=>existsf:A->B,IsSimulationf.Definitionlimit_is_upper_bound`{Univalence} `{PropResizing}{X:Type} (F:X->Ordinal):forallx,Fx<=limitF.Proof.set(f:=funx: {i:X&Fi} => ↓x.2).introsx.unfoldle,le_on_Ordinal.exists(funu=>factor1f(x;u)).split.-introsuvu_v.change(smalltype(f(x;u) <f(x;v))).applyequiv_smalltype.applyisembedding_initial_segment.exactu_v.-introsu.nrefine(image_ind_propf__). 1:exact_.introsaa_u.change(smalltype(fa<f(x;u)))ina_u.applyequiv_smalltypeina_u.applytr.exists(out(bounda_u)).split.+applyinitial_segment_property.+apply(isinjective_factor2f);simpl.change(factor2f(factor1f?A))with(fA).unfoldf.rewrite(path_initial_segment_simulationout).symmetry.applybound_property.Qed.Any type equivalent to an ordinal is an ordinal, and we can change the universe that the relation takes values in.(* TODO: Should factor this into two results:  (1) Anything equivalent to an ordinal is an ordinal (with the relation landing in the same universe for both).  (2) Under PropResizing, the universe that the relation takes values in can be changed. *)Definitionresize_ordinal@{ij+} `{PropResizing} (B:Ordinal@{i_}) (C:Type@{j}) (g:C<~>B):Ordinal@{j_}.Proof.existsC(func1c2:C=>smalltype(gc1<gc2)).snrapply(isordinal_simulationg). 2, 3, 4, 5:exact_.-apply(istrunc_equiv_istruncB(equiv_inverseg)).-constructor.+introsaa'a_a'.apply(equiv_smalltype_).exacta_a'.+introsabb_fa.applytr.exists(g^-1b).split.*applyequiv_smalltype.rewriteeisretr.exactb_fa.*applyeisretr.Defined.Lemmaresize_ordinal_iso@{ij+} `{PropResizing} (B:Ordinal@{i_}) (C:Type@{j}) (g:C<~>B):Isomorphism(resize_ordinalBCg)B.Proof.existsg.introsaa'.cbn.split;applyequiv_smalltype.Qed.

--- Miscellaneous\ParallelPair.html ---
ParallelPairLibrary ParallelPairRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Graph.RequireImportDiagrams.Diagram.RequireImportDiagrams.Cocone.Parallel pairsDefinitionparallel_pair_graph:Graph.Proof.srapply(Build_GraphBool).introsij.exact(ifithenifjthenEmptyelseBoolelseEmpty).Defined.Parallel pair diagramDefinitionparallel_pair{AB:Type} (fg:A->B):Diagramparallel_pair_graph.Proof.srapplyBuild_Diagram.1:intros[]; [exactA|exactB].intros[] [] []; [exactf|exactg].Defined.Cones onparallel_pairsDefinitionBuild_parallel_pair_cocone{ABQ} {fg:B->A}`(q:A->Q) (Hq:qog==qof):Cocone(parallel_pairfg)Q.Proof.srapplyBuild_Cocone.1:intros[]; [exact(qof) |exactq].intros[] [] []; [reflexivity|exactHq].Defined.

--- Miscellaneous\Parts.html ---
PartsLibrary PartsFunctoriality of the construction of adjunctions from universal morphismsRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportFunctor.IdentityFunctor.Composition.Core.RequireImportNaturalTransformation.Composition.CoreNaturalTransformation.Composition.Laws.RequireImportFunctor.DualNaturalTransformation.Dual.RequireImportAdjoint.CoreAdjoint.UnitCounitAdjoint.Dual.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopenatural_transformation_scope.Local OpenScopemorphism_scope.Sectionleft.action on morphisms of the construction of a left adjoint toGfunctoriality onC,D, andGSectionalso_categories.VariablesCC':PreCategory.VariableCF:FunctorCC'.VariablesDD':PreCategory.VariableDF:FunctorDD'.VariableG:FunctorDC.VariableF:FunctorCD.VariableA:F-|G.VariableG':FunctorD'C'.VariableF':FunctorC'D'.VariableA':F'-|G'.VariableT:NaturalTransformation(CFoG) (G'oDF).Definitionleft_morphism_of:NaturalTransformation(F'oCF) (DFoF).Proof.refine((_)o(counitA'oR(DFoF))o_o(F'oL((ToRF)o_o(CFoLunitA)o_)))%natural_transformation;nt_solve_associator.Defined.Endalso_categories.functoriality inGSectiononly_functor.VariablesCD:PreCategory.VariableG:FunctorDC.VariableF:FunctorCD.VariableA:F-|G.VariableG':FunctorDC.VariableF':FunctorCD.VariableA':F'-|G'.VariableT:NaturalTransformationGG'.Definitionleft_morphism_of_nondep:NaturalTransformationF'F.Proof.refine(_o(@left_morphism_ofCC1DD1GFAG'F'A'(_oTo_))o_)%natural_transformation;nt_solve_associator.Defined.Endonly_functor.Endleft.Sectionright.action on morphisms of the construction of a right adjoint toFDefinitionright_morphism_ofCC'CFDD'DF(F:FunctorCD) (G:FunctorDC) (A:F-|G)(F':FunctorC'D') (G':FunctorD'C') (A':F'-|G')(T:NaturalTransformation(F'oCF) (DFoF)):NaturalTransformation(CFoG) (G'oDF):= (@left_morphism_of__DF^op__CF^opF^opG^opA^opF'^opG'^opA'^opT^op)^op.Definitionright_morphism_of_nondepCD(F:FunctorCD) (G:FunctorDC) (A:F-|G)(F':FunctorCD) (G':FunctorDC) (A':F'-|G')(T:NaturalTransformationF'F):NaturalTransformationGG':= (@left_morphism_of_nondep__F^opG^opA^opF'^opG'^opA'^opT^op)^op.Endright.

--- Miscellaneous\PathAny.html ---
PathAnyLibrary PathAnyRequireImportBasicsTypes.A nice method for proving characterizations of path-types of nested sigma-types, due to Rijke.To show that the based path-type ofAis equivalent to some specified familyP, it suffices to show thatPis reflexive and its total space is contractible. This is part of Theorem 5.8.2, namely (iv) implies (iii).Definitionequiv_path_from_contr{A:Type} (a:A) (P:A->Type)(Prefl:Pa)(cp:Contr{y:A&Py} )(b:A):Pb<~>a=b.Proof.applyequiv_inverse.srefine(Build_Equiv____).{intros[];applyPrefl. }revertb;applyisequiv_from_functor_sigma.rapplyisequiv_contr_contr.Defined.See Homotopy/EncodeDecode.v for a related characterization of identity types.This is another result for characterizing the path type ofAwhen given an equivalencee:B<~>A, such as anissiglemma forA. It can help Coq to deduce the type familyPifrevertis used to movea0anda1into the goal, if needed.Definitionequiv_path_along_equiv{AB:Type} {P:A->A->Type}(e:B<~>A)(K:forallb0b1:B,P(eb0) (eb1) <~>b0=b1):foralla0a1:A,Pa0a1<~>a0=a1.Proof.equiv_introseb0b1.refine(_oEKb0b1).applyequiv_ap'.Defined.This simply combines the two previous results, a common idiom. Again, it can help Coq to deduce the type familyPifrevertis used to movea0anda1into the goal, if needed.Definitionequiv_path_issig_contr{AB:Type} {P:A->A->Type}(e:B<~>A)(Prefl:forallb,P(eb) (eb))(cp:forallb1,Contr{b2:B&P(eb1) (eb2)}):foralla0a1:A,Pa0a1<~>a0=a1.Proof.apply(equiv_path_along_equive).introa0.srapplyequiv_path_from_contr.applyPrefl.Defined.Afterequiv_path_issig_contr, we are left showing the contractibility of a sigma-type whose base and fibers are large nested sigma-types of the same depth.  Moreover, we expect that the types appearing in those two large nested sigma-types "pair up" to form contractible based "path-types".  The following lemma "peels off" the first such pair, whose contractibility can often be found with typeclass search.  The remaining contractibility goal is then simplified by substituting the center of contraction of that first based "path-type", or more precisely a *specific* center that may or may not be the one given by the contractibility instance; the latter freedom sometimes makes things faster and simpler.Definitioncontr_sigma_sigma(A:Type) (B:A->Type)(C:A->Type) (D:foralla,Ba->Ca->Type){cac:Contr{x:A&Cx} }(a:A) (c:Ca){ccd:Contr{y:Ba&Dayc} }:Contr{ab: {x:A&Bx} & {y:Cab.1 &Dab.1ab.2y} }.Proof.pose(d:= (center{y:Ba&Dayc}).2).set(b:= (center{y:Ba&Dayc}).1)in*.apply(Build_Contr_((a;b);(c;d))).intros[[a'b'] [c'd']];cbnin*.pose(ac':= (a';c')).pose(bd':= (b';d') : {y:Bac'.1 &Dac'.1yac'.2}).change(((a;b);(c;d)) = ((ac'.1;bd'.1);(ac'.2;bd'.2)):> {ab: {x:A&Bx} & {y:Cab.1 &Dab.1ab.2y} }).clearbodyac'bd';cleara'b'c'd'.destruct(@path_contr{x:A&Cx}_(a;c)ac').destruct(@path_contr{y:Ba&Dayc}_(b;d)bd').reflexivity.Defined.This tactic just applies the previous lemma, using a match to figure out the appropriate type families so the user doesn't have to specify them.Ltaccontr_sigsigac:=matchgoalwith| [ |-Contr(@sig(@sig?A?B) (funab=> @sig(@?Cab) (@?Dab))) ] =>(* The lemma only applies when C depends only on the first component of ab, so we need to factor it somehow through pr1. *)letC':=freshintransparentassert(C': {C':A->Type&forallab,C'ab.1 =Cab});[eexists;introsab;reflexivity|nrefine(contr_sigma_sigmaABC'.1 (funab=>D(a;b))ac);In practice, usually the firstContrhypothesis can be found by typeclass search, so we try that.  But we don't try on the second one, since often it can't be, and trying can be slow.[tryexact_|substC'] ]end.For examples of the use of this tactic, see for instanceFactorizationandIdempotents.

--- Miscellaneous\PathCube.html ---
PathCubeLibrary PathCubeRequireImportBasics.RequireImportCubical.DPath.RequireImportCubical.PathSquare.RequireImportCubical.DPathSquare.RequireImportTypes.PathsTypes.Prod.Declare Scopecube_scope.DelimitScopecube_scopewithcube.LocalUnsetEliminationSchemes.Generalizable All Variables.Local OpenScopesquare_scope.(*x001----pi01----x101              x001----pi01----x101|  \               \              |               |  \|  p00i  ==si0i=>  p10i           |               |  p10ip0i1  \               \           p0i1 ==sii1=>   p1i1  \|    x000----pi00----x100         |               |    x100|s0ii |               |    ===>   |               | s1ii|x011   |               |          x011----pi11----x111   |\   p0i0  ==sii0=>  p1i0          \               \   p1i0p01i  |               |           p01i  ==si1i=>  p11i  |\ |               |               \               \ |x010----pi10----x110              x010----pi10----x110*)(* Contents:* Definition of PathCube* PathCube reflexivity* PathCube face rewriting* PathCubes from paths between squares* PathCubes from squres* PathCube flipping* Kan fillers* PathCube concatenation* natural cubes from ap*)(* Homogeneous cubes *)(* PathCube left right top bottom front back *)Cumulative InductivePathCube{A}:forallx000{x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}(s0ii:PathSquarep0i0p0i1p00ip01i) (s1ii:PathSquarep1i0p1i1p10ip11i)(sii0:PathSquarep0i0p1i0pi00pi10) (sii1:PathSquarep0i1p1i1pi01pi11)(si0i:PathSquarep00ip10ipi00pi01) (si1i:PathSquarep01ip11ipi10pi11),Type:=idcube:forallx,PathCubex1 1 1 1 1 1.ArgumentsPathCube{_____________________}.SchemePathCube_ind:=InductionforPathCubeSortType.ArgumentsPathCube_ind{A}Pf{__________________________}.SchemePathCube_rec:=MinimalityforPathCubeSortType.ArgumentsPathCube_rec{A}Pf{__________________________}.(* These notations make it easier to write our lemmas *)Local Notationhr:= (sq_refl_h_).Local Notationvr:= (sq_refl_v_).Local Notationtr:=sq_tr.Local Notationfv:=sq_flip_v.(* PathCubes form a path of squares up to retyping *)Definitionequiv_cu_path{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i} {s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10} {sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01} {si1i:PathSquarep01ip11ipi10pi11}:sq_concat_h(tr(fvs0ii)) (sq_concat_hsi0i(trs1ii)) =sq_ccGG(moveL_Vp___(sq_path^-1sii0))(moveL_Vp___(sq_path^-1sii1))si1i<~>PathCubes0iis1iisii0sii1si0isi1i.Proof.srapplyequiv_adjointify.{destructsii0,sii1;cbn.rewrite(eisretrsq_G1si0i)^,(eisretrsq_1Gs0ii)^,(eisretrsq_1Gs1ii)^.introX.bydestruct(sq_G1^-1si0i), (sq_1G^-1s0ii),(sq_1G^-1s1ii),X,p00i. }1,2:byintros[].destructsii0,sii1.cbn.rewrite<- (eisretrsq_G1si0i).rewrite<- (eisretrsq_1Gs0ii).rewrite<- (eisretrsq_1Gs1ii).destruct(@equiv_inv__sq_G1_si0i).destruct(@equiv_inv__sq_1G_s0ii).destruct(@equiv_inv__sq_1G_s1ii).destructp00i.introX.bydestructX.Defined.Notationcu_path:=equiv_cu_path.SectionReflexivity.(* PathCube reflexivity *)Context{A} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}.(* Left right reflexivity *)Definitioncu_refl_lr(s:PathSquarepx0px1p0xp1x) :PathCubesshrhrhrhr.Proof.bydestructs.Defined.(* Top bottom reflexivity *)Definitioncu_refl_tb(s:PathSquarepx0px1p0xp1x) :PathCubehrhrssvrvr.Proof.bydestructs.Defined.(* Front back reflexivity *)Definitioncu_refl_fb(s:PathSquarepx0px1p0xp1x) :PathCubevrvrvrvrss.Proof.bydestructs.Defined.EndReflexivity.(* Lemmas for rewriting faces of cubes *)SectionPathCubeRewriting.Context{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i} {s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10} {sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01} {si1i:PathSquarep01ip11ipi10pi11}.(* We write the most general version and derive special cases from this *)Definitionequiv_cu_GGGGGG{s0ii's1ii'sii0'sii1'si0i'si1i'}(t0ii:s0ii=s0ii') (t1ii:s1ii=s1ii') (tii0:sii0=sii0')(tii1:sii1=sii1') (ti0i:si0i=si0i') (ti1i:si1i=si1i'):PathCubes0iis1iisii0sii1si0isi1i<~>PathCubes0ii's1ii'sii0'sii1'si0i'si1i'.Proof.bydestructt0ii,t1ii,tii0,tii1,ti0i,ti1i.Defined.Context{s0ii's1ii'sii0'sii1'si0i'si1i'}(t0ii:s0ii=s0ii') (t1ii:s1ii=s1ii') (tii0:sii0=sii0')(tii1:sii1=sii1') (ti0i:si0i=si0i') (ti1i:si1i=si1i').Definitionequiv_cu_Gccccc:=equiv_cu_GGGGGGt0ii1 1 1 1 1.Definitionequiv_cu_cGcccc:=equiv_cu_GGGGGG1t1ii1 1 1 1.Definitionequiv_cu_ccGccc:=equiv_cu_GGGGGG1 1tii01 1 1.Definitionequiv_cu_cccGcc:=equiv_cu_GGGGGG1 1 1tii11 1.Definitionequiv_cu_ccccGc:=equiv_cu_GGGGGG1 1 1 1ti0i1.Definitionequiv_cu_cccccG:=equiv_cu_GGGGGG1 1 1 1 1ti1i.Definitionequiv_cu_ccGGGG:=equiv_cu_GGGGGG1 1tii0tii1ti0iti1i.Definitionequiv_cu_GGGGcc:=equiv_cu_GGGGGGt0iit1iitii0tii11 1.Definitionequiv_cu_GGcccc:=equiv_cu_GGGGGGt0iit1ii1 1 1 1.Definitionequiv_cu_ccGGcc:=equiv_cu_GGGGGG1 1tii0tii11 1.Definitionequiv_cu_ccccGG:=equiv_cu_GGGGGG1 1 1 1ti0iti1i.EndPathCubeRewriting.Notationcu_GGGGGG:=equiv_cu_GGGGGG.Notationcu_Gccccc:=equiv_cu_Gccccc.Notationcu_cGcccc:=equiv_cu_cGcccc.Notationcu_ccGccc:=equiv_cu_ccGccc.Notationcu_cccGcc:=equiv_cu_cccGcc.Notationcu_ccccGc:=equiv_cu_ccccGc.Notationcu_cccccG:=equiv_cu_cccccG.Notationcu_ccGGGG:=equiv_cu_ccGGGG.Notationcu_GGGGcc:=equiv_cu_GGGGcc.Notationcu_GGcccc:=equiv_cu_GGcccc.Notationcu_ccGGcc:=equiv_cu_ccGGcc.Notationcu_ccccGG:=equiv_cu_ccccGG.(* Rotating top and bottom to front and back *)Definitionequiv_cu_rot_tb_fb{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i} {s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10} {sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01} {si1i:PathSquarep01ip11ipi10pi11}:PathCubesi0isi1i(sq_trs0ii) (sq_trs1ii) (sq_trsii0) (sq_trsii1)<~>PathCubes0iis1iisii0sii1si0isi1i.Proof.srapplyequiv_adjointify.{introcube.refine(cu_GGGGcc_____).1,2,3,4:exact(eissecttr_).revertcube.set(a:=trs0ii).set(b:=trs1ii).set(c:=trsii0).set(d:=trsii1).clearbodyabcd;clears0iis1iisii0sii1.introcube.bydestructcube. }1,2 :byintros[].rewrite<- (eissecttrs0ii).rewrite<- (eissecttrs1ii).rewrite<- (eissecttrsii0).rewrite<- (eissecttrsii1).set(a:=trs0ii).set(b:=trs1ii).set(c:=trsii0).set(d:=trsii1).clearbodyabcd;clears0iis1iisii0sii1.introX.rewrite<- (eissect(cu_ccGGGG(eisretrtr_)(eisretrtr_) (eisretrtr_) (eisretrtr_))X).set(e:=cu_ccGGGG(eisretrtr_) (eisretrtr_)(eisretrtr_) (eisretrtr_)X).clearbodye;clearX.bydestructe.Defined.Notationcu_rot_tb_fb:=equiv_cu_rot_tb_fb.(* Degnerate cubes formed from paths between squares *)(* The first case is easiest to prove and can be written as equivalences *)Definitionequiv_cu_G11{A} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}{ss':PathSquarepx0px1p0xp1x}:s=s'<~>PathCubess'hrhrhrhr.Proof.destructs.refine(cu_pathoE_).refine(equiv_concat_l(sq_concat_h_1s(sq_concat_h1%square(trs'))(p0y:=1) (p1y:=1))_oE_).refine(equiv_concat_l(sq_concat_h_1s(trs')(p0y:=1) (p1y:=1))_oE_).refine(equiv_moveR_equiv_M(f:=tr)__oE_).applyequiv_path_inverse.Defined.(* This case can be reduced to the first by rotating the cubeand rewriting some faces *)Definitionequiv_cu_1G1{A} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}{ss':PathSquarepx0px1p0xp1x}:s=s'<~>PathCubehrhrss'vrvr.Proof.refine(cu_rot_tb_fboE_).refine(cu_rot_tb_fboE_).refine(cu_ccGGGG____oE_).1,2:exactsq_tr_refl_v^.1,2:exact(eisretrtr_)^.refine(_oEequiv_ap'tr__).applyequiv_cu_G11.Defined.(* Finally this is an even simpler rotation *)Definitionequiv_cu_11G{A} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}{ss':PathSquarepx0px1p0xp1x}:s=s'<~>PathCubevrvrvrvrss'.Proof.refine(cu_rot_tb_fboE_).refine(cu_ccGGGG____oE_).1-4:exactsq_tr_refl_v^.byapplyequiv_cu_G11.Defined.Notationcu_G11:=equiv_cu_G11.Notationcu_1G1:=equiv_cu_1G1.Notationcu_11G:=equiv_cu_11G.(* Degnerate cubes given by squares *)SectionPathPathSquares.Context{A} {xy:A} {a00a10a01a11:x=y}(px0:a00=a10) (px1:a01=a11)(p0x:a00=a01) (p1x:a10=a11).Definitionequiv_cu_GG1:PathSquarepx0px1p0xp1x<~>PathCube(sq_G1px0) (sq_G1px1) (sq_G1p0x) (sq_G1p1x) 1 1.Proof.destructp0x,p1x,a00.refine(_oEsq_G1^-1).refine(_oEequiv_ap'sq_G1__).exactcu_G11.Defined.Definitionequiv_cu_1GG:PathSquarepx0px1p0xp1x<~>PathCube1 1 (sq_1Gpx0) (sq_1Gpx1) (sq_1Gp0x) (sq_1Gp1x).Proof.destructpx0,px1,a01.refine(_oEsq_1G^-1).refine(_oEequiv_ap'sq_1G__).exactcu_11G.Defined.Definitionequiv_cu_G1G:PathSquarepx0px1p0xp1x<~>PathCube(sq_1Gpx0) (sq_1Gpx1) 1 1 (sq_G1p0x) (sq_G1p1x).Proof.destructp0x,p1x,a10.refine(_oEsq_G1^-1).refine(_oEequiv_ap'sq_1G__).exactcu_G11.Defined.EndPathPathSquares.Notationcu_GG1:=equiv_cu_GG1.Notationcu_G1G:=equiv_cu_G1G.Notationcu_1GG:=equiv_cu_1GG.Argumentscu_GG1{___________}.Argumentscu_G1G{___________}.Argumentscu_1GG{___________}.(* PathCubes can be given by DPathSquares over Paths*)Definitionequiv_cu_ds{AB} {fg:A->B} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}{s:PathSquarepx0px1p0xp1x}{b00:fa00=ga00} {b01:fa01=ga01}{b10:fa10=ga10} {b11:fa11=ga11}{qx0:DPath(funx=>fx=gx)px0b00b10}{qx1:DPath(funx=>fx=gx)px1b01b11}{q0x:DPath(funx=>fx=gx)p0xb00b01}{q1x:DPath(funx=>fx=gx)p1xb10b11}:DPathSquare(funx=>fx=gx)sqx0qx1q0xq1x<~>PathCube(sq_dpqx0) (sq_dpqx1) (sq_dpq0x) (sq_dpq1x)(sq_apfs) (sq_apgs).Proof.destructs.applycu_GG1.Defined.Notationcu_ds:=equiv_cu_ds.(* PathCubes can be given by DPaths over PathSquares *)Definitionequiv_dp_cu{AB:Type} {x1x2:A} {a00a01a10a11:A->B}{px0:a00==a10} {px1:a01==a11} {p0x:a00==a01} {p1x:a10==a11}{f1:PathSquare(px0x1) (px1x1) (p0xx1) (p1xx1)}{f2:PathSquare(px0x2) (px1x2) (p0xx2) (p1xx2)}{p:x1=x2}:PathCubef1f2(sq_dp(apDpx0p)) (sq_dp(apDpx1p))(sq_dp(apDp0xp)) (sq_dp(apDp1xp))<~>DPath(funx=>PathSquare(px0x) (px1x) (p0xx) (p1xx))pf1f2.Proof.destructp;symmetry;exactcu_G11.Defined.Notationdp_cu:=equiv_dp_cu.(* Flipping a cube along the left right direction *)Definitionequiv_cu_flip_lr{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i} {s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10} {sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01} {si1i:PathSquarep01ip11ipi10pi11}:PathCubes0iis1iisii0sii1si0isi1i<~>PathCubes1iis0ii(sq_flip_hsii0) (sq_flip_hsii1)(sq_flip_hsi0i) (sq_flip_hsi1i).Proof.destructsi1i,si0i.refine(cu_GGcccc__oE_).1,2:exact(eisretrsq_G1_).refine(cu_GG1oE_).refine(sq_flip_hoE_).refine(cu_GG1^-1oE_).refine(cu_GGGGcc____).all:exact(eisretrsq_G1_)^.Defined.Notationcu_flip_lr:=equiv_cu_flip_lr.(* PathCube Kan fillers ~ Every open crate has a lid *)Definitioncu_fill_left{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}(s1ii:PathSquarep1i0p1i1p10ip11i)(sii0:PathSquarep0i0p1i0pi00pi10) (sii1:PathSquarep0i1p1i1pi01pi11)(si0i:PathSquarep00ip10ipi00pi01) (si1i:PathSquarep01ip11ipi10pi11): {s0ii:PathSquarep0i0p0i1p00ip01i&PathCubes0iis1iisii0sii1si0isi1i}.Proof.destructsi0i,si1i.set(a:=sq_G1^-1s1ii).set(b:=sq_G1^-1sii0).set(c:=sq_G1^-1sii1).rewrite<- (eisretrsq_G1s1ii).rewrite<- (eisretrsq_G1sii0).rewrite<- (eisretrsq_G1sii1).change(sq_G1^-1s1ii)witha.change(sq_G1^-1sii0)withb.change(sq_G1^-1sii1)withc.clearbodyabc.clears1iisii0sii1.refine(sq_G1(b@a@c^);_).bydestructa,b,c,p0i1.Defined.Definitioncu_fill_right{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}(s0ii:PathSquarep0i0p0i1p00ip01i)(sii0:PathSquarep0i0p1i0pi00pi10) (sii1:PathSquarep0i1p1i1pi01pi11)(si0i:PathSquarep00ip10ipi00pi01) (si1i:PathSquarep01ip11ipi10pi11): {s1ii:PathSquarep1i0p1i1p10ip11i&PathCubes0iis1iisii0sii1si0isi1i}.Proof.refine(_;_).applycu_flip_lr^-1.applycu_fill_left.Defined.Definitioncu_fill_top{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}(s0ii:PathSquarep0i0p0i1p00ip01i) (s1ii:PathSquarep1i0p1i1p10ip11i)(sii1:PathSquarep0i1p1i1pi01pi11)(si0i:PathSquarep00ip10ipi00pi01) (si1i:PathSquarep01ip11ipi10pi11): {sii0:PathSquarep0i0p1i0pi00pi10&PathCubes0iis1iisii0sii1si0isi1i}.Proof.refine(_;_).applycu_rot_tb_fb.applycu_rot_tb_fb.refine(cu_Gccccc(eisretrtr_)^_).applycu_fill_left.Defined.Definitioncu_fill_bottom{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}(s0ii:PathSquarep0i0p0i1p00ip01i) (s1ii:PathSquarep1i0p1i1p10ip11i)(sii0:PathSquarep0i0p1i0pi00pi10)(si0i:PathSquarep00ip10ipi00pi01) (si1i:PathSquarep01ip11ipi10pi11): {sii1:PathSquarep0i1p1i1pi01pi11&PathCubes0iis1iisii0sii1si0isi1i}.Proof.refine(_;_).applycu_rot_tb_fb.applycu_rot_tb_fb.refine(cu_cGcccc(eisretrtr_)^_).applycu_fill_right.Defined.Definitioncu_fill_front{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}(s0ii:PathSquarep0i0p0i1p00ip01i) (s1ii:PathSquarep1i0p1i1p10ip11i)(sii0:PathSquarep0i0p1i0pi00pi10) (sii1:PathSquarep0i1p1i1pi01pi11)(si1i:PathSquarep01ip11ipi10pi11): {si0i:PathSquarep00ip10ipi00pi01&PathCubes0iis1iisii0sii1si0isi1i}.Proof.refine(_;_).applycu_rot_tb_fb.applycu_fill_left.Defined.Definitioncu_fill_back{A} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}(s0ii:PathSquarep0i0p0i1p00ip01i) (s1ii:PathSquarep1i0p1i1p10ip11i)(sii0:PathSquarep0i0p1i0pi00pi10) (sii1:PathSquarep0i1p1i1pi01pi11)(si0i:PathSquarep00ip10ipi00pi01): {si1i:PathSquarep01ip11ipi10pi11&PathCubes0iis1iisii0sii1si0isi1i}.Proof.refine(_;_).applycu_rot_tb_fb.applycu_fill_right.Defined.PathCube concatenationSectionConcat.Context{A:Type}(* Main Cube *){x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i} {s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10} {sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01} {si1i:PathSquarep01ip11ipi10pi11}(ciii:PathCubes0iis1iisii0sii1si0isi1i).Definitioncu_concat_lr{x201x200x210x211:A}{pj01:x101=x201} {pj11:x111=x211} {pj10:x110=x210}{pj00:x100=x200} {p2i1:x201=x211} {p2i0:x200=x210}{p20i:x200=x201} {p21i:x210=x211}{sji0:PathSquarep1i0p2i0pj00pj10} {sji1:PathSquarep1i1p2i1pj01pj11}{sj0i:PathSquarep10ip20ipj00pj01} {sj1i:PathSquarep11ip21ipj10pj11}{s2ii:PathSquarep2i0p2i1p20ip21i}(cjii:PathCubes1iis2iisji0sji1sj0isj1i):PathCubes0iis2ii(sq_concat_hsii0sji0) (sq_concat_hsii1sji1)(sq_concat_hsi0isj0i) (sq_concat_hsi1isj1i).Proof.destructcjii,pi00,pi01,pi10,pi11.exactciii.Defined.Definitioncu_concat_tb{x020x021x120x121:A}{p0j0:x010=x020} {p1j0:x110=x120} {p0j1:x011=x021}{p1j1:x111=x121} {p02i:x020=x021} {p12i:x120=x121}{pi20:x020=x120} {pi21:x021=x121}{s0ji:PathSquarep0j0p0j1p01ip02i} {s1ji:PathSquarep1j0p1j1p11ip12i}{sij0:PathSquarep0j0p1j0pi10pi20} {sij1:PathSquarep0j1p1j1pi11pi21}{si2i:PathSquarep02ip12ipi20pi21}(ciji:PathCubes0jis1jisij0sij1si1isi2i):PathCube(sq_concat_vs0iis0ji) (sq_concat_vs1iis1ji)(sq_concat_vsii0sij0) (sq_concat_vsii1sij1)si0isi2i.Proof.destructciji,p0i0,p1i0,p0i1,p1i1.exactciii.Defined.Definitioncu_concat_fb{x002x012x102x112:A}{p0i2:x002=x012} {p00j:x001=x002} {p01j:x011=x012}{p1i2:x102=x112} {p10j:x101=x102} {p11j:x111=x112}{pi02:x002=x102} {pi12:x012=x112}{s0ij:PathSquarep0i1p0i2p00jp01j} {s1ij:PathSquarep1i1p1i2p10jp11j}{si0j:PathSquarep00jp10jpi01pi02} {si1j:PathSquarep01jp11jpi11pi12}{sii2:PathSquarep0i2p1i2pi02pi12}(ciij:PathCubes0ijs1ijsii1sii2si0jsi1j):PathCube(sq_concat_hs0iis0ij) (sq_concat_hs1iis1ij)sii0sii2(sq_concat_vsi0isi0j) (sq_concat_vsi1isi1j).Proof.destructciij,p00i,p10i,p11i,p01i.exactciii.Defined.EndConcat.(* Notation for left right concatenation *)Notation"x '@lr' y" := (cu_concat_lrxy) :cube_scope.Local Notationapc:= (ap_compose_sq___).(* sq_ap analogue for ap_compse *)Definitionsq_ap_compose{ABC:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}(f:A->B) (g:B->C) (s:PathSquarepx0px1p0xp1x):PathCube(sq_ap(gof)s) (sq_apg(sq_apfs))apcapcapcapc.Proof.bydestructs.Defined.Local Notationapi:= (ap_idmap_sq_).(* sq_ap analogue for ap_idmap *)Definitionsq_ap_idmap{A:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}(s:PathSquarepx0px1p0xp1x):PathCube(sq_apidmaps)sapiapiapiapi.Proof.bydestructs.Defined.Local Notationapn:= (ap_nat__).(* sq_ap analogue for ap_nat *)Definitionsq_ap_nat{AB:Type} {a00a10a01a11:A} (ff':A->B) (h:f==f'){px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}(s:PathSquarepx0px1p0xp1x):PathCube(sq_apfs) (sq_apf's) (ap_nath_)apnapnapn.Proof.destructsas[x];cbn;bydestruct(hx).Defined.(* Uncurry a function in sq_ap2 *)Definitionsq_ap_uncurry{ABC} (f:A->B->C){aa':A} (p:a=a') {bb':B} (q:b=b'):PathCube(sq_ap(uncurryf) (sq_prod(hr,vr))) (sq_ap011fpq)(sq_G1(ap_uncurry___)) (sq_G1(ap_uncurry___))(sq_G1(ap_uncurry___)) (sq_G1(ap_uncurry___)).Proof.bydestructp,q.Defined.(* ap for cubes *)Definitioncu_ap{AB} {x000x010x100x110x001x011x101x111:A}{p0i0:x000=x010} {p1i0:x100=x110} {pi00:x000=x100}{pi10:x010=x110} {p0i1:x001=x011} {p1i1:x101=x111}{pi01:x001=x101} {pi11:x011=x111} {p00i:x000=x001}{p01i:x010=x011} {p10i:x100=x101} {p11i:x110=x111}{s0ii:PathSquarep0i0p0i1p00ip01i} {s1ii:PathSquarep1i0p1i1p10ip11i}{sii0:PathSquarep0i0p1i0pi00pi10} {sii1:PathSquarep0i1p1i1pi01pi11}{si0i:PathSquarep00ip10ipi00pi01} {si1i:PathSquarep01ip11ipi10pi11}(f:A->B) (c:PathCubes0iis1iisii0sii1si0isi1i):PathCube(sq_apfs0ii) (sq_apfs1ii) (sq_apfsii0)(sq_apfsii1) (sq_apfsi0i) (sq_apfsi1i).Proof.bydestructc.Defined.

--- Miscellaneous\Paths.html ---
PathsLibrary PathsRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoids.RequireImportWildCat.CoreWildCat.TwoOneCatWildCat.NatTrans.Path groupoids as wild categoriesNot global instances for nowThese are written so that they can be augmented with an existing wildcat structure. For instance, you may partially define a wildcat and ask for paths for the higher cells.Any type is a graph with morphisms given by the identity type.Definitionisgraph_paths(A:Type) :IsGraphA:= {|Hom:=paths|}.Any graph is a 2-graph with 2-cells given by the identity type.Definitionis2graph_paths(A:Type) `{IsGraphA} :Is2GraphA:=fun__=>isgraph_paths_.Any 2-graph is a 3-graph with 3-cells given by the identity type.Definitionis3graph_paths(A:Type) `{Is2GraphA} :Is3GraphA:=fun__=>is2graph_paths_.We assume these as instances for the rest of the file with a low priority.Local Existing Instancesisgraph_pathsis2graph_pathsis3graph_paths| 10.Any type has composition and identity morphisms given by path concatenation and reflexivity.Global Instanceis01cat_paths(A:Type) :Is01CatA:= {|Id:= @idpath_;cat_comp:=fun___xy=>concatyx|}.Any type has a 0-groupoid structure with inverse morphisms given by path inversion.Global Instanceis0gpd_paths(A:Type) :Is0GpdA:= {|gpd_rev:= @inverse_|}.Postcomposition is a 0-functor when the 2-cells are paths.Global Instanceis0functor_cat_postcomp_paths(A:Type) `{Is01CatA}(abc:A) (g:b$->c):Is0Functor(cat_postcompag).Proof.snrapplyBuild_Is0Functor.exact(@ap__(cat_postcompag)).Defined.Precomposition is a 0-functor when the 2-cells are paths.Global Instanceis0functor_cat_precomp_paths(A:Type) `{Is01CatA}(abc:A) (f:a$->b):Is0Functor(cat_precompcf).Proof.snrapplyBuild_Is0Functor.exact(@ap__(cat_precompcf)).Defined.Any type is a 1-category with n-morphisms given by paths.Global Instanceis1cat_paths{A:Type} :Is1CatA.Proof.snrapplyBuild_Is1Cat.-exact_.-exact_.-exact_.-exact_.-exact(@concat_p_ppA).-exact(@concat_pp_pA).-exact(@concat_p1A).-exact(@concat_1pA).Defined.Any type is a 1-groupoid with morphisms given by paths.Global Instanceis1gpd_paths{A:Type} :Is1GpdA.Proof.snrapplyBuild_Is1Gpd.-exact(@concat_pVA).-exact(@concat_VpA).Defined.Any type is a 2-category with higher morphhisms given by paths.Global Instanceis21cat_paths{A:Type} :Is21CatA.Proof.snrapplyBuild_Is21Cat.-exact_.-exact_.-introsxyzp.snrapplyBuild_Is1Functor.+introsabqr.exact(ap(funx=>whiskerRx_)).+reflexivity.+introsabc.exact(whiskerR_ppp).-introsxyzp.snrapplyBuild_Is1Functor.+introsabqr.exact(ap(whiskerLp)).+reflexivity.+introsabc.exact(whiskerL_ppp).-introsabcqrsthg.exact(concat_whiskerqrsthg)^.-introsabcdqr.snrapplyBuild_Is1Natural.introssth.applyconcat_p_pp_nat_r.-introsabcdqr.snrapplyBuild_Is1Natural.introssth.applyconcat_p_pp_nat_m.-introsabcdqr.snrapplyBuild_Is1Natural.introssth.applyconcat_p_pp_nat_l.-introsab.snrapplyBuild_Is1Natural.introspqh;cbn.applymoveL_Mp.lhsnrapplyconcat_p_pp.exact(whiskerR_p1h).-introsab.snrapplyBuild_Is1Natural.introspqh.applymoveL_Mp.lhsrapplyconcat_p_pp.exact(whiskerL_1ph).-introsabcdepqrs.lhsnrapplyconcat_p_pp.exact(pentagonpqrs).-introsabcpq.exact(triangulatorpq).Defined.

--- Miscellaneous\PathSplit.html ---
PathSplitLibrary PathSplitRequireImportHoTT.BasicsHoTT.Types.Local OpenScopenat_scope.Local OpenScopepath_scope.Generalizable VariablesABf.SectionAssumeFunext.Context`{Funext}.n-Path-split maps.A map is n-path-split if its induced maps on the first n iterated path-spaces are split surjections.  Thus every map is 0-path-split, the 1-path-split maps are the split surjections, and so on.  It turns out that for n>1, being n-path-split is the same as being an equivalence.FixpointPathSplit(n:nat) `(f:A->B) :Type:=matchnwith| 0 =>Unit|Sn=> (foralla,hfiberfa) *forall(xy:A),PathSplitn(@ap__fxy)end.Definitionisequiv_pathsplit(n:nat) `{f:A->B}:PathSplitn.+2f->IsEquivf.Proof.intros[gk].pose(h:=funxyp=> (fst(kxy)p).1).pose(hs:=funxy=> (funp=> (fst(kxy)p).2): (apf)o(hxy) ==idmap).clearbodyhs;clearbodyh;cleark.applyisequiv_contr_map;introsb.applycontr_inhabited_hprop.2:exact(gb).applyhprop_allpath;intros[ap] [a'p'].refine(path_sigma'_(haa'(p@p'^))_).refine(transport_paths_Fl__@_).refine((inverse2(hsaa'(p@p'^)) @@ 1) @_).refine((inv_pppp'^ @@ 1) @_).refine(concat_pp_p___@_).refine((1 @@concat_Vp_) @_).exact((inv_Vp'@@ 1) @concat_p1_).Defined.Global Instancecontr_pathsplit_isequiv(n:nat) `(f:A->B) `{IsEquiv__f}:Contr(PathSplitnf).Proof.generalizedependentB;revertA.simple_inductionnnIHn;introsABf?.-exact_.-applycontr_prod.Defined.Global Instanceishprop_pathsplit(n:nat) `(f:A->B):IsHProp(PathSplitn.+2f).Proof.applyhprop_inhabited_contr;introsps.pose(isequiv_pathsplitnps).exact_.Defined.Definitionequiv_pathsplit_isequiv(n:nat) `(f:A->B):PathSplitn.+2f<~>IsEquivf.Proof.refine(equiv_iff_hprop__).-applyisequiv_pathsplit.-intros?;refine(center_).Defined.Path-splitness transfers across commutative squares of equivalences.Lemmaequiv_functor_pathsplit(n:nat) {ABCD}(f:A->B) (g:C->D) (h:A<~>C) (k:B<~>D)(p:goh==kof):PathSplitnf<~>PathSplitng.Proof.destructnas[|n].1:applyequiv_idmap.destructnas[|n].-simpl.refine(_*Eequiv_contr_contr).refine(equiv_functor_forall'k^-1_);introsd.unfoldhfiber.refine(equiv_functor_sigma'h_);introsa.refine(equiv_concat_l(pa)doE_).simpl;applyequiv_moveR_equiv_M.-refine(_oEequiv_pathsplit_isequivnf).refine((equiv_pathsplit_isequivng)^-1oE_).applyequiv_iff_hprop;introse.+refine(isequiv_commsqfghk(funa=> (pa)^)).+refine(isequiv_commsq'fghkp).Defined.A map is oo-path-split if it is n-path-split for all n.  This is also equivalent to being an equivalence.DefinitionooPathSplit`(f:A->B) :Type:=foralln,PathSplitnf.Definitionisequiv_oopathsplit`{f:A->B}:ooPathSplitf->IsEquivf:=funps=>isequiv_pathsplit0 (ps2).Global Instancecontr_oopathsplit_isequiv`(f:A->B) `{IsEquiv__f}:Contr(ooPathSplitf).Proof.applycontr_forall.Defined.Global Instanceishprop_oopathsplit`(f:A->B):IsHProp(ooPathSplitf).Proof.applyhprop_inhabited_contr;introsps.pose(isequiv_oopathsplitps).exact_.Defined.Definitionequiv_oopathsplit_isequiv`(f:A->B):ooPathSplitf<~>IsEquivf.Proof.refine(equiv_iff_hprop__).-applyisequiv_oopathsplit.-intros?;refine(center_).Defined.EndAssumeFunext.

--- Miscellaneous\PathSquare.html ---
PathSquareLibrary PathSquareRequireImportBasics.RequireImportTypes.PathsTypes.Prod.RequireImportDPath.Declare Scopesquare_scope.DelimitScopesquare_scopewithsquare.LocalUnsetEliminationSchemes.(* Homogeneous squares *)(*x00 ----pi0---- x01|               ||               |p0i     ==>     p1i|               ||               |x01-----pi1-----x11*)(* Contents:* Definition of PathSquare* Degenerate PathSquares as paths between paths* Flipping squares horizontally and vertically* PathSquare transpose* PathSquare inverse* PathSquare rotations* Edge rewriting* Concatenation* Kan fillers* natural squares from ap*)(* Definition of PathSquare *)(* PathSquare left right up down *)Cumulative InductivePathSquare{A} :foralla00{a10a01a11:A},a00=a10->a01=a11->a00=a01->a10=a11->Type:=sq_id:forall{x:A},PathSquarex1 1 1 1.Argumentssq_id{Ax}.ArgumentsPathSquare{A____}.Notation"1" :=sq_id:square_scope.SchemePathSquare_ind:=InductionforPathSquareSortType.ArgumentsPathSquare_ind{A}Pf{________}_.SchemePathSquare_rec:=MinimalityforPathSquareSortType.ArgumentsPathSquare_rec{A}Pf{________}_.(* PathSquare_ind is an equivalence, similar to how paths_ind is *)Global Instanceisequiv_PathSquare_ind`{Funext} {A}(P:forall(a00a10a01a11:A) (p:a00=a10) (p0:a01=a11)(p1:a00=a01) (p2:a10=a11),PathSquarepp0p1p2->Type) :IsEquiv(PathSquare_indP).Proof.srapplyisequiv_adjointify.1:introsX?;applyX.2:intro;reflexivity.intro.do8 (applypath_forall;intro).applypath_forall.byintros[].Defined.(* PathSquares can be given by 2-dimensional paths *)Definitionequiv_sq_path{A} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}:px0@p1x=p0x@px1<~>PathSquarepx0px1p0xp1x.Proof.snrapplyBuild_Equiv.{destructp0x,p1x.introe.generalize(e@concat_1p_).introe'.destructe',px0.exactsq_id. }srapplyisequiv_adjointify;trybyintros[].destructp0x,p1x.introse.patterne.pose(e':=e@concat_1p_).pose(e'':=e'@ (concat_1p_)^).refine(@transport__e''e__).-subste'e'';hott_simpl.-clearbodye';cleare.destructe',px0.reflexivity.Defined.Notationsq_path:=equiv_sq_path.Squares in (n+2)-truncated types are n-truncatedGlobal Instanceistrunc_sqn{A} `{!IsTruncn.+2A} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}:IsTruncn(PathSquarepx0px1p0xp1x).Proof.exact(istrunc_equiv_istrunc_sq_path).Defined.(* We can give degenerate squares *)SectionPathSquaresFromPaths.Context{A:Type} {a00a10a01:A}{pp':a00=a10} {qq':a00=a01}.Definitionequiv_sq_G1:p=p'<~>PathSquarepp'1 1:=sq_pathoEequiv_p1_1q.Definitionequiv_sq_1G:q=q'<~>PathSquare1 1qq':=sq_pathoEequiv_1p_q1oEequiv_path_inverse__.EndPathSquaresFromPaths.Notationsq_G1:=equiv_sq_G1.Notationsq_1G:=equiv_sq_1G.Local OpenScopeequiv_scope.Local OpenScopepath_scope.(* PathSquare horizontal reflexivity *)Definitionsq_refl_h{A} {a0a1:A} (p:a0=a1):PathSquarepp1 1 :=sq_G11.(* PathSquare vertical reflexivity *)Definitionsq_refl_v{A} {a0a1:A} (p:a0=a1):PathSquare1 1pp:=sq_1G1.(* Horizontal flip *)Definitionequiv_sq_flip_h{A:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}:PathSquarepx0px1p0xp1x<~>PathSquarepx1px0p0x^p1x^.Proof.destructp0x,p1x.refine(sq_G1oE_).refine(equiv_path_inverse__oE_).applysq_G1^-1.Defined.Notationsq_flip_h:=equiv_sq_flip_h.(* Vertical flip *)Definitionequiv_sq_flip_v{A:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}:PathSquarepx0px1p0xp1x<~>PathSquarepx0^px1^p1xp0x.Proof.destructpx0,px1.refine(sq_1GoE_).refine(equiv_path_inverse__oE_).applysq_1G^-1.Defined.Notationsq_flip_v:=equiv_sq_flip_v.(* Transpose of a square *)We make a local definition that will never get unfoldedLocal Definitiontr{A:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}:PathSquarepx0px1p0xp1x->PathSquarep0xp1xpx0px1.Proof.byintros[].Defined.Argumentstr:simplnever.Definitionequiv_sq_tr{A:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}:PathSquarepx0px1p0xp1x<~>PathSquarep0xp1xpx0px1.Proof.srapply(equiv_adjointifytrtr).1,2:byintros[].Defined.Notationsq_tr:=equiv_sq_tr.(* NOTE: sq_tr ought to be some sort of involution but it obviously isn'tsince it is not of the form A -> A. Perhaps there is a more general"involution" but between equivalent types? But then that very equivalenceis given by sq_tr so it seems a bit circular... *)Definitionsq_tr_refl_h{A} {ab:A} {p:a=b}:sq_tr(sq_refl_hp) =sq_refl_vp.Proof.bydestructp.Defined.Definitionsq_tr_refl_v{A} {ab:A} {p:a=b}:sq_tr(sq_refl_vp) =sq_refl_hp.Proof.bydestructp.Defined.(* Operations on squares *)SectionPathSquareOps.Context{A:Type}{a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}.(* Inverse square *)Definitionequiv_sq_V:PathSquarepx0px1p0xp1x<~>PathSquarepx1^px0^p1x^p0x^.Proof.refine(sq_pathoE_).refine(equiv_concat_lr(inv_pp__)^ (inv_pp__)oE_).refine(equiv_ap___oE_).refine(sq_path^-1oE_).exactsq_tr.Defined.(* Left rotation : left right top bottom  ->  top bottom right left *)Definitionequiv_sq_rot_l:PathSquarepx0px1p0xp1x<~>PathSquarep0x^p1x^px1px0.Proof.refine(sq_pathoE_).refine(equiv_moveR_Vp___oE_).refine(equiv_concat_r(concat_pp_p___)_oE_).refine(equiv_moveL_pV___oE_).exactsq_path^-1.Defined.(* Right rotation : left right top bottom -> bottom top left right *)Definitionequiv_sq_rot_r:PathSquarepx0px1p0xp1x->PathSquarep1xp0xpx0^px1^.Proof.refine(sq_pathoE_).refine(equiv_moveL_Vp___oE_).refine(equiv_concat_l(concat_p_pp___)_oE_).refine(equiv_moveR_pV___oE_).exactsq_path^-1.Defined.EndPathSquareOps.Notationsq_V:=equiv_sq_V.Notationsq_rot_l:=equiv_sq_rot_l.Notationsq_rot_r:=equiv_sq_rot_r.(* Lemmas for rewriting sides of squares *)SectionPathSquareRewriting.Context{A:Type}{a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}.(* These are all special cases of the following "rewrite all sides"lemma which we prove is an equivalence giving us all special casesas equivalences too *)Definitionequiv_sq_GGGG{px0'px1'p0x'p1x'} (qx0:px0=px0')(qx1:px1=px1') (q0x:p0x=p0x') (q1x:p1x=p1x'):PathSquarepx0px1p0xp1x<~>PathSquarepx0'px1'p0x'p1x'.Proof.bydestructqx0,qx1,q0x,q1x.Defined.Context{px0'px1'p0x'p1x'}(qx0:px0=px0') (qx1:px1=px1')(q0x:p0x=p0x') (q1x:p1x=p1x').Definitionequiv_sq_Gccc:=equiv_sq_GGGGqx01 1 1.Definitionequiv_sq_cGcc:=equiv_sq_GGGG1qx11 1.Definitionequiv_sq_ccGc:=equiv_sq_GGGG1 1q0x1.Definitionequiv_sq_cccG:=equiv_sq_GGGG1 1 1q1x.Definitionequiv_sq_GGcc:=equiv_sq_GGGGqx0qx11 1.Definitionequiv_sq_GcGc:=equiv_sq_GGGGqx01q0x1.Definitionequiv_sq_GccG:=equiv_sq_GGGGqx01 1q1x.Definitionequiv_sq_cGGc:=equiv_sq_GGGG1qx1q0x1.Definitionequiv_sq_cGcG:=equiv_sq_GGGG1qx11q1x.Definitionequiv_sq_ccGG:=equiv_sq_GGGG1 1q0xq1x.Definitionequiv_sq_GGGc:=equiv_sq_GGGGqx0qx1q0x1.Definitionequiv_sq_cGGG:=equiv_sq_GGGG1qx1q0xq1x.EndPathSquareRewriting.Notationsq_GGGG:=equiv_sq_GGGG.Notationsq_Gccc:=equiv_sq_Gccc.Notationsq_cGcc:=equiv_sq_cGcc.Notationsq_ccGc:=equiv_sq_ccGc.Notationsq_cccG:=equiv_sq_cccG.Notationsq_GGcc:=equiv_sq_GGcc.Notationsq_GcGc:=equiv_sq_GcGc.Notationsq_GccG:=equiv_sq_GccG.Notationsq_cGGc:=equiv_sq_cGGc.Notationsq_cGcG:=equiv_sq_cGcG.Notationsq_ccGG:=equiv_sq_ccGG.Notationsq_GGGc:=equiv_sq_GGGc.Notationsq_cGGG:=equiv_sq_cGGG.SectionMovePaths.Context{A:Type} {xx00x20x02x22:A}{f10:x00=x20} {f12:x02=x22} {f01:x00=x02} {f21:x20=x22}.Operations to move paths around a square. We define all these operations immediately as equvialences. The naming first number indicates in which argument the path that moves is on the left of the equivalence, and the second number where it is on the right. The equivalences are all set up so that on the right, there is no path inversion. For the24and13equivalences there is a path inverse on the left. The corresponding equivalences42and31are the symmetric versions of these, but the path inverse is in another place.Definitionequiv_sq_move_23{f12'':x02=x} {f12':x=x22}:PathSquaref10(f12''@f12')f01f21<~>PathSquaref10f12'(f01@f12'')f21.Proof.clearf12.destructf12''.refine(sq_cGcc(concat_1p_)oE_).refine(sq_ccGc(concat_p1_)^).Defined.Definitionequiv_sq_move_14{f10'':x00=x} {f10':x=x20}:PathSquare(f10''@f10')f12f01f21<~>PathSquaref10''f12f01(f10'@f21).Proof.clearf10.destructf10'.refine(sq_cccG(concat_1p_)^oE_).refine(sq_Gccc(concat_p1_)).Defined.Definitionequiv_sq_move_24{f12'':x02=x} {f12':x22=x}:PathSquaref10(f12''@f12'^)f01f21<~>PathSquaref10f12''f01(f21@f12').Proof.clearf12.destructf12'.refine(sq_cccG(concat_p1_)^oE_).refine(sq_cGcc(concat_p1_)).Defined.Definitionequiv_sq_move_42{f12'':x02=x} {f12':x=x22}:PathSquaref10f12''f01(f21@f12'^) <~>PathSquaref10(f12''@f12')f01f21.Proof.clearf12.destructf12'.refine(sq_cGcc(concat_p1_)^oE_).refine(sq_cccG(concat_p1_)).Defined.Definitionequiv_sq_move_13{f10'':x=x00} {f10':x=x20}:PathSquare(f10''^ @f10')f12f01f21<~>PathSquaref10'f12(f10''@f01)f21.Proof.clearf10.destructf10''.refine(sq_ccGc(concat_1p_)^oE_).refine(sq_Gccc(concat_1p_)).Defined.Definitionequiv_sq_move_31{f10'':x00=x} {f10':x=x20}:PathSquaref10'f12(f10''^ @f01)f21<~>PathSquare(f10''@f10')f12f01f21.Proof.clearf10.destructf10''.refine(sq_Gccc(concat_1p_)^oE_).refine(sq_ccGc(concat_1p_)).Defined.EndMovePaths.Notationsq_move_23:=equiv_sq_move_23.Notationsq_move_14:=equiv_sq_move_14.Notationsq_move_24:=equiv_sq_move_24.Notationsq_move_42:=equiv_sq_move_42.Notationsq_move_13:=equiv_sq_move_13.Notationsq_move_31:=equiv_sq_move_31.(* Depdent path product definition of PathSquare *)Definitionequiv_sq_dp_prod{A:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}:DPath(funxy=>fstxy=sndxy) (path_prod'p0xp1x)px0px1<~>PathSquarepx0px1p0xp1x.Proof.refine(_oE(dp_paths_FlFr___)^-1).refine(_oE(equiv_concat_l(concat_pp_p___)_)^-1).refine(_oEequiv_moveL_Mp___).refine(_oEsq_path).exact(sq_ccGG(ap_fst_path_prod__) (ap_snd_path_prod__)).Defined.Notationsq_dp_prod:=equiv_sq_dp_prod.(* Concatenation of squares *)SectionPathSquareConcat.Context{A:Type} {a00a10a01a11:A}{px0:a00=a10} {px1:a01=a11}{p0x:a00=a01} {p1x:a10=a11}.(* Horizontal concatenation of squares *)Definitionsq_concat_h{a02a12:A}{p0y:a01=a02} {p1y:a11=a12} {px2:a02=a12}:PathSquarepx0px1p0xp1x->PathSquarepx1px2p0yp1y->PathSquarepx0px2(p0x@p0y) (p1x@p1y).Proof.introsab.destructb.refine(sq_ccGG__a).1,2:applyinverse,concat_p1.Defined.Infix"@@h" :=sq_concat_h:square_scope.(* Vertical concatenation of squares *)Definitionsq_concat_v{a20a21:A}{py0:a10=a20} {py1:a11=a21} {p2x:a20=a21}:PathSquarepx0px1p0xp1x->PathSquarepy0py1p1xp2x->PathSquare(px0@py0) (px1@py1)p0xp2x.Proof.introsab.destructb.refine(sq_GGcc__a).1,2:applyinverse,concat_p1.Defined.Infix"@@v" :=sq_concat_v:square_scope.EndPathSquareConcat.(* Horizontal groupoid laws for concatenation *)SectionGroupoidLawsH.(* There are many more laws to write, but it seems we don't really need them *)Context{A:Type}{a00a10a01a11a02a12a20a21a03a13:A} {px0:a00=a10}{px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}{px2:a02=a12} {p0y:a01=a02} {p1y:a11=a12}{px3:a03=a13} {p0z:a02=a03} {p1z:a12=a13}(s:PathSquarepx0px1p0xp1x).Local OpenScopesquare_scope.Notationhr:= (sq_refl_h_).Definitionsq_concat_h_s1:sq_concat_hshr=sq_ccGG(concat_p1_)^ (concat_p1_)^s.Proof.bydestructs.Defined.Definitionsq_concat_h_1s:sq_concat_hhrs=sq_ccGG(concat_1p_)^ (concat_1p_)^s.Proof.bydestructs.Defined.Context(t:PathSquarepx1px2p0yp1y) (u:PathSquarepx2px3p0zp1z).Definitionsq_concat_h_ss_s:sq_concat_h(sq_concat_hst)u=sq_ccGG(concat_p_pp___) (concat_p_pp___) (sq_concat_hs(sq_concat_htu)).Proof.bydestructs,u, (sq_1G^-1t),p0y.Defined.EndGroupoidLawsH.(* PathSquare Kan fillers ~ Every open box has a lid *)SectionKan.(* These can be used to prove groupoid laws about paths *)Context{A:Type} {a00a10a01a11:A}.Definitionsq_fill_l(px1:a01=a11) (p0x:a00=a01) (p1x:a10=a11): {px0:a00=a10&PathSquarepx0px1p0xp1x}.Proof.exists(p0x@px1@p1x^).bydestructpx1,p0x,p1x.Defined.Definitionsq_fill_l_uniq{px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}{px0:a00=a10} (s:PathSquarepx0px1p0xp1x){px0':a00=a10} (s':PathSquarepx0'px1p0xp1x):px0=px0'.Proof.destructs.applysq_path^-1ins'.exact(s'^ @concat_p1_).Defined.Definitionsq_fill_r(px0:a00=a10) (p0x:a00=a01) (p1x:a10=a11): {px1:a01=a11&PathSquarepx0px1p0xp1x}.Proof.exists(p0x^ @px0@p1x).bydestructpx0,p0x,p1x.Defined.Definitionsq_fill_r_uniq{px0:a00=a10} {p0x:a00=a01} {p1x:a10=a11}{px1:a01=a11} (s:PathSquarepx0px1p0xp1x){px1':a01=a11} (s':PathSquarepx0px1'p0xp1x):px1=px1'.Proof.destructs.applysq_path^-1ins'.exact(s'@concat_1p_).Defined.Definitionequiv_sq_fill_lr(p0x:a00=a01) (p1x:a10=a11): (a00=a10) <~> (a01=a11).Proof.srapplyequiv_adjointify.-introspx0;exact(sq_fill_rpx0p0xp1x).1.-introspx1;exact(sq_fill_lpx1p0xp1x).1.-introspx1.exact(sq_fill_r_uniq(sq_fill_r_p0xp1x).2(sq_fill_lpx1p0xp1x).2).-introspx0.exact(sq_fill_l_uniq(sq_fill_l_p0xp1x).2(sq_fill_rpx0p0xp1x).2).Defined.Definitionsq_fill_t(px0:a00=a10) (px1:a01=a11) (p1x:a10=a11): {p0x:a00=a01&PathSquarepx0px1p0xp1x}.Proof.exists(px0@p1x@px1^).bydestructpx0,px1,p1x.Defined.Definitionsq_fill_b(px0:a00=a10) (px1:a01=a11) (p0x:a00=a01): {p1x:a10=a11&PathSquarepx0px1p0xp1x}.Proof.exists(px0^ @p0x@px1).bydestructpx0,px1,p0x.Defined.EndKan.(* Apply a function to the sides of square *)Definitionsq_ap{AB:Type} {a00a10a01a11:A} (f:A->B){px0:a00=a10} {px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11}:PathSquarepx0px1p0xp1x->PathSquare(apfpx0) (apfpx1) (apfp0x) (apfp1x).Proof.byintros[].Defined.This preserves reflexivityDefinitionsq_ap_refl_h{AB} (f:A->B) {a0a1:A} (p:a0=a1):sq_apf(sq_refl_hp) =sq_refl_h(apfp).Proof.bydestructp.Defined.Definitionsq_ap_refl_v{AB} (f:A->B) {a0a1:A} (p:a0=a1):sq_apf(sq_refl_vp) =sq_refl_v(apfp).Proof.bydestructp.Defined.(* PathSquares respect products *)Definitionequiv_sq_prod{AB:Type} {a00a10a01a11:A} {px0:a00=a10}{px1:a01=a11} {p0x:a00=a01} {p1x:a10=a11} {b00b10b01b11:B}{qx0:b00=b10} {qx1:b01=b11} {q0x:b00=b01} {q1x:b10=b11}: (PathSquarepx0px1p0xp1x) * (PathSquareqx0qx1q0xq1x)<~>PathSquare(path_prod'px0qx0) (path_prod'px1qx1)(path_prod'p0xq0x) (path_prod'p1xq1x).Proof.refine(_oE(equiv_functor_prod'sq_pathsq_path)^-1%equiv).refine(_oEequiv_path_prod(_,_) (_,_)).srefine(_oEequiv_ap'___).3:apply(equiv_path_prod(_,_) (_,_)).refine(_oEequiv_concat_l_^_).2:apply(path_prod_pp(_,_) (_,_) (_,_)).refine(_oEequiv_concat_r__).2:apply(path_prod_pp(_,_) (_,_) (_,_)).applysq_path.Defined.Notationsq_prod:=equiv_sq_prod.(* The natural square from an ap *)Definitionap_nat{AB} {ff':A->B} (h:f==f') {xy:A} (p:x=y):PathSquare(apfp) (apf'p) (hx) (hy).Proof.bydestructp;applysq_1G.Defined.(* The transpose of the natural square *)Definitionap_nat'{AB} {ff':A->B} (h:f==f') {xy:A} (p:x=y):PathSquare(hx) (hy) (apfp) (apf'p).Proof.bydestructp;applysq_G1.Defined.(* ap_compose fits naturally into a square *)Definitionap_compose_sq{ABC} (f:A->B) (g:B->C) {xy:A} (p:x=y):PathSquare(ap(gof)p) (apg(apfp)) 1 1 :=sq_G1(ap_composefgp).Definitionap_idmap_sq{A} {xy:A} (p:x=y) :PathSquare(apidmapp)p1 1:=sq_G1(ap_idmapp).(* A DPath of a certain form can be turned into a square *)Definitionequiv_sq_dp{AB:Type} {fg:A->B} {a1a2:A} {p:a1=a2}{q1:fa1=ga1} {q2:fa2=ga2}:DPath(funx=>fx=gx)pq1q2<~>PathSquareq1q2(apfp) (apgp).Proof.destructp.exactsq_G1.Defined.Notationsq_dp:=equiv_sq_dp.(* ap011 fits into a square *)Definitionsq_ap011{ABC} (f:A->B->C){aa':A} (p:a=a') {bb':B} (q:b=b'):PathSquare(ap(funx=>fxb)p) (ap(funx=>fxb')p)(ap(fa)q) (ap(fa')q).Proof.applysq_dp.exact(apD(funy=>ap(funx=>fxy)p)q).Defined.

--- Miscellaneous\peano_naturals.html ---
peano_naturalsLibrary peano_naturalsRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.naturalsHoTT.Classes.interfaces.ordersHoTT.Classes.theory.ringsHoTT.Classes.orders.semiringsHoTT.Classes.theory.apartness.Local OpenScopenat_scope.Local OpenScopemc_scope.LocalSetUniverseMinimizationToSet.(* This should go away one Coq has universe cumulativity through inductives. *)Sectionnat_lift.UniverseN.(* It's important that the universeNbe free.  Occasionally, Coq will choose universe variables in proofs that forceNto beSet.  To pinpoint where this happens, you can add the lineConstraintSet<N.here, and see what fails below. *)Letnatpaths:= @paths@{N}nat.Infix"=N=" :=natpaths.Definitionnatpaths_symm:Symmetric@{NN}natpaths.Proof.unfoldnatpaths;apply_.Defined.Global Instancenat_0:Zero@{N}nat:= 0%nat.Global Instancenat_1:One@{N}nat:= 1%nat.Global Instancenat_plus:Plus@{N}nat:=Nat.Core.nat_add.Notationmul:=Nat.Core.nat_mul.Global Instancenat_mult:Mult@{N}nat:=Nat.Core.nat_mul.Ltacsimpl_nat:=change(@plusnat_)withNat.Core.nat_add;change(@multnat_)withNat.Core.nat_mul;simpl;changeNat.Core.nat_addwith(@plusnatNat.Core.nat_add);changeNat.Core.nat_mulwith(@multnatNat.Core.nat_mul).0+a=N=aLocal Instanceadd_0_l:LeftIdentity@{NN} (plus:Plusnat) 0 :=fun_=>idpath.Definitionadd_S_lab:Sa+b=N=S(a+b) :=idpath.a+0=N=aLocal Instanceadd_0_r:RightIdentity@{NN} (plus:Plusnat) (zero:Zeronat).Proof.introsa;inductionaas[|aIHa].-reflexivity.-apply(apS),IHa.Qed.Lemmaadd_S_r:forallab,a+Sb=N=S(a+b).Proof.introsab;inductionaas[|aIHa].-reflexivity.-apply(apS),IHa.Qed.forallabc:nat,a+(b+c)=(a+b)+c.  The RHS is writtena+b+c.Local Instanceadd_assoc:Associative@{N} (plus:Plusnat).Proof.introsabc;inductionaas[|aIHa].-reflexivity.-change(S(a+ (b+c)) =S(a+b+c)).apply(apS),IHa.Qed.Local Instanceadd_comm:Commutative@{NN} (plus:Plusnat).Proof.introsab;inductionaas[|aIHa].-rhsapplyadd_0_r.reflexivity.-rhsapplyadd_S_r.apply(apS),IHa.Qed.Local Instancemul_0_l:LeftAbsorb@{NN} (mult:Multnat) (zero:Zeronat):=fun_=>idpath.Definitionmul_S_lab: (Sa) *b=N=b+a*b:=idpath.1*a=N=a.Local Instancemul_1_l:LeftIdentity@{NN} (mult:Multnat) (one:Onenat):=add_0_r.Local Instancemul_0_r:RightAbsorb@{NN} (mult:Multnat) (zero:Zeronat).Proof.introsa;inductionaas[|aIHa].-reflexivity.-change(a* 0 = 0).exactIHa.Qed.Lemmamul_S_rab:a*Sb=N=a+a*b.Proof.inductionaas[|aIHa].-reflexivity.-change(S(b+a*Sb) =S(a+ (b+a*b))).apply(apS).rhsrapplyadd_assoc.rhsrapply(ap(funx=>x+_) (add_comm__)).rhsrapply(add_assoc___)^.exact(ap(plusb)IHa).Qed.a*1=N=a.Local Instancemul_1_r:RightIdentity@{NN} (mult:Multnat) (one:Onenat).Proof.introsa.lhsnrapplymul_S_r.lhsnrapply(ap_(mul_0_ra)).applyadd_0_r.Qed.Local Instancemul_comm:Commutative@{NN} (mult:Multnat).Proof.introsab;inductionaas[|aIHa].-rhsapplymul_0_r.reflexivity.-rhsapplymul_S_r.change(b+a*b=b+b*a).apply(ap(funx=>b+x)),IHa.Qed.a*(b+c)=N=a*b+a*c.Local Instanceadd_mul_distr_l:LeftDistribute@{N} (mult:Multnat) (plus:Plusnat).Proof.introsabc;inductionaas[|aIHa].-reflexivity.-change((b+c) +a* (b+c) = (b+a*b) + (c+a*c)).lhsrapply(add_assoc___)^.rhsrapply(add_assoc___)^.apply(ap(plusb)).rhsrapplyadd_assoc.rhsrapply(ap(funx=>x+_) (add_comm__)).rhsrapply(add_assoc___)^.apply(ap(plusc)),IHa.Qed.(a+b)*c=N=a*c+b*c.  This also follows fromplus_mult_distr_r, which currently requires that we already have a semiring.  It should be adjusted to not require associativity.Local Instanceadd_mul_distr_r:RightDistribute@{N} (mult:Multnat) (plus:Plusnat).Proof.introsabc.lhsapplymul_comm.lhsapplyadd_mul_distr_l.applyap011;applymul_comm.Defined.Local Instancemul_assoc:Associative@{N} (mult:Multnat).Proof.introsabc;inductionaas[|aIHa].-reflexivity.-simpl_nat.rhsapplyadd_mul_distr_r.applyap,IHa.Qed.Global InstanceS_neq_0x:PropHolds(~ (Sx=N= 0)).Proof.introsE.change((funa=>matchawithS_=>Unit| 0%nat=>Emptyend) 0).eapplytransport.-exactE.-split.Qed.Definitionpredx:=matchxwith| 0%nat=> 0 |Sk=>kend.Global InstanceS_inj:IsInjective@{NN}S:= {injective:=funabE=>appredE}.This is also in Spaces.Nat.Core.Global Instancenat_dec:DecidablePaths@{N}nat.Proof.hnf.apply(nat_rect@{N} (funx=>forally,_)).-intros[|b].+left;reflexivity.+right;applysymmetric_neq,S_neq_0.-introsaIHa[|b].+right;applyS_neq_0.+destruct(IHab).*left.applyap;trivial.*right;introsE.apply(injectiveS)inE.auto.Defined.Global Instancenat_set:IsTrunc@{N} 0nat.Proof.applyhset_pathcoll,pathcoll_decpaths,nat_dec.Qed.Instancenat_semiring:IsSemiCRing@{N}nat.Proof.repeat(split;tryexact_).Qed.(* Add Ring nat: (rings.stdlib_semiring_theory nat). *)(* Close Scope nat_scope. *)LemmaO_nat_0:O=N= 0.Proof.reflexivity.Qed.LemmaS_nat_plus_1x:Sx=N=x+ 1.Proof.rewriteadd_comm.reflexivity.Qed.LemmaS_nat_1_plusx:Sx=N= 1 +x.Proof.reflexivity.Qed.Lemmanat_induction(P:nat->Type) :P0 -> (foralln,Pn->P(1 +n)) ->foralln,Pn.Proof.applynat_rect.Qed.Lemmaplus_eq_zero:forallab:nat,a+b=N= 0 ->a=N= 0 /\b=N= 0.Proof.intros[|a];[intros[|b];auto|].-introsE.destruct(S_neq_0_E).-intros?E.destruct(S_neq_0_E).Qed.Lemmamult_eq_zero:forallab:nat,a*b=N= 0 ->a=N= 0 |_|b=N= 0.Proof.intros[|a] [|b];auto.-intros_;right;reflexivity.-simpl_nat.introsE.destruct(S_neq_0_E).Defined.Instancenat_zero_divisors:NoZeroDivisorsnat.Proof.introsx[Ex[y[Ey1Ey2]]].applymult_eq_zeroinEy2.destructEy2;auto.Qed.Instancenat_plus_cancel_l:forallz:nat,LeftCancellation@{N}plusz.Proof.red.introsa;inductionaas[|aIHa];simpl_nat;introsbcE.-trivial.-applyIHa.apply(injectiveS).assumption.Qed.Instancenat_mult_cancel_l:forallz:nat,PropHolds(~ (z=N= 0)) ->LeftCancellation@{N} (.*.)z.Proof.unfoldPropHolds.unfoldLeftCancellation.introsaEabcE;revertbcaEaE.inductionbas[|bIHb];intros[|c];simpl_nat;introsaEaE.-reflexivity.-rewritemul_0_rinE.rewritemul_S_rinE;applysymmetryinE.applyplus_eq_zeroinE.destruct(Ea(fstE)).-rewritemul_0_r,mul_S_rinE.applyplus_eq_zeroinE.destruct(Ea(fstE)).-rewrite2!mul_S_rinE.apply(left_cancellation__)inE.applyap.applyIHbwitha;trivial.Qed.(* Order *)Global Instancenat_le:Le@{NN}nat:=Nat.Core.leq.Global Instancenat_lt:Lt@{NN}nat:=Nat.Core.lt.Lemmale_plus:forallnk,n<=k+n.Proof.inductionk.-applyNat.Core.leq_refl.-simpl_nat.constructor.assumption.Qed.Lemmale_exists:forallnm:nat,iff@{NNN} (n<=m) (sig@{NN} (funk=>m=N=k+n)).Proof.introsnm;split.-introsE;inductionEas[|mEIH].+exists0;split.+destructIHas[kIH].exists(Sk).rewriteIH;reflexivity.-intros[kHk].rewriteHk.applyle_plus.Qed.Lemmazero_least:foralla, 0 <=a.Proof.inductiona;constructor;auto.Qed.Lemmale_S_S:forallab:nat,iff@{NNN} (a<=b) (Sa<=Sb).Proof.intros.etransitivity;[applyle_exists|].etransitivity;[|applysymmetry,le_exists].split;intros[kE];existsk.-rewriteE,add_S_r.reflexivity.-rewriteadd_S_rinE;apply(injective_)inE.trivial.Qed.Lemmalt_0_S:foralla:nat, 0 <Sa.Proof.intros.applyle_S_S.applyzero_least.Qed.Lemmale_S_either:forallab,a<=Sb->a<=b|_|a=Sb.Proof.intros[|a]b.-intros;left;applyzero_least.-introsE.apply(snd(le_S_S__))inE.destructEas[|bE];auto.left.applyle_S_S.trivial.Defined.Lemmale_lt_dec:forallab:nat,a<=b|_|b<a.Proof.inductionaas[|aIHa].-intros;left;applyzero_least.-intros[|b].+right.applylt_0_S.+destruct(IHab).*left.applyle_S_S;trivial.*right.applyle_S_S.trivial.Defined.Lemmanot_lt_0:foralla, ~ (a< 0).Proof.introsaE.applyle_existsinE.destructEas[kE].applynatpaths_symm,plus_eq_zeroinE.apply(S_neq_0_(sndE)).Qed.Lemmalt_le:forallab,a<b->a<=b.Proof.intros.destructb.-destruct(not_lt_0a).trivial.-constructor.applyle_S_S.trivial.Qed.Local Instancenat_le_total:TotalRelation@{NN} (_:Lenat).Proof.hnf.introsab.destruct(le_lt_decab);[left|right].-trivial.-applylt_le;trivial.Qed.Local Instancenat_lt_irrefl:Irreflexive@{NN} (_:Ltnat).Proof.hnf.introsxE.applyle_existsinE.destructEas[kE].apply(S_neq_0k).apply(left_cancellation@{N} (+)x).foldnatpaths.rewriteadd_0_r,add_S_r,<-add_S_l.rewriteadd_comm.applynatpaths_symm,E.Qed.Local Instancenat_le_hprop:is_mere_relationnatle.Proof.introsmn;applyTrunc.hprop_allpath.generalize(idpath(Sn) :Sn=N=Sn).generalizenat2 3 4 5.change(foralln0:nat,Sn=N=Sn0->forallle_mn1le_mn2:m<=n0,le_mn1=le_mn2).induction(Sn)as[|n0IHn0].-intros?E;destruct(S_neq_0_(natpaths_symm__E)).-clearn;introsnH.apply(injectiveS)inH.rewrite<-H;introsle_mn1le_mn2;clearnH.pose(def_n2:=idpathn0);path_via(paths_indn0(funn_=>lem_)le_mn2n0def_n2).generalizedef_n2;revertle_mn1le_mn2.generalizen0at1 4 5 8;introsn1le_mn1.destructle_mn1;introsle_mn2;destructle_mn2.+introsdef_n0.rewrite(Trunc.path_ishpropdef_n0idpath).simpl.reflexivity.+introsdef_n0;generalizele_mn2;rewrite<-def_n0;introsle_mn0.destruct(irreflexivitynat_lt_le_mn0).+introsdef_n0.destruct(irreflexivitynat_ltm0).rewritedef_n0inle_mn1;trivial.+introsdef_n0.poseproof(injectiveS__def_n0)asE.destructE.rewrite(Trunc.path_ishpropdef_n0idpath).simpl.applyap.applyIHn0;trivial.Qed.Local Instancenat_le_po:PartialOrdernat_le.Proof.repeatsplit.-apply_.-apply_.-hnf;intros;constructor.-hnf.introsabcE1E2.applyle_existsinE1;applyle_existsinE2.destructE1as[k1E1],E2as[k2E2].rewriteE2,E1,add_assoc.applyle_plus.-hnf.introsabE1E2.applyle_existsinE1;applyle_existsinE2.destructE1as[k1E1],E2as[k2E2].assert(k1+k2= 0)asE.+apply(left_cancellation(+)a).rewriteplus_0_r.path_via(k2+b).rewriteE1.rewrite(plus_comma), (plus_assock2), (plus_commk2).reflexivity.+applyplus_eq_zeroinE.destructEas[Ek1Ek2].rewriteEk2,plus_0_linE2.trivial.Qed.Local Instancenat_strict:StrictOrder(_:Ltnat).Proof.split.-cbv;exact_.-apply_.-hnf.introsabcE1E2.applyle_exists;applyle_existsinE1;applyle_existsinE2.destructE1as[k1E1],E2as[k2E2].exists(S(k1+k2)).rewriteE2,E1.rewrite!add_S_r,add_S_l.rewrite(add_assock2), (add_commk2).reflexivity.Qed.Instancenat_trichotomy:Trichotomy@{NNi} (lt:Ltnat).Proof.hnf.foldnatpaths.introsab.destruct(le_lt_decab)as[[|]|E];auto.-right;left;split.-left.applyle_S_S.trivial.Qed.Global Instancenat_apart:Apart@{NN}nat:=funnm=>n<m|_|m<n.Instancenat_apart_mere:is_mere_relationnatnat_apart.Proof.intros;applyishprop_sum;tryapply_.introsE1E2.apply(irreflexivitynat_ltx).transitivityy;trivial.Qed.Instancedecidable_nat_apartxy:Decidable(nat_apartxy).Proof.rapplydecidable_sum@{NNN};applyNat.Core.decidable_lt.Defined.Global Instancenat_trivial_apart:TrivialApartnat.Proof.split.-apply_.-introsab;split;introsE.+destructEas[E|E];applyirrefl_neqinE;trivial.applysymmetric_neq;trivial.+hnf.destruct(trichotomy_ab)as[?|[?|?]];auto.destructE;trivial.Qed.Lemmanat_not_lt_le:forallab, ~ (a<b) ->b<=a.Proof.intros??E.destruct(le_lt_decba);auto.destructE;auto.Qed.Lemmanat_lt_not_le:forallab:nat,a<b-> ~ (b<=a).Proof.introsabE1E2.applyle_existsinE1;applyle_existsinE2.destructE1as[k1E1],E2as[k2E2].apply(S_neq_0(k1+k2)).apply(left_cancellation(+)a).foldnatpaths.rewriteadd_0_r.rewriteE1inE2.rewriteadd_S_r;rewrite!add_S_rinE2.rewrite(add_assoca), (add_comma), <-(add_assock1), (add_comma).rewrite(add_assock1), (add_commk1), <-(add_assock2).applynatpaths_symm,E2.Qed.Global Instancenat_le_dec:forallxy:nat,Decidable(x≤y).Proof.introsab.destruct(le_lt_decab).-left;trivial.-right.applynat_lt_not_le.trivial.Defined.LemmaS_gt_0:foralla, 0 <Sa.Proof.intros;applyle_S_S,zero_least.Qed.Lemmanonzero_gt_0:foralla, ~ (a=N= 0) -> 0 <a.Proof.intros[|a]E.-destructE;split.-applyS_gt_0.Qed.Lemmanat_le_lt_trans:forallabc:nat,a<=b->b<c->a<c.Proof.introsabcE1E2.applyle_existsinE1;applyle_existsinE2.destructE1as[k1E1],E2as[k2E2];rewriteE2,E1.rewriteadd_S_r,add_assoc.applyle_S_S,le_plus.Qed.Lemmalt_strong_cotrans:forallab:nat,a<b->forallc,a<c|_|c<b.Proof.introsabE1c.destruct(le_lt_decca)as[E2|E2].-right.applynat_le_lt_transwitha;trivial.-left;trivial.Defined.Lemmanat_full':FullPseudoSemiRingOrdernat_lenat_lt.Proof.split;[apply_|split|].-split;tryapply_.+introsab[E1E2].destruct(irreflexivitylta).transitivityb;trivial.+hnf.introsabEc;applytr;applylt_strong_cotrans;trivial.+reflexivity.-introsabE.applynat_not_lt_le,le_existsinE.destructEas[kE];existsk;rewriteplus_comm;auto.-split.+introsabE.applyle_existsinE;destructEas[kHk].rewriteHk.rewriteadd_S_r,<-add_S_l.rewriteplus_assoc,(plus_commz(Sk)), <-plus_assoc.applyle_S_S,le_plus.+introsabE.applyle_existsinE;destructEas[kE].rewrite<-add_S_r,plus_assoc,(plus_commkz),<-plus_associnE.apply(left_cancellationplus_)inE.rewriteE;applyle_plus.-intros????E.applytrivial_apartinE.destruct(dec(apartx₁x₂))as[?|ex];applytr;auto.right.applytight_apartinex.applytrivial_apart.introsey.applyE.applyap011;trivial.-unfoldPropHolds.introsabEaEb.applynonzero_gt_0.introsE.applymult_eq_zeroinE.destructEas[E|E];[rewriteEinEa|rewriteEinEb];apply(irreflexivitylt0);trivial.-introsab;split.+introsE1E2.applynat_lt_not_leinE2.auto.+introsE.destruct(le_lt_decab);auto.destructE;auto.Qed.(* Coq pre 8.8 produces phantom universes, see GitHub Coq/Coq1033. *)Definitionnat_full@{} :=ltac:(first[exactnat_full'@{UlargeUlarge}|exactnat_full'@{UlargeUlargeN}|exactnat_full'@{}]).Local Existing Instancenat_full.Lemmale_nat_max_lnm:n<=Nat.Core.nat_maxnm.Proof.revertm.inductionnas[|n'IHn];introsm;inductionmas[|m'IHm];tryreflexivity;cbn.-applyzero_least.-applyle_S_S.exact(IHnm').Qed.Lemmale_nat_max_rnm:m<=Nat.Core.nat_maxnm.Proof.revertm.inductionnas[|n'IHn];introsm;inductionmas[|m'IHm];tryreflexivity;cbn.-applyzero_least.-applyle_S_S.exact(IHnm').Qed.InstanceS_embedding:OrderEmbeddingS.Proof.split.-intros??;applyle_S_S.-intros??;applyle_S_S.Qed.Global InstanceS_strict_embedding:StrictOrderEmbeddingS.Proof.split;apply_.Qed.Global Instancenat_naturals_to_semiring:NaturalsToSemiRing@{Ni}nat:=fun______=>fixf(n:nat) :=matchnwith0%nat=> 0 | 1%nat=> 1 |Sn'=> 1 +fn'end.Sectionfor_another_semiring.UniverseU.Context{R:Type@{U} } `{IsSemiCRing@{U}R}.NotationtoR:= (naturals_to_semiringnatR).(*   Add Ring R: (rings.stdlib_semiring_theory R). *)Local Definitionf_S:forallx,toR(Sx) = 1 +toRx.Proof.intros[|x].-symmetry;applyplus_0_r.-reflexivity.Defined.Local Definitionf_preserves_plusaa':toR(a+a') =toRa+toRa'.Proof.inductionaas[|aIHa].-change(toRa'= 0 +toRa').applysymmetry,plus_0_l.-change(toR(S(a+a')) =toR(Sa) +toRa').rewrite!f_S,IHa.applyassociativity.Qed.Local Definitionf_preserves_multaa':toR(a*a') =toRa*toRa'.Proof.inductionaas[|aIHa].-change(0 = 0 *toRa').rewritemult_0_l.reflexivity.-rewritef_S.change(toR(a'+a*a') = (1 +toRa) *toRa').rewritef_preserves_plus,IHa.rewriteplus_mult_distr_r,mult_1_l.reflexivity.Qed.Global Instancenat_to_sr_morphism:IsSemiRingPreserving(naturals_to_semiringnatR).Proof.split;split.-rapplyf_preserves_plus.-reflexivity.-rapplyf_preserves_mult.-reflexivity.Defined.LemmatoR_unique(h:nat->R) `{!IsSemiRingPreservingh}x:naturals_to_semiringnatRx=hx.Proof.inductionxas[|nE].+change(0 =h0).applysymmetry,preserves_0.+rewritef_S.change(1 +naturals_to_semiringnatRn=h(1+n)).rewrite(preserves_plus(f:=h)).rewriteE.applyap10,ap,symmetry,preserves_1.Qed.Endfor_another_semiring.Lemmanat_naturals:Naturals@{NNNNNNNi}nat.Proof.split;tryapply_.intros;applytoR_unique,_.Qed.Global Existing Instancenat_naturals.Global Instancenat_cut_minus:CutMinus@{N}nat:=Nat.Core.nat_sub.Lemmaplus_minus:forallab,cut_minus(a+b)b=N=a.Proof.unfoldcut_minus,nat_cut_minus.introsab;reverta;inductionbas[|bIH].-intros[|a];simpl;trysplit.applyap,add_0_r.-intros[|a].+simpl.poseproof(IH0)asE.rewriteadd_0_linE.exactE.+simpl.changenat_pluswithplus.rewriteadd_S_r,<-add_S_l;applyIH.Qed.Lemmale_plus_minus:forallnm:nat,n<=m->m=N= (n+ (cut_minusmn)).Proof.introsnmE.applyle_existsinE.destructEas[kE];rewriteE.rewriteplus_minus.applyadd_comm.Qed.Lemmaminus_ge:forallab,a<=b->cut_minusab=N= 0.Proof.unfoldcut_minus,nat_cut_minus.introsab;reverta;inductionbas[|bIH];intros[|a];simpl.-split.-introsE;destruct(not_lt_0_E).-split.-introsE.applyIH;applyle_S_S,E.Qed.Global Instancenat_cut_minus_spec:CutMinusSpec@{NN}natnat_cut_minus.Proof.split.-introsxyE.rewriteadd_comm.symmetry.apply(le_plus_minus__E).-applyminus_ge.Qed.Endnat_lift.

--- Miscellaneous\pEquiv.html ---
pEquivLibrary pEquivRequireImportBasics.RequireImportTypes.RequireImportWildCat.RequireImportPointed.Core.Local OpenScopepointed_scope.(* Pointed equivalence is a reflexive relation. *)Global Instancepequiv_reflexive:ReflexivepEquiv.Proof.intro;applypequiv_pmap_idmap.Defined.(* We can probably get rid of the following notation, and use ^-1*)Notation"f ^-1*" := (@cate_invpType____hasequivs_ptype__f) :pointed_scope.(* Pointed equivalence is a symmetric relation. *)Global Instancepequiv_symmetric:SymmetricpEquiv.Proof.intros? ?;applypequiv_inverse.Defined.(* Pointed equivalences compose. *)Definitionpequiv_compose{ABC:pType} (f:A<~>*B) (g:B<~>*C):A<~>*C:=g$oEf.(* Pointed equivalence is a transitive relation. *)Global Instancepequiv_transitive:TransitivepEquiv.Proof.intros? ? ?;applypequiv_compose.Defined.Notation"g o*E f" := (pequiv_composefg) :pointed_scope.(* Sometimes we wish to construct a pEquiv from an equiv and a proof that it is pointed. *)DefinitionBuild_pEquiv'{AB:pType} (f:A<~>B)(p:f(pointA) =pointB):A<~>*B:=Build_pEquiv__(Build_pMap__fp)_.ArgumentsBuild_pEquiv'&____.(* A version of equiv_adjointify for pointed equivalences where all data is pointed. There is a lot of unnecessary data here but sometimes it is easier to prove equivalences using this. *)Definitionpequiv_adjointify{AB:pType} (f:A->*B) (f':B->*A)(r:fo*f'==*pmap_idmap) (s:f'o*f==pmap_idmap) :A<~>*B:= (Build_pEquiv__f(isequiv_adjointifyff'rs)).(* In some situations you want the back and forth maps to be pointed but not the sections. *)Definitionpequiv_adjointify'{AB:pType} (f:A->*B) (f':B->*A)(r:fof'==idmap) (s:f'of==idmap) :A<~>*B:= (Build_pEquiv__f(isequiv_adjointifyff'rs)).Pointed versions ofmoveR_equiv_Mand friends.DefinitionmoveR_pequiv_Mf{ABC} (f:B<~>*C) (g:A->*B) (h:A->*C)(p:g==*f^-1*o*h): (fo*g==*h).Proof.refine(pmap_postwhiskerfp@*_).refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhiskerh(peisretrf) @*_).applypmap_postcompose_idmap.Defined.DefinitionmoveL_pequiv_Mf{ABC} (f:B<~>*C) (g:A->*B) (h:A->*C)(p:f^-1*o*h==*g): (h==*fo*g).Proof.refine(_@*pmap_postwhiskerfp).refine(_@* (pmap_compose_assoc___)).refine((pmap_postcompose_idmap_)^* @*_).applypmap_prewhisker.symmetry;applypeisretr.Defined.DefinitionmoveL_pequiv_Vf{ABC} (f:B<~>*C) (g:A->*B) (h:A->*C)(p:fo*g==*h):g==*f^-1*o*h.Proof.refine(_@*pmap_postwhiskerf^-1*p).refine(_@* (pmap_compose_assoc___)).refine((pmap_postcompose_idmap_)^* @*_).applypmap_prewhisker.symmetry;applypeissect.Defined.DefinitionmoveR_pequiv_Vf{ABC} (f:B<~>*C) (g:A->*B) (h:A->*C)(p:h==*fo*g):f^-1*o*h==*g.Proof.refine(pmap_postwhiskerf^-1*p@*_).refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhiskerg(peissectf) @*_).applypmap_postcompose_idmap.Defined.DefinitionmoveR_pequiv_fV{ABC} (f:B->*C) (g:A<~>*B) (h:A->*C)(p:fo*g==*h): (f==*ho*g^-1*).Proof.refine(_@*pmap_prewhiskerg^-1*p).refine(_@* (pmap_compose_assoc___)^*).refine((pmap_precompose_idmap_)^* @*_).applypmap_postwhisker.symmetry;applypeisretr.Defined.Definitionpequiv_pequiv_precompose`{Funext} {ABC:pType} (f:A<~>*B): (B->**C) <~>* (A->**C).Proof.srapplyBuild_pEquiv'.-exact(equiv_precompose_cat_equivf).-(* By usingpelimf, we can avoidFunextin this part of the proof. *)cbn;unfold"o*",point_pforall;cbn.bypelimf.Defined.Definitionpequiv_pequiv_postcompose`{Funext} {ABC:pType} (f:B<~>*C): (A->**B) <~>* (A->**C).Proof.srapplyBuild_pEquiv'.-exact(equiv_postcompose_cat_equivf).-cbn;unfold"o*",point_pforall;cbn.bypelimf.Defined.Propositionequiv_pequiv_inverse`{Funext} {AB:pType}: (A<~>*B) <~> (B<~>*A).Proof.refine(issig_pequiv'__oE_oE(issig_pequiv'AB)^-1).srapply(equiv_functor_sigma'(equiv_equiv_inverse__));introe;cbn.exact(equiv_moveR_equiv_V__oEequiv_path_inverse__).Defined.

--- Miscellaneous\pFiber.html ---
pFiberLibrary pFiberRequireImportBasicsTypesWildCat.RequireImportHFiber.RequireImportPointed.Core.RequireImportPointed.pEquiv.RequireImportPointed.Loops.Local OpenScopepointed_scope.Pointed fibersGlobal Instanceispointed_fiber{AB:pType} (f:A->*B) :IsPointed(hfiberf(pointB)):= (pointA;point_eqf).Definitionpfiber{AB:pType} (f:A->*B) :pType:= [hfiberf(pointB),_].Definitionpfib{AB:pType} (f:A->*B) :pfiberf->*A:=Build_pMap(pfiberf)Apr11.The double fiber object is equivalent to loops on the base.Definitionpfiber2_loops{AB:pType} (f:A->*B):pfiber(pfibf) <~>*loopsB.Proof.pointed_reduce_pmapf.snrapplyBuild_pEquiv'.1:make_equiv_contr_basedpaths.reflexivity.Defined.Definitionpfiber_fmap_loops{AB:pType} (f:A->*B):pfiber(fmaploopsf) <~>*loops(pfiberf).Proof.srapplyBuild_pEquiv'.{etransitivity.2:srapplyequiv_path_sigma.simpl;unfoldhfiber.srapplyequiv_functor_sigma_id.introp;cbn.refine(_oEequiv_moveL_Mp___).refine(_oEequiv_concat_r(concat_p1_)_).refine(_oEequiv_moveL_Vp___).refine(_oEequiv_path_inverse__).applyequiv_concat_l.applytransport_paths_Fl. }bypointed_reduce.Defined.Definitionpr1_pfiber_fmap_loops{AB} (f:A->*B):fmaploops(pfibf)o*pfiber_fmap_loopsf==*pfib(fmaploopsf).Proof.srapplyBuild_pHomotopy.-intros[uv].refine(concat_1p_@concat_p1_@_).exact(@ap_pr1_path_sigma__(pointA;point_eqf) (pointA;point_eqf)__).-abstract(pointed_reduce_rewrite;reflexivity).Defined.Definitionpfiber_fmap_iterated_loops{AB:pType} (n:nat) (f:A->*B):pfiber(fmap(iterated_loopsn)f) <~>*iterated_loopsn(pfiberf).Proof.inductionn.1:reflexivity.refine(_o*Epfiber_fmap_loops_).rapply(emaploops).exactIHn.Defined.Definitionfunctor_pfiber{ABCD}{f:A->*B} {g:C->*D} {h:A->*C} {k:B->*D}(p:ko*f==*go*h):pfiberf->*pfiberg.Proof.srapplyBuild_pMap.+cbn.refine(functor_hfiber2p(point_eqk)).+srapplypath_hfiber.-applypoint_eq.-refine(concat_pp_p___@_).applymoveR_Vp.apply(point_htpyp)^.Defined.Definitionpequiv_pfiber{ABCD}{f:A->*B} {g:C->*D} (h:A<~>*C) (k:B<~>*D)(p:ko*f==*go*h):pfiberf$<~>pfiberg:=Build_pEquiv__(functor_pfiberp)_.Definitionsquare_functor_pfiber{ABCD}{f:A->*B} {g:C->*D} {h:A->*C} {k:B->*D}(p:ko*f==*go*h):ho*pfibf==*pfibgo*functor_pfiberp.Proof.srapplyBuild_pHomotopy.-introsx;reflexivity.-applymoveL_pV.cbn;unfoldfunctor_sigma;cbn.abstract(rewriteap_pr1_path_sigma,concat_p1;reflexivity).Defined.Definitionsquare_pequiv_pfiber{ABCD}{f:A->*B} {g:C->*D} (h:A<~>*C) (k:B<~>*D)(p:ko*f==*go*h):ho*pfibf==*pfibgo*pequiv_pfiberhkp:=square_functor_pfiberp.The triple-fiber functor is equal to the negative of the loopspace functor.Definitionpfiber2_fmap_loops{AB:pType} (f:A->*B):pfiber2_loopsfo*pfib(pfib(pfibf))==*fmaploopsfo* (loops_inv_o*pfiber2_loops(pfibf)).Proof.pointed_reduce.simplerefine(Build_pHomotopy__).-intros[[[xp]q]r].simplin*.Apparentlydestructqisn't smart enough to generalize overp.moveqbeforex;revertdependentx;refine(paths_ind_r___);introspr;cbn.rewrite!concat_1p,concat_p1.rewritepaths_ind_r_transport.rewritetransport_arrow_toconst,transport_paths_Fl.rewriteconcat_p1,inv_V,ap_V.refine(((r^)..2)^ @_).rewritetransport_paths_Fl;cbn.rewritepr1_path_V, !ap_V, !inv_V.applyconcat_p1.-reflexivity.Qed.

--- Miscellaneous\Pi.html ---
PiLibrary PiDependent Product CategoryRequireImportCategory.Strict.RequireImportBasics.Trunc.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Local OpenScopemorphism_scope.Definition of∀, or∏, for categoriesSectionpi.Context`{Funext}.VariableA:Type.VariableP:A->PreCategory.Definitionpi:PreCategory.refine(@Build_PreCategory(foralla:A,Pa)(funsd=>foralla:A,morphism(Pa) (sa) (da))(funx=>funa=>identity(xa))(funsdd'm2m1=>funa=>m2aom1a)____);abstract(repeat(intro||applypath_forall);autowithmorphism).Defined.Endpi.Local Notation"'forall'  x .. y , P" := (forallx, .. (forally,P) ..) :type_scope.Local Notation"'forall'  x .. y , P" := (pi(funx=> .. (pi(funy=>P)) .. )) :category_scope.The product of strict categories is strictGlobal Instanceisstrict_category_pi`{Funext}`{foralla:A,IsStrictCategory(Pa)}:IsStrictCategory(foralla,Pa).Proof.typeclasseseauto.Qed.LocalSetWarningsAppend"-notation-overridden".ModuleExportCategoryPiNotations.Notation"'forall'  x .. y , P" := (forallx, .. (forally,P) ..)%type:type_scope.Notation"'forall'  x .. y , P" := (pi(funx=> .. (pi(funy=>P)) .. )) :category_scope.EndCategoryPiNotations.

--- Miscellaneous\PinSn.html ---
PinSnLibrary PinSnRequireImportBasicsTypes.RequireImportWildCat.RequireImportPointed.RequireImportTruncations.CoreTruncations.Connectedness.RequireImportSpaces.IntSpaces.CircleSpaces.Spheres.RequireImportAlgebra.AbGroups.RequireImportHomotopy.HomotopyGroup.RequireImportHomotopy.HSpaceS1.RequireImportHomotopy.Hopf.We show that the nth homotopy group of the n-sphere is the integers, for n >= 1.Local OpenScopewc_iso_scope.Local OpenScopepointed_scope.The fundamental group of the 1-sphere / circle.SectionPi1S1.Context`{Univalence}.Local OpenScopepointed_scope.Theorempi1_circle:Pi1 [Circle,base] ≅abgroup_Z.Proof.We give the isomorphism backwards, so we check the operation is preserved coming from the integer side.symmetry.srapplyBuild_GroupIsomorphism'.{equiv_via(base=base).2:exact(equiv_tr0 (loops[Circle,base])).symmetry.exactequiv_loopCircle_int. }introsab.cbn;applyap.applyloopexp_add.Defined.Theorempi1_s1:Pi1 (psphere1) ≅abgroup_Z.Proof.etransitivity.2:applypi1_circle.applygroupiso_pi_functor.applypequiv_S1_Circle.Defined.EndPi1S1.The second homotopy group of the 2-sphere is the integers.SectionPi2S2.Definitionptr_loops_s2_s1`{Univalence}:pTr1 (loops(psphere2)) <~>*psphere1:= (licata_finster(psphere1))^-1*.Definitionpi2_s2`{Univalence}:Pi2 (psphere2) $<~>abgroup_Z.Proof.refine(pi1_s1$oE_).change(Pi2 ?X)with(Pi1 (loopsX)).refine(compose_cate(b:=Pi1 (pTr1 (loops(psphere2))))__).1:exact(emap(Pi1)ptr_loops_s2_s1).applygrp_iso_pi_Tr.Defined.EndPi2S2.For n >= 1, the nth homotopy group of the n-sphere is the integers.SectionPinSn.Definitionpin_sn`{Univalence} (n:nat):Pin.+1 (pspheren.+1) $<~>abgroup_Z.Proof.destructn.1:exactpi1_s1.inductionnas[|nIHn].1:exactpi2_s2.refine(_$oEgroupiso_pi_loopsn.+1 (pspheren.+3)).refine(IHn$oE_).symmetry.snrapply(grp_iso_pi_connmap_(loop_susp_unit(pspheren.+2))).(* The (n+2)-sphere is (n+1)-connected, soloop_susp_unitisn+2+n-connected.  Sincen.+2<=n+2+n, we're done, after sometrunc_indexjuggling. *)apply(isconnmap_pred_addn.-2).rewrite2trunc_index_add_succ.change(IsConnMap(Tr(n+2+n)) (loop_susp_unit(pspheren.+2))).exact_.(*conn_map_loop_susp_unit*)Defined.EndPinSn.

--- Miscellaneous\pMap.html ---
pMapLibrary pMapRequireImportBasicsTypes.RequireImportPointed.Core.Local OpenScopepointed_scope.Trivially pointed mapsNot infrequently we have a map between two unpointed types and want to consider it as a pointed map that trivially respects some given point in the domain.Definitionpmap_from_point{AB:Type} (f:A->B) (a:A): [A,a] ->* [B,fa]:=Build_pMap[A,a] [B,fa]f1%path.A variant ofpmap_from_pointwhere the domain is pointed, but the codomain is not.Definitionpmap_from_pointed{A:pType} {B:Type} (f:A->B):A->* [B,f(pointA)]:=Build_pMapA[B,f(pointA)]f1%path.The same, for a dependent pointed map.Definitionpforall_from_pointed{A:pType} {B:A->Type} (f:forallx,Bx):pForallA(Build_pFamB(f(pointA))):=Build_pForallA(Build_pFamB(f(pointA)))f1%path.(* precomposing the zero map is the zero map *)Lemmaprecompose_pconst{ABC:pType} (f:B->*C):fo* @pconstAB==*pconst.Proof.srapplyBuild_pHomotopy.1:intro;applypoint_eq.exact(concat_p1_@concat_1p_)^.Defined.(* postcomposing the zero map is the zero map *)Lemmapostcompose_pconst{ABC:pType} (f:A->*B):pconsto*f==* @pconstAC.Proof.srapplyBuild_pHomotopy.1:reflexivity.exact(concat_p1_@concat_p1_@ap_const__)^.Defined.Lemmapconst_factor{AB:pType} {f:pUnit->*B} {g:A->*pUnit}:fo*g==*pconst.Proof.refine(_@*precompose_pconstf).applypmap_postwhisker.symmetry.applypmap_punit_pconst.Defined.(* We note that the inverse ofpath_pmapcomputes definitionally on reflexivity, and hencepath_pmapitself computes typally so.  *)Definitionequiv_inverse_path_pmap_1`{Funext} {AB} {f:A->*B}: (equiv_path_pforallff)^-1%equiv1%path=reflexivityf:= 1.If we have a fiberwise pointed map, with a variable as codomain, this is an
  induction principle that allows us to assume it respects all basepoints by
  reflexivityDefinitionfiberwise_pointed_map_rec`{H0:Funext} {A:Type} {B:A->pType}(P:forall(C:A->pType) (g:foralla,Ba->*Ca),Type)(H:forall(C:A->Type) (g:foralla,Ba->Ca),P_(funa=>pmap_from_pointed(ga))):forall(C:A->pType) (g:foralla,Ba->*Ca),PCg.Proof.equiv_intros(equiv_functor_arrow'(equiv_idmapA)issig_ptypeoEequiv_sig_coind__)C.destructCas[Cc0].equiv_intros(@equiv_functor_forall_id_A__(funa=>issig_pmap(Ba) [Ca,c0a])oEequiv_sig_coind__)g.simplin*.destructgas[gg0].unfoldpointing0.unfoldfunctor_forall,sig_coind_uncurried.simpl.(* now we need to apply path induction on the homotopy g0 *)pose(path_forall_c0g0).assert(p=path_forall(funx:A=>gx(ispointed_type(Bx)))c0g0).1:reflexivity.inductionp.applymoveR_equiv_VinX.inductionX.applyH.Defined.A alternative constructor to build a pHomotopy between maps into pForallDefinitionBuild_pHomotopy_pForall`{Funext} {AB:pType} {C:B->pType}{fg:A->*ppforallb,Cb} (p:foralla,fa==*ga)(q:p(pointA) ==*phomotopy_path(point_eqf) @* (phomotopy_path(point_eqg))^*):f==*g.Proof.snrapplyBuild_pHomotopy.1:introa;exact(path_pforall(pa)).hnf;rapplymoveR_equiv_M'.refine(_^ @ap10__).2:exactpath_equiv_path_pforall_phomotopy_path.applypath_pforall.refine(phomotopy_path_pp__@*_@*q^*).applyphomotopy_prewhisker.applyphomotopy_path_V.Defined.Operations on dependent pointed maps(* functorial action ofpForallABinB*)Definitionfunctor_pforall_right{A:pType} {BB':pFamA}(f:foralla,Ba->B'a)(p:f(pointA) (dpointB) =dpointB') (g:pForallAB):pForallAB':=Build_pForallAB'(funa=>fa(ga)) (ap(f(pointA)) (dpoint_eqg) @p).Definitionequiv_functor_pforall_id`{Funext} {A:pType} {BB':pFamA}(f:foralla,Ba<~>B'a) (p:f(pointA) (dpointB) =dpointB'):pForallAB<~>pForallAB'.Proof.refine(issig_pforall__oE_oE(issig_pforall__)^-1).srapplyequiv_functor_sigma'.1:exact(equiv_functor_forall_idf).intros;cbn.refine(equiv_concat_rp_oE_).apply(equiv_ap'(f(pointA))).Defined.Definitionfunctor2_pforall_right{A:pType} {BC:pFamA}{gg':forall(a:A),Ba->Ca}{g₀:g(pointA) (dpointB) =dpointC}{g₀':g'(pointA) (dpointB) =dpointC} {ff':pForallAB}(p:foralla,ga==g'a) (q:f==*f')(r:p(pointA) (dpointB) @g₀'=g₀):functor_pforall_rightgg₀f==*functor_pforall_rightg'g₀'f'.Proof.srapplyBuild_pHomotopy.1: {introa.refine(pa(fa) @ap(g'a) (qa)). }pointed_reduce_rewrite.symmetry.applyconcat_Ap.Defined.Definitionfunctor2_pforall_right_refl{A:pType} {BC:pFamA}(g:foralla,Ba->Ca) (g₀:g(pointA) (dpointB) =dpointC)(f:pForallAB):functor2_pforall_right(funa=>reflexivity(ga)) (phomotopy_reflexivef)(concat_1p_)==*phomotopy_reflexive(functor_pforall_rightgg₀f).Proof.pointed_reduce.reflexivity.Defined.(* functorial action ofpForallA(pointed_famB)inB. *)Definitionpmap_compose_ppforall{A:pType} {BB':A->pType}(g:foralla,Ba->*B'a) (f:ppforalla,Ba) :ppforalla,B'a.Proof.simplerefine(functor_pforall_right__f).+exactg.+exact(point_eq(g(pointA))).Defined.Definitionpmap_compose_ppforall_point{A:pType} {BB':A->pType}(g:foralla,Ba->*B'a):pmap_compose_ppforallg(point_pforallB) ==*point_pforallB'.Proof.srapplyBuild_pHomotopy.+introx.exact(point_eq(gx)).+exact(concat_p1_@concat_1p_)^.Defined.Definitionpmap_compose_ppforall_compose{A:pType} {PQR:A->pType}(h:forall(a:A),Qa->*Ra) (g:forall(a:A),Pa->*Qa)(f:ppforalla,Pa):pmap_compose_ppforall(funa=>hao*ga)f==*pmap_compose_ppforallh(pmap_compose_ppforallgf).Proof.srapplyBuild_pHomotopy.+reflexivity.+simpl.refine((whiskerL_(inverse2_)) @concat_pV_)^.refine(whiskerR__@concat_pp_p___).refine(ap_pp___@whiskerR(ap_compose___)^_).Defined.Definitionpmap_compose_ppforall2{A:pType} {PQ:A->pType} {gg':forall(a:A),Pa->*Qa}{ff':ppforall(a:A),Pa} (p:foralla,ga==*g'a) (q:f==*f'):pmap_compose_ppforallgf==*pmap_compose_ppforallg'f'.Proof.srapplyfunctor2_pforall_right.+exactp.+exactq.+exact(point_htpy(p(pointA))).Defined.Definitionpmap_compose_ppforall2_left{A:pType} {PQ:A->pType} {gg':forall(a:A),Pa->*Qa}(f:ppforall(a:A),Pa) (p:foralla,ga==*g'a):pmap_compose_ppforallgf==*pmap_compose_ppforallg'f:=pmap_compose_ppforall2p(phomotopy_reflexivef).Definitionpmap_compose_ppforall2_right{A:pType} {PQ:A->pType} (g:forall(a:A),Pa->*Qa){ff':ppforall(a:A),Pa} (q:f==*f'):pmap_compose_ppforallgf==*pmap_compose_ppforallgf':=pmap_compose_ppforall2(funa=>phomotopy_reflexive(ga))q.Definitionpmap_compose_ppforall2_refl`{Funext} {A:pType} {PQ:A->pType}(g:forall(a:A),Pa->*Qa) (f:ppforall(a:A),Pa):pmap_compose_ppforall2(funa=>phomotopy_reflexive(ga)) (phomotopy_reflexivef)==*phomotopy_reflexive_.Proof.unfoldpmap_compose_ppforall2.revertQg.refine(fiberwise_pointed_map_rec__).introsQg.srapplyfunctor2_pforall_right_refl.Defined.Definitionpmap_compose_ppforall_pid_left{A:pType} {P:A->pType}(f:ppforall(a:A),Pa) :pmap_compose_ppforall(funa=>pmap_idmap)f==*f.Proof.srapplyBuild_pHomotopy.+reflexivity.+symmetry.refine(whiskerR(concat_p1_@ap_idmap_)_@concat_pV_).Defined.Definitionpmap_compose_ppforall_path_pforall`{Funext} {A:pType} {PQ:A->pType}(g:foralla,Pa->*Qa) {ff':ppforalla,Pa} (p:f==*f') :ap(pmap_compose_ppforallg) (path_pforallp) =path_pforall(pmap_compose_ppforall2_rightgp).Proof.revertf'p.refine(phomotopy_ind__).refine(ap_path_pforall_1@path_pforall_1^ @ap__^).exact(path_pforall(pmap_compose_ppforall2_refl__)).Defined.

--- Miscellaneous\pModality.html ---
pModalityLibrary pModalityRequireImportBasicsTypesReflectiveSubuniversePointed.Core.Local OpenScopepointed_scope.Modalities, reflective subuniverses and pointed typesSo far, everything is about general reflective subuniverses, but in the future results about modalities can be placed here as well.Global Instanceispointed_O`{O:ReflectiveSubuniverse} (X:Type)`{IsPointedX} :IsPointed(OX) :=toO_(pointX).Definitionpto(O:ReflectiveSubuniverse@{u}) (X:pType@{u}):X->* [OX,_]:=Build_pMapX[OX,_] (toOX)idpath.IfAis alreadyO-local, then Coq knows thatptois an equivalence, so we can simply define:Definitionpequiv_pto`{O:ReflectiveSubuniverse} {X:pType} `{InOX}:X<~>* [OX,_] :=Build_pEquiv__(ptoOX)_.ApplyingO_recto a pointed map yields a pointed map.DefinitionpO_rec`{O:ReflectiveSubuniverse} {XY:pType}`{InOY} (f:X->*Y) : [OX,_] ->*Y:=Build_pMap[OX,_]_(O_recf) (O_rec_beta__@point_eqf).DefinitionpO_rec_beta`{O:ReflectiveSubuniverse} {XY:pType}`{InOY} (f:X->*Y):pO_recfo*ptoOX==*f.Proof.srapplyBuild_pHomotopy.1:nrapplyO_rec_beta.cbn.applymoveL_pV.exact(concat_1p_)^.Defined.A pointed version of the universal property.Definitionpequiv_o_pto_O`{Funext}(O:ReflectiveSubuniverse) (PQ:pType) `{InOQ}: ([OP,_] ->**Q) <~>* (P->**Q).Proof.snrapplyBuild_pEquiv.(* We could just use the mapedefined in the next bullet, but we want Coq to immediately unfold the underlying map to this. *)-exact(Build_pMap__(funf=>fo*ptoOP) 1).(* We'll give an equivalence that definitionally has the same underlying map. *)-transparentassert(e: (([OP,_] ->*Q) <~> (P->*Q))).+refine(issig_pmapPQoE_oE(issig_pmap[OP,_]Q)^-1%equiv).snrapplyequiv_functor_sigma'.*rapplyequiv_o_to_O.*introf;cbn.(*reflexivityworks here, but then the underlying map won't agree definitionally with precomposition byptoP, since pointed composition inserts a reflexivity path here. *)apply(equiv_concat_l1).+apply(equiv_isequive).Defined.Pointed functorialityDefinitionO_pfunctor`(O:ReflectiveSubuniverse) {XY:pType}(f:X->*Y) : [OX,_] ->* [OY,_]:=pO_rec(ptoOYo*f).Coq knows thatO_pfunctorOfis an equivalence wheneverfis.Definitionequiv_O_pfunctor`(O:ReflectiveSubuniverse) {XY:pType}(f:X->*Y) `{IsEquiv__f} : [OX,_] <~>* [OY,_]:=Build_pEquiv__(O_pfunctorOf)_.Pointed naturality ofO_pfunctor.Definitionpto_O_natural`(O:ReflectiveSubuniverse) {XY:pType}(f:X->*Y) :O_pfunctorOfo*ptoOX==*ptoOYo*f.Proof.nrapplypO_rec_beta.Defined.Definitionpequiv_O_inverts`(O:ReflectiveSubuniverse) {XY:pType}(f:X->*Y) `{O_invertsOf}: [OX,_] <~>* [OY,_]:=Build_pEquiv__(O_pfunctorOf)_.

--- Miscellaneous\Pointed.html ---
PointedLibrary PointedRequireExportPointed.Core.RequireExportPointed.Loops.RequireExportPointed.pMap.RequireExportPointed.pFiber.RequireExportPointed.pEquiv.RequireExportPointed.pTrunc.RequireExportPointed.pModality.RequireExportPointed.pSusp.RequireExportPointed.pSect.

--- Miscellaneous\PointedCat.html ---
PointedCatLibrary PointedCatRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.CoreWildCat.Opposite.RequireImportWildCat.Equiv.A wild category is pointed if the initial and terminal object are the same.ClassIsPointedCat(A:Type) `{Is1CatA} := {zero_object:A;isinitial_zero_object:IsInitialzero_object;isterminal_zero_object:IsTerminalzero_object;}.Global Existing Instanceisinitial_zero_object.Global Existing Instanceisterminal_zero_object.The zero morphism between objectsaandbof a pointed categoryAis the unique morphism that factors throguh the zero object.Definitionzero_morphism{A:Type} `{IsPointedCatA} {ab:A} :a$->b:= (mor_initial_b) $o(mor_terminala_).SectionZeroLaws.Context{A:Type} `{IsPointedCatA} {abc:A}(f:a$->b) (g:b$->c).Definitioncat_zero_source(h:zero_object$->a) :h$==zero_morphism:= (mor_initial_unique___)^$ $@ (mor_initial_unique___).Definitioncat_zero_target(h:a$->zero_object) :h$==zero_morphism:= (mor_terminal_unique___)^$ $@ (mor_terminal_unique___).We show the last two arguments so that end pointes can easily be specified.Argumentszero_morphism{______}__.Definitioncat_zero_l:zero_morphismbc$of$==zero_morphismac.Proof.refine(cat_assoc___$@ (_$@L_^$)).applymor_terminal_unique.Defined.Definitioncat_zero_r:g$ozero_morphismab$==zero_morphismac.Proof.refine((_$@R_) $@cat_assoc___)^$.applymor_initial_unique.Defined.Any morphism which factors through an object equivalent to the zero object is homotopic to the zero morphism.Definitioncat_zero_m`{!HasEquivsA} (be:b$<~>zero_object):g$of$==zero_morphismac.Proof.refine(_$@L(compose_V_hhbef)^$ $@_).refine(cat_assoc_opp___$@_).refine(_$@L(mor_terminal_uniquea__)^$ $@_).exact((mor_initial_unique___)^$ $@R_).Defined.EndZeroLaws.We make the last two arguments explicit so that end points can easily be specified. We had to do this again, since the section encapsulated the previous attempt.Local Argumentszero_morphism{______}__.A functor is pointed if it preserves the zero object.ClassIsPointedFunctor{AB:Type} (F:A->B) `{Is1FunctorABF} :={preservesinitial_pfunctor:PreservesInitialF;preservesterminal_pfunctor:PreservesTerminalF;}.Global Existing Instancespreservesinitial_pfunctorpreservesterminal_pfunctor.Here is an alternative constructor using preservation of the zero object. This requires more structure on the categories however.DefinitionBuild_IsPointedFunctor'{AB:Type} (F:A->B)`{Is1CatA,Is1CatB, !Is0FunctorF, !Is1FunctorF}`{!IsPointedCatA, !IsPointedCatB, !HasEquivsA, !HasEquivsB}(p:Fzero_object$<~>zero_object):IsPointedFunctorF.Proof.applyBuild_IsPointedFunctor.+introsxinx.rapplyisinitial_cate.symmetry.refine(p$oE_).rapply(emapF_).rapplycate_isinitial.+introsxtex.rapplyisterminal_cate.refine(p$oE_).rapply(emapF_).rapplycate_isterminal.Defined.Pointed functors preserve the zero object upto isomorphism.Lemmapfunctor_zero{AB:Type} (F:A->B)`{IsPointedCatA,IsPointedCatB, !HasEquivsB,!Is0FunctorF, !Is1FunctorF, !IsPointedFunctorF}:Fzero_object$<~>zero_object.Proof.rapplycate_isinitial.Defined.Pointed functors preserve the zero morphism upto homotopyLemmafmap_zero_morphism{AB:Type} (F:A->B)`{IsPointedCatA,IsPointedCatB, !HasEquivsB,!Is0FunctorF, !Is1FunctorF, !IsPointedFunctorF} {ab:A}:fmapF(zero_morphismab) $==zero_morphism(Fa) (Fb).Proof.refine(fmap_compF__$@_).refine(_$@R_$@_).1:nrapplyfmap_initial; [exact_].refine(_$@L_$@_).1:nrapplyfmap_terminal; [exact_].rapplycat_zero_m.rapplypfunctor_zero.Defined.Opposite category of a pointed category is also pointed.Global Instanceispointedcat_op{A:Type} `{IsPointedCatA} :IsPointedCatA^op.Proof.snrapplyBuild_IsPointedCat.1:unfoldop;exactzero_object.1,2:exact_.Defined.

--- Miscellaneous\Pointwise.html ---
PointwiseLibrary PointwiseRequireImportBasicsTypesPointedHSpace.CoreHSpace.Coherent.Local OpenScopepointed_scope.Local OpenScopemc_mult_scope.Pointwise H-space structuresWheneverXis an H-space, so is the type of maps intoX.Global Instanceishspace_map`{Funext} (X:pType) (Y:Type)`{IsHSpaceX} :IsHSpace[Y->X,constpt].(* Note: When writingf*g, Coq only finds this instance iffis explicitly in the pointed type[Y->X,constpt]. *)Proof.snrapplyBuild_IsHSpace.-exact(funfgy=> (fy) * (gy)).-introg;funexty.applyhspace_left_identity.-introf;funexty.applyhspace_right_identity.Defined.IfXis coherent, so is[Y->X,constpt].Global Instanceiscoherent_ishspace_map`{Funext} (X:pType) (Y:Type)`{IsCoherentX} :IsCoherent[Y->X,constpt].Proof.hnf;cbn.refine(ap__).funexty;applyiscoherent.Defined.IfXis left-invertible, so is[Y->X,constpt].Global Instanceisleftinvertible_hspace_map`{Funext} (X:pType) (Y:Type)`{IsHSpaceX} `{forallx,IsEquiv(x*.)}:forallf: [Y->X,constpt],IsEquiv(f*.).Proof.introf;cbn.Left multiplication byfunifies withfunctor_forall.exact(isequiv_functor_forall(P:=constX) (f:=idmap)(g:=funygy=> (fy) *gy)).Defined.For the type of pointed mapsY->**X, coherence ofXis needed even to get a noncoherent H-space structure onY->**X.Global Instanceishspace_pmap`{Funext} (XY:pType) `{IsCoherentX}:IsHSpace(Y->**X).Proof.snrapplyBuild_IsHSpace.-introsfg.snrapplyBuild_pMap.+exact(funy=>hspace_op(fy) (gy)).+cbn.refine(ap_(point_eqg) @_);cbn.refine(ap(.*pt) (point_eqf) @_).applyhspace_left_identity.-introg.applypath_pforall.snrapplyBuild_pHomotopy.+introy;cbn.applyhspace_left_identity.+cbn.applymoveL_pV.exact(1 @@concat_1p_@concat_A1p__)^.-introf.applypath_pforall.snrapplyBuild_pHomotopy.+introy;cbn.applyhspace_right_identity.+pelimf;cbn.symmetry.lhsnrapply(concat_p1_@concat_1p_@concat_1p_).applyiscoherent.Defined.Global Instanceiscoherent_hspace_pmap`{Funext} (XY:pType) `{IsCoherentX}:IsCoherent(Y->**X).Proof.(* Note thatptsometimes means the constant mapY->*X. *)unfoldIsCoherent.(* Both identities are created usingpath_pforall. *)refine(appath_pforall_).applypath_pforall.snrapplyBuild_pHomotopy.-introy;cbn.applyiscoherent.-cbn.generalizeiscoherentasisc.unfoldleft_identity,right_identity.(* The next line is essentially the same asgeneralize, but for some reason that tactic doesn't work here. *)set(p:=hspace_left_identitypt);clearbodyp.intros[].inductionp.reflexivity.Defined.If the H-space structure onXis left-invertible, so is the one induced onY->**X.Global Instanceisleftinvertible_hspace_pmap`{Funext} (XY:pType)`{IsCoherentX} `{forallx,IsEquiv(x*.)}:forallf:Y->**X,IsEquiv(f*.).Proof.introf.srefine(isequiv_homotopic(equiv_functor_pforall_id__)_).-exact(funa=>equiv_hspace_left_op(fa)).-cbn.exact(right_identity_@point_eqf).-introg.applypath_pforall;snrapplyBuild_pHomotopy.+introy;cbn.reflexivity.+cbn.apply(moveR_1M__)^-1.applywhiskerL.refine(whiskerL_iscoherent@_).exact(concat_A1pright_identity(point_eqf)).Defined.

--- Miscellaneous\Pos.html ---
PosLibrary PosRequireExportHoTT.Spaces.Pos.Core.RequireExportHoTT.Spaces.Pos.Spec.

--- Miscellaneous\Powers.html ---
PowersLibrary PowersFromHoTTRequireImportBasicsTypesTruncType.FromHoTTRequireImportUniverses.Smallness.FromHoTTRequireImportSpaces.CardSpaces.Nat.Core.Definition of Power types(* The definition is only used in Hartogs.v to allow defining a coercion, and one place below.  Everywhere else we prefer to write out the definition for clarity. *)Definitionpower_type(A:Type) :Type:=A->HProp.Iterated powersLemmaInjection_power{PR:PropResizing}X:IsHSetX->InjectionX(X->HProp).Proof.introsHX.set(f(x:X) :=funy=>Build_HProp(smalltype(x=y))).existsf.introsxx'H.eapplyequiv_smalltype.change(fxx').rewriteH.cbn.applyequiv_smalltype.reflexivity.Qed.Definitionpower_iteratedXn:=nat_iternpower_typeX.Definitionpower_iterated_shiftXn:power_iterated(X->HProp)n= (power_iteratedXn->HProp):= (nat_iter_succ_r___)^.Global Instancehset_power{UA:Univalence} (X:HSet):IsHSet(X->HProp).Proof.applyistrunc_S.introspq.applyhprop_allpath.introsHH'.destruct(equiv_path_arrowpq)as[f[gHfgHgf_]].rewrite<- (HfgH), <- (HfgH').applyap.applypath_forall.introsx.applypath_ishprop.Qed.Global Instancehset_power_iterated{UA:Univalence} (X:HSet)n:IsHSet(power_iteratedXn).Proof.nrapply(nat_iter_invariantnpower_type(funA=>IsHSetA)).-introsYHS.rapplyhset_power.-exact_.Defined.LemmaInjection_power_iterated{UA:Univalence} {PR:PropResizing} (X:HSet)n:InjectionX(power_iteratedXn).Proof.inductionnas[|nIHn].-reflexivity.-eapplyInjection_trans;tryapplyIHn.applyInjection_power.exact_.Qed.Lemmainfinite_injectXY:infiniteX->InjectionXY->infiniteY.Proof.applyInjection_trans.Qed.Lemmainfinite_power_iterated{UA:Univalence} {PR:PropResizing} (X:HSet)n:infiniteX->infinite(power_iteratedXn).Proof.introsH.eapplyinfinite_inject;tryapplyH.applyInjection_power_iterated.Qed.

--- Miscellaneous\premetric.html ---
premetricLibrary premetricRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.rationalsHoTT.Classes.interfaces.ordersHoTT.Classes.implementations.peano_naturalsHoTT.Classes.implementations.natpair_integersHoTT.Classes.theory.groupsHoTT.Classes.theory.integersHoTT.Classes.theory.dec_fieldsHoTT.Classes.orders.dec_fieldsHoTT.Classes.orders.sumHoTT.Classes.theory.rationalsHoTT.Classes.orders.latticesHoTT.Classes.implementations.assume_rationalsHoTT.Classes.tactics.ring_quoteHoTT.Classes.tactics.ring_tac.ImportNatPair.Instances.ImportQuoting.Instances.Generalizable VariablesAB.LocalSetUniverseMinimizationToSet.ClassCloseness@{i} (A:Type@{i}) :=close:Q+ ->Relation@{ii}A.Global InstanceQ_close@{} :ClosenessQ:=funeqr=> - 'e<q-r< 'e.ClassSeparatedA`{ClosenessA}:=separated:forallxy, (foralle,closeexy) ->x=y:>A.ClassTriangularA`{ClosenessA}:=triangular:foralluvwed,closeeuv->closedvw->close(e+d)uw.ClassRounded@{ij} (A:Type@{i}) `{ClosenessA}:=rounded:foralleuv,iff@{ijj} (closeeuv)(merely@{j} (sig@{UQj} (fund=>sig@{UQj} (fund'=>e=d+d'/\closeduv)))).ClassPreMetric@{ij} (A:Type@{i}) {Aclose:ClosenessA} :={premetric_prop:foralle,is_mere_relationA(closee);premetric_refl:foralle,Reflexive(close(A:=A)e);premetric_symm:foralle,Symmetric(close(A:=A)e);premetric_separated:SeparatedA;premetric_triangular:TriangularA;premetric_rounded:Rounded@{ij}A}.#[export]ExistingInstancespremetric_proppremetric_reflpremetric_symmpremetric_separatedpremetric_triangularpremetric_rounded.Global Instancepremetric_hset@{ij} `{Funext}{A:Type@{i} } `{PreMetric@{ij}A} :IsHSetA.Proof.apply(@HSet.ishset_hrel_subpaths@{jij}_(funxy=>foralle,closeexy)).-introsx;reflexivity.-apply_.-applyseparated.Qed.RecordApproximation@{i} (A:Type@{i}) {Aclose:ClosenessA} :={approximate:>Q+ ->A;approx_equiv:forallde,close(d+e) (approximated) (approximatee) }.Lemmaapprox_eq`{Funext} `{ClosenessA} `{forallexy,IsHProp(closeexy)}:forallxy:ApproximationA,approximate_x=approximate_y->x=y.Proof.intros[xEx] [yEy];simpl;introsE.destructE.applyap.applypath_ishprop.Qed.DefinitionIsLimit@{i} {A:Type@{i} } {Aclose:ClosenessA}(x:ApproximationA) (l:A):=foralled:Q+,close(e+d) (xd)l.ClassLim@{i} (A:Type@{i}) {Aclose:ClosenessA} :=lim:ApproximationA->A.ClassCauchyComplete@{i} (A:Type@{i}) {Aclose:ClosenessA} {Alim:LimA}:=cauchy_complete:forallx:ApproximationA,IsLimitx(limx).Sectioncontents.Context{funext:Funext} {univalence:Univalence}.Lemmarounded_plus`{RoundedA} :foralldd'uv,closeduv->close(d+d')uv.Proof.introsdd'uvxi;applyrounded.applytr;existsd,d';auto.Qed.Lemmarounded_le'`{RoundedA}:foralleuv,closeeuv->foralld, 'e<= 'd->closeduv.Proof.introseuvxidE.applyle_equiv_ltinE.destructEas[E|E].-applypos_eqinE.rewrite<-E;trivial.-poseproof(pos_eq_(_+_) (Qpos_diff_pr__E))asE'.rewriteE'.applyrounded_plus.trivial.Qed.(* Coq pre 8.8 produces phantom universes, see coq/coq6483 **)Definitionrounded_le@{ij} :=ltac:(first[exact@rounded_le'@{jiUlarge}|exact@rounded_le'@{jiUlargej}|exact@rounded_le'@{ij}]).Argumentsrounded_le{A__}euv_d_.Sectionclose_prod.UniverseUAUBi.Context(A:Type@{UA}) (B:Type@{UB}) `{ClosenessA} `{ClosenessB}`{foralle,is_mere_relationA(closee)}`{foralle,is_mere_relationB(closee)}.Global Instanceclose_prod@{} :Closeness@{i} (A/\B):=funexy=>closee(fstx) (fsty) /\closee(sndx) (sndy).Global Instanceclose_prod_refl@{}`{foralle,Reflexive(close(A:=A)e)}`{foralle,Reflexive(close(A:=B)e)}:foralle,Reflexive(close(A:=A/\B)e).Proof.introse;split;reflexivity.Qed.Global Instanceclose_prod_symm@{}`{foralle,Symmetric(close(A:=A)e)}`{foralle,Symmetric(close(A:=B)e)}:foralle,Symmetric(close(A:=A/\B)e).Proof.introseuvxi;split;symmetry;applyxi.Qed.Global Instanceclose_prod_separated@{}`{!SeparatedA}`{!SeparatedB}:Separated(A/\B).Proof.introsxyE.applyProd.path_prod;applyseparated;intros;applyE.Qed.Global Instanceclose_prod_triangular@{}`{!TriangularA}`{!TriangularB}:Triangular(A/\B).Proof.introsuvwedE1E2;split;(eapplytriangular;[applyE1|applyE2]).Qed.Lemmaclose_prod_rounded'`{!RoundedA}`{!RoundedB}:Rounded(A/\B).Proof.introseuv.split.-intros[E0E0'];applyroundedinE0;applyroundedinE0'.revertE0;apply(Trunc_ind_);intros[d1[d1'[E1E2]]].revertE0';apply(Trunc_ind_);intros[d2[d2'[E3E4]]].applytr;exists(joind1d2), (meetd1'd2');split.+rewriteE1.applyQpos_sum_eq_join_meet.rewrite<-E1;trivial.+split.*applyrounded_lewithd1;trivial.applyjoin_ub_l.*applyrounded_lewithd2;trivial.applyjoin_ub_r.-apply(Trunc_ind_);intros[d[d'[E1E2]]].rewriteE1;split;applyrounded_plus,E2.Qed.(* Coq pre 8.8 produces phantom universes, see coq/coq6483 **)Definitionclose_prod_rounded@{j} :=ltac:(first[exact@close_prod_rounded'@{jjjjj}|exact@close_prod_rounded'@{jj}|exact@close_prod_rounded'@{jjj}]).Argumentsclose_prod_rounded{__}___.Global Existing Instanceclose_prod_rounded.Lemmaprod_premetric@{j} `{!PreMetric@{UAj}A} `{!PreMetric@{UBj}B}:PreMetric@{ij} (A/\B).Proof.split;tryapply_.Qed.Global Existing Instanceprod_premetric.Context{Alim:LimA} {Blim:LimB}.Global Instanceprod_lim@{} :Lim(A/\B).Proof.introsxy.split;applylim;[exists(fune=>fst(xye))|exists(fune=>snd(xye))];intros;applyxy.Defined.Global Instanceprod_cauchy_complete`{!CauchyCompleteA} `{!CauchyCompleteB}:CauchyComplete(A/\B).Proof.introsxyed;split.-apply(cauchy_complete{|approximate:=fune0:Q+ =>fst(xye0);approx_equiv:=_|}).-apply(cauchy_complete{|approximate:=fune0:Q+ =>snd(xye0);approx_equiv:=_|}).Qed.Endclose_prod.Sectionclose_arrow.Context{A:Type} `{Bclose:ClosenessB} `{!PreMetricB}.(* Usingforallx,closee(fx)(gx)works for closed balls, not open ones. *)Global Instanceclose_arrow:Closeness(A->B):=funefg=>merely(existsdd',e=d+d'/\forallx,closed(fx) (gx)).Lemmaclose_arrow_apply:foralle(fg:A->B),closeefg->forallx,closee(fx) (gx).Proof.introsefgEx;revertE;apply(Trunc_ind_);intros[d[d'[E1E2]]].rewriteE1;applyrounded_plus;trivial.Qed.Global Instanceclose_arrow_premetric:PreMetric(A->B).Proof.split.-apply_.-introsef;applytr;exists(e/2), (e/2);split.+applypos_split2.+introsx;reflexivity.-introsefg;apply(Trunc_ind_);intros[d[d'[E1E2]]].applytr;existsd,d';split;trivial.introsx;symmetry;trivial.-introsfgE.applypath_forall;introsx.applyseparated.introse.apply(merely_destruct(Ee)).intros[d[d'[E1E2]]].rewriteE1.applyrounded_plus.trivial.-introsfghedE1E2.apply(merely_destructE1);intros[d1[d1'[E3E4]]].apply(merely_destructE2);intros[d2[d2'[E5E6]]].applytr;exists(d1+d2),(d1'+d2').split.+rewriteE3,E5.abstract(applypos_eq;ring_tac.ring_with_nat).+introsx.applytriangularwith(gx);trivial.-introsefg.split.+apply(Trunc_ind_).intros[d[d'[E1E2]]].applytr;exists(d+d'/2),(d'/2).split.*rewrite<-Qpos_plus_assoc,<-pos_split2.exactE1.*applytr.existsd, (d'/2);split;trivial.+apply(Trunc_ind_);intros[d[d'[E1E2]]].applytr;existsd,d';split;trivial.applyclose_arrow_apply.trivial.Qed.Context{Blim:LimB}.Global Instancearrow_lim:Lim(A->B).Proof.introsfx.applylim.exists(fune=>fex).intros.applyclose_arrow_apply.applyapprox_equiv.Defined.Argumentsarrow_lim_/_.Context`{!CauchyCompleteB}.Global Instancearrow_cauchy_complete:CauchyComplete(A->B).Proof.introsfed.unfoldlim;simpl.applytr.exists(e/2 +d), (e/2).split.+abstract(set(e':=e/2);rewrite(pos_split2e);unfolde';applypos_eq;ring_tac.ring_with_nat).+introsx.set(S:= {|approximate:=fune0:Q+ => (fe0)x;approx_equiv:=_|}).poseproof(cauchy_completeS)asE;redinE.applyE.Qed.Endclose_arrow.ClassNonExpanding`{ClosenessA} `{ClosenessB} (f:A->B):=non_expanding:forallexy,closeexy->closee(fx) (fy).Argumentsnon_expanding{A_B_}f{_exy}_.ClassLipschitz`{ClosenessA} `{ClosenessB} (f:A->B) (L:Q+):=lipschitz:forallexy,closeexy->close(L*e) (fx) (fy).Argumentslipschitz{A_B_}fL{_exy}_.ClassUniform`{ClosenessA} `{ClosenessB} (f:A->B) (mu:Q+ ->Q+):=uniform:forallexy,close(mue)xy->closee(fx) (fy).Argumentsuniform{A_B_}fmu{_}____.ClassContinuous@{UAUB}{A:Type@{UA} } `{ClosenessA}{B:Type@{UB} } `{ClosenessB} (f:A->B):=continuous:forallue,merely@{Ularge} (sig@{UQUlarge}(fund=>forallv,closeduv->closee(fu) (fv))).Argumentscontinuous{A_B_}f{_}__.DefinitionBinaryDup@{i} {A:Type@{i} } :A->A/\A:=funx=> (x,x).Definitionmap2{ABCD} (f:A->C) (g:B->D) :A/\B->C/\D:=funx=> (f(fstx),g(sndx)).Sectioncloseness.UniverseUA.Context{A:Type@{UA} } `{ClosenessA}.Global Instanceid_nonexpanding:NonExpanding(@idA).Proof.hnf;trivial.Qed.Global InstanceBinaryDup_nonexpanding@{} :NonExpanding(@BinaryDupA).Proof.introsexyE;split;exactE.Qed.UniverseUB.Context{B:Type@{UB} } `{ClosenessB} (f:A->B).Lemmanonexpanding_lipschitz'`{!NonExpandingf}:Lipschitzf1.Proof.red.intro;rewriteleft_identity;applynon_expanding,_.Qed.Definitionnonexpanding_lipschitz@{} `{!NonExpandingf}:Lipschitzf1:=ltac:(first[exactnonexpanding_lipschitz'@{Ularge}|exactnonexpanding_lipschitz'@{}]).Global Existing Instancenonexpanding_lipschitz.Lemmalipschitz_nonexpanding@{} `{!Lipschitzf1} :NonExpandingf.Proof.red.introsexyE;rewrite<-(left_identitye).apply(lipschitzf1E).Qed.Global Instanceconst_nonexpanding@{} `{foralle,Reflexive(close(A:=B)e)}(b:B) :NonExpanding(fun_:A=>b).Proof.hnf.intros;reflexivity.Qed.Global Instancelipschitz_const@{} `{foralle,Reflexive(close(A:=B)e)}:forall(b:B) (L:Q+),Lipschitz(fun_:A=>b)L.Proof.intros;hnf.introse___.reflexivity.Qed.Global Instancelipschitz_uniform@{} (L:Q+) `{!LipschitzfL}:Uniformf(fune=>e/L) | 5.Proof.introseuvxi.rewrite<-(pos_unconjugateLe),<-Qpos_mult_assoc.apply(lipschitzfL),xi.Qed.Lemmauniform_continuous@{}mu`{!Uniform@{UAUB}fmu} :Continuousf.Proof.hnf.introsue;applytr;exists(mue).apply(uniformfmu).Qed.Global Existing Instanceuniform_continuous| 5.Definitionlipschitz_continuous@{} (L:Q+) `{!LipschitzfL} :Continuousf:=_.Definitionnonexpanding_continuous@{} `{!NonExpandingf} :Continuousf:=_.Endcloseness.Sectioncompositions.UniverseUA.Context{A:Type@{UA} } `{ClosenessA}.UniverseUB.Context{B:Type@{UB} } `{ClosenessB}.UniverseUC.Context{C:Type@{UC} } `{ClosenessC} (g:B->C) (f:A->B).Global Instancenonexpanding_compose@{}{Eg:NonExpandingg} {Ef:NonExpandingf}:NonExpanding(Composegf).Proof.hnf.introsexyxi;exact(non_expandingg(non_expandingfxi)).Qed.Global Instancelipschitz_compose@{}Lg{Eg:LipschitzgLg}Lf{Ef:LipschitzfLf}:Lipschitz(Composegf) (Lg*Lf).Proof.intros???He.unfoldCompose;applyEf,EginHe.pattern(Lg*Lf*e).eapplytransport;[|exactHe].applyassociativity.Qed.Lemmalipschitz_compose_nonexpanding_r'L{Eg:LipschitzgL} {Ef:NonExpandingf}:Lipschitz(Composegf)L.Proof.rewrite<-(left_identityL),commutativity.apply_.Qed.Global Instancelipschitz_compose_nonexpanding_r@{}L{Eg:LipschitzgL} {Ef:NonExpandingf}:Lipschitz(Composegf)L:=ltac:(first[exact(lipschitz_compose_nonexpanding_r'@{Ularge}L)|exact(lipschitz_compose_nonexpanding_r'@{}L)]).Lemmalipschitz_compose_nonexpanding_l'L{Eg:NonExpandingg} {Ef:LipschitzfL}:Lipschitz(Composegf)L.Proof.rewrite<-(left_identityL).apply_.Qed.Global Instancelipschitz_compose_nonexpanding_l@{}L{Eg:NonExpandingg} {Ef:LipschitzfL}:Lipschitz(Composegf)L:=ltac:(first[exact(lipschitz_compose_nonexpanding_l'@{Ularge}L)|exact(lipschitz_compose_nonexpanding_l'@{}L)]).Lemmauniform_compose@{}mu{Eg:Uniformgmu}mu'{Ef:Uniformfmu'}:Uniform(Composegf) (Composemu'mu).Proof.introseuvxi.unfoldCompose.apply(uniformg_),(uniformf_),xi.Qed.Global Existing Instanceuniform_compose.Global Instancecontinuous_compose@{} {Eg:Continuousg} {Ef:Continuousf}:Continuous(Composegf).Proof.introsue.apply(merely_destruct(continuousg(fu)e)).intros[dE].apply(merely_destruct(continuousfud)).intros[d'E'].applytr;existsd';introsvxi.applyE,E',xi.Qed.Endcompositions.Sectioncurrying.UniverseUA.Context{A:Type@{UA} } `{ClosenessA}.UniverseUB.Context{B:Type@{UB} } `{ClosenessB}.UniverseUC.Context{C:Type@{UC} } `{ClosenessC} `{!TriangularC}.Global Instanceuncurry_lipschitz(f:A->B->C)L1L2`{!forallx,Lipschitz(fx)L1}`{!forally,Lipschitz(funx=>fxy)L2}:Lipschitz(uncurryf) (L1+L2).Proof.introse[u1u2] [v1v2] [xi1xi2].simplinxi1,xi2.simpl.assert(Hrw: (L1+L2) *e=L1*e+L2*e)byabstract(applypos_eq;ring_tac.ring_with_nat);rewriteHrw;clearHrw.apply(triangular_(fu1v2)).-apply(lipschitz_L1).trivial.-apply(lipschitz(funu=>fuv2)L2).trivial.Qed.Lemmauncurry_uniform`{!RoundedA} `{!RoundedB} (f:A->B->C)mumu'`{!forallx,Uniform(fx)mu}`{!forally,Uniform(funx=>fxy)mu'}:Uniform(uncurryf) (fune=>meet(mu(e/2)) (mu'(e/2))).Proof.introse[u1u2] [v1v2] [xi1xi2].simplin*.rewrite(pos_split2e).apply(triangular_(fu1v2)).-apply(uniform(fu1)_).eapplyrounded_le.+exactxi2.+applymeet_lb_l.-apply(uniform(funv=>fvv2)_).eapplyrounded_le.+exactxi1.+applymeet_lb_r.Qed.Endcurrying.Sectionpair.UniverseUA.Context{A:Type@{UA} } `{ClosenessA} `{foralle,Reflexive(close(A:=A)e)}.UniverseUB.Context{B:Type@{UB} } `{ClosenessB} `{foralle,Reflexive(close(A:=B)e)}.Global Instancepair_nonexpanding_l:forallx,NonExpanding(@pairABx).Proof.introsxeuvxi;split;simpl.-reflexivity.-exactxi.Qed.Global Instancepair_nonexpanding_r:forally,NonExpanding(funx=> @pairABxy).Proof.introsxeuvxi;split;simpl.-exactxi.-reflexivity.Qed.Global Instancefst_nonexpanding:NonExpanding(@fstAB).Proof.introseuvxi;applyxi.Qed.Global Instancesnd_nonexpanding:NonExpanding(@sndAB).Proof.introseuvxi;applyxi.Qed.Endpair.Sectionprod_equiv.UniverseUA.Context{A:Type@{UA} } `{ClosenessA}.UniverseUB.Context{B:Type@{UB} } `{ClosenessB}.Global Instanceequiv_prod_symm_nonexpanding:NonExpanding(@Prod.equiv_prod_symmAB).Proof.introseuvxi;split;applyxi.Qed.Global Instanceequiv_prod_symm_inv_nonexpanding:NonExpanding((@Prod.equiv_prod_symmAB)^-1).Proof.introseuvxi;split;applyxi.Qed.UniverseUC.Context{C:Type@{UC} } `{ClosenessC}.Global Instanceequiv_prod_assoc_nonexpanding:NonExpanding(@Prod.equiv_prod_assocABC).Proof.introseuvxi;repeatsplit;applyxi.Qed.Global Instanceequiv_prod_assoc_inc_nonexpanding:NonExpanding((@Prod.equiv_prod_assocABC)^-1).Proof.introseuvxi;repeatsplit;applyxi.Qed.Endprod_equiv.Sectionmap2.UniverseUA.Context{A:Type@{UA} } `{ClosenessA}.UniverseUB.Context{B:Type@{UB} } `{ClosenessB}.UniverseUC.Context{C:Type@{UC} } `{ClosenessC}.UniverseUD.Context{D:Type@{UD} } `{ClosenessD}.Variables(f:A->C) (g:B->D).Lemmamap2_nonexpanding'`{!NonExpandingf} `{!NonExpandingg}:NonExpanding(map2fg).Proof.introseuvxi;split;simpl;apply(non_expanding_),xi.Qed.Definitionmap2_nonexpanding@{i} := @map2_nonexpanding'@{ii}.Argumentsmap2_nonexpanding{__}exyxi.Global Existing Instancemap2_nonexpanding.Lemmamap2_lipschitz'`{!RoundedC} `{!RoundedD}LfLg`{!LipschitzfLf} `{!LipschitzgLg}:Lipschitz(map2fg) (joinLfLg).Proof.introseuvxi.split;simpl.-applyrounded_lewith(Lf*e).+apply(lipschitz__),xi.+apply(order_preserving(.* 'e)).applyjoin_ub_l.-applyrounded_lewith(Lg*e).+apply(lipschitz__),xi.+apply(order_preserving(.* 'e)).applyjoin_ub_r.Qed.(* Coq pre 8.8 produces phantom universes, see coq/coq6483 **)Definitionmap2_lipschitz@{i} :=ltac:(first[exact@map2_lipschitz'@{iii}|exact@map2_lipschitz'@{iiii}]).Argumentsmap2_lipschitz{__}LfLg{__}exyxi.Global Existing Instancemap2_lipschitz.Lemmamap2_continuous'`{!RoundedA} `{!RoundedB}`{!Continuousf} `{!Continuousg}:Continuous(map2fg).Proof.introsue.apply(merely_destruct(continuousf(fstu)e));intros[d1E1].apply(merely_destruct(continuousg(sndu)e));intros[d2E2].applytr;exists(meetd1d2).introsvxi.split;simpl.-applyE1.applyrounded_lewith(meetd1d2).+applyxi.+applymeet_lb_l.-applyE2.applyrounded_lewith(meetd1d2).+applyxi.+applymeet_lb_r.Qed.(* Coq pre 8.8 produces phantom universes, see coq/coq6483 **)Definitionmap2_continuous@{i} :=ltac:(first[exact@map2_continuous'@{iii}|exact@map2_continuous'@{iiii}]).Argumentsmap2_continuous{____}ue.Global Existing Instancemap2_continuous.Endmap2.Sectioninterval.UniverseUAUALE.Context{A:Type@{UA} } {Ale:Le@{UAUALE}A}.DefinitionIntervalab:=sig(funx:A=>a<=x/\x<=b).Definitioninterval_projab:Intervalab->A:=pr1.Context{Ameet:MeetA} {Ajoin:JoinA}`{!LatticeOrder@{UAUALE}Ale}.DefinitionInterval_restrict@{} (ab:A) (E:a<=b) :A->Intervalab.Proof.introsx.exists(joina(meetxb)).split.-applyjoin_ub_l.-applyjoin_le.+exactE.+applymeet_lb_r.Defined.LemmaInterval_restrict_pr:forallabEx(E':a<=x/\x<=b),Interval_restrictabEx=exist_xE'.Proof.introsabExE'.unfoldInterval_restrict.applySigma.path_sigma_hprop.simpl.rewritemeet_l;[applyjoin_r|];applyE'.Qed.Context`{ClosenessA}.Global InstanceInterval_close(ab:A) :Closeness(Intervalab):=funexy=>closee(interval_projabx) (interval_projaby).ArgumentsInterval_close_____/.(* NB: for some reason this forces UALE <= UA *)LemmaInterval_premetric@{i} `{!PreMetric@{UAi}A}ab:PreMetric@{UAi} (Intervalab).Proof.split.-unfoldclose;simpl.apply_.-introseu.red;red.reflexivity.-introseuvxi;red;red;symmetry;applyxi.-introsuvE.applySigma.path_sigma_hprop.applyseparated,E.-introsuvwedxi1xi2.red;red.apply(triangular_(interval_projabv)).+exactxi1.+exactxi2.-introseuv.split.+introsxi.do2redinxi.apply(fst(rounded___))inxi.exactxi.+introsE.unfoldclose,Interval_closeinE.apply(snd(rounded___))inE.exactE.Qed.Global Existing InstanceInterval_premetric.Global Instanceinterval_proj_nonexpanding(ab:A):NonExpanding(interval_projab):=fun___xi=>xi.Endinterval.Sectionrationals.LemmaQclose_alt:foralle(qr:Q),closeeqr<->abs(q-r) < 'e.Proof.introseqr;split.-intros[E1E2].destruct(totalle0 (q-r))as[E|E].+rewrite(Qabs_of_nonneg_E).trivial.+rewrite(Qabs_of_nonpos_E).applyflip_lt_negate.rewriteinvolutive.trivial.-introsE.split;[applyflip_lt_negate;rewriteinvolutive|];applyle_lt_transwith(abs(q-r));trivial.+applyQabs_le_neg_raw.+applyQabs_le_raw.Qed.LemmaQclose_neg@{} :foralle(xy:Q),closeexy<->closee(-x) (-y).Proof.introsexy;split;introsE;applyQclose_altinE;applyQclose_alt.-rewrite<-(negate_plus_distr),Qabs_neg.trivial.-rewrite<-(negate_plus_distr),Qabs_neginE.trivial.Qed.InstanceQ_close_symm@{} :foralle,Symmetric(@closeQ_e).Proof.red;unfoldclose;simpl.introsexy[E1E2];split.-applyflip_lt_negate.rewrite<-negate_swap_r,involutive.trivial.-applyflip_lt_negate.rewritenegate_swap_r,involutive.trivial.Qed.LemmaQ_triangular_one@{} :forall(qr:Q)(e:Q+) (Hqr:closeeqr)(q0:Q) (n:Q+),(closenqq0->close(e+n)rq0).Proof.unfoldclose;simpl.introsqre[E1E1']sn[E2E2'].split.-applyflip_lt_negate.rewritenegate_swap_r,!involutive.applyflip_lt_negateinE2.rewritenegate_swap_r,!involutiveinE2.poseproof(plus_lt_compat____E1'E2)asE.assert(Hrw:s-r=q-r+ (s-q))byabstractring_tac.ring_with_integers(NatPair.Znat).rewriteHrw;trivial.-applyflip_lt_negateinE1.rewritenegate_swap_r,!involutiveinE1.poseproof(plus_lt_compat____E1E2')asE.assert(Hrw:r-s=r-q+ (q-s))byabstractring_tac.ring_with_integers(NatPair.Znat).rewriteHrw;trivial.Qed.InstanceQ_triangular@{} :TriangularQ.Proof.hnf.introsuvwedE1E2.applyQ_triangular_onewithv.-symmetry;trivial.-trivial.Qed.LemmaQclose_separating_not_lt:forallqr:Q, (foralle,closeeqr) ->~ (q<r).Proof.introsqrE1E2.poseproof(E1(Qpos_diff__E2))asE3.applysymmetryinE3;applyQclose_altinE3.unfoldcastinE3;simplinE3.apply(irreflexivitylt(r-q)).applyle_lt_transwith(abs(r-q));trivial.applyQabs_le_raw.Qed.InstanceQclose_separating:SeparatedQ.Proof.hnf.introsqrE1.applytight_apart.introsE2.applyapart_iff_total_ltinE2.destructE2as[E2|E2].-exact(Qclose_separating_not_lt__E1E2).-refine(Qclose_separating_not_lt___E2).intros;symmetry;trivial.Qed.InstanceQclose_rounded@{} :RoundedQ.Proof.introseqr;split.-introsE;applyQclose_altinE.poseproof(Q_average_between__E)as[E1E2].applytr;simplerefine(exist_(mkQpos((abs(q-r) + 'e) / 2)_)_).{applypos_mult_compat;[|solve_propholds].red.applypos_plus_le_lt_compat_r;[solve_propholds|applyQabs_nonneg].}simpl.exists(Qpos_diff__E2).split.+applypos_eq.exact(Qpos_diff_pr__E2).+applyQclose_alt.exactE1.-apply(Trunc_ind_).intros[d[d'[Hexi]]].applyQclose_alt;rewriteHe.applyQclose_altinxi.applylt_le_transwith('d);trivial.applynonneg_plus_le_compat_r.solve_propholds.Qed.Global InstanceQ_premetric@{} :PreMetricQ.Proof.split;tryapply_.introseu;applyQclose_alt.rewriteplus_negate_r.unfoldabs.rewrite(fst(abs_sig0).2).-solve_propholds.-reflexivity.Qed.Global InstanceQneg_nonexpanding@{} :NonExpanding((-) :NegateQ).Proof.introsexy.applyQclose_neg.Defined.Global InstanceQplus_nonexpanding_l@{} :foralls:Q,NonExpanding(+s).Proof.red.unfoldclose,Q_close;simpl.introsseqrE.assert(Hrw:q+s- (r+s) =q-r)byabstractring_tac.ring_with_integers(NatPair.Znat).rewriteHrw;trivial.Qed.Global InstanceQplus_nonexpanding_r@{} :foralls:Q,NonExpanding(s+).Proof.red;unfoldclose,Q_close;simpl.introsseqrE.assert(Hrw:s+q- (s+r) =q-r)byabstractring_tac.ring_with_integers(NatPair.Znat).rewriteHrw;trivial.Qed.Global InstanceQabs_nonexpanding:NonExpanding(abs(A:=Q)).Proof.introseqrxi.applyQclose_altinxi;applyQclose_alt.applyle_lt_transwith(abs(q-r));trivial.applyQabs_triangle_alt.Qed.Global InstanceQmeet_nonexpanding_l:foralls:Q,NonExpanding(⊓s).Proof.introsseqrxi.applyQclose_alt;applyQclose_altinxi.applyle_lt_transwith(abs(q-r));trivial.clearxi.destruct(totalleqs)as[E1|E1], (totallers)as[E2|E2];rewrite?(meet_l__E1), ?(meet_r__E1), ?(meet_l__E2), ?(meet_r__E2).-reflexivity.-rewrite(Qabs_of_nonpos(q-r))by(apply(snd(flip_nonpos_minus__));transitivitys;trivial).rewrite<-negate_swap_r.rewrite(Qabs_of_nonpos_(snd(flip_nonpos_minus__)E1)).rewrite<-negate_swap_r.apply(order_preserving(+ (-q))).trivial.-rewrite(Qabs_of_nonneg(q-r))by(apply(snd(flip_nonneg_minus__));transitivitys;trivial).rewrite(Qabs_of_nonneg_(snd(flip_nonneg_minus__)E2)).apply(order_preserving(+ (-r))).trivial.-rewriteplus_negate_r,Qabs_of_nonnegbyreflexivity.applyQabs_nonneg.Qed.Global InstanceQmeet_nonexpanding_r:foralls:Q,NonExpanding(s⊓).Proof.introsseqrxi.poseproofmeet_sl_order_meet_sl.rewrite!(commutativitys).apply(non_expanding(funx=>meetxs)).trivial.Qed.Global InstanceQjoin_nonexpanding_l:foralls:Q,NonExpanding(⊔s).Proof.introsseqrxi.applyQclose_alt;applyQclose_altinxi.applyle_lt_transwith(abs(q-r));trivial.clearxi.destruct(totalleqs)as[E1|E1], (totallers)as[E2|E2];rewrite?(join_l__E1), ?(join_r__E1), ?(join_l__E2), ?(join_r__E2).-rewriteplus_negate_r,Qabs_of_nonnegbyreflexivity.applyQabs_nonneg.-rewrite(Qabs_of_nonpos(q-r))by(apply(snd(flip_nonpos_minus__));transitivitys;trivial).rewrite<-negate_swap_r.rewrite(Qabs_of_nonpos_(snd(flip_nonpos_minus__)E2)).rewrite<-negate_swap_r.apply(order_preserving(r+)).apply(snd(flip_le_negate__)).trivial.-rewrite(Qabs_of_nonneg(q-r))by(apply(snd(flip_nonneg_minus__));transitivitys;trivial).rewrite(Qabs_of_nonneg_(snd(flip_nonneg_minus__)E1)).apply(order_preserving(q+)).apply(snd(flip_le_negate__)).trivial.-reflexivity.Qed.Global InstanceQjoin_nonexpanding_r:foralls:Q,NonExpanding(s⊔).Proof.introsseqrxi.poseproofjoin_sl_order_join_sl.rewrite!(commutativitys).apply(non_expanding(funx=>joinxs)).trivial.Qed.Global InstanceQmult_lipschitz@{} :forallq:Q,Lipschitz(q*.) (pos_of_Qq).Proof.introsqexyxi.applyQclose_alt.rewritenegate_mult_distr_r,<-plus_mult_distr_l,Qabs_mult.applypos_mult_le_lt_compat;trysplit.-applyQabs_nonneg.-rewriteQabs_is_join.applyjoin_le.+applyflip_le_negate;rewriteinvolutive;applyQ_abs_plus_1_bounds.+applyQ_abs_plus_1_bounds.-solve_propholds.-applyQabs_nonneg.-applyQclose_alt,xi.Qed.Global InstanceQpos_upper_closee:Closeness(Qpos_uppere):=funnxy=>closenx.1y.1.ArgumentsQpos_upper_close____/.Global InstanceQ_recip_lipschitz(e:Q+):Lipschitz((/) ∘pr1∘ (Qpos_upper_injecte)) (/ (e*e)).Proof.introsnqrxi.unfoldCompose;simpl.applyQclose_alt.assert(PropHolds(0 <joinq('e)))asEby(applylt_le_transwith('e);[solve_propholds|applyjoin_ub_r]).apply(strictly_order_reflecting((joinq('e)) *.)).assert(PropHolds(0 <joinr('e)))asE'by(applylt_le_transwith('e);[solve_propholds|applyjoin_ub_r]).apply(strictly_order_reflecting((joinr('e)) *.)).set(X:=joinr('e))at2 3.rewrite<-(Qabs_of_nonneg(joinr_))bysolve_propholds.set(Y:=joinq('e))at2 3.rewrite<-(Qabs_of_nonneg(joinq_))bysolve_propholds.rewrite<-!Qabs_mult.rewrite!(plus_mult_distr_l(Aplus:=Qplus)).rewritedec_recip_inverseby(applyirrefl_neq,symmetric_neqinE;trivial).rewritemult_1_r.assert(Hrw:  (r⊔ 'e) * ((q⊔ 'e) * - / (r⊔ 'e)) = -Y* (X/X))byring_tac.ring_with_integers(NatPair.Znat).rewriteHrw;clearHrw.rewritedec_recip_inverseby(applyirrefl_neq,symmetric_neqinE';trivial).rewritemult_1_r.unfoldX,Y.eapplylt_le_trans.-applyQclose_alt.eapply(non_expanding(⊔ 'e)).symmetry.applyxi.-transitivity(' (((e*e) / (e*e)) *n)).+rewritepos_recip_r,Qpos_mult_1_l;reflexivity.+rewrite<-!Qpos_mult_assoc.change(' (e* (e* (/ (e*e) *n))))with('e* ('e* ' (/ (e*e) *n))).applymult_le_compat;trysolve_propholds;[applyjoin_ub_r|].applymult_le_compat;trysolve_propholds;[applyjoin_ub_r|].reflexivity.Qed.Endrationals.Sectioncauchy.UniverseUA.Context{A:Type@{UA} } {Aclose:ClosenessA}.Context`{!PreMetricA}.Lemmalimit_unique:forallxl1l2,IsLimitxl1->IsLimitxl2->l1=l2.Proof.introsxl1l2E1E2.applyseparated.introse.rewrite(pos_split2e),(pos_split2(e/2)).applytriangularwith(x(e/ 2 / 2));[symmetry;applyE1|applyE2].Qed.Lemmaequiv_through_approx0:forall(y:ApproximationA)ly,IsLimityly->forallued,closeeu(yd) ->close(e+d)uly.Proof.introsylyE1uedxi.apply(merely_destruct((fst(rounded___)xi))).intros[d0[d'[HeE2]]].poseproof(triangular_____E2(E1d'_))asE3.assert(Hrw:e+d=d0+ (d'+d));[|rewriteHrw;trivial].rewriteHe.symmetry.applyQpos_plus_assoc.Qed.Context{Alim:LimA} `{!CauchyCompleteA}.Lemmaequiv_through_approx:forallu(y:ApproximationA)ed,closeeu(yd) ->close(e+d)u(limy).Proof.introsuy;applyequiv_through_approx0.applycauchy_complete.Qed.Lemmaequiv_lim_lim(xy:ApproximationA) (edne':Q+):e=d+n+e'->closee'(xd) (yn) ->closee(limx) (limy).Proof.introsHexi.rewriteHe.assert(Hrw:d+n+e'=e'+d+n)by(applypos_eq;ring_tac.ring_with_nat);rewriteHrw;clearHrw.applyequiv_through_approx.symmetry.applyequiv_through_approx.symmetry;trivial.Qed.Lemmalim_same_distance@{} :forall(xy:ApproximationA)e,(foralldn,close(e+d) (xn) (yn)) ->foralld,close(e+d) (limx) (limy).Proof.introsxyeEd.applyequiv_lim_limwith(d/3) (d/3) (e+d/3);[|applyE].path_via(e+ 3 / 3 *d).-rewritepos_recip_r,Qpos_mult_1_l;trivial.-applypos_eq;ring_tac.ring_with_nat.Qed.Endcauchy.Sectionlipschitz_lim.Context{A:Type} {Aclose:ClosenessA} `{!PreMetricA}`{Bclose:ClosenessB} `{!PreMetricB} {Blim:LimB}`{!CauchyCompleteB}.Global Instancelipschitz_lim_lipschitz(s:Approximation(A->B))L`{!foralle,Lipschitz(se)L} :Lipschitz(lims)L.Proof.introsexyxi.applyroundedinxi;revertxi;apply(Trunc_ind_);intros[d[d'[Exi]]].rewriteE,Qpos_plus_mult_distr_l.applylim_same_distance.cleared'E.introsd'n.simpl.applyrounded_plus.apply(lipschitz(sn)L).trivial.Qed.Endlipschitz_lim.Endcontents.Argumentsrounded_le{__A__}euv_d_.Argumentsnon_expanding{A_B_}f{_exy}_.Argumentslipschitz{A_B_}fL{_exy}_.Argumentsuniform{A_B_}fmu{_}____.Argumentscontinuous{A_B_}f{_}__.Argumentsmap2_nonexpanding{A_B_C_D_}fg{__}exyxi.Argumentsmap2_lipschitz{__A_B_C_D_}fg{__}LfLg{__}exyxi.Argumentsmap2_continuous{__A_B_C_D_}fg{____}ue.ArgumentsInterval_close{___}_____/.ArgumentsLimA{_}.Argumentslim{A__}_.ArgumentsApproximationA{_}.ArgumentsBuild_Approximation{A_}__.Argumentsapproximate{A_}__.Argumentsapprox_equiv{A_}___.ArgumentsCauchyCompleteA{__}.Argumentsarrow_lim{AB___}_/_.

--- Miscellaneous\Presentation.html ---
PresentationLibrary PresentationRequireImportBasicsTypes.RequireImportTruncations.Core.RequireImportAlgebra.Groups.Group.RequireImportAlgebra.Groups.FreeGroup.RequireImportAlgebra.Groups.GroupCoeq.RequireImportSpaces.FiniteSpaces.List.Core.RequireImportWildCat.Local OpenScopemc_scope.Local OpenScopemc_mult_scope.In this file we develop presentations of groups.The data of a group presentationRecordGroupPresentation:= {We have a type of generatorsgp_generators:Type;An indexing type for relatorsgp_rel_index:Type;The relators are picked out amongst elements of the free group on the generators.gp_relators:gp_rel_index->FreeGroupgp_generators;}.Note: A relator is a relation in the form of "w = 1", any relation "w = v" can become a relator "wv^-1 = 1" for words v and w.Given the data of a group presentation we can construct the group. This is sometimes called the presented group.Definitiongroup_gp:GroupPresentation->Group.Proof.intros[XIR].exact(GroupCoeq(FreeGroup_recI(FreeGroupX)R)(FreeGroup_recI(FreeGroupX) (funx=> @group_unit(FreeGroupX)))).Defined.A groupGhas a presentation if there exists a group presentation whose presented group is isomorphic toG.ClassHasPresentation(G:Group) := {presentation:GroupPresentation;grp_iso_presentation:GroupIsomorphism(group_gppresentation)G;}.Coercionpresentation:HasPresentation>->GroupPresentation.Here are a few finiteness properties of group presentations.A group presentation is finitely generated if its generating set is finite.ClassFinitelyGeneratedPresentation(P:GroupPresentation):=finite_gp_generators:Finite(gp_generatorsP).A group presentation is finitely related if its relators indexing set is finite.ClassFinitelyRelatedPresentation(P:GroupPresentation):=finite_gp_relators:Finite(gp_rel_indexP).A group presentation is a finite presentation if it is finitely generated and related.ClassFinitePresentation(P:GroupPresentation) := {fp_generators:FinitelyGeneratedPresentationP;fp_relators:FinitelyRelatedPresentationP;}.These directly translate into properties of groups.A group is finitely generated if it has a finitely generated presentation.ClassIsFinitelyGenerated(G:Group) := {fg_presentation:HasPresentationG;fg_presentation_fg:FinitelyGeneratedPresentationfg_presentation;}.A group is finitely related if it has a finitely related presentation.ClassIsFinitelyRelated(G:Group) := {fr_presentation:HasPresentationG;fr_presentation_fr:FinitelyRelatedPresentationfr_presentation;}.ClassIsFinitelyPresented(G:Group) := {fp_presentation:HasPresentationG;fp_presentation_fp:FinitePresentationfp_presentation;}.Fundamental theorem of presentations of groupsA group homomorphism from a presented group is determined with how the underlying map acts on generators subject to the condition that relators are sent to the unit.Theoremgrp_pres_rec{funext:Funext} (G:Group) (P:HasPresentationG) (H:Group): {f:gp_generatorsP->H&forallr,FreeGroup_rec__f(gp_relatorsPr) =group_unit}<~>GroupHomomorphismGH.Proof.refine((equiv_precompose_cat_equivgrp_iso_presentation)^-1oE_).refine(equiv_groupcoeq_rec__oE_).srefine(equiv_functor_sigma_pb_oE_).2:applyequiv_freegroup_rec.applyequiv_functor_sigma_id.introsf.srapplyequiv_iff_hprop.{introsp.change(equiv_freegroup_recH_f$oFreeGroup_rec__(gp_relatorsP)$==equiv_freegroup_rec__f$oFreeGroup_rec__(fun_=>group_unit)).rapplyFreeGroup_ind_homotopy.exactp. }introspr.hnfinp.exact(p(freegroup_inr)).Defined.Constructors for finite presentationsDefinitionBuild_Finite_GroupPresentationnm(f:FinSeqm(FreeGroup(Finn))):GroupPresentation.Proof.snrapplyBuild_GroupPresentation.-exact(Finn).-exact(Finm).-exactf.Defined.Global InstanceFinitelyGeneratedPresentation_Build_Finite_GroupPresentation{nmf}:FinitelyGeneratedPresentation(Build_Finite_GroupPresentationnmf).Proof.unshelveeconstructor.2:simpl;applytr;reflexivity.Defined.Global InstanceFinitelyRelatedPresentation_Build_Finite_GroupPresentation{nmf}:FinitelyRelatedPresentation(Build_Finite_GroupPresentationnmf).Proof.unshelveeconstructor.2:simpl;applytr;reflexivity.Defined.Notations for presentationsConvenient abbreviation when defining notations.Local Notationff:= (freegroup_inofin_nat).TODO: I haven't worked out how to generalize to any number of binders, so we explicitly list the first few levels.Local OpenScopenat_scope.One generatorNotation"⟨ x | F , .. , G ⟩" :=(Build_Finite_GroupPresentation1_(fscons((fun(x:FreeGroup(Fin1))=>F:FreeGroup(Fin_)) (ff0%nat)).. (fscons((fun(x:FreeGroup(Fin1))=>G:FreeGroup(Fin_)) (ff0))fsnil) ..))(atlevel200,xbinder).Two generatorsNotation"⟨ x , y | F , .. , G ⟩" :=(Build_Finite_GroupPresentation2_(fscons((fun(xy:FreeGroup(Fin2))=>F:FreeGroup(Fin_)) (ff0) (ff1)).. (fscons((fun(xy:FreeGroup(Fin2))=>G:FreeGroup(Fin_)) (ff0) (ff1))fsnil) ..))(atlevel200,xbinder,ybinder).Three generatorsNotation"⟨ x , y , z | F , .. , G ⟩" :=(Build_Finite_GroupPresentation3_(fscons((fun(xyz:FreeGroup(Fin3))=>F:FreeGroup(Fin_)) (ff0) (ff1) (ff2)).. (fscons((fun(xyz:FreeGroup(Fin3))=>G:FreeGroup(Fin_)) (ff0) (ff1) (ff2))fsnil) ..))(atlevel200,xbinder,ybinder,zbinder).

--- Miscellaneous\Prod.html ---
ProdLibrary ProdRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.RequireImportWildCat.Equiv.RequireImportTypes.Prod.Product categoriesProducts preserve (0,1)-categories.Global Instanceisgraph_prodAB`{IsGraphA} `{IsGraphB}:IsGraph(A*B):=Build_IsGraph(A*B) (funxy=> (fstx$->fsty) * (sndx$->sndy)).Global Instanceis01cat_prodAB`{Is01CatA} `{Is01CatB}:Is01Cat(A*B).Proof.econstructor.-intros[ab];exact(Ida,Idb).-intros[a1b1] [a2b2] [a3b3] [f1g1] [f2g2];cbnin*.exact(f1$of2,g1$og2).Defined.Global Instanceis0gpd_prodAB`{Is0GpdA} `{Is0GpdB}:Is0Gpd(A*B).Proof.srapplyBuild_Is0Gpd.intros[x1x2] [y1y2] [f1f2].cbnin*.exact( (f1^$,f2^$) ).Defined.Global Instanceis2graph_prodAB`{Is2GraphA,Is2GraphB}:Is2Graph(A*B).Proof.intros[x1x2] [y1y2].rapplyisgraph_prod.Defined.Global Instanceis1cat_prodAB`{Is1CatA} `{Is1CatB}:Is1Cat(A*B).Proof.srapplyBuild_Is1Cat.-intros[x1x2] [y1y2] [z1z2] [h1h2].srapplyBuild_Is0Functor.intros[f1f2] [g1g2] [p1p2];cbnin*.exact(h1$@Lp1,h2$@Lp2).-intros[x1x2] [y1y2] [z1z2] [h1h2].srapplyBuild_Is0Functor.intros[f1f2] [g1g2] [p1p2];cbnin*.exact(p1$@Rh1,p2$@Rh2).-intros[a1a2] [b1b2] [c1c2] [d1d2] [f1f2] [g1g2] [h1h2].cbnin*.exact(cat_assocf1g1h1,cat_assocf2g2h2).-intros[a1a2] [b1b2] [c1c2] [d1d2] [f1f2] [g1g2] [h1h2].cbnin*.exact(cat_assoc_oppf1g1h1,cat_assoc_oppf2g2h2).-intros[a1a2] [b1b2] [f1f2].cbnin*.exact(cat_idl_,cat_idl_).-intros[a1a2] [b1b2] [g1g2].cbnin*.exact(cat_idr_,cat_idr_).Defined.Product categories inherit equivalencesGlobal Instancehasequivs_prodAB`{HasEquivsA} `{HasEquivsB}:HasEquivs(A*B).Proof.srefine(Build_HasEquivs(A*B)____(funab=> (fsta$<~>fstb) * (snda$<~>sndb))_________).1:introsabf;exact(CatIsEquiv(fstf) *CatIsEquiv(sndf)).all:cbn;introsabf.-split; [exact(fstf) |exact(sndf) ].-split;exact_.-intros[fe1fe2];split.+exact(Build_CatEquiv(fstf)).+exact(Build_CatEquiv(sndf)).-intros[fe1fe2];cbn;split;applycate_buildequiv_fun.-split; [exact((fstf)^-1$) |exact((sndf)^-1$) ].-split;applycate_issect.-split;applycate_isretr.-introsgrs;split.+exact(catie_adjointify(fstf) (fstg) (fstr) (fsts)).+exact(catie_adjointify(sndf) (sndg) (sndr) (snds)).Defined.Global Instanceisequivs_prodAB`{HasEquivsA} `{HasEquivsB}{a1a2:A} {b1b2:B} {f:a1$->a2} {g:b1$->b2}{ef:CatIsEquivf} {eg:CatIsEquivg}: @CatIsEquiv(A*B)_____(a1,b1) (a2,b2) (f,g) := (ef,eg).Product functorsGlobal Instanceis0functor_prod_functor{ABCD:Type}(F:A->B) (G:C->D) `{Is0Functor__F,Is0Functor__G}:Is0Functor(functor_prodFG).Proof.applyBuild_Is0Functor.intros[a1c1] [a2c2] [fg].exact(fmapFf,fmapGg).Defined.Global Instanceis1functor_prod_functor{ABCD:Type}(F:A->B) (G:C->D) `{Is1Functor__F,Is1Functor__G}:Is1Functor(functor_prodFG).Proof.applyBuild_Is1Functor.-intros[a1c1] [a2c2] [f1g1] [f2g2] [pq].exact(fmap2Fp,fmap2Gq).-intros[ac].exact(fmap_idFa,fmap_idGc).-intros[a1c1] [a2c2] [a3c3] [f1g1] [f2g2].exact(fmap_compFf1f2,fmap_compGg1g2).Defined.Global Instanceis0functor_fst{AB:Type} `{!IsGraphA, !IsGraphB}:Is0Functor(@fstAB).Proof.applyBuild_Is0Functor.intros? ?f;exact(fstf).Defined.Global Instanceis0functor_snd{AB:Type} `{!IsGraphA, !IsGraphB}:Is0Functor(@sndAB).Proof.applyBuild_Is0Functor.intros? ?f;exact(sndf).Defined.Swap functorGlobal Instanceis0functor_equiv_prod_symm{AB:Type} `{IsGraphA,IsGraphB}:Is0Functor(equiv_prod_symmAB).Proof.snrapplyBuild_Is0Functor.introsab.applyequiv_prod_symm.Defined.Global Instanceis1functor_equiv_prod_symm{AB:Type} `{Is1CatA,Is1CatB}:Is1Functor(equiv_prod_symmAB).Proof.snrapplyBuild_Is1Functor.-introsabfg.applyequiv_prod_symm.-introsa.reflexivity.-reflexivity.Defined.Inclusions into a product category are functorial.Global Instanceis0functor_prod_include10{AB:Type} `{IsGraphA,Is01CatB}(b:B):Is0Functor(funa:A=> (a,b)).Proof.nrapplyBuild_Is0Functor.introsacf.exact(f,Idb).Defined.Global Instanceis1functor_prod_include10{AB:Type} `{Is1CatA,Is1CatB}(b:B):Is1Functor(funa:A=> (a,b)).Proof.nrapplyBuild_Is1Functor.-introsacfgp.exact(p,Id_).-introsa;reflexivity.-introsacdfg.exact(Id_, (cat_idl_)^$).Defined.Global Instanceis0functor_prod_include01{AB:Type} `{Is01CatA,IsGraphB}(a:A):Is0Functor(funb:B=> (a,b)).Proof.nrapplyBuild_Is0Functor.introsbcf.exact(Ida,f).Defined.Global Instanceis1functor_prod_include01{AB:Type} `{Is1CatA,Is1CatB}(a:A):Is1Functor(funb:B=> (a,b)).Proof.nrapplyBuild_Is1Functor.-introsbcfgp.exact(Id_,p).-introsb;reflexivity.-introsbcdfg.exact((cat_idl_)^$,Id_).Defined.Functors from a product category are functorial in each argumentGlobal Instanceis0functor_functor_uncurried01{ABC:Type}`{Is01CatA,IsGraphB,IsGraphC}(F:A*B->C) `{!Is0FunctorF} (a:A):Is0Functor(funb=>F(a,b)):=is0functor_compose(funb=> (a,b))F.Global Instanceis1functor_functor_uncurried01{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC}(F:A*B->C) `{!Is0FunctorF, !Is1FunctorF} (a:A):Is1Functor(funb=>F(a,b)):=is1functor_compose(funb=> (a,b))F.Global Instanceis0functor_functor_uncurried10{ABC:Type}`{IsGraphA,Is01CatB,IsGraphC}(F:A*B->C) `{!Is0FunctorF} (b:B):Is0Functor(funa=>F(a,b)):=is0functor_compose(funa=> (a,b))F.Global Instanceis1functor_functor_uncurried10{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC}(F:A*B->C) `{!Is0FunctorF, !Is1FunctorF} (b:B):Is1Functor(funa=>F(a,b)):=is1functor_compose(funa=> (a,b))F.Conversely, ifF:A*B->Cis a 0-functor in each variable, then it is a 0-functor.Definitionis0functor_prod_is0functor{ABC:Type}`{IsGraphA,IsGraphB,Is01CatC} (F:A*B->C)`{!foralla,Is0Functor(funb=>F(a,b)), !forallb,Is0Functor(funa=>F(a,b))}:Is0FunctorF.Proof.snrapplyBuild_Is0Functor.intros[ab] [a'b'] [fg].exact(fmap(funa0=>F(a0,b'))f$ofmap(funb0=>F(a,b0))g).Defined.TODO: If we make this an instance, will it cause typeclass search to spin?Hint Immediateis0functor_prod_is0functor:typeclass_instances.And ifF:A*B->Cis a 1-functor in each variable and satisfies a coherence, then it is a 1-functor.Definitionis1functor_prod_is1functor{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC} (F:A*B->C)`{!foralla,Is0Functor(funb=>F(a,b)), !forallb,Is0Functor(funa=>F(a,b))}`{!foralla,Is1Functor(funb=>F(a,b)), !forallb,Is1Functor(funa=>F(a,b))}(bifunctor_coh:foralla0a1(f:a0$->a1)b0b1(g:b0$->b1),fmap(funb=>F(a1,b))g$ofmap(funa=>F(a,b0))f$==fmap(funa=>F(a,b1))f$ofmap(funb=>F(a0,b))g):Is1FunctorF.Proof.snrapplyBuild_Is1Functor.-intros[ab] [a'b'] [fg] [f'g'] [pp'];unfoldfst,sndin* |- .exact(fmap2(funb0=>F(a,b0))p'$@@fmap2(funa0=>F(a0,b'))p).-intros[ab].exact((fmap_id(funb0=>F(a,b0))b$@@fmap_id(funa0=>F(a0,b))_) $@cat_idr_).-intros[ab] [a'b'] [a''b''] [fg] [f'g'];unfoldfst,sndin* |- .refine((fmap_comp(funb0=>F(a,b0))gg'$@@fmap_comp(funa0=>F(a0,b''))ff') $@_).nrefine(cat_assoc_opp___$@ (_$@R_) $@cat_assoc___).refine(cat_assoc___$@ (_$@L_^$) $@cat_assoc_opp___).nrapplybifunctor_coh.Defined.Hint Immediateis1functor_prod_is1functor:typeclass_instances.Applies a two variable functor via uncurrying. Note that the precondition onCis slightly weaker than that ofBifunctor.fmap11.Definitionfmap11_uncurry{ABC:Type} `{IsGraphA,IsGraphB,IsGraphC}(F:A->B->C) {H2:Is0Functor(uncurryF)}{a0a1:A} (f:a0$->a1) {b0b1:B} (g:b0$->b1):Fa0b0$->Fa1b1:= @fmap____(uncurryF)H2(a0,b0) (a1,b1) (f,g).Definitionfmap_pair{ABC:Type}`{IsGraphA,IsGraphB,IsGraphC}(F:A*B->C) `{!Is0FunctorF}{a0a1:A} (f:a0$->a1) {b0b1:B} (g:b0$->b1):F(a0,b0) $->F(a1,b1):=fmap(a:= (a0,b0)) (b:= (a1,b1))F(f,g).Definitionfmap_pair_comp{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC}(F:A*B->C) `{!Is0FunctorF, !Is1FunctorF}{a0a1a2:A} {b0b1b2:B}(f:a0$->a1) (h:b0$->b1) (g:a1$->a2) (i:b1$->b2):fmap_pairF(g$of) (i$oh)$==fmap_pairFgi$ofmap_pairFfh:=fmap_comp(a:= (a0,b0)) (b:= (a1,b1)) (c:= (a2,b2))F(f,h) (g,i).Definitionfmap2_pair{ABC:Type}`{Is1CatA,Is1CatB,Is1CatC}(F:A*B->C) `{!Is0FunctorF, !Is1FunctorF}{a0a1:A} {ff':a0$->a1} (p:f$==f'){b0b1:B} {gg':b0$->b1} (q:g$==g'):fmap_pairFfg$==fmap_pairFf'g':=fmap2F(a:= (a0,b0)) (b:= (a1,b1)) (f:= (f,g)) (g:= (f',g')) (p,q).

--- Miscellaneous\ProductLaws.html ---
ProductLawsLibrary ProductLawsLaws about product categoriesRequireImportHoTT.BasicsHoTT.Types.RequireImportCategory.CoreFunctor.CoreInitialTerminalCategory.CoreInitialTerminalCategory.FunctorsCategory.ProdFunctor.ProdFunctor.Composition.CoreFunctor.IdentityFunctor.Composition.Laws.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Local OpenScopefunctor_scope.Local Notationprod_type:=Basics.Overture.prod.Local Notationfst_type:=Basics.Overture.fst.Local Notationsnd_type:=Basics.Overture.snd.Local Notationpair_type:=Basics.Overture.pair.Swap functorC×D→D×CModuleSwap.Definitionfunctor(CD:PreCategory):Functor(C*D) (D*C):=Build_Functor(C*D) (D*C)(funcd=> (snd_typecd,fst_typecd)%core)(fun__m=> (snd_typem,fst_typem)%core)(fun_____=>idpath)(fun_=>idpath).Definitionlaw(CD:PreCategory):functorCDofunctorDC= 1:=idpath.EndSwap.A*(B*C)≅(A*B)*CModuleAssociativity.Sectionassociativity.VariablesABC:PreCategory.Definitionfunctor:Functor(A* (B*C)) ((A*B) *C):= (fst* (fstosnd)) * (sndosnd).Definitioninverse:Functor((A*B) *C) (A* (B*C)):= (fstofst) * ((sndofst) *snd).Definitionlaw:functoroinverse= 1/\inverseofunctor= 1:= (idpath,idpath)%core.Endassociativity.EndAssociativity.Laws about the initial category0ModuleLaw0.Sectionlaw0.Context`{Funext}.Context`{IsInitialCategoryzero}.Local Notation"0" :=zero:category_scope.VariableC:PreCategory.Global Instanceis_initial_category__product:IsInitialCategory(C* 0):=funPc=>initial_category_indP(sndc).Global Instanceis_initial_category__product':IsInitialCategory(0 *C):=funPc=>initial_category_indP(fstc).Definitionfunctor:Functor(C* 0) 0 :=Functors.from_initial_.Definitionfunctor':Functor(0 *C) 0 :=Functors.from_initial_.Definitioninverse:Functor0 (C* 0) :=Functors.from_initial_.Definitioninverse':Functor0 (0 *C) :=Functors.from_initial_.C×0≅0Definitionlaw:functoroinverse= 1/\inverseofunctor= 1:=center_.0×C≅0Definitionlaw':functor'oinverse'= 1/\inverse'ofunctor'= 1:=center_.Endlaw0.EndLaw0.Laws about the terminal category1ModuleLaw1.Sectionlaw1.Context`{Funext}.Context`{IsTerminalCategoryone}.Local Notation"1" :=one:category_scope.VariableC:PreCategory.Definitionfunctor:Functor(C* 1)C:=fst.Definitionfunctor':Functor(1 *C)C:=snd.Definitioninverse:FunctorC(C* 1):= 1 *Functors.to_terminal_.Definitioninverse':FunctorC(1 *C):=Functors.to_terminal_* 1.We could throw this in arepeatmatchgoalwith...end, but
      we know the order, so we hard-code the order to speed it up by a
      factor of about 10.Local Ltact_prod:=split;tryfirst[exact(compose_fst_prod__)|exact(compose_snd_prod__) ];[];applyFunctor.Prod.Universal.path_prod;rewrite<- !Functor.Composition.Laws.associativitybyassumption;(rewrite?compose_fst_prod, ?compose_snd_prod,?Functor.Composition.Laws.left_identity,?Functor.Composition.Laws.right_identitybyassumption);try(reflexivity||exact(center_)).C×1≅CLemmalaw1:functoroinverse= 1/\inverseofunctor= 1.Proof.unfoldfunctor,inverse.t_prod.Qed.1×C≅CLemmalaw1':functor'oinverse'= 1/\inverse'ofunctor'= 1.Proof.unfoldfunctor',inverse'.t_prod.Qed.Endlaw1.EndLaw1.

--- Miscellaneous\Products.html ---
ProductsLibrary ProductsRequireImportBasics.EquivalencesBasics.OvertureBasics.Tactics.RequireImportTypes.BoolTypes.ProdTypes.Forall.RequireImportWildCat.BifunctorWildCat.CoreWildCat.EquivWildCat.EquivGpdWildCat.ForallWildCat.NatTransWildCat.OppositeWildCat.UniverseWildCat.YonedaWildCat.ZeroGroupoidWildCat.MonoidalWildCat.MonoidalTwistConstruction.Categories with productsDefinitioncat_prod_corec_inv{IA:Type} `{Is1CatA}(prod:A) (x:I->A) (z:A) (pr:foralli,prod$->xi):yon_0gpdprodz$->prod_0gpdI(funi=>yon_0gpd(xi)z).Proof.snrapplyequiv_prod_0gpd_corec.introsi.exact(fmap(funx=>yon_0gpdxz) (pri)).Defined.(* A product of anI-indexed family of objects of a category is an object of the category with anI-indexed family of projections such that the induced map is an equivalence. *)ClassProduct(I:Type) {A:Type} `{Is1CatA} {x:I->A} :=Build_Product'{cat_prod:A;cat_pr:foralli:I,cat_prod$->xi;cat_isequiv_cat_prod_corec_inv::forallz:A,CatIsEquiv(cat_prod_corec_invcat_prodxzcat_pr);}.ArgumentsProductI{A____}x.Argumentscat_prodI{A____}x{product} :rename.A convenience wrapper for building productsDefinitionBuild_Product(I:Type) {A:Type} `{Is1CatA} {x:I->A}(cat_prod:A) (cat_pr:foralli:I,cat_prod$->xi)(cat_prod_corec:forallz:A,(foralli:I,z$->xi) -> (z$->cat_prod))(cat_prod_beta_pr:forall(z:A) (f:foralli,z$->xi) (i:I),cat_pri$ocat_prod_coreczf$==fi)(cat_prod_eta_pr:forall(z:A) (fg:z$->cat_prod),(foralli:I,cat_pri$of$==cat_pri$og) ->f$==g):ProductIx.Proof.snrapply(Build_Product'IA_____cat_prodcat_pr).introsz.nrapplyisequiv_0gpd_issurjinj.nrapplyBuild_IsSurjInj.-introsf.exists(cat_prod_coreczf).introsi.nrapplycat_prod_beta_pr.-introsfgp.bynrapplycat_prod_eta_pr.Defined.SectionLemmata.Context(I:Type) {A:Type} {x:I->A} `{ProductI_x}.Definitioncate_cat_prod_corec_inv{z:A}: (yon_0gpd(cat_prodIx)z) $<~>prod_0gpdI(funi=>yon_0gpd(xi)z):=Build_CatEquiv(cat_prod_corec_inv(cat_prodIx)xzcat_pr).Definitioncate_cat_prod_corec{z:A}:prod_0gpdI(funi=>yon_0gpd(xi)z) $<~> (yon_0gpd(cat_prodIx)z):=cate_cat_prod_corec_inv^-1$.Definitioncat_prod_corec{z:A}: (foralli,z$->xi) -> (z$->cat_prodIx).Proof.applycate_cat_prod_corec.Defined.Applying theith projection after a tuple of maps gives theithmap.Lemmacat_prod_beta{z:A} (f:foralli,z$->xi):foralli,cat_pri$ocat_prod_corecf$==fi.Proof.exact(cate_isretrcate_cat_prod_corec_invf).Defined.The pairing map is the unique map that makes the following diagram commute.Lemmacat_prod_eta{z:A} (f:z$->cat_prodIx):cat_prod_corec(funi=>cat_pri$of) $==f.Proof.exact(cate_issectcate_cat_prod_corec_invf).Defined.Local Instanceis0functor_prod_0gpd_helper:Is0Functor(funz:A^op=>prod_0gpdI(funi=>yon_0gpd(xi)z)).Proof.snrapplyBuild_Is0Functor.introsabf.snrapplyBuild_Morphism_0Gpd.-introsgi.exact(f$ogi).-snrapplyBuild_Is0Functor.introsghpi.exact(f$@Lpi).Defined.Local Instanceis1functor_prod_0gpd_helper:Is1Functor(funz:A^op=>prod_0gpdI(funi=>yon_0gpd(xi)z)).Proof.snrapplyBuild_Is1Functor.-introsabfgpri.refine(_$@L_).exactp.-introsari.nrapplycat_idl;exact_.-introsabcfgri.nrapplycat_assoc;exact_.Defined.Definitionnatequiv_cat_prod_corec_inv:NatEquiv(yon_0gpd(cat_prodIx))(funz:A^op=>prod_0gpdI(funi=>yon_0gpd(xi)z)).Proof.snrapplyBuild_NatEquiv.1:intro;nrapplycate_cat_prod_corec_inv.exact(is1natural_yoneda_0gpd(cat_prodIx)(funz=>prod_0gpdI(funi=>yon_0gpd(xi)z))cat_pr).Defined.Lemmacat_prod_corec_eta{z:A} {ff':foralli,z$->xi}: (foralli,fi$==f'i) ->cat_prod_corecf$==cat_prod_corecf'.Proof.introsp.unfoldcat_prod_corec.nrapply(moveL_equiv_V_0gpdcate_cat_prod_corec_inv).nrefine(cate_isretrcate_cat_prod_corec_inv_$@_).exactp.Defined.Lemmacat_prod_pr_eta{z:A} {ff':z$->cat_prodIx}: (foralli,cat_pri$of$==cat_pri$of') ->f$==f'.Proof.introsp.refine((cat_prod_eta_)^$ $@_$@cat_prod_eta_).bynrapplycat_prod_corec_eta.Defined.EndLemmata.Diagonal mapDefinitioncat_prod_diag{I:Type} {A:Type} (x:A)`{ProductI_(fun_=>x)}:x$->cat_prodI(fun_=>x):=cat_prod_corecI(fun_=>Idx).Uniqueness of productsDefinitioncate_cat_prod{IJ:Type} (ie:I<~>J) {A:Type} `{HasEquivsA}(x:I->A) `{!ProductIx} (y:J->A) `{!ProductJy}(e:foralli:I,xi$<~>y(iei)):cat_prodIx$<~>cat_prodJy.Proof.nrapplyyon_equiv_0gpd.nrefine(natequiv_compose_(natequiv_cat_prod_corec_inv_)).nrefine(natequiv_compose(natequiv_inverse(natequiv_cat_prod_corec_inv_))_).snrapplyBuild_NatEquiv.-introsz.nrapply(cate_prod_0gpdie).introsi.exact(natequiv_yon_equiv_0gpd(ei)_).-snrapplyBuild_Is1Natural.introsabfgj.cbn.destruct(eisretriej).exact(cat_assoc_opp___).Defined.I-indexed products are unique no matter how they are constructed.Definitioncat_prod_unique{IA:Type} `{HasEquivsA}(x:I->A) `{!ProductIx} (y:I->A) `{!ProductIy}(e:foralli:I,xi$<~>yi):cat_prodIx$<~>cat_prodIy.Proof.exact(cate_cat_prod1xye).Defined.Existence of productsClassHasProducts(IA:Type) `{Is1CatA}:=has_products::forallx:I->A,ProductIx.ClassHasAllProducts(A:Type) `{Is1CatA}:=has_all_products::forallI:Type,HasProductsIA.Product functorGlobal Instanceis0functor_cat_prod(I:Type) (A:Type) `{HasProductsIA}:Is0Functor(funx:I->A=>cat_prodIx).Proof.nrapplyBuild_Is0Functor.introsxyf.exact(cat_prod_corecI(funi=>fi$ocat_pri)).Defined.Global Instanceis1functor_cat_prod(I:Type) (A:Type) `{HasProductsIA}:Is1Functor(funx:I->A=>cat_prodIx).Proof.nrapplyBuild_Is1Functor.-introsxyfgp.exact(cat_prod_corec_etaI(funi=>pi$@Rcat_pri)).-introsx.nrefine(_$@ (cat_prod_etaI(Id_))).exact(cat_prod_corec_etaI(funi=>cat_idl_$@ (cat_idr_)^$)).-introsxyzfg.nrapplycat_prod_pr_eta.introsi.nrefine(cat_prod_beta___$@_).nrefine(_$@cat_assoc___).symmetry.nrefine(cat_prod_beta___$@R_$@_).nrefine(cat_assoc___$@_).nrefine(_$@Lcat_prod_beta___$@_).nrapplycat_assoc_opp.Defined.Categories with specific kinds of productsDefinitionisterminal_prodempty{A:Type} {z:A}`{ProductEmptyA(fun_=>z)}:IsTerminal(cat_prodEmpty(fun_=>z)).Proof.introsa.snrefine(cat_prod_corec__;funf=>cat_prod_pr_eta__);intros[].Defined.Binary productsClassBinaryProduct{A:Type} `{Is1CatA} (xy:A):=binary_product::ProductBool(funb=>ifbthenxelsey).A category with binary products is a category with a binary product for each pair of objects.ClassHasBinaryProducts(A:Type) `{Is1CatA}:=has_binary_products::forallxy:A,BinaryProductxy.Global Instancehasbinaryproducts_hasproductsbool{A:Type} `{HasProductsBoolA}:HasBinaryProductsA:=funxy=>has_products(funb:Bool=>ifbthenxelsey).SectionBinaryProducts.Context{A:Type} `{Is1CatA} {xy:A} `{!BinaryProductxy}.Definitioncat_binprod:A:=cat_prodBool(funb:Bool=>ifbthenxelsey).Definitioncat_pr1:cat_binprod$->x:=cat_prtrue.Definitioncat_pr2:cat_binprod$->y:=cat_prfalse.Definitioncat_binprod_corec{z:A} (f:z$->x) (g:z$->y):z$->cat_binprod.Proof.nrapply(cat_prod_corecBool).intros[|].-exactf.-exactg.Defined.Definitioncat_binprod_beta_pr1{z:A} (f:z$->x) (g:z$->y):cat_pr1$ocat_binprod_corecfg$==f:=cat_prod_beta__true.Definitioncat_binprod_beta_pr2{z:A} (f:z$->x) (g:z$->y):cat_pr2$ocat_binprod_corecfg$==g:=cat_prod_beta__false.Definitioncat_binprod_eta{z:A} (f:z$->cat_binprod):cat_binprod_corec(cat_pr1$of) (cat_pr2$of) $==f.Proof.unfoldcat_binprod_corec.nrapplycat_prod_pr_eta.intros[|].-exact(cat_binprod_beta_pr1__).-exact(cat_binprod_beta_pr2__).Defined.Definitioncat_binprod_eta_pr{z:A} (fg:z$->cat_binprod):cat_pr1$of$==cat_pr1$og->cat_pr2$of$==cat_pr2$og->f$==g.Proof.introspq.rapplycat_prod_pr_eta.intros[|].-exactp.-exactq.Defined.Definitioncat_binprod_corec_eta{z:A} (ff':z$->x) (gg':z$->y):f$==f'->g$==g'->cat_binprod_corecfg$==cat_binprod_corecf'g'.Proof.introspq.rapplycat_prod_corec_eta.intros[|].-exactp.-exactq.Defined.EndBinaryProducts.Argumentscat_binprod{A____}xy{_}.A convenience wrapper for building binary productsDefinitionBuild_BinaryProduct{A:Type} `{Is1CatA} {xy:A}(cat_binprod:A) (cat_pr1:cat_binprod$->x) (cat_pr2:cat_binprod$->y)(cat_binprod_corec:forallz:A,z$->x->z$->y->z$->cat_binprod)(cat_binprod_beta_pr1:forall(z:A) (f:z$->x) (g:z$->y),cat_pr1$ocat_binprod_coreczfg$==f)(cat_binprod_beta_pr2:forall(z:A) (f:z$->x) (g:z$->y),cat_pr2$ocat_binprod_coreczfg$==g)(cat_binprod_eta_pr:forall(z:A) (fg:z$->cat_binprod),cat_pr1$of$==cat_pr1$og->cat_pr2$of$==cat_pr2$og->f$==g):ProductBool(funb=>ifbthenxelsey).Proof.snrapply(Build_Product_cat_binprod).-intros[|].+exactcat_pr1.+exactcat_pr2.-introszf.nrapplycat_binprod_corec.+exact(ftrue).+exact(ffalse).-introszf[|].+nrapplycat_binprod_beta_pr1.+nrapplycat_binprod_beta_pr2.-introszfgp.nrapplycat_binprod_eta_pr.+exact(ptrue).+exact(pfalse).Defined.Definitioncat_binprod_eta_pr_x_xx{A:Type} `{HasBinaryProductsA} {wxyz:A}(fg:w$->cat_binprodx(cat_binprodyz)):cat_pr1$of$==cat_pr1$og->cat_pr1$ocat_pr2$of$==cat_pr1$ocat_pr2$og->cat_pr2$ocat_pr2$of$==cat_pr2$ocat_pr2$og->f$==g.Proof.introspqr.snrapplycat_binprod_eta_pr.-exactp.-snrapplycat_binprod_eta_pr.+exact(cat_assoc_opp___$@q$@cat_assoc___).+exact(cat_assoc_opp___$@r$@cat_assoc___).Defined.Definitioncat_binprod_eta_pr_xx_x{A:Type} `{HasBinaryProductsA} {wxyz:A}(fg:w$->cat_binprod(cat_binprodxy)z):cat_pr1$ocat_pr1$of$==cat_pr1$ocat_pr1$og->cat_pr2$ocat_pr1$of$==cat_pr2$ocat_pr1$og->cat_pr2$of$==cat_pr2$og->f$==g.Proof.introspqr.snrapplycat_binprod_eta_pr.2:exactr.snrapplycat_binprod_eta_pr.1,2:refine(cat_assoc_opp___$@_$@cat_assoc___).-exactp.-exactq.Defined.Definitioncat_binprod_eta_pr_x_xx_id{A:Type} `{HasBinaryProductsA} {xyz:A}(f:cat_binprodx(cat_binprodyz) $->cat_binprodx(cat_binprodyz)):cat_pr1$of$==cat_pr1->cat_pr1$ocat_pr2$of$==cat_pr1$ocat_pr2->cat_pr2$ocat_pr2$of$==cat_pr2$ocat_pr2->f$==Id_.Proof.introspqr.snrapplycat_binprod_eta_pr_x_xx.-exact(p$@ (cat_idr_)^$).-exact(q$@ (cat_idr_)^$).-exact(r$@ (cat_idr_)^$).Defined.From binary products, all Bool-shaped products can be constructed. This should not be an instance to avoid a cycle withhasbinaryproducts_hasproductsbool.Definitionhasproductsbool_hasbinaryproducts{A:Type} `{HasBinaryProductsA}:HasProductsBoolA.Proof.introsx.snrapplyBuild_Product.-exact(cat_binprod(xtrue) (xfalse)).-intros[|].+exactcat_pr1.+exactcat_pr2.-introszf.exact(cat_binprod_corec(ftrue) (ffalse)).-introszf[|].+exact(cat_binprod_beta_pr1(ftrue) (ffalse)).+exact(cat_binprod_beta_pr2(ftrue) (ffalse)).-introszfgp.nrapplycat_binprod_eta_pr.+exact(ptrue).+exact(pfalse).Defined.Operations on indexed productsWe can take the disjoint union of the index set of an indexed product if we have all binary products. This is useful for associating products in a canonical way. This leads to symmetry and associativity of binary products.Definitioncat_prod_index_sum{IJ:Type} {A:Type} `{HasBinaryProductsA}(x:I->A) (y:J->A):ProductIx->ProductJy->Product(I+J) (sum_ind_xy).Proof.introspq.snrapplyBuild_Product.-exact(cat_binprod(cat_prodIx) (cat_prodJy)).-intros[i|j].+exact(cat_pr_$ocat_pr1).+exact(cat_pr_$ocat_pr2).-introszf.nrapplycat_binprod_corec.+nrapplycat_prod_corec.exact(foinl).+nrapplycat_prod_corec.exact(foinr).-introszf[i|j].+nrefine(cat_assoc___$@_).nrefine((_$@Lcat_binprod_beta_pr1__) $@_).rapplycat_prod_beta.+nrefine(cat_assoc___$@_).nrefine((_$@Lcat_binprod_beta_pr2__) $@_).rapplycat_prod_beta.-introszfgr.rapplycat_binprod_eta_pr.+rapplycat_prod_pr_eta.introsi.exact((cat_assoc___)^$ $@r(inli) $@cat_assoc___).+rapplycat_prod_pr_eta.introsj.exact((cat_assoc___)^$ $@r(inrj) $@cat_assoc___).Defined.Binary product functorWe prove bifunctoriality ofcat_binprod:A->A->Aby factoring it ascat_prodBooloBool_recA. First, we prove thatBool_recA:A->A->(Bool->A)is a bifunctor.Local Instanceis0bifunctor_boolrec{A:Type} `{Is1CatA}:Is0Bifunctor(Bool_recA).Proof.snrapplyBuild_Is0Bifunctor'.1,2:exact_.snrapplyBuild_Is0Functor.intros[ab] [a'b'] [fg] [ | ].-exactf.-exactg.Defined.Local Instanceis1bifunctor_boolrec{A:Type} `{Is1CatA}:Is1Bifunctor(Bool_recA).Proof.snrapplyBuild_Is1Bifunctor'.snrapplyBuild_Is1Functor.-intros[ab] [a'b'] [fg] [f'g'] [pq] [ | ].+exactp.+exactq.-intros[ab] [ | ];reflexivity.-intros[ab] [a'b'] [a''b''] [ff'] [gg'] [ | ];reflexivity.Defined.As a special case of the product functor, restriction alongBool_recAyields bifunctoriality ofcat_binprod.Global Instanceis0bifunctor_cat_binprod{A:Type} `{HasBinaryProductsA}:Is0Bifunctor(funxy=>cat_binprodxy).Proof.pose(p:=@has_products______hasproductsbool_hasbinaryproducts).exact(is0bifunctor_postcompose(Bool_recA) (funx=>cat_prodBoolx(product:=px))).Defined.Global Instanceis1bifunctor_cat_binprod{A:Type} `{HasBinaryProductsA}:Is1Bifunctor(funxy=>cat_binprodxy).Proof.pose(p:=@has_products______hasproductsbool_hasbinaryproducts).exact(is1bifunctor_postcompose(Bool_recA) (funx=>cat_prodBoolx(product:=px))).Defined.Binary products are functorial in each argument.Global Instanceis0functor_cat_binprod_l{A:Type} `{HasBinaryProductsA}(y:A):Is0Functor(funx=>cat_binprodxy).Proof.exact(is0functor10_bifunctor_y).Defined.Global Instanceis1functor_cat_binprod_l{A:Type} `{HasBinaryProductsA}(y:A):Is1Functor(funx=>cat_binprodxy).Proof.exact(is1functor10_bifunctor_y).Defined.Global Instanceis0functor_cat_binprod_r{A:Type} `{HasBinaryProductsA}(x:A):Is0Functor(funy=>cat_binprodxy).Proof.exact(is0functor01_bifunctor_x).Defined.Global Instanceis1functor_cat_binprod_r{A:Type} `{HasBinaryProductsA}(x:A):Is1Functor(funy=>cat_binprodxy).Proof.exact(is1functor01_bifunctor_x).Defined.cat_binprod_corecis also functorial in each morphsism.Global Instanceis0functor_cat_binprod_corec_l{A:Type}`{HasBinaryProductsA} {xyz:A} (g:z$->y):Is0Functor(funf:z$->y=>cat_binprod_corecfg).Proof.snrapplyBuild_Is0Functor.introsff'p.bynrapplycat_binprod_corec_eta.Defined.Global Instanceis0functor_cat_binprod_corec_r{A:Type}`{HasBinaryProductsA} {xyz:A} (f:z$->x):Is0Functor(fung:z$->x=>cat_binprod_corecfg).Proof.snrapplyBuild_Is0Functor.introsghp.bynrapplycat_binprod_corec_eta.Defined.Definitioncat_pr1_fmap01_binprod{A:Type} `{HasBinaryProductsA}(a:A) {xy:A} (g:x$->y):cat_pr1$ofmap01(funxy=>cat_binprodxy)ag$==cat_pr1:=cat_binprod_beta_pr1__$@cat_idl_.Definitioncat_pr1_fmap10_binprod{A:Type} `{HasBinaryProductsA}{xy:A} (f:x$->y) (a:A):cat_pr1$ofmap10(funxy=>cat_binprodxy)fa$==f$ocat_pr1:=cat_binprod_beta_pr1__.Definitioncat_pr1_fmap11_binprod{A:Type} `{HasBinaryProductsA}{wxyz:A} (f:w$->y) (g:x$->z):cat_pr1$ofmap11(funxy=>cat_binprodxy)fg$==f$ocat_pr1:=cat_binprod_beta_pr1__.Definitioncat_pr2_fmap01_binprod{A:Type} `{HasBinaryProductsA}(a:A) {xy:A} (g:x$->y):cat_pr2$ofmap01(funxy=>cat_binprodxy)ag$==g$ocat_pr2:=cat_binprod_beta_pr2__.Definitioncat_pr2_fmap10_binprod{A:Type} `{HasBinaryProductsA}{xy:A} (f:x$->y) (a:A):cat_pr2$ofmap10(funxy=>cat_binprodxy)fa$==cat_pr2:=cat_binprod_beta_pr2__$@cat_idl_.Definitioncat_pr2_fmap11_binprod{A:Type} `{HasBinaryProductsA}{wxyz:A} (f:w$->y) (g:x$->z):cat_pr2$ofmap11(funxy=>cat_binprodxy)fg$==g$ocat_pr2:=cat_binprod_beta_pr2__.DiagonalAnnoyingly this doesn't follow directly from the general diagonal sincefunb=>ifbthenxelsexis not definitionally equal tofun_=>x.Definitioncat_binprod_diag{A:Type}`{Is1CatA} (x:A) `{!BinaryProductxx}:x$->cat_binprodxx.Proof.snrapplycat_binprod_corec;exact(Id_).Defined.Lemmas aboutcat_binprod_corecDefinitioncat_binprod_fmap01_corec{A:Type}`{Is1CatA, !HasBinaryProductsA} {wxyz:A}(f:w$->z) (g:x$->y) (h:w$->x):fmap01(funxy=>cat_binprodxy)zg$ocat_binprod_corecfh$==cat_binprod_corecf(g$oh).Proof.snrapplycat_binprod_eta_pr.-nrefine(cat_assoc_opp___$@_).refine((_$@R_) $@cat_assoc___$@cat_idl_$@_$@_^$).1-3:rapplycat_binprod_beta_pr1.-nrefine(cat_assoc_opp___$@_).refine((_$@R_) $@cat_assoc___$@ (_$@L_) $@_^$).1-3:rapplycat_binprod_beta_pr2.Defined.Definitioncat_binprod_fmap10_corec{A:Type}`{Is1CatA, !HasBinaryProductsA} {wxyz:A}(f:x$->y) (g:w$->x) (h:w$->z):fmap10(funxy=>cat_binprodxy)fz$ocat_binprod_corecgh$==cat_binprod_corec(f$og)h.Proof.snrapplycat_binprod_eta_pr.-refine(cat_assoc_opp___$@_).refine((_$@R_) $@cat_assoc___$@ (_$@L_) $@_^$).1-3:nrapplycat_binprod_beta_pr1.-refine(cat_assoc_opp___$@_).refine((_$@R_) $@cat_assoc___$@cat_idl_$@_$@_^$).1-3:nrapplycat_binprod_beta_pr2.Defined.Definitioncat_binprod_fmap11_corec{A:Type}`{Is1CatA, !HasBinaryProductsA} {vwxyz:A}(f:w$->y) (g:x$->z) (h:v$->w) (i:v$->x):fmap11(funxy=>cat_binprodxy)fg$ocat_binprod_corechi$==cat_binprod_corec(f$oh) (g$oi).Proof.snrapplycat_binprod_eta_pr.-refine(cat_assoc_opp___$@_).refine((_$@R_) $@cat_assoc___$@ (_$@L_) $@_^$).1-3:nrapplycat_binprod_beta_pr1.-nrefine(cat_assoc_opp___$@_).refine((_$@R_) $@cat_assoc___$@ (_$@L_) $@_^$).1-3:rapplycat_binprod_beta_pr2.Defined.Symmetry of binary productsSectionSymmetry.The requirement of having all binary products can be weakened further to having specific binary products, but it is not clear this is a useful generality.Context{A:Type} `{HasEquivsA} `{!HasBinaryProductsA}.Definitioncat_binprod_swap(xy:A) :cat_binprodxy$->cat_binprodyx:=cat_binprod_coreccat_pr2cat_pr1.Lemmacat_binprod_swap_cat_binprod_swap(xy:A):cat_binprod_swapxy$ocat_binprod_swapyx$==Id_.Proof.nrapplycat_binprod_eta_pr.-refine((cat_assoc___)^$ $@_).nrefine(cat_binprod_beta_pr1__$@R_$@_).exact(cat_binprod_beta_pr2__$@ (cat_idr_)^$).-refine((cat_assoc___)^$ $@_).nrefine(cat_binprod_beta_pr2__$@R_$@_).exact(cat_binprod_beta_pr1__$@ (cat_idr_)^$).Defined.Lemmacate_binprod_swap(xy:A):cat_binprodxy$<~>cat_binprodyx.Proof.snrapplycate_adjointify.1,2:nrapplycat_binprod_swap.all:nrapplycat_binprod_swap_cat_binprod_swap.Defined.Definitioncat_binprod_swap_corec{abc:A} (f:a$->b) (g:a$->c):cat_binprod_swapbc$ocat_binprod_corecfg$==cat_binprod_corecgf.Proof.nrapplycat_binprod_eta_pr.-refine(cat_assoc_opp___$@ (_$@R_) $@ (_$@_^$)).1,3:nrapplycat_binprod_beta_pr1.nrapplycat_binprod_beta_pr2.-refine(cat_assoc_opp___$@ (_$@R_) $@ (_$@_^$)).1,3:nrapplycat_binprod_beta_pr2.nrapplycat_binprod_beta_pr1.Defined.Definitioncat_binprod_swap_nat{abcd:A} (f:a$->c) (g:b$->d):cat_binprod_swapcd$ofmap11(funxy:A=>cat_binprodxy)fg$==fmap11(funxy:A=>cat_binprodxy)gf$ocat_binprod_swapab:=cat_binprod_swap_corec__$@ (cat_binprod_fmap11_corec____)^$.Local Instancesymmetricbraiding_binprod:SymmetricBraiding(funxy=>cat_binprodxy).Proof.snrapplyBuild_SymmetricBraiding.-snrapplyBuild_NatTrans.+intros[xy].exact(cat_binprod_swapxy).+snrapplyBuild_Is1Natural.intros[ab] [cd] [fg];cbninf,g.exact(cat_binprod_swap_natfg).-exactcat_binprod_swap_cat_binprod_swap.Defined.EndSymmetry.Associativity of binary productsSectionAssociativity.Context{A:Type} `{HasEquivsA} `{!HasBinaryProductsA}.Definitioncat_binprod_twist(xyz:A):cat_binprodx(cat_binprodyz) $->cat_binprody(cat_binprodxz).Proof.nrapplycat_binprod_corec.-exact(cat_pr1$ocat_pr2).-exact(fmap01(funxy=>cat_binprodxy)xcat_pr2).Defined.Definitioncat_binprod_pr1_twist(xyz:A):cat_pr1$ocat_binprod_twistxyz$==cat_pr1$ocat_pr2:=cat_binprod_beta_pr1__.Definitioncat_binprod_pr1_pr2_twist(xyz:A):cat_pr1$ocat_pr2$ocat_binprod_twistxyz$==cat_pr1.Proof.nrefine(cat_assoc___$@_).nrefine((_$@Lcat_binprod_beta_pr2__) $@_).nrapplycat_pr1_fmap01_binprod.Defined.Definitioncat_binprod_pr2_pr2_twist(xyz:A):cat_pr2$ocat_pr2$ocat_binprod_twistxyz$==cat_pr2$ocat_pr2.Proof.nrefine(cat_assoc___$@_).nrefine((_$@Lcat_binprod_beta_pr2__) $@_).nrapplycat_pr2_fmap01_binprod.Defined.Definitioncat_binprod_twist_corec{wxyz:A}(f:w$->x) (g:w$->y) (h:w$->z):cat_binprod_twistxyz$ocat_binprod_corecf(cat_binprod_corecgh)$==cat_binprod_corecg(cat_binprod_corecfh).Proof.nrapplycat_binprod_eta_pr.-nrefine(cat_assoc_opp___$@_).refine((_$@R_) $@cat_assoc___$@ (_$@L_) $@ (_$@_^$)).1:nrapplycat_binprod_pr1_twist.1:nrapplycat_binprod_beta_pr2.1,2:nrapplycat_binprod_beta_pr1.-refine(cat_assoc_opp___$@ (_$@R_) $@_$@ (cat_binprod_beta_pr2__)^$).1:nrapplycat_binprod_beta_pr2.nrefine(cat_binprod_fmap01_corec___$@_).nrapplycat_binprod_corec_eta.1:exact(Id_).nrapplycat_binprod_beta_pr2.Defined.Lemmacat_binprod_twist_cat_binprod_twist(xyz:A):cat_binprod_twistxyz$ocat_binprod_twistyxz$==Id_.Proof.nrapplycat_binprod_eta_pr_x_xx_id.-nrefine(cat_assoc_opp___$@ (cat_binprod_pr1_twist___$@R_) $@_).nrapplycat_binprod_pr1_pr2_twist.-nrefine(cat_assoc_opp___$@ (cat_binprod_pr1_pr2_twist___$@R_) $@_).nrapplycat_binprod_pr1_twist.-nrefine(cat_assoc_opp___$@ (cat_binprod_pr2_pr2_twist___$@R_) $@_).nrapplycat_binprod_pr2_pr2_twist.Defined.Definitioncate_binprod_twist(xyz:A):cat_binprodx(cat_binprodyz) $<~>cat_binprody(cat_binprodxz).Proof.snrapplycate_adjointify.1,2:nrapplycat_binprod_twist.1,2:nrapplycat_binprod_twist_cat_binprod_twist.Defined.Definitioncat_binprod_twist_nat{aa'bb'cc':A}(f:a$->a') (g:b$->b') (h:c$->c'):cat_binprod_twista'b'c'$ofmap11(funxy=>cat_binprodxy)f(fmap11(funxy=>cat_binprodxy)gh)$==fmap11(funxy=>cat_binprodxy)g(fmap11(funxy=>cat_binprodxy)fh)$ocat_binprod_twistabc.Proof.nrapplycat_binprod_eta_pr.-refine(cat_assoc_opp___$@_).nrefine((cat_binprod_beta_pr1__$@R_) $@_).nrefine(cat_assoc___$@_).nrefine((_$@L_) $@_).1:nrapplycat_pr2_fmap11_binprod.nrefine(cat_assoc_opp___$@_).nrefine((_$@R_) $@_).1:nrapplycat_pr1_fmap11_binprod.nrefine(_$@cat_assoc___).refine(_$@ (_^$ $@R_)).2:nrapplycat_pr1_fmap11_binprod.refine(cat_assoc___$@ (_$@L_^$) $@ (cat_assoc___)^$).nrapplycat_binprod_beta_pr1.-nrefine(cat_assoc_opp___$@ (cat_binprod_beta_pr2__$@R_) $@_).nrefine(_$@cat_assoc___).refine(_$@ (_^$ $@R_)).2:nrapplycat_pr2_fmap11_binprod.refine(_$@ (_$@L_^$) $@ (cat_assoc___)^$).2:nrapplycat_binprod_beta_pr2.refine(_^$ $@_$@_).1,3:rapplyfmap11_comp.rapplyfmap22.1:exact(cat_idl_$@ (cat_idr_)^$).nrapplycat_binprod_beta_pr2.Defined.Local Existing Instancesymmetricbraiding_binprod.Local Instanceassociator_cat_binprod:Associator(funxy=>cat_binprodxy).Proof.snrapplyassociator_twist.-exact_.-exactcat_binprod_twist.-exactcat_binprod_twist_cat_binprod_twist.-intros? ? ? ? ? ?;exactcat_binprod_twist_nat.Defined.Definitioncat_pr1_pr1_associator_binprodxyz:cat_pr1$ocat_pr1$oassociator_cat_binprodxyz$==cat_pr1.Proof.nrefine((_$@Lassociator_twist'_unfold________) $@_).nrefine(cat_assoc___$@ (_$@L(cat_assoc_opp___$@ (_$@R_))) $@_).1:nrapplycat_binprod_beta_pr1.do2nrefine(cat_assoc_opp___$@_).nrefine((cat_binprod_pr1_pr2_twist___$@R_) $@_).nrapplycat_pr1_fmap01_binprod.Defined.Definitioncat_pr2_pr1_associator_binprodxyz:cat_pr2$ocat_pr1$oassociator_cat_binprodxyz$==cat_pr1$ocat_pr2.Proof.nrefine((_$@Lassociator_twist'_unfold________) $@_).nrefine(cat_assoc___$@ (_$@L(cat_assoc_opp___$@ (_$@R_))) $@_).1:nrapplycat_binprod_beta_pr1.do2nrefine(cat_assoc_opp___$@_).nrefine((cat_binprod_pr2_pr2_twist___$@R_) $@_).nrefine(cat_assoc___$@ (_$@Lcat_pr2_fmap01_binprod__) $@_).exact(cat_assoc_opp___$@ (cat_binprod_beta_pr2__$@R_)).Defined.Definitioncat_pr2_associator_binprodxyz:cat_pr2$oassociator_cat_binprodxyz$==cat_pr2$ocat_pr2.Proof.nrefine((_$@Lassociator_twist'_unfold________) $@_).nrefine(cat_assoc_opp___$@ (cat_binprod_beta_pr2__$@R_) $@_).nrefine(cat_assoc_opp___$@ (cat_binprod_pr1_twist___$@R_) $@_).nrefine(cat_assoc___$@ (_$@Lcat_pr2_fmap01_binprod__) $@_).exact(cat_assoc_opp___$@ (cat_binprod_beta_pr1__$@R_)).Defined.Definitioncat_binprod_associator_corec{wxyz}(f:w$->x) (g:w$->y) (h:w$->z):associator_cat_binprodxyz$ocat_binprod_corecf(cat_binprod_corecgh)$==cat_binprod_corec(cat_binprod_corecfg)h.Proof.nrefine((associator_twist'_unfold________$@R_) $@_).nrefine((cat_assoc_opp___$@R_) $@cat_assoc___$@ (_$@L(_$@_)) $@_).1:nrapplycat_binprod_fmap01_corec.1:rapply(cat_binprod_corec_eta____(Id_)).1:nrapplycat_binprod_swap_corec.nrefine(cat_assoc___$@ (_$@L_) $@_).1:nrapplycat_binprod_twist_corec.nrapplycat_binprod_swap_corec.Defined.Context(unit:A) `{!IsTerminalunit}.Local Instanceright_unitor_binprod:RightUnitor(funxy=>cat_binprodxy)unit.Proof.snrapplyBuild_NatEquiv.-introsa;unfoldflip.snrapplycate_adjointify.+exactcat_pr1.+exact(cat_binprod_corec(Id_) (mor_terminal__)).+exact(cat_binprod_beta_pr1__).+nrapplycat_binprod_eta_pr.*nrefine(cat_assoc_opp___$@ (cat_binprod_beta_pr1__$@R_) $@_).exact(cat_idl_$@ (cat_idr_)^$).*nrefine(cat_assoc_opp___$@ (cat_binprod_beta_pr2__$@R_) $@_).exact((mor_terminal_unique___)^$ $@mor_terminal_unique___).-snrapplyBuild_Is1Natural.introsabf.refine((_$@R_) $@_$@ (_$@L_^$)).1,3:nrapplycate_buildequiv_fun.nrapplycat_binprod_beta_pr1.Defined.Local Existing Instanceleft_unitor_twist.Local Instancetriangle_binprod:TriangleIdentity(funxy=>cat_binprodxy)unit.Proof.snrapplytriangle_twist.introsab.refine(fmap02___$@_$@ ((_$@Lfmap02___^$) $@R_)).1,3:nrapplycate_buildequiv_fun.nrapplycat_binprod_eta_pr.-nrefine(cat_pr1_fmap01_binprod__$@_$@cat_assoc___).refine(_$@ (((_^$ $@R_) $@cat_assoc___) $@R_)).2:nrapplycat_binprod_beta_pr1.refine((_$@R_) $@_)^$.1:nrapplycat_pr2_fmap01_binprod.nrapplycat_binprod_pr1_pr2_twist.-nrefine(cat_pr2_fmap01_binprod__$@_$@cat_assoc___).refine(_$@ (((cat_binprod_beta_pr2__)^$ $@R_) $@cat_assoc___$@R_)).refine((_$@R_) $@_)^$.1:nrapplycat_pr1_fmap01_binprod.nrapplycat_binprod_beta_pr1.Defined.Local Instancepentagon_binprod:PentagonIdentity(funxy=>cat_binprodxy).Proof.introsabcd.nrapplycat_binprod_eta_pr_xx_x.-nrefine(cat_assoc_opp___$@ (_$@R_) $@_).1:nrapplycat_pr1_pr1_associator_binprod.refine(_$@ (_$@L((((_^$ $@R_) $@cat_assoc___) $@R_)$@cat_assoc___)) $@cat_assoc_opp___).2:nrapplycat_pr1_fmap10_binprod.do2nrefine(_$@ (_$@Lcat_assoc_opp___)).nrapplycat_binprod_eta_pr.+nrefine(cat_assoc_opp___$@_$@cat_assoc___).refine(_$@_$@ (_^$ $@R_) $@cat_assoc___).1,3:nrapplycat_pr1_pr1_associator_binprod.do2nrefine(_$@cat_assoc___).refine(_^$ $@ (_^$ $@R_)).2:nrapplycat_pr1_pr1_associator_binprod.nrapplycat_pr1_fmap01_binprod.+nrefine(cat_assoc_opp___$@_$@cat_assoc___).refine(_$@_$@ (_^$ $@R_) $@cat_assoc___).1,3:nrapplycat_pr2_pr1_associator_binprod.do2nrefine(_$@cat_assoc___).refine(_$@ ((cat_assoc___$@ (_$@L(_^$ $@cat_assoc___))$@cat_assoc_opp___$@cat_assoc_opp___) $@R_)).2:nrapplycat_pr2_pr1_associator_binprod.refine(_^$ $@ (_$@L_^$) $@cat_assoc_opp___).2:nrapplycat_pr2_fmap01_binprod.nrefine(cat_assoc_opp___$@ (_$@R_)).nrapplycat_pr1_pr1_associator_binprod.-nrefine(cat_assoc_opp___$@ (_$@R_) $@_).1:nrapplycat_pr2_pr1_associator_binprod.nrefine(cat_assoc___$@_$@cat_assoc_opp___).nrefine((_$@Lcat_pr2_associator_binprod___) $@_).refine(_$@ (_$@L((((_^$ $@R_) $@cat_assoc___) $@R_) $@cat_assoc___))).2:nrapplycat_pr1_fmap10_binprod.nrefine(_$@ (_$@L(cat_assoc_opp___$@cat_assoc_opp___))).refine(_$@ (_^$ $@R_) $@cat_assoc___).2:nrapplycat_pr2_associator_binprod.refine(_$@ (_$@L((_^$ $@R_) $@cat_assoc___$@cat_assoc___)) $@cat_assoc_opp___).2:nrapplycat_pr2_pr1_associator_binprod.refine(_$@ (_$@L((_$@L_^$) $@cat_assoc_opp___))).2:nrapplycat_pr2_fmap01_binprod.refine(cat_assoc_opp___$@ (_^$ $@R_) $@cat_assoc___$@cat_assoc___).nrapplycat_pr2_pr1_associator_binprod.-nrefine(cat_assoc_opp___$@ (cat_pr2_associator_binprod___$@R_) $@_).nrefine(cat_assoc___$@ (_$@L(cat_pr2_associator_binprod___)) $@_).refine(_$@ (_^$ $@R_) $@cat_assoc___$@ (_$@L(cat_assoc_opp___))).2:nrapplycat_pr2_fmap10_binprod.refine(_$@cat_assoc_opp___$@ (_^$ $@R_) $@cat_assoc___).2:nrapplycat_pr2_associator_binprod.refine(cat_assoc_opp___$@ (_^$ $@R_) $@cat_assoc___$@ (_$@L(cat_pr2_fmap01_binprod__)^$)).nrapplycat_pr2_associator_binprod.Defined.Local Instancehexagon_identity:HexagonIdentity(funxy=>cat_binprodxy).Proof.introsabc.nrefine(cat_assoc___$@_$@cat_assoc_opp___).nrapplycat_binprod_eta_pr.{nrefine(cat_assoc_opp___$@ (cat_pr1_fmap10_binprod__$@R_) $@_).nrefine(cat_assoc___$@_).nrapplycat_binprod_eta_pr.{nrefine(cat_assoc_opp___$@_$@cat_assoc___$@cat_assoc___).refine((_$@R_) $@_$@ (_^$ $@R_)).1:nrapplycat_binprod_beta_pr1.2:nrapplycat_pr1_pr1_associator_binprod.nrefine(cat_assoc_opp___$@cat_assoc_opp___$@_$@cat_assoc___).refine((_$@R_) $@_$@ (_^$ $@R_)).1:nrapplycat_pr2_pr1_associator_binprod.2:nrapplycat_binprod_beta_pr1.refine(cat_assoc___$@ (_$@L_) $@cat_assoc_opp___$@ (_$@R_) $@_^$).1:nrapplycat_pr2_fmap01_binprod.2:nrapplycat_pr2_associator_binprod.nrapplycat_binprod_beta_pr1. }nrefine(cat_assoc_opp___$@_$@cat_assoc___$@cat_assoc___).refine((_$@R_) $@_$@ (_^$ $@R_)).1:nrapplycat_binprod_beta_pr2.2:nrapplycat_pr2_pr1_associator_binprod.nrefine(cat_assoc_opp___$@cat_assoc_opp___$@_$@cat_assoc___).refine((_$@R_) $@_$@ (((_$@L_^$) $@cat_assoc_opp___) $@R_)).1:nrapplycat_pr1_pr1_associator_binprod.2:nrapplycat_binprod_beta_pr2.refine(cat_pr1_fmap01_binprod__$@_^$).nrapplycat_pr1_pr1_associator_binprod. }nrefine(cat_assoc_opp___$@_$@cat_assoc___$@cat_assoc___).refine((_$@R_) $@_$@ ((_^$ $@R_) $@R_)).1:nrapplycat_pr2_fmap10_binprod.2:nrapplycat_pr2_associator_binprod.nrefine(cat_assoc_opp___$@ (cat_pr2_associator_binprod___$@R_) $@_).nrefine(cat_assoc___$@ (_$@L_) $@_$@ (cat_assoc_opp___$@R_)).1:nrapplycat_pr2_fmap01_binprod.refine(cat_assoc_opp___$@ (_$@R_) $@_^$ $@ ((_$@L_^$) $@R_)).1,3:nrapplycat_binprod_beta_pr2.nrapplycat_pr2_pr1_associator_binprod.Defined.Global Instanceismonoidal_cat_binprod:IsMonoidalA(funxy=>cat_binprodxy)unit:= {}.Global Instanceissymmetricmonoidal_cat_binprod:IsSymmetricMonoidalA(funxy=>cat_binprodxy)unit:= {}.EndAssociativity.Products in TypeSince we use the Yoneda lemma in this file, we therefore depend on WildCat.Universe which means these instances have to live here.Global Instancehasbinaryproducts_type:HasBinaryProductsType.Proof.introsXY.snrapplyBuild_BinaryProduct.-exact(X*Y).-exactfst.-exactsnd.-introsZfgz.exact(fz,gz).-reflexivity.-reflexivity.-introsZfgpqx.nrapplypath_prod.+exact(px).+exact(qx).Defined.AssumingFunext,Typehas all products.Global Instancehasallproducts_type`{Funext} :HasAllProductsType.Proof.introsIx.snrapplyBuild_Product.-exact(forall(i:I),xi).-introsif.exact(fi).-introsAfai.exact(fia).-reflexivity.-introsAfgpa.exact(path_forall__(funi=>pia)).Defined.

--- Miscellaneous\Profunctor.html ---
ProfunctorLibrary ProfunctorProfunctorsRequireExportProfunctor.Notations.DefinitionRequireProfunctor.Core.Identity ProfunctorRequireProfunctor.Identity.Representable ProfunctorsRequireProfunctor.Representable.IncludeProfunctor.Core.IncludeProfunctor.Representable.IncludeProfunctor.Identity.

--- Miscellaneous\Projection.html ---
ProjectionLibrary ProjectionProjection functors from comma categoriesRequireImportCategory.CoreFunctor.Core.RequireImportCategory.ProdFunctor.Prod.Core.RequireImportFunctor.Composition.CoreFunctor.Identity.RequireImportInitialTerminalCategory.Functors.RequireComma.Core.RequireImportTypes.Prod.LocalSetWarningsAppend"-notation-overridden".(* work around bug 5567, https://coq.inria.fr/bugs/show_bug.cgi?id=5567, notation-overridden,parsing should not trigger for only printing notations *)ImportComma.Core.LocalSetWarningsAppend"notation-overridden".(* work around bug 5567, https://coq.inria.fr/bugs/show_bug.cgi?id=5567, notation-overridden,parsing should not trigger for only printing notations *)SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.Local OpenScopecategory_scope.First projection(S/T)→A×B(forS:A→C←B:T)Sectioncomma_category.VariablesABC:PreCategory.VariableS:FunctorAC.VariableT:FunctorBC.Definitioncomma_category_projection:Functor(S/T) (A*B):=Build_Functor(S/T) (A*B)(funabf=> (CommaCategory.aabf,CommaCategory.babf)%core)(fun__m=> (CommaCategory.gm,CommaCategory.hm)%core)(fun_____=>idpath)(fun_=>idpath).Endcomma_category.First projections(S/a)→Aand(a/S)→ASectionslice_category.VariableA:PreCategory.Local ArgumentsFunctor.Composition.Core.compose/ .Local ArgumentsFunctor.Composition.Core.compose_composition_of/ .Local ArgumentsFunctor.Composition.Core.compose_identity_of/ .Local Argumentspath_prod/ .Local Argumentspath_prod'/ .Local Argumentspath_prod_uncurried/ .Definitionarrow_category_projection:Functor(arrow_categoryA)A:=Evalsimplinfstocomma_category_projection_1.Definitionslice_category_over_projection(a:A) :Functor(A/a)A:=Evalsimplinfstocomma_category_projection1_.Definitioncoslice_category_over_projection(a:A) :Functor(a\A)A:=Evalsimplinsndocomma_category_projection_1.Sectionslice_coslice.VariableC:PreCategory.Variablea:C.VariableS:FunctorAC.Definitionslice_category_projection:Functor(S/a)A:=Evalsimplinfstocomma_category_projectionS!a.Definitioncoslice_category_projection:Functor(a/S)A:=Evalsimplinsndocomma_category_projection!aS.Endslice_coslice.Endslice_category.

--- Miscellaneous\ProjectionFunctors.html ---
ProjectionFunctorsLibrary ProjectionFunctorsFunctoriality of the comma category construction with projection functorsRequireImportCategory.CoreFunctor.Core.RequireImportCategory.ProdFunctor.Prod.Core.RequireImportCategory.DualFunctor.Dual.RequireImportFunctor.Composition.Core.RequireImportInitialTerminalCategory.CoreInitialTerminalCategory.FunctorsNatCategory.RequireImportFunctorCategory.Core.RequireImportCat.Core.RequireImportFunctor.Paths.RequireComma.Core.LocalSetWarningsAppend"-notation-overridden".(* work around bug 5567, https://coq.inria.fr/bugs/show_bug.cgi?id=5567, notation-overridden,parsing should not trigger for only printing notations *)ImportComma.Core.LocalSetWarningsAppend"notation-overridden".RequireImportComma.InducedFunctorsComma.Projection.RequireProductLawsExponentialLaws.Law1.FunctorsExponentialLaws.Law4.Functors.RequireImportTypes.ForallPathGroupoidsHoTT.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Functor from(A→C)ᵒᵖ×(B→C)tocat/(A×B)It sendsS:A→C←B:Tto the category(S/T)and its projection functor toA×B.Sectioncomma.Local OpenScopetype_scope.Context`{Funext}.VariableP:PreCategory->Type.Context`{HF:forallCD,PC->PD->IsHSet(FunctorCD)}.Local NotationCat:= (@sub_pre_cat_PHF).VariablesABC:PreCategory.HypothesisPAB:P(A*B).HypothesisP_comma:forall(S:FunctorAC) (T:FunctorBC),P(S/T).Local OpenScopecategory_scope.Local OpenScopemorphism_scope.Definitioncomma_category_projection_functor_object_of(ST:object((A->C)^op* (B->C))):Cat/ !((A*B;PAB) :Cat).Proof.exists(Basics.Overture.fstST/Basics.Overture.sndST;P_comma__) (center_).exact(comma_category_projection(Basics.Overture.fstST) (Basics.Overture.sndST)).Defined.Definitioncomma_category_projection_functor_morphism_ofsd(m:morphism((A->C)^op* (B->C))sd):morphism(Cat/ !((A*B;PAB) :Cat))(comma_category_projection_functor_object_ofs)(comma_category_projection_functor_object_ofd).Proof.hnf.refine(CommaCategory.Build_morphism(comma_category_projection_functor_object_ofs)(comma_category_projection_functor_object_ofd)(comma_category_induced_functorm)(center_)_).simpl.destruct_head_hnfBasics.Overture.prod.path_functor.Defined.Local Ltaccomma_laws_t:=repeat(applypath_forall||intro);simpl;rewrite!transport_forall_constant;transport_path_forall_hammer;simpl;destruct_headBasics.Overture.prod;simplin*;applyCommaCategory.path_morphism;simpl;repeatmatchgoalwith| [ |-context[?f_______(transport?P?p?z)] ]=>simplrewrite(@ap_transport_P___p(fun_=>f_______)z)| [ |-context[transport(funy=> ?f(?fa_____y) ?x)] ]=>rewrite(funab=> @transport_compose__ab(funy=>fyx) (fa_____))| [ |-context[transport(funy=> ?f?x(?fa_____y))] ]=>rewrite(funab=> @transport_compose__ab(funy=>fxy) (fa_____))end;unfoldcomma_category_induced_functor_object_of_identity;unfoldcomma_category_induced_functor_object_of_compose;simpl;rewrite?CommaCategory.ap_a_path_object', ?CommaCategory.ap_b_path_object';tryreflexivity.Lemmacomma_category_projection_functor_identity_ofx:comma_category_projection_functor_morphism_of(Category.Core.identityx)= 1.Proof.applyCommaCategory.path_morphism;simpl; [ |reflexivity].path_functor.exists(path_forall__(comma_category_induced_functor_object_of_identity_)).comma_laws_t.Qed.Lemmacomma_category_projection_functor_composition_ofsdd'mm':comma_category_projection_functor_morphism_of(@Category.Core.compose_sdd'm'm)= (comma_category_projection_functor_morphism_ofm')o(comma_category_projection_functor_morphism_ofm).Proof.applyCommaCategory.path_morphism;simpl; [ |reflexivity].path_functor.simpl.exists(path_forall__(comma_category_induced_functor_object_of_composem'm)).comma_laws_t.Qed.Definitioncomma_category_projection_functor:Functor((A->C)^op* (B->C))(Cat/ !((A*B;PAB) :Cat)):=Build_Functor((A->C)^op* (B->C))(Cat/ !((A*B;PAB) :Cat))comma_category_projection_functor_object_ofcomma_category_projection_functor_morphism_ofcomma_category_projection_functor_composition_ofcomma_category_projection_functor_identity_of.Endcomma.Sectionslice_category_projection_functor.Local OpenScopetype_scope.Context`{Funext}.VariableP:PreCategory->Type.Context`{HF:forallCD,PC->PD->IsHSet(FunctorCD)}.Local NotationCat:= (@sub_pre_cat_PHF).VariablesCD:PreCategory.HypothesisP1C:P(1 *C).HypothesisPC1:P(C* 1).HypothesisPC:PC.HypothesisP_comma:forall(S:FunctorCD) (T:Functor1D),P(S/T).HypothesisP_comma':forall(S:Functor1D) (T:FunctorCD),P(S/T).Local OpenScopefunctor_scope.Local OpenScopecategory_scope.Local NotationinvD:= (@ExponentialLaws.Law1.Functors.inverse_terminal_category___D).Functor(C→D)ᵒᵖ→D→(cat/C)Definitionslice_category_projection_functor:object(((C->D)^op) -> (D-> (Cat/ ((C;PC) :Cat)))).Proof.refine((ExponentialLaws.Law4.Functors.inverse___)_).refine(_o(Functor.Identity.identity(C->D)^op,invD)).refine(_o@comma_category_projection_functor_PHFC1DPC1P_comma).refine(cat_over_induced_functor_).hnf.exact(ProductLaws.Law1.functor_).Defined.Definitioncoslice_category_projection_functor:object((C->D)^op-> (D-> (Cat/ ((C;PC) :Cat)))).Proof.refine((ExponentialLaws.Law4.Functors.inverse___)_).refine(_o(Functor.Identity.identity(C->D)^op,invD)).refine(_o@comma_category_projection_functor_PHFC1DPC1P_comma).refine(cat_over_induced_functor_).hnf.exact(ProductLaws.Law1.functor_).Defined.Functor(C→D)→Dᵒᵖ→(cat/C)Definitionslice_category_projection_functor':object((C->D) -> (D^op-> (Cat/ ((C;PC) :Cat)))).Proof.refine((ExponentialLaws.Law4.Functors.inverse___)_).refine(_o(Functor.Identity.identity(C->D),(invD)^op)).refine(_oProductLaws.Swap.functor__).refine(_o@comma_category_projection_functor_PHF1CDP1CP_comma').refine(cat_over_induced_functor_).hnf.exact(ProductLaws.Law1.functor'_).Defined.Definitioncoslice_category_projection_functor':object((C->D) -> (D^op-> (Cat/ ((C;PC) :Cat)))).Proof.refine((ExponentialLaws.Law4.Functors.inverse___)_).refine(_o(Functor.Identity.identity(C->D),(invD)^op)).refine(_oProductLaws.Swap.functor__).refine(_o@comma_category_projection_functor_PHF1CDP1CP_comma').refine(cat_over_induced_functor_).hnf.exact(ProductLaws.Law1.functor'_).Defined.Endslice_category_projection_functor.

--- Miscellaneous\Projective.html ---
ProjectiveLibrary ProjectiveRequireImportBasicsTypes.RequireImportTruncations.CoreTruncations.SeparatedTrunc.RequireImportModalities.ModalityModalities.Identity.RequireImportLimits.Pullback.Projective typesTo quantify over all truncation levels including infinity, we parametrizeIsOProjectiveby aModality. When specializing toIsOProjectivepurelywe get an (oo,-1)-projectivity predicate,IsProjective. When specializing toIsOProjective(Trn)we get an (n,-1)-projectivity predicate,IsTrProjective.DefinitionIsOProjective(O:Modality) (X:Type) :Type:=forallA,InOA->forallB,InOB->forallf:X->B,forallp:A->B,IsSurjectionp->merely(existss:X->A,pos==f).(oo,-1)-projectivity.NotationIsProjective:= (IsOProjectivepurely).(n,-1)-projectivity.NotationIsTrProjectiven:= (IsOProjective(Trn)).A type X is projective if and only if surjections into X merely split.Propositioniff_isoprojective_surjections_split(O:Modality) (X:Type) `{InOX}:IsOProjectiveOX<->(forall(Y:Type),InOY->forall(p:Y->X),IsSurjectionp->merely(existss:X->Y,pos==idmap)).Proof.split.-introsisprojXYoYpS;unfoldIsOProjectiveinisprojX.exact(isprojXY_X_idmappS).-introsplits.unfoldIsOProjective.introsAoABoBfpS.poseproof(splits(Pullbackpf)_pullback_pr2_)ass'.strip_truncations.destructs'as[sE].refine(tr(pullback_pr1os;_)).introx.refine(pullback_commsqpf(sx) @_).apply(apf).applyE.Defined.Corollaryequiv_isoprojective_surjections_split`{Funext} (O:Modality) (X:Type) `{InOX}:IsOProjectiveOX<~>(forall(Y:Type),InOY->forall(p:Y->X),IsSurjectionp->merely(existss:X->Y,pos==idmap)).Proof.exact(equiv_iff_hprop_uncurried(iff_isoprojective_surjections_splitOX)).Defined.Projectivity and the axiom of choiceIn topos theory, an object X is said to be projective if the axiom of choice holds when making choices indexed by X. We will refer to this asHasOChoice, to avoid confusion withIsOProjectiveabove. In similarity withIsOProjective, we parametrize it by aModality.ClassHasOChoice(O:Modality) (A:Type) :=hasochoice:forall(B:A->Type), (forallx,InO(Bx)) ->(forallx,merely(Bx)) ->merely(forallx,Bx).(oo,-1)-choice.NotationHasChoice:= (HasOChoicepurely).(n,-1)-choice.NotationHasTrChoicen:= (HasOChoice(Trn)).Global Instancehasochoice_sigma`{Funext} {A:Type} {B:A->Type} (O:Modality)(chA:HasOChoiceOA)(chB:foralla:A,HasOChoiceO(Ba)):HasOChoiceO{a:A|Ba}.Proof.introsCsCf.set(f':=funa=>chBa(funb=>C(a;b))_(funb=>f(a;b))).specialize(chA(funa=>forallb,C(a;b))_f').strip_truncations.applytr.intro.applychA.Defined.Propositionisoprojective_ochoice(O:Modality) (X:Type):HasOChoiceOX->IsOProjectiveOX.Proof.introschXA?B?fpS.assert(g:merely(forallx:X,hfiberp(fx))).-rapplychX.introx.exact(center_).-strip_truncations;applytr.exists(funx:X=>pr1(gx)).introx.exact(gx).2.Defined.Propositionhasochoice_oprojective(O:Modality) (X:Type) `{InOX}:IsOProjectiveOX->HasOChoiceOX.Proof.refine(_ofst(iff_isoprojective_surjections_splitOX)).introssplitsPoPS.specializesplitswith{x:X&Px}pr1.poseproof(splits_(fst(iff_merely_issurjectionP)S))asM.clearSsplits.strip_truncations;applytr.destructMas[sp].introx.exact(transport_(px) (sx).2).Defined.Propositioniff_isoprojective_hasochoice(O:Modality) (X:Type) `{InOX}:IsOProjectiveOX<->HasOChoiceOX.Proof.split.-applyhasochoice_oprojective.exact_.-applyisoprojective_ochoice.Defined.Propositionequiv_isoprojective_hasochoice`{Funext} (O:Modality) (X:Type) `{InOX}:IsOProjectiveOX<~>HasOChoiceOX.Proof.refine(equiv_iff_hprop_uncurried(iff_isoprojective_hasochoiceOX)).applyistrunc_forall.Defined.Propositionisprojective_unit:IsProjectiveUnit.Proof.apply(isoprojective_ochoicepurelyUnit).introsPtrPS.specializeSwithtt.strip_truncations;applytr.applyUnit_ind.exactS.Defined.SectionAC_oo_neg1.Projectivity and AC(oo,-1) (defined in HoTT book, Exercise 7.8)(* TODO: Generalize to n, m. *)Context{AC:forallX:HSet,HasChoiceX}.(Exercise 7.9) Assuming AC(oo,-1) every type merely has a projective cover.Propositionprojective_cover_AC`{Univalence} (A:Type):merely(existsX:HSet,existsp:X->A,IsSurjectionp).Proof.pose(X:=Build_HSet(Tr0A)).poseproof((equiv_isoprojective_hasochoice_X)^-1 (ACX))asP.poseproof(PA_X_idmaptr_)asF;clearP.strip_truncations.destructFas[fp].refine(tr(X; (f;BuildIsSurjectionf_))).introa;unfoldhfiber.applyequiv_O_sigma_O.refine(tr(tra;_)).rapply(equiv_path_Tr__)^-1%equiv.(* Uses Univalence. *)applyp.Defined.Assuming AC(oo,-1), projective types are exactly sets.Theoremequiv_isprojective_ishset_AC`{Univalence} (X:Type):IsProjectiveX<~>IsHSetX.Proof.applyequiv_iff_hprop.-introisprojX.unfoldIsOProjectiveinisprojX.poseproof(projective_cover_ACX)asP;strip_truncations.destructPas[P[pissurj_p]].poseproof(isprojXP_X_idmappissurj_p)asS;strip_truncations.exact(inO_retract_inO(Tr0)XPS.1pS.2).-introishsetX.apply(equiv_isoprojective_hasochoicepurelyX)^-1.rapplyAC.Defined.EndAC_oo_neg1.

--- Miscellaneous\Properties.html ---
PropertiesLibrary PropertiesProperties of pointwise functorsRequireImportCategory.CoreFunctor.CoreFunctor.Pointwise.CoreNaturalTransformation.CoreNaturalTransformation.PathsFunctor.Composition.CoreFunctor.IdentityFunctor.Paths.RequireImportPathGroupoidsTypes.ForallHoTT.Tactics.RequireImportBasics.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Local OpenScopefunctor_scope.Sectionparts.Context`{Funext}.We could do this all in a bigrepeatmatch, but we split it
      up, to shave off about two seconds per proof.Local Ltacfunctor_pointwise_thelper_lem_matchhelper_lem:=repeat(applypath_forall;intro);rewrite!transport_forall_constant, !path_forall_2_beta;path_natural_transformation;repeatmatchgoalwith| [ |-context[components_of(transport?P?p?z)] ]=>simplrewrite(@ap_transport_P___p(fun_=>components_of)z)end;rewrite!transport_forall_constant;transport_to_ap;repeatmatchgoalwith| [x:_|-context[ap(funx3: ?T=> ?f(object_ofx3?z))] ]=>rewrite(@ap_compose'___(funx3':T=>object_ofx3') (funOx3=>f(Ox3x)))| [x:_|-context[ap(funx3: ?T=> ?f(object_ofx3?z) ?w)] ]=>rewrite(@ap_compose'___(funx3':T=>object_ofx3') (funOx3=>f(Ox3x)w))end;repeatmatchgoalwith|_=>done| [ |-context[funF=> @object_of?C?DF] ]=>progresschange(funF'=> @object_ofCDF')with(@object_ofCD)| [ |-context[helper_lem_match?x] ]=>rewrite(helper_lemx)end.respects identitySectionidentity_of.VariablesCD:PreCategory.Lemmaidentity_of_helper_helper(x:FunctorCD): 1oxo1 =x.Proof.path_functor.Defined.Definitionidentity_of_helper_helper_object_ofx:apobject_of(identity_of_helper_helperx) =idpath:=path_functor_uncurried_fst___.Lemmaidentity_of_helper: (funx:FunctorCD=> 1oxo1) =idmap.Proof.applypath_forall;introx.applyidentity_of_helper_helper.Defined.Lemmaidentity_of:pointwise(identityC) (identityD) =identity_.Proof.path_functor.existsidentity_of_helper.unfoldidentity_of_helper.abstractfunctor_pointwise_tidentity_of_helper_helperidentity_of_helper_helper_object_of.Defined.Endidentity_of.respects compositionSectioncomposition_of.VariablesCDC'D'C''D'':PreCategory.VariableF':FunctorC'C''.VariableG:FunctorDD'.VariableF:FunctorCC'.VariableG':FunctorD'D''.Lemmacomposition_of_helper_helper(x:FunctorC''D):G'oGoxo(F'oF) =G'o(GoxoF')oF.Proof.path_functor.Defined.Definitioncomposition_of_helper_helper_object_ofx:apobject_of(composition_of_helper_helperx) =idpath:=path_functor_uncurried_fst___.Lemmacomposition_of_helper: (funx=>G'oGoxo(F'oF)) = (funx=>G'o(GoxoF')oF).Proof.applypath_forall;introx.applycomposition_of_helper_helper.Defined.Lemmacomposition_of:pointwise(F'oF) (G'oG) =pointwiseFG'opointwiseF'G.Proof.path_functor.existscomposition_of_helper.unfoldcomposition_of_helper.abstractfunctor_pointwise_tcomposition_of_helper_helpercomposition_of_helper_helper_object_of.Defined.Endcomposition_of.Endparts.

--- Miscellaneous\PropResizing.html ---
PropResizingLibrary PropResizingRequireImportBasics.Overture.To assume the PropResizing axiom outright, import this file. (Doing this instead of simply positing PropResizing directly avoids creating multiple witnesses for the axiom in different developments.)Axiompropresizing_axiom:PropResizing.Global Existing Instancepropresizing_axiom.

--- Miscellaneous\PropTrunc.html ---
PropTruncLibrary PropTruncRequireImportBasicsTypes.RequireImportDiagrams.Sequence.RequireImportHomotopy.Join.Core.RequireImportColimits.ColimitColimits.Sequential.Local OpenScopenat_scope.Propositonal truncation as a colimit.In this file we give an alternative construction of the propositional truncation using colimits. This can serve as a metatheoretic justification that propositional truncations exist.The sequence of increasing joins.DefinitionJoin_seq(A:Type) :Sequence.Proof.srapplyBuild_Sequence.1:exact(iterated_joinA).introsn.exactjoinr.Defined.Propositional truncation can be defined as the colimit of this sequence.DefinitionPropTruncA:Type:=Colimit(Join_seqA).The constructor is given by the colimit constructor.Definitionptr_in{A} :A->PropTruncA:=colim(D:=Join_seqA) 0.The sequential colimit of this sequence is the propositional truncation.Universal property of propositional truncation.Lemmaequiv_PropTrunc_rec`{Funext} (AP:Type) `{IsHPropP}: (PropTruncA->P) <~> (A->P).Proof.refine(_oEequiv_colim_seq_rec_P).srapplyequiv_iff_hprop.{introsh.exact(h0). }introsf.inductionn.-exactf.-cbn.srapplyJoin_rec.1,2:assumption.introsab.rapplypath_ishprop.Defined.The propositional truncation is a hprop.Global Instanceishprop_proptrunc`{Funext} (A:Type):IsHProp(PropTruncA).Proof.rapplyhprop_inhabited_contr.rapply(equiv_PropTrunc_rec__)^-1.introsx.srapplycontr_colim_seq_into_prop.-introsn.destructn.1:exactx.exact(joinlx).-introsn.rapplyjglue.Defined.

--- Miscellaneous\pSect.html ---
pSectLibrary pSectRequireImportBasicsTypesPointed.CorePointed.pEquiv.Pointed sections of pointed mapsLocal OpenScopepointed_scope.(* The type of pointed sections of a pointed map. *)DefinitionpSect{AB:pType} (f:A->*B):= {s:B->*A&fo*s==*pmap_idmap}.Definitionissig_psect{AB:pType} (f:A->*B): {s:B->A& {p:spt=pt& {H:fos==idmap&Hpt=apfp@ (point_eqf) } } }<~>pSectf.Proof.transitivity{s:B->A& {p:spt=pt& {H:fos==idmap&Hpt=apfp@ (point_eqf) @ 1 }}}.2:make_equiv.do3 (nrapplyequiv_functor_sigma_id;intro).rapplyequiv_concat_r.exact(concat_p1_)^.Defined.Any pointed equivalence overAinduces an equivalence between pointed sections.Definitionequiv_pequiv_pslice_psect`{Funext} {ABC:pType}(f:B->*A) (g:C->*A) (t:B<~>*C) (h:f==*go*t):pSectf<~>pSectg.Proof.srapplyequiv_functor_sigma'.1:exact(pequiv_pequiv_postcomposet).intros;cbn.applyequiv_phomotopy_concat_l.refine((pmap_compose_assoc___)^* @*_).applypmap_prewhisker.exacth^*.Defined.Pointed sections ofpsnd:A*B->*Bcorrespond to pointed mapsB->*A.Definitionequiv_psect_psnd`{Funext} {AB:pType}:pSect(@psndAB) <~> (B->*A).Proof.unfoldpSect.transitivity{s: (B->*A) * (B->*B) &snds==*pmap_idmap}.{snrefine(equiv_functor_sigma'(equiv_pprod_coind(pfam_constA) (pfam_constB))^-1%equiv_).cbn.intros.applyequiv_phomotopy_concat_l.srapplyBuild_pHomotopy.1:reflexivity.cbn.applymoveL_pV.exact(concat_1p_@concat_p1_). }snrefine(_oEequiv_functor_sigma_id(funs=>equiv_path_pforall__)).snrefine(_oE(equiv_functor_sigma_pb(equiv_sigma_prod0__))^-1%equiv);cbn.refine(_oE(equiv_sigma_assoc__)^-1%equiv).rapplyequiv_sigma_contr.Defined.

--- Miscellaneous\Pseudofunctor.html ---
PseudofunctorLibrary PseudofunctorPseudofunctorsDefinitionRequirePseudofunctor.Core.Helper lemmas for rewritingRequirePseudofunctor.RewriteLaws.Construction from a functor to catRequirePseudofunctor.FromFunctor.Identity pseudofunctorRequirePseudofunctor.Identity.IncludePseudofunctor.Core.IncludePseudofunctor.RewriteLaws.IncludePseudofunctor.FromFunctor.IncludePseudofunctor.Identity.

--- Miscellaneous\Pseudofunctors.html ---
PseudofunctorsLibrary PseudofunctorsPseudofunctors from initial and terminal categoriesRequireImportCategory.CoreFunctor.Core.RequireImportFunctor.Identity.RequireImportPseudofunctor.Core.RequireImportInitialTerminalCategory.Core.RequireImportFunctorCategory.Morphisms.RequireImportNaturalTransformation.Paths.RequireImportNatCategory.RequireImportPathGroupoids.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Sectionpseudofunctors.Constant functor from any terminal categoryDefinitionfrom_terminal`{Funext} `{@IsTerminalCategoryoneHoneHone'}(c:PreCategory):Pseudofunctorone.Proof.refine(Build_Pseudofunctorone(fun_=>c)(fun___=> 1%functor)(fun_____=>reflexivity_)(fun_=>reflexivity_)___);simpl;abstract(intros;path_natural_transformation;rewriteap_const;simpl;reflexivity).Defined.Functor from any initial categoryDefinitionfrom_initial`{Funext} `{@IsInitialCategoryzero}:Pseudofunctorzero:=Build_Pseudofunctorzero(funx=>initial_category_ind_x)(funx__=>initial_category_ind_x)(funx____=>initial_category_ind_x)(funx=>initial_category_ind_x)(funx=>initial_category_ind_x)(funx=>initial_category_ind_x)(funx=>initial_category_ind_x).Endpseudofunctors.Local Argumentsfrom_terminal/ .Local Argumentsfrom_initial/ .Definitionfrom_1`{Funext}c:Pseudofunctor1:=Evalsimplinfrom_terminalc.Definitionfrom_0`{Funext} :Pseudofunctor0:=Evalsimplinfrom_initial.Local Notation"! x" := (@from_terminal_terminal_category___x) :pseudofunctor_scope.ModuleExportInitialTerminalCategoryPseudofunctorsNotations.Notation"! x" := (@from_terminal_terminal_category___x) :pseudofunctor_scope.EndInitialTerminalCategoryPseudofunctorsNotations.

--- Miscellaneous\PseudofunctorToCat.html ---
PseudofunctorToCatLibrary PseudofunctorToCatGrothendieck Construction of a pseudofunctor to CatRequireImportFunctorCategory.Morphisms.RequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportPseudofunctor.CorePseudofunctor.RewriteLaws.RequireImportCategory.MorphismsCat.Morphisms.RequireImportFunctor.Composition.Core.RequireImportFunctor.Identity.RequireImportFunctorCategory.Core.RequireImportBasicsTypesHoTT.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.SectionGrothendieck.Context`{Funext}.VariableC:PreCategory.VariableF:PseudofunctorC.RecordPair:={c:C;x:object(Fc)}.Local Notationmorphismsd:={f:morphismCs.(c)d.(c)|morphism_(p_morphism_ofFfs.(x))d.(x) }.Definitioncomposesdd'(m1:morphismdd')(m2:morphismsd):morphismsd'.Proof.exists(m1.1om2.1).refine(m1.2o((p_morphism_ofFm1.1)_1m2.2o_)).apply(p_composition_ofF).Defined.Definitionidentitys:morphismss.Proof.exists1.apply(p_identity_ofF).Defined.Global Argumentsidentity_/ .Global Argumentscompose_____/ .Local Ltactry_associativity_f_ap:=first[f_ap; []|repeat(etransitivity; [applyCategory.Core.associativity| ]);repeat(etransitivity; [ |symmetry;applyCategory.Core.associativity]);f_ap; []|repeat(etransitivity; [symmetry;applyCategory.Core.associativity| ]);repeat(etransitivity; [ |applyCategory.Core.associativity]);f_ap; [] ].Local Ltacassoc_before_commutes_tac:=rewrite!composition_of;rewrite<- !Category.Core.associativity;etransitivity; [ |symmetry;applycompose4associativity_helper].Local Ltacassoc_fin_tac:=repeatmatchgoalwith|_=>reflexivity|_=>progressrewrite?Category.Core.left_identity, ?Category.Core.right_identity| [ |-context[components_of?T?xocomponents_of?T^-1 ?x] ]=>letk:=constr:(@iso_compose_pV___(Tx)_)insimplrewritek(* https://coq.inria.fr/bugs/show_bug.cgi?id=3773 and https://coq.inria.fr/bugs/show_bug.cgi?id=3772 (probably) *)|_=>try_associativity_quickfirst[f_ap; []|applyconcat_left_identity|applyconcat_right_identity]|_=>rewrite<- ?identity_of, <- ?composition_of;progressrepeat(f_ap; []);rewrite?identity_of, ?composition_of|_=>try_associativity_quickrewritecompose4associativity_helperend.Local Ltachelper_tbefore_commutes_tac:=repeatintro;symmetry;applypath_sigma_uncurried;simplin*;letex_hyp:=matchgoalwith| [H: ?A= ?B|- @sig(?B= ?A)_] =>constr:(H)endin(exists(inverseex_hyp));simpl;rewrite?transport_Fc_to_idtoiso, ?transport_cF_to_idtoiso;rewrite?idtoiso_inv, ?ap_V, ?inv_V;simpl;letrew_hyp:=matchgoalwith| [H':context[ex_hyp] |-_] =>constr:(H')endinrewriterew_hyp;clearrew_hypex_hyp;before_commutes_tac;repeatfirst[reflexivity|progressrewrite?Category.Core.left_identity, ?Category.Core.right_identity|try_associativity_quick(f_ap; []) ];matchgoalwith|_=>reflexivity| [ |-context[?F_1?mocomponents_of?T?x] ]=>simplrewrite<- (commutesT__m);tryreflexivity| [ |-context[components_of?T?xo?F_1?m] ]=>simplrewrite(commutesT__m);tryreflexivityend.(* The goal for, e.g., the following associativity helper was madewith the following code:<<intros a b c dff'gg'hh'; simpl.pose proof (apD10 (ap components_of (p_composition_ofCoherent_for_rewrite F _ _ _ _ f g h))) as rew_hyp.revert rew_hyp.generalize dependent (Category.Core.associativity C _ _ _ _ f g h). intros fst_hyp ?.simpl in *.hnf in rew_hyp.simpl in *.Local Ltac gen_x x :=generalize dependent (X x);generalize dependent (C x);repeat (let x1 := fresh "x" in intro x1).gen_x a.gen_x b.gen_x c.gen_x d.repeat match goal with||-context[p_identity_of?F?x]=> generalize dependent (p_identity_of F x)||-context[p_composition_of?F?x?y?z?f?g]=> generalize dependent (p_composition_of F x y z f g)||-context[p_morphism_of?F?m]=> generalize dependent (p_morphism_of F m)||-context[p_object_of?F?x]=> generalize dependent (p_object_of F x)|H:context[p_morphism_of?F?m]|-_=> generalize dependent (p_morphism_of F m)||-context[@p_morphism_of__?F?x?y]=> generalize dependent (@p_morphism_of _ _ F x y)end.simpl.intros.lazymatch goal with|H:context[ap?f?H']|-_=> rename H' into fst_hyp;rename H into rew_hyp;move rew_hyp at topend.generalize dependent fst_hyp.clear.intros.move rew_hyp at top.move H at top.repeat match goal with|H:Isomorphic__|-_=> let x := fresh "x" inlet H' := fresh "H" indestruct H asxH';simpl in *end.move rew_hyp at top.repeat match goal with|H:_|-_=> revert Hend.intro H.intro C.>> *)Lemmapseudofunctor_to_cat_assoc_helper:forall{xx0:C} {x2:Category.Core.morphismCxx0} {x1:C}{x5:Category.Core.morphismCx0x1} {x4:C} {x7:Category.Core.morphismCx1x4}{pp0:PreCategory} {f:Category.Core.morphismCxx4->Functorp0p}{p1p2:PreCategory} {f0:Functorp2p} {f1:Functorp1p2}{f2:Functorp0p2} {f3:Functorp0p1} {f4:Functorp1p}{x16:Category.Core.morphism(_->_) (f(x7ox5ox2)) (f4of3)%functor}{x15:Category.Core.morphism(_->_)f2(f1of3)%functor} {H2:IsIsomorphismx15}{x11:Category.Core.morphism(_->_) (f(x7o(x5ox2))) (f0of2)%functor}{H1:IsIsomorphismx11} {x9:Category.Core.morphism(_->_)f4(f0of1)%functor}{fst_hyp:x7ox5ox2=x7o(x5ox2)}(rew_hyp:forallx3:p0,(idtoiso(p0->p) (apffst_hyp) :Category.Core.morphism___)x3=x11^-1x3o(f0_1(x15^-1x3)o(1o(x9(f3x3)ox16x3)))){H0':IsIsomorphismx16}{H1':IsIsomorphismx9}{x13:p} {x3:p0} {x6:p1} {x10:p2}{x14:Category.Core.morphismp(f0x10)x13} {x12:Category.Core.morphismp2(f1x6)x10}{x8:Category.Core.morphismp1(f3x3)x6},exist(funf5:Category.Core.morphismCxx4=>Category.Core.morphismp((ff5)x3)x13)(x7ox5ox2)(x14o(f0_1x12ox9x6)o(f4_1x8ox16x3)) =(x7o(x5ox2);x14o(f0_1(x12o(f1_1x8ox15x3))ox11x3)).Proof.helper_tassoc_before_commutes_tac.assoc_fin_tac.Qed.Lemmapseudofunctor_to_cat_left_identity_helper:forall{x1x2:C} {f:Category.Core.morphismCx2x1} {pp0:PreCategory}{f0:Category.Core.morphismCx2x1->Functorp0p} {f1:Functorpp}{x0:Category.Core.morphism(_->_) (f0(1of)) (f1of0f)%functor}{x:Category.Core.morphism(_->_)f11%functor}{fst_hyp: 1of=f}(rewrite_hyp:forallx3:p0,(idtoiso(p0->p) (apf0fst_hyp) :Category.Core.morphism___)x3= 1o(x((f0f)x3)ox0x3)){H0':IsIsomorphismx0}{H1':IsIsomorphismx}{x3:p} {x4:p0} {f':Category.Core.morphismp((f0f)x4)x3},exist(funf2:Category.Core.morphismCx2x1=>Category.Core.morphismp((f0f2)x4)x3)(1of)(xx3o(f1_1f'ox0x4))= (f;f').Proof.helper_tidtac.Qed.Lemmapseudofunctor_to_cat_right_identity_helper:forall{x1x2:C} {f:Category.Core.morphismCx2x1} {pp0:PreCategory}{f0:Category.Core.morphismCx2x1->Functorp0p} {f1:Functorp0p0}{x0:Category.Core.morphism(_->_) (f0(fo1)) (f0fof1)%functor}{H0':IsIsomorphismx0}{x:Category.Core.morphism(_->_)f11%functor}{H1':IsIsomorphismx}{fst_hyp:fo1 =f}(rew_hyp:forallx3:p0,(idtoiso(p0->p) (apf0fst_hyp) :Category.Core.morphism___)x3= 1o((f0f)_1(xx3)ox0x3)){x3:p} {x4:p0} {f':Category.Core.morphismp((f0f)x4)x3},exist(funf2:Category.Core.morphismCx2x1=>Category.Core.morphismp((f0f2)x4)x3)(fo1)(f'o((f0f)_1(xx4)ox0x4))= (f;f').Proof.helper_tidtac.Qed.Category of elementsDefinitioncategory:PreCategory.Proof.refine(@Build_PreCategoryPair(funsd=>morphismsd)identitycompose____);[abstract(intros? ? ? ? [f?] [g?] [h?];exact(pseudofunctor_to_cat_assoc_helper(apD10(apcomponents_of(p_composition_of_coherent_for_rewriteF____fgh)))))|abstract(intros? ? [f?];exact(pseudofunctor_to_cat_left_identity_helper(apD10(apcomponents_of(p_left_identity_of_coherent_for_rewriteF__f)))))|abstract(intros? ? [f?];exact(pseudofunctor_to_cat_right_identity_helper(apD10(apcomponents_of(p_right_identity_of_coherent_for_rewriteF__f))))) ].Defined.First projection functorDefinitionpr1:FunctorcategoryC:=Build_FunctorcategoryCc(funsd=> @pr1__)(fun_____=>idpath)(fun_=>idpath).EndGrothendieck.

--- Miscellaneous\PseudonaturalTransformation.html ---
PseudonaturalTransformationLibrary PseudonaturalTransformationPseudonatural TransformationsDefinition of pseudonatural transformationsRequirePseudonaturalTransformation.Core.IncludePseudonaturalTransformation.Core.

--- Miscellaneous\pSusp.html ---
pSuspLibrary pSuspRequireImportBasics.RequireImportTypes.RequireImportPointed.Core.RequireImportPointed.Loops.RequireImportPointed.pTrunc.RequireImportPointed.pEquiv.RequireImportHomotopy.Suspension.RequireImportHomotopy.Freudenthal.RequireImportTruncations.RequireImportWildCat.Generalizable VariablesXABfgn.Local OpenScopepath_scope.Local OpenScopepointed_scope.Pointedness ofSuspand path spaces thereofWe arbitrarily chooseNorthto be the point.Global Instanceispointed_susp{X:Type} :IsPointed(SuspX) | 0:=North.Global Instanceispointed_path_susp`{IsPointedX}:IsPointed(North=South:>SuspX) | 0 :=merid(pointX).Global Instanceispointed_path_susp'`{IsPointedX}:IsPointed(South=North:>SuspX) | 0 := (merid(pointX))^.Definitionpsusp(X:Type) :pType:= [SuspX,_].Suspension Functorpsusphas a functorial action.  TODO: make this a displayed functorGlobal Instanceis0functor_psusp:Is0Functorpsusp:=Build_Is0Functor____psusp(funXYf=>Build_pMap(psuspX) (psuspY) (functor_suspf) 1).psuspis a 1-functor.Global Instanceis1functor_psusp:Is1Functorpsusp.Proof.snrapplyBuild_Is1Functor.Action on 2-cells-introsXYfgp.pointed_reduce.srapplyBuild_pHomotopy.{simpl.srapplySusp_ind.1,2:reflexivity.introx;cbn.rewritetransport_paths_FlFr.rewriteconcat_p1.rewrite2Susp_rec_beta_merid.destruct(px).applyconcat_Vp. }reflexivity.Preservation of identity.-introsX.srapplyBuild_pHomotopy.{srapplySusp_ind;tryreflexivity.introx.refine(transport_paths_FFlr__@_).byrewriteap_idmap,Susp_rec_beta_merid,concat_p1,concat_Vp. }reflexivity.Preservation of composition.-pointed_reduce_rewrite;srefine(Build_pHomotopy__);cbn.{srapplySusp_ind;tryreflexivity;cbn.introsx.refine(transport_paths_FlFr__@_).rewriteconcat_p1;applymoveR_Vp.byrewriteconcat_p1,ap_compose, !Susp_rec_beta_merid. }reflexivity.Defined.Loop-Suspension AdjunctionModuleBook_Loop_Susp_Adjunction.Here is the proof of the adjunction isomorphism given in the book (6.5.4); we put it in a non-exported module for reasons discussed below.Definitionloop_susp_adjoint`{Funext} (AB:pType): (psuspA->*B) <~> (A->*loopsB).Proof.refine(_oE(issig_pmap(psuspA)B)^-1).refine(_oE(equiv_functor_sigma_pb(Q:=funNSm=>fstNSm.1 =pointB)(equiv_Susp_recAB))).transitivity{bp: {b:B&b=pointB} & {b:B&A->bp.1 =b} }.1:make_equiv.refine(_oEequiv_contr_sigma_);simpl.refine(_oE(equiv_sigma_contr(A:= {p:B&A->pointB=p})(funpm=> {q:pointB=pm.1 &pm.2 (pointA) =q}))^-1).make_equiv_contr_basedpaths.Defined.Unfortunately, with this definition it seems to be quite hard to prove that the isomorphism is natural on pointed maps.  The following proof gets partway there, but ends with a pretty intractable goal.  It's also quite slow, so we don't want to compile it all the time.Definition loop_susp_adjoint_nat_r `{Funext} (A B B' : pType)
             (f : psusp A ->* B) (g : B ->* B')
  : loop_susp_adjoint A B' (g o* f)
    ==* fmap loops g o* loop_susp_adjoint A B f.
  Proof.
    pointed_reduce. (* Very slow for some reason. *)
    srefine (Build_pHomotopy _ _).
    - intros a. simpl.
      refine (_ @ (concat_1p _)^).
      refine (_ @ (concat_p1 _)^).
      rewrite !transport_sigma. simpl.
      rewrite !(transport_arrow_fromconst (B := A)).
      rewrite !transport_paths_Fr.
      rewrite !ap_V, !ap_pr1_path_basedpaths.
      Fail rewrite ap_pp, !(ap_compose f g), ap_V. (* This line fails with current versions of the library. *)
      Fail reflexivity.
      admit.
    - cbn.
      Fail reflexivity.
  Abort.EndBook_Loop_Susp_Adjunction.Thus, instead we will construct the adjunction in terms of a unit and counit natural transformation.Definitionloop_susp_unit(X:pType) :X->*loops(psuspX):=Build_pMapX(loops(psuspX))(funx=>meridx@ (merid(pointX))^) (concat_pV_).By Freudenthal, we have that this map is (2n+2)-connected whenXis (n+1)-connected.Global Instanceconn_map_loop_susp_unit`{Univalence} (n:trunc_index)(X:pType) `{IsConnectedn.+1X}:IsConnMap(n+2+n) (loop_susp_unitX).Proof.refine(conn_map_compose_merid(equiv_concat_r(meridpt)^_)).Defined.We also have this corollary:Definitionpequiv_ptr_loop_psusp`{Univalence} (X:pType)n`{IsConnectedn.+1X}:pTr(n+2+n)X<~>*pTr(n+2+n) (loops(psuspX)).Proof.snrapplyBuild_pEquiv.1:rapply(fmap(pTr_) (loop_susp_unit_)).rapplyO_inverts_conn_map.Defined.Definitionloop_susp_unit_natural{XY:pType} (f:X->*Y):loop_susp_unitYo*f==*fmaploops(fmappsuspf)o*loop_susp_unitX.Proof.pointed_reduce.simplerefine(Build_pHomotopy__);cbn.-introsx;symmetry.refine(concat_1p_@(concat_p1_@_)).refine(ap_pp(Susp_recNorthSouth(meridof))(meridx) (merid(pointX))^ @_).refine((1 @@ap_V__) @_).refine(Susp_rec_beta_merid_@@inverse2(Susp_rec_beta_merid_)).-cbn.applymoveL_pV.rewrite!inv_pp, !concat_pp_p,concat_1p;symmetry.applymoveL_Vp.refine(concat_pV_inverse2__(Susp_rec_beta_merid(pointX)) @_).applymoveL_Vp,moveL_Vp.refine(ap_pp_concat_pV__@_).applymoveL_Vp,moveL_Vp.rewriteconcat_p1_1,concat_1p_1.cbn;symmetry.refine(concat_p1_@_).refine(ap_compose(funp'=> (ap(Susp_recNorthSouth(meridof)))p'@ 1)(funp'=> 1 @p')(concat_pV(merid(pointX))) @_).applyap.refine(ap_compose(ap(Susp_recNorthSouth(meridof)))(funp'=>p'@ 1)_).Qed.Definitionloop_susp_counit(X:pType) :psusp(loopsX) ->*X:=Build_pMap(psusp(loopsX))X(Susp_rec(pointX) (pointX)idmap) 1.Definitionloop_susp_counit_natural{XY:pType} (f:X->*Y):fo*loop_susp_counitX==*loop_susp_counitYo*fmappsusp(fmaploopsf).Proof.pointed_reduce.simplerefine(Build_pHomotopy__);simpl.-simplerefine(Susp_ind____);cbn;tryreflexivity;introsp.rewritetransport_paths_FlFr,ap_compose,concat_p1.applymoveR_Vp.refine(ap_compose(Susp_recNorthSouth(funx0=>merid(1 @ (apfx0@ 1))))(Susp_rec(pointY) (pointY)idmap) (meridp) @_).do2rewriteSusp_rec_beta_merid.refine(concat_1p_@_).f_ap.f_ap.symmetry.refine(Susp_rec_beta_merid_).-reflexivity.Qed.Now the triangle identitiesDefinitionloop_susp_triangle1(X:pType):fmaploops(loop_susp_counitX)o*loop_susp_unit(loopsX)==*pmap_idmap.Proof.simplerefine(Build_pHomotopy__).-introsp;cbn.refine(concat_1p_@ (concat_p1_@_)).refine(ap_pp(Susp_rec(pointX) (pointX)idmap)(meridp) (merid(point(pointX=pointX)))^ @_).refine((1 @@ap_V__) @_).refine((Susp_rec_beta_meridp@@inverse2(Susp_rec_beta_merid(point(loopsX)))) @_).exact(concat_p1_).-applymoveL_pV.destructXas[Xx];cbn;unfoldpoint.applywhiskerR.rewrite(concat_pV_inverse2(ap(Susp_recxxidmap) (merid1))1 (Susp_rec_beta_merid1)).rewrite(ap_pp_concat_pV(Susp_recxxidmap) (merid1)).rewriteap_compose, (ap_compose_(funp=>p@ 1)).rewriteconcat_1p_1;applyap.applyconcat_p1_1.Qed.Definitionloop_susp_triangle2(X:pType):loop_susp_counit(psuspX)o*fmappsusp(loop_susp_unitX)==*pmap_idmap.Proof.simplerefine(Build_pHomotopy__);[simplerefine(Susp_ind____) | ];tryreflexivity;cbn.-exact(merid(pointX)).-introsx.rewritetransport_paths_FlFr,ap_idmap,ap_compose.rewriteSusp_rec_beta_merid.applymoveR_pM;rewriteconcat_p1.refine(inverse2(Susp_rec_beta_merid_) @_).rewriteinv_pp,inv_V;reflexivity.Qed.Now we can finally construct the adjunction equivalence.Definitionloop_susp_adjoint`{Funext} (AB:pType): (psuspA->**B) <~>* (A->**loopsB).Proof.snrapplyBuild_pEquiv'.-refine(equiv_adjointify(funf=>fmaploopsfo*loop_susp_unitA)(fung=>loop_susp_counitBo*fmappsuspg)__).+introsg.applypath_pforall.refine(pmap_prewhisker_(fmap_comploops__) @*_).refine(pmap_compose_assoc___@*_).refine(pmap_postwhisker_(loop_susp_unit_naturalg)^* @*_).refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhiskerg(loop_susp_triangle1B) @*_).applypmap_postcompose_idmap.+introsf.applypath_pforall.refine(pmap_postwhisker_(fmap_comppsusp__) @*_).refine((pmap_compose_assoc___)^* @*_).refine(pmap_prewhisker_(loop_susp_counit_naturalf)^* @*_).refine(pmap_compose_assoc___@*_).refine(pmap_postwhiskerf(loop_susp_triangle2A) @*_).applypmap_precompose_idmap.-applypath_pforall.unfoldequiv_adjointify,equiv_fun.nrapply(pmap_prewhisker_fmap_loops_pconst@*_).rapplycat_zero_l.Defined.And its naturality is easy.Definitionloop_susp_adjoint_nat_r`{Funext} (ABB':pType)(f:psuspA->*B) (g:B->*B') :loop_susp_adjointAB'(go*f)==*fmaploopsgo*loop_susp_adjointABf.Proof.cbn.refine(_@*pmap_compose_assoc___).applypmap_prewhisker.refine(fmap_comploopsfg).Defined.Definitionloop_susp_adjoint_nat_l`{Funext} (AA'B:pType)(f:A->*loopsB) (g:A'->*A) : (loop_susp_adjointA'B)^-1 (fo*g)==* (loop_susp_adjointAB)^-1fo*fmappsuspg.Proof.cbn.refine(_@* (pmap_compose_assoc___)^*).applypmap_postwhisker.exact(fmap_comppsuspgf).Defined.Global Instanceis1natural_loop_susp_adjoint_r`{Funext} (A:pType):Is1Natural(opyon(psuspA)) (opyonAoloops)(loop_susp_adjointA).Proof.snrapplyBuild_Is1Natural.introsBB'gf.refine(_@cat_assoc_strong___).refine(ap(funx=>xo*loop_susp_unitA)_).applypath_pforall.rapply(fmap_comploops).Defined.Lemmanatequiv_loop_susp_adjoint_r`{Funext} (A:pType):NatEquiv(opyon(psuspA)) (opyonAoloops).Proof.rapplyBuild_NatEquiv.Defined.

--- Miscellaneous\pTrunc.html ---
pTruncLibrary pTruncRequireImportBasicsTypesWildCatTruncationsPointed.CorePointed.pEquivPointed.LoopsPointed.pModality.Local OpenScopepointed_scope.Truncations of pointed typesTODO: Many things here can be generalized to any modality or any reflective subuniverse, and could be moved to pModality.vDefinitionpTr(n:trunc_index) (A:pType) :pType:= [TrnA,_].We specializeptoandpequiv_ptofrom pModalities.v to truncations.Definitionptr{n:trunc_index} {A:pType} :A->*pTrnA:=pto(Trn)_.Definitionpequiv_ptr{n:trunc_index} {A:pType} `{IsTruncnA}:A<~>*pTrnA:= @pequiv_pto(Trn)A_.We could specializepO_recto give the following result, but since maps induced by truncation-recursion compute on elements of the formtr_, we can give a better proof of pointedness than the one coming frompO_rec.DefinitionpTr_recn{XY:pType} `{IsTruncnY} (f:X->*Y):pTrnX->*Y:=Build_pMap(pTrnX)Y(Trunc_recf) (point_eqf).Note that we get an equality of pointed functions here, without Funext, whilepO_rec_betaonly gives a pointed homotopy. This is becausepTr_reccomputes on elements of the formtr_.DefinitionpTr_rec_beta_pathn{XY:pType} `{IsTruncnY} (f:X->*Y):pTr_recnfo*ptr=f.Proof.unfoldpTr_rec, "o*";cbn.(* Sincefis definitionally equal toBuild_pMap__f(point_eqf), this works: *)apply(ap(Build_pMap__f)).applyconcat_1p.Defined.The version with a pointed homotopy.DefinitionpTr_rec_betan{XY:pType} `{IsTruncnY} (f:X->*Y):pTr_recnfo*ptr==*f:=phomotopy_path(pTr_rec_beta_pathnf).A pointed version of the induction principle.DefinitionpTr_indn{X:pType} {Y:pFam(pTrnX)} `{forallx,IsTruncn(Yx)}(f:pForallX(Build_pFam(Yotr) (dpointY))):pForall(pTrnX)Y:=Build_pForall(pTrnX)Y(Trunc_indYf) (dpoint_eqf).Definitionpequiv_ptr_rec`{Funext} {n} {XY:pType} `{IsTruncnY}: (pTrnX->**Y) <~>* (X->**Y):=pequiv_o_pto_O_XY.Functoriality ofpTrGlobal Instanceis0functor_ptrn:Is0Functor(pTrn).Proof.applyBuild_Is0Functor.introsXYf.exact(pTr_rec_(ptro*f)).Defined.Global Instanceis1functor_ptrn:Is1Functor(pTrn).Proof.applyBuild_Is1Functor.-introsXYfgp.srapplypTr_ind;cbn.snrapplyBuild_pForall.+cbn.exact(funx=>aptr(px)).+pointed_reduce.exact(concat_p1_@concat_p1_@ap_(concat_p1_))^.-introsX.srapplyBuild_pHomotopy.1:applyTrunc_rec_tr.cbn.reflexivity.-introsXYZfg.srapplyBuild_pHomotopy.1:byrapplyTrunc_ind.bypointed_reduce.Defined.Naturality ofptr.  Note that we get a equality of pointed functions, not just a pointed homotopy.Definitionptr_natural_path(n:trunc_index) {XY:pType} (f:X->*Y):fmap(pTrn)fo*ptr=ptro*f:=pTr_rec_beta_pathn(ptro*f).The version with a pointed homotopy.Definitionptr_natural(n:trunc_index) {XY:pType} (f:X->*Y):fmap(pTrn)fo*ptr==*ptro*f:=phomotopy_path(ptr_natural_pathnf).Definitionptr_functor_pconst{XY:pType}n:fmap(pTrn) (@pconstXY) ==*pconst.Proof.srapplyBuild_pHomotopy.1:byrapplyTrunc_ind.reflexivity.Defined.Definitionpequiv_ptr_functor{XY:pType} (n:trunc_index) (f:X<~>*Y):pTrnX<~>*pTrnY:=emap(pTrn)f.Definitionptr_loops`{Univalence} (n:trunc_index) (A:pType):pTrn(loopsA) <~>*loops(pTrn.+1A).Proof.srapplyBuild_pEquiv'.1:applyequiv_path_Tr.reflexivity.Defined.Definitionptr_iterated_loops`{Univalence} (n:trunc_index)(k:nat) (A:pType):pTrn(iterated_loopskA) <~>*iterated_loopsk(pTr(trunc_index_inc'nk)A).Proof.revertAn.inductionk.{introsAn;cbn.reflexivity. }introsAn.cbn;etransitivity.1:applyptr_loops.rapply(emaploops).applyIHk.Defined.Definitionptr_loops_eq`{Univalence} (n:trunc_index) (A:pType):pTrn(loopsA) =loops(pTrn.+1A) :>pType:=path_ptype(ptr_loopsnA).(* This lemma generalizes a goal that appears inptr_loops_commutes, allowing us to prove it by path induction. *)Definitionpath_Tr_commutes(n:trunc_index) (A:Type) (a0a1:A) (p:a0=a1):path_Tr(n:=n) (trp) =aptrp.Proof.bydestructp.Defined.(*ptr_loopscommutes with the twoptrmaps. *)Definitionptr_loops_commutes`{Univalence} (n:trunc_index) (A:pType): (ptr_loopsnA)o*ptr==*fmaploopsptr.Proof.srapplyBuild_pHomotopy.-introp.simpl.refine(_@_).+applypath_Tr_commutes.+symmetry;refine(_@_).*applyconcat_1p.*applyconcat_p1.-simpl.reflexivity.Defined.Pointed truncation preserves binary products.Definitionpequiv_ptr_prod(n:trunc_index) (AB:pType):pTrn(A*B) <~>*pTrnA*pTrnB.Proof.snrapplyBuild_pEquiv'.1:nrapplyequiv_Trunc_prod_cmp.reflexivity.Defined.Truncatedness ofpForallandpMapBuchholtz-van Doorn-Rijke, Theorem 4.2:  Letj>=-1andn>=-2.  WhenXisj-connected andYis a pointed family ofj+k+1-truncated types, the type of pointed sections isn-truncated.  We formalize it withjreplaced with a trunc indexm, and so there is a shift compared to the informal statement. This version also allowsnto be one smaller than BvDR allow.Definitionistrunc_pforall`{Univalence} {mn:trunc_index}(X:pType@{u}) {iscX:IsConnectedm.+1X}(Y:pFam@{uv}X) {istY:forallx,IsTrunc(n+2+m) (Yx)}:IsTrunc@{w}n(pForallXY).Proof.nrapply(istrunc_equiv_istrunc_(equiv_extension_along_pforall@{vwu}Y)).rapply(istrunc_extension_along_conn(n:=m)_Y(HP:=istY)).Defined.From this we deduce the non-dependent version, which is Corollary 4.3 of BvDR.  We includen=-2here as well, but in this case it is not interesting.  SinceX->*Yis inhabited, then=-1case also gives contractibility, with weaker hypotheses.Definitionistrunc_pmap`{Univalence} {mn:trunc_index} (XY:pType)`{!IsConnectedm.+1X} `{!IsTrunc(n+2+m)Y}:IsTruncn(X->*Y):=istrunc_pforallX(pfam_constY).We can give a different proof of then=-1case (with the conclusion upgraded to contractibility).  This proof works for any reflective subuniverse and avoids univalence.  Is it possible to generalize this to dependent functions while still avoiding univalence and/or keepingOa general RSU or modality?  Canistrunc_pmapbe proven without univalence?  What aboutistrunc_pforall?  If then=-2orn=-1cases can be proven without univalence, the rest can be done inductively without univalence.Definitioncontr_pmap_isconnected_inO`{Funext} (O:ReflectiveSubuniverse)(X:pType) `{IsConnectedOX} (Y:pType) `{InOY}:Contr(X->*Y).Proof.srapply(contr_equiv'([OX,_] ->*Y)).rapplypequiv_o_pto_O.Defined.Every pointed type is (-1)-connected.Global Instanceis_minus_one_connected_pointed(X:pType):IsConnected(Tr(-1))X:=contr_inhabited_hprop_(trpt).

--- Miscellaneous\Pullback.html ---
PullbackLibrary PullbackRequireImportHoTT.BasicsHoTT.Types.RequireImportHFiberPathAnyCubical.PathSquare.RequireImportDiagrams.CommutativeSquares.Local OpenScopepath_scope.PullbacksThe pullback as an objectDefinitionPullback{ABC} (f:B->A) (g:C->A):= {b:B& {c:C&fb=gc}}.Global ArgumentsPullback{ABC}%_type_scope(fg)%_function_scope.The universal commutative squareDefinitionpullback_pr1{ABC} {f:B->A} {g:C->A}:Pullbackfg->B:= (funz=>z.1).Definitionpullback_pr2{ABC} {f:B->A} {g:C->A}:Pullbackfg->C:= (funz=>z.2.1).Definitionpullback_commsq{ABC} (f:B->A) (g:C->A):fopullback_pr1==gopullback_pr2:= (funz=>z.2.2).The universally induced map into it by any commutative squareDefinitionpullback_corec{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh):A->Pullbackkg:=funa=> (fa;ha;pa).Definitionpullback_corec_uncurried{ABCD} (k:B->D) (g:C->D): {f:A->B& {h:A->C&kof==goh}} -> (A->Pullbackkg).Proof.intros[f[hp]].exact(pullback_corecp).Defined.Global Instanceisequiv_pullback_corec{ABCD} (k:B->D) (g:C->D):IsEquiv(@pullback_corec_uncurriedABCDkg).Proof.snrapplyisequiv_adjointify.-introm.exact(pullback_pr1om;pullback_pr2om; (pullback_commsqkg)om).-reflexivity.-reflexivity.Defined.Definitionequiv_pullback_corec{ABCD} (k:B->D) (g:C->D): {f:A->B& {h:A->C&kof==goh}} <~> (A->Pullbackkg):=Build_Equiv___(isequiv_pullback_coreckg).A homotopy commutative square is equivalent to a pullback of arrow typesDefinitionequiv_ispullback_commsq`{Funext} {ABCD} (k:B->D) (g:C->D): {f:A->B& {h:A->C&kof==goh}}<~> @Pullback(A->D) (A->B) (A->C) (funf=>kof) (funh=>goh).Proof.applyequiv_functor_sigma_id;introf.applyequiv_functor_sigma_id;introh.applyequiv_path_forall.Defined.The diagonal of a mapDefinitiondiagonal{XY:Type} (f:X->Y) :X->Pullbackff:=funx=> (x;x;idpath).The fiber of the diagonal is a path-space in the fiber.Definitionhfiber_diagonal{XY:Type} (f:X->Y) (p:Pullbackff):hfiber(diagonalf)p<~>  ((p.1 ;p.2.2) = (p.2.1 ;idpath) :>hfiberf(fp.2.1)).Proof.destructpas[x1[x2p]];cbn.refine(_oEequiv_functor_sigma_id(funx=> (equiv_path_sigma___)^-1));cbn.refine(_oEequiv_sigma_assoc'__).refine(_oEequiv_contr_sigma_);cbn.refine(equiv_path_sigma___oE_oE(equiv_path_sigma___)^-1);cbn.applyequiv_functor_sigma_id;introsq.destructq;cbn.applyequiv_path_inverse.Defined.Symmetry of the pullbackDefinitionequiv_pullback_symm{ABC} (f:B->A) (g:C->A):Pullbackfg<~>Pullbackgf.Proof.refine(_oEequiv_sigma_symm(funbc=>fb=gc)).applyequiv_functor_sigma_id;introsc.applyequiv_functor_sigma_id;introsb.applyequiv_path_inverse.Defined.Pullback overUnitis equivalent to a product.Definitionequiv_pullback_unit_prod(AB:Type):Pullback(const_ttA) (const_ttB) <~>A*B.Proof.simplerefine(equiv_adjointify____).-intros[a[b_]];exact(a,b).-intros[ab];exact(a;b; 1).-intros[ab];exact1.-intros[a[bp]];simpl.apply(path_sigma'_1);simpl.apply(path_sigma'_1);simpl.applypath_contr.Defined.The property of a given commutative square being a pullbackDefinitionIsPullback{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh):=IsEquiv(pullback_corecp).Definitionequiv_ispullback{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh) (ip:IsPullbackp):A<~>Pullbackkg:=Build_Equiv__(pullback_corecp)ip.This is equivalent to the transposed square being a pullback.Definitionispullback_symm{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:goh==kof) (pb:IsPullback(funa=> (pa)^)):IsPullbackp.Proof.rapply(cancelL_isequiv(equiv_pullback_symmgk)).applypb.Defined.The pullback of the projections{d:D&Pd}->D<-{d:D&Qd}is equivalent to{d:D&Pd*Qd}.Definitionispullback_sigprod{D:Type} (PQ:D->Type):IsPullback(funz:{d:D&Pd*Qd} => 1%path: (z.1;fstz.2).1 = (z.1;sndz.2).1).Proof.srapplyisequiv_adjointify.-intros[[d1p] [[d2q]e]];cbnine.existsd1.exact(p,e^ #q).-intros[[d1p] [[d2q]e]];unfoldpullback_corec;cbnin*.destructe;reflexivity.-intros[d[pq]];reflexivity.Defined.Definitionequiv_sigprod_pullback{D:Type} (PQ:D->Type): {d:D&Pd*Qd} <~>Pullback(@pr1DP) (@pr1DQ):=Build_Equiv___(ispullback_sigprodPQ).For any commutative square, the fiber of the fibers is equivalent to the fiber of the "gap map"pullback_corec.Definitionhfiber_pullback_corec{ABCD}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh) (b:B) (c:C) (q:kb=gc):hfiber(pullback_corecp) (b;c;q) <~>hfiber(functor_hfiberpb) (c;q^).Proof.unfoldhfiber,functor_hfiber,functor_sigma.refine(equiv_sigma_assoc__oE_).applyequiv_functor_sigma_id;introsa;cbn.refine(_oE(equiv_path_sigma___)^-1);cbn.applyequiv_functor_sigma_id;introp0;cbn.rewritetransport_sigma';cbn.refine((equiv_path_sigma___)oE_oE(equiv_path_sigma___)^-1);cbn.applyequiv_functor_sigma_id;introp1;cbn.rewrite!transport_paths_Fr, !transport_paths_Fl.refine(_oE(equiv_ap(equiv_path_inverse__)__));cbn.applyequiv_concat_l.refine(_@ (inv_pp__)^).applywhiskerL.refine(_@ (inv_pp__)^).applywhiskerL.symmetry;applyinv_V.Defined.If the induced maps on fibers are equivalences, then a square is a pullback.Definitionispullback_isequiv_functor_hfiber{ABCD:Type}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh)(e:forallb:B,IsEquiv(functor_hfiberpb)):IsPullbackp.Proof.unfoldIsPullback.applyisequiv_contr_map;introx.rapplycontr_equiv'.-symmetry;applyhfiber_pullback_corec.-exact_.Defined.Conversely, if the square is a pullback then the induced maps on fibers are equivalences.Definitionisequiv_functor_hfiber_ispullback{ABCD:Type}{f:A->B} {g:C->D} {h:A->C} {k:B->D}(p:kof==goh)(e:IsPullbackp):forallb:B,IsEquiv(functor_hfiberpb).Proof.applyisequiv_from_functor_sigma.unfoldIsPullbackine.snrapplyisequiv_commsq'.4:exact(equiv_fibration_replacementf)^-1%equiv.1:exact(Pullbackkg).1:exact(pullback_corecp).{apply(functor_sigmaidmap);introb.apply(functor_sigmaidmap);introc.applyinverse. }{intros[x[yq]].destructq.apply(path_sigma'_idpath).apply(path_sigma'_idpath).simpl.refine(_^ @ (inv_Vp__)^).applyconcat_1p. }all:exact_.Defined.The pullback of a map along another oneDefinitionpullback_along{ABC} (f:B->A) (g:C->A):Pullbackfg->B:=pr1.Notation"f ^*" := (pullback_alongf) :function_scope.Definitionhfiber_pullback_along{ABC} (f:B->A) (g:C->A) (b:B):hfiber(f^*g)b<~>hfiberg(fb).Proof.refine(equiv_functor_sigma_id(func=>equiv_path_inverse__)oE_).make_equiv_contr_basedpaths.Defined.And the dual sort of pullbackDefinitionpullback_along'{ABC} (g:C->A) (f:B->A):Pullbackfg->C:=funz=>z.2.1.Argumentspullback_along'/ .Notation"g ^*'" := (pullback_along'g) :function_scope.Definitionhfiber_pullback_along'{ABC} (g:C->A) (f:B->A) (c:C):hfiber(g^*'f)c<~>hfiberf(gc).Proof.make_equiv_contr_basedpaths.Defined.A version wheregis pointed, but we unbundle the pointed condition to avoid importing pointed types.Definitionhfiber_pullback_along_pointed{ABC} {c:C} {a:A}(g:C->A) (f:B->A) (p:gc=a):hfiber(g^*'f)c<~>hfiberfa.Proof.refine(_oEhfiber_pullback_along'___);cbn.srapply(equiv_functor_hfiber2(h:=equiv_idmap) (k:=equiv_idmap)).-reflexivity.-assumption.Defined.SectionFunctor_Pullback.Context{A1B1C1A2B2C2}(f1:B1->A1) (g1:C1->A1)(f2:B2->A2) (g2:C2->A2)(h:A1->A2) (k:B1->B2) (l:C1->C2)(p:f2ok==hof1) (q:g2ol==hog1).Definitionfunctor_pullback:Pullbackf1g1->Pullbackf2g2:=functor_sigmak(funb1=> (functor_sigmal(func1e1=>pb1@aphe1@ (qc1)^))).Definitionhfiber_functor_pullback(z:Pullbackf2g2):hfiberfunctor_pullbackz<~>Pullback(transport(hfiberh)z.2.2ofunctor_hfiber(k:=f2)pz.1)(functor_hfiberqz.2.1).Proof.destructzas[b2[c2e2]].refine(_oEhfiber_functor_sigma______).applyequiv_functor_sigma_id.intros[b1e1];simpl.refine(_oE(equiv_transport_(transport_sigma'e1^ (c2;e2)))).refine(_oEhfiber_functor_sigma______);simpl.applyequiv_functor_sigma_id.intros[c1e3];simpl.refine(_oE(equiv_transport_(ap(fune=>e3^ #e) (transport_paths_Fle1^e2)))).refine(_oE(equiv_transport_(transport_paths_Fre3^_))).unfoldfunctor_hfiber;simpl.refine(equiv_concat_l(transport_sigma'e2_)_oE_);simpl.refine(equiv_path_sigma___oE_);simpl.applyequiv_functor_sigma_id;introse0;simpl.refine(equiv_concat_l(transport_paths_Fle0_)_oE_).refine(equiv_concat_l(whiskerL(aphe0)^ (transport_paths_re2_))_oE_).refine(equiv_moveR_Vp___oE_).refine(equiv_concat_l(concat_pp_p___)_oE_).refine(equiv_moveR_Vp___oE_).do2refine(equiv_concat_r(concat_pp_p___)_oE_).refine(equiv_moveL_pM___oE_).abstract(rewrite!ap_V,inv_V;refine(equiv_path_inverse__)).Defined.EndFunctor_Pullback.SectionEquivPullback.Context{ABCfgA'B'C'f'g'}(eA:A<~>A') (eB:B<~>B') (eC:C<~>C')(p:f'oeB==eAof) (q:g'oeC==eAog).Lemmaequiv_pullback:Pullbackfg<~>Pullbackf'g'.Proof.unfoldPullback.apply(equiv_functor_sigma'eB);introb.apply(equiv_functor_sigma'eC);introc.refine(equiv_concat_l(p_)_oE_).refine(equiv_concat_r(q_)^_oE_).refine(equiv_ap'eA__).Defined.EndEquivPullback.Pullbacks commute with sigmasSectionPullbackSigma.Context{XYZ:Type}{A:X->Type} {B:Y->Type} {C:Z->Type}(f:Y->X) (g:Z->X)(r:forallx,Bx->A(fx))(s:forallx,Cx->A(gx)).Definitionequiv_sigma_pullback: {p:Pullbackfg&Pullback(transportAp.2.2orp.1) (sp.2.1)}<~>Pullback(functor_sigmafr) (functor_sigmags).Proof.refine(equiv_functor_sigma_id(fun_=>equiv_functor_sigma_id_)oE_).-intros;rapplyequiv_path_sigma.-make_equiv.Defined.EndPullbackSigma.Paths in pullbacksDefinitionequiv_path_pullback{ABC} (f:B->A) (g:C->A)(xy:Pullbackfg): {p:x.1 =y.1 & {q:x.2.1 =y.2.1 &PathSquare(apfp) (apgq)x.2.2y.2.2 } }<~> (x=y).Proof.reverty;rapplyequiv_path_from_contr.{existsidpath.existsidpath.cbn.applysq_refl_v. }destructxas[b[cp]];unfoldPullback;cbn.contr_sigsigb(idpathb).contr_sigsigc(idpathc).cbn.rapply(contr_equiv'{p':fb=gc&p=p'}).applyequiv_functor_sigma_id;introsp'.applysq_1G.Defined.Maps into pullbacks are determined by their composites with the projections, and a coherence.  This can also be proved directly.  WithFunext, we could also prove an equivalence analogous toequiv_path_pullback_rec_hsetbelow.  Not sure of the best name for this version.Definitionpullback_homotopic{ABCD} {g:C->D} {k:B->D}(fh:A->Pullbackkg)(p1:pullback_pr1of==pullback_pr1oh)(p2:pullback_pr2of==pullback_pr2oh)(q:foralla, (apk) (p1a) @ (ha).2.2 = (fa).2.2 @ (apg) (p2a)):f==h.Proof.introa.applyequiv_path_pullback.exists(p1a).exists(p2a).applysq_path,q.Defined.WhenAis a set, thePathSquarebecomes trivial.Definitionequiv_path_pullback_hset{ABC} `{IsHSetA} (f:B->A) (g:C->A)(xy:Pullbackfg): (x.1 =y.1) * (x.2.1 =y.2.1) <~> (x=y).Proof.refine(equiv_path_pullbackfgxyoE_^-1%equiv).refine(_oEequiv_sigma_prod(funpq=>PathSquare(apf(fstpq)) (apg(sndpq)) (x.2).2 (y.2).2)).rapplyequiv_sigma_contr.(* Usesistrunc_sq. *)Defined.Lemmaequiv_path_pullback_rec_hset`{Funext} {AXYZ:Type} `{IsHSetZ}(f:X->Z) (g:Y->Z) (phipsi:A->Pullbackfg): ((pullback_pr1ophi==pullback_pr1opsi) * (pullback_pr2ophi==pullback_pr2opsi))<~> (phi==psi).Proof.refine(_oEequiv_prod_coind__).srapplyequiv_functor_forall_id;introa;cbn.applyequiv_path_pullback_hset.Defined.The 3x3 LemmaSectionPullback3x3.Context(A00A02A04A20A22A24A40A42A44:Type)(f01:A00->A02) (f03:A04->A02)(f10:A00->A20) (f12:A02->A22) (f14:A04->A24)(f21:A20->A22) (f23:A24->A22)(f30:A40->A20) (f32:A42->A22) (f34:A44->A24)(f41:A40->A42) (f43:A44->A42)(H11:f12of01==f21of10) (H13:f12of03==f23of14)(H31:f32of41==f21of30) (H33:f32of43==f23of34).LetfX1:=functor_pullbackf10f30f12f32f21f01f41H11H31.LetfX3:=functor_pullbackf14f34f12f32f23f03f43H13H33.Letf1X:=functor_pullbackf01f03f21f23f12f10f14(symmetry__H11) (symmetry__H13).Letf3X:=functor_pullbackf41f43f21f23f32f30f34(symmetry__H31) (symmetry__H33).Theorempullback3x3:PullbackfX1fX3<~>Pullbackf1Xf3X.Proof.refine(_oE_oE_).1,3:do2 (rapplyequiv_functor_sigma_id;intro).1:applyequiv_path_pullback.1:symmetry;applyequiv_path_pullback.refine(_oE_).{do4 (rapplyequiv_functor_sigma_id;intro).refine(sq_troE_).refine(sq_move_14^-1oE_).refine(sq_move_31oE_).refine(sq_move_24^-1oE_).refine(sq_move_23^-1oE_).rewrite2inv_V.reflexivity. }make_equiv.Defined.EndPullback3x3.Pasting for pullbacks (or 2-pullbacks lemma)SectionPasting.Given the following diagram where the right square is a pullback square, then the outer square is a pullback square if and only if the left square is a pullback.(* A --k--> B --l--> C|    //  |    //  |f  comm  g  comm  h|  //    |  //    |V //     V //     VX --i--> Y --j--> Z *)Context{ABCXYZ:Type}{k:A->B} {l:B->C}{f:A->X} {g:B->Y} {h:C->Z}{i:X->Y} {j:Y->Z}(H:iof==gok) (K:jog==hol) {e1:IsPullbackK}.Definitionispullback_pasting_left:IsPullback(comm_square_comp'HK) ->IsPullbackH.Proof.introe2.applyispullback_isequiv_functor_hfiber.introb.pose(e1':=isequiv_functor_hfiber_ispullback_e1(ib)).pose(e2':=isequiv_functor_hfiber_ispullback_e2b).snrapplyisequiv_commsq'.7:applyisequiv_idmap.4:apply(functor_hfiber_composeHKb).1,2:exact_.Defined.Definitionispullback_pasting_outer:IsPullbackH->IsPullback(comm_square_comp'HK).Proof.introe2.applyispullback_isequiv_functor_hfiber.introb.pose(e1':=isequiv_functor_hfiber_ispullback_e1(ib)).pose(e2':=isequiv_functor_hfiber_ispullback_e2b).snrapplyisequiv_commsq'.9:applyisequiv_idmap.4:symmetry;apply(functor_hfiber_composeHKb).1,2:exact_.Defined.EndPasting.

--- Miscellaneous\PullbackFiberSequence.html ---
PullbackFiberSequenceLibrary PullbackFiberSequenceRequireImportBasicsTypesHSetHFiberLimits.Pullback.RequireImportWildCatPointed.CoreHomotopy.ExactSequence.RequireImportGroups.QuotientGroup.RequireImportAbGroups.AbelianGroupAbGroups.AbPullbackAbGroups.Biproduct.RequireImportAbSES.CoreAbSES.Pullback.RequireImportModalities.IdentityModalities.ModalityTruncations.Core.Local OpenScopepointed_scope.Local OpenScopemc_scope.Local OpenScopemc_add_scope.The fiber sequence induced by pulling back along a short exact sequenceWe show that pulling back along a short exact sequenceE:AbSESCBproduces a fiber sequenceAbSESCA->AbSESEA->AbSESBA. The associated long exact sequence of homotopy groups recovers the usual (contravariant) six-term exact sequence of Ext groups.We will prove the analog of exactness in terms of path data, and deduce the usual notion.If a short exact sequenceA->F->Ebecomes trivial after pulling back along an inclusioni:B->E, then there is a "transpose" short exact sequenceB->F->F/B. We begin by constructing the the mapB->F.Definitionabses_pullback_inclusion_transpose_map{ABE:AbGroup}(i:B$->E) `{IsEmbeddingi}(F:AbSESEA) (p:abses_pullbackiF$==pt):B$->F:=grp_pullback_pr1__$op^$.1 $oab_biprod_inr.The comparison mapA+B$->Fis an embedding.  This comes up twice so we factor it out as a lemma.Local Instanceabses_pullback_inclusion_lemma{ABE:AbGroup}(i:B$->E) `{IsEmbeddingi}(F:AbSESEA) (p:abses_pullbackiF$==pt):IsEmbedding(grp_pullback_pr1__$op^$.1).Proof.nrapply(istruncmap_compose(-1)p^$.1 (grp_pullback_pr1(projectionF)i)).all:rapplyistruncmap_mapinO_tr.Defined.The mapB->Fis an inclusion.Local Instanceabses_pullback_inclusion_transpose_embedding{ABE:AbGroup}(i:B$->E) `{IsEmbeddingi}(F:AbSESEA) (p:abses_pullbackiF$==pt):IsEmbedding(abses_pullback_inclusion_transpose_mapiFp).Proof.rapply(istruncmap_compose_(ab_biprod_inr)).Defined.We define the cokernelF/B, which is what we need below.Definitionabses_pullback_inclusion_transpose_endpoint'{ABE:AbGroup}(i:B$->E) `{IsEmbeddingi}(F:AbSESEA) (p:abses_pullbackiF$==pt):AbGroup:=ab_cokernel_embedding(abses_pullback_inclusion_transpose_mapiFp).The composite mapB->F->Eis homotopic to the original inclusioni:B->E.Lemmaabses_pullback_inclusion_transpose_beta{ABE:AbGroup}(i:B$->E) `{IsEmbeddingi}(F:AbSESEA) (p:abses_pullbackiF$==pt):projectionF$o(abses_pullback_inclusion_transpose_mapiFp) ==i.Proof.introb.changebwith(ab_biprod_pr2(A:=A) (mon_unit,b)).refine(pullback_commsq___@api_).exact(sndp^$.2_)^.Defined.Short exact sequences in the fiber ofinclusionEdescend alongprojectionE.Definitionabses_pullback_trivial_preimage`{Univalence} {ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt):AbSESCA.Proof.snrapplyBuild_AbSES.-exact(abses_pullback_inclusion_transpose_endpoint'(inclusionE)Fp).-exact(grp_quotient_map$oinclusionF).-srapply(ab_cokernel_embedding_rec_(projectionE$oprojectionF)).introb.refine(ap(projectionE) (abses_pullback_inclusion_transpose_beta(inclusionE)Fpb) @_).applyiscomplex_abses.-applyisembedding_grouphomomorphism.introsaq0.(* SinceinclusionFais killed bygrp_quotient_map, its in the image ofB. *)poseproof(in_coset:=related_quotient_paths___q0).(* Cleaning up the context facilitates later steps. *)destructin_cosetas[bq1];rewritegrp_unit_rinq1.(* Since bothinclusionFandB->Ffactor through the monoab_biprodAB->F, we can liftq1toab_biprodAB. *)assert(q2:ab_biprod_inrb=ab_biprod_inl(-a)).1: {apply(isinj_embedding(grp_pullback_pr1__$op^$.1)).-applyabses_pullback_inclusion_lemma.exact_.-nrefine(q1@_);symmetry.refine(ap(grp_pullback_pr1__) (fstp^$.2 (-a)) @_).exact(grp_homo_inv__). }(* Usingq2, we conclude. *)poseproof(q3:=apnegate(fst((equiv_path_prod__)^-1q2)));cbninq3.exact((negate_involutive_)^ @q3^ @negate_mon_unit).-apply(cancelR_conn_map(Tr(-1))grp_quotient_map).1:exact_.simpl.exact_.-snrapplyBuild_IsExact.+srapplyphomotopy_homotopy_hset.introa;simpl.refine(ap(projectionE)_@_).1:applyiscomplex_abses.applygrp_homo_unit.+intros[yq].apply(@contr_inhabited_hprop__).(* We choose a preimage bygrp_quotient_map. *)assert(f:merely(hfibergrp_quotient_mapy)).1:applycenter,issurj_class_of.revert_opaquef;applyTrunc_rec;intros[fq0].(* SinceprojectionFfis in the kernel ofprojectionE, we find a preimage inB. *)assert(b:merely(hfiber(inclusionE) (projectionFf))).1: {rapplyisexact_preimage.exact(ap_q0@q). }revert_opaqueb;applyTrunc_rec;intros[bq1].(* The differencef-binFis in the kernel ofprojectionF, hence lies inA. *)assert(a:merely(hfiber(inclusionF)(sg_opf(-(grp_pullback_pr1__(p^$.1 (ab_biprod_inrb))))))).1: {rapplyisexact_preimage.refine(grp_homo_op___@_).refine(ap(funx=>_+x) (grp_homo_inv__) @_).refine(ap(funx=>_-x) (abses_pullback_inclusion_transpose_beta(inclusionE)Fpb@q1) @_).applyright_inverse. }revert_opaquea;applyTrunc_rec;intros[aq2].(* It remains to show thatais the desired preimage. *)refine(tr(a;_)).letT:=typeofyinapply(@path_sigma_hpropT).1:intros?;applyistrunc_paths;applygroup_isgroup.refine(apgrp_quotient_mapq2@_@q0).refine(grp_homo_op___@_).applygrp_moveR_Mg.refine(_@ (left_inverse_)^).applyqglue.existsb.refine(_@ (grp_unit_r_)^).exact(negate_involutive_)^.Defined.Thatabses_pullback_trivial_preimageEFppulls back toFis immediate fromabses_pullback_component1_idand the following map. As such, we've shown that sequences which become trivial after pulling back alonginclusionEare in the image of pullback alongprojectionE.Definitionabses_pullback_inclusion0_map'`{Univalence} {ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt):AbSESMorphismF(abses_pullback_trivial_preimageEFp).Proof.srapplyBuild_AbSESMorphism.-exactgrp_homo_id.-exactgrp_quotient_map.-exact(projectionE).-reflexivity.-reflexivity.Defined.For exactness we need not only a preimage ofFbut a preimage of(F,p)alongcxfib. We now define and prove this in terms of path data.The analog ofcxfibinduced by pullback in terms of path data.Definitioncxfib'{ABC:AbGroup} (E:AbSESCB):AbSESCA->graph_hfiber(abses_pullback(A:=A) (inclusionE))pt.Proof.introY.exists(abses_pullback(projectionE)Y).refine(abses_pullback_compose'__Y$@_).refine(abses_pullback_homotopic'_grp_homo_const_Y$@_).1:rapplyiscomplex_abses.symmetry;applyabses_pullback_const'.Defined.Definitionhfiber_cxfib'{ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt):= {Y:AbSESCA&hfiber_abses_path(cxfib'EY) (F;p)}.(* This is justidpath, but Coq takes too long to see that. *)Local Definitionpr2_cxfib'`{Univalence} {ABC:AbGroup} {E:AbSESCB} (U:AbSESCA):equiv_ptransformation_phomotopy(iscomplex_abses_pullback'__(iscomplex_absesE))U=equiv_path_abses_iso(cxfib'EU).2.Proof.change(equiv_ptransformation_phomotopy(iscomplex_abses_pullback'__(iscomplex_absesE))U)with(equiv_path_abses_iso((iscomplex_abses_pullback'__(iscomplex_absesE)).1U)).apply(apequiv_path_abses_iso).rapplypath_hom.refine(_$@Rabses_pullback_compose'(inclusionE) (projectionE)U);unfoldtrans_comp.refine(_$@Rabses_pullback_homotopic'(projectionE$oinclusionE)grp_homo_const(iscomplex_absesE)U).reflexivity.Defined.Makingabses_pullback'opaque speeds up the following proof.Opaqueabses_pullback'.Local Definitioneq_cxfib_cxfib'`{Univalence} {ABC:AbGroup} {E:AbSESCB} (U:AbSESCA):cxfib(iscomplex_pullback_absesE)U=equiv_hfiber_abses__(cxfib'EU).Proof.srapplypath_sigma.1:reflexivity.nrefine(concat_p1_@_).nrefine(concat_1p_@_).cbnzeta.unfoldequiv_hfiber_abses,equiv_functor_sigma_id,equiv_functor_sigma',equiv_functor_sigma,equiv_fun,functor_sigma, ".2".(* The goal looks identical topr2_cxfib', but the implicit argument to@pathsis expressed differently, which is why the next line isn't faster. *)exact(@pr2_cxfib'_ABCEU).Defined.Transparentabses_pullback'.Definitionequiv_hfiber_cxfib'`{Univalence} {ABC:AbGroup} {E:AbSESCB}(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt):hfiber_cxfib'EFp<~>hfiber(cxfib(iscomplex_pullback_absesE))(equiv_hfiber_abses_pt(F;p)).Proof.srapplyequiv_functor_sigma_id;introU;lazybeta.refine(_oEequiv_hfiber_abses_pullback___).refine(_oEequiv_ap'(equiv_hfiber_abses_pt)__).applyequiv_concat_l.applyeq_cxfib_cxfib'.Defined.The type of paths inhfiber_cxfib'in terms of path data.Definitionpath_hfiber_cxfib'{ABC:AbGroup} {E:AbSESCB}{F:AbSES(middleE)A} {p:abses_pullback(inclusionE)F$==pt}(XY:hfiber_cxfib'(B:=B)EFp):Type.Proof.refine(sig(funq0:X.1 $==Y.1 =>_)).exact((fmap(abses_pullback(projectionE))q0)^$ $@X.2.1 $==Y.2.1).Defined.Definitiontransport_hfiber_abses_path_cxfib'_l`{Univalence} {ABC:AbGroup} {E:AbSESCB}(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt)(UV:hfiber_cxfib'EFp) (q:U.1 =V.1): (transport(funY:AbSESCA=>hfiber_abses_path(cxfib'EY) (F;p))qU.2).1=fmap(abses_pullback(projectionE)) (equiv_path_abses_iso^-1q^) $@U.2.1.Proof.inductionq.refine(appr1(transport_1__) @_).refine(_@ap(funx=>fmap(abses_pullback(projectionE))x$@_)equiv_path_absesV_1^).refine(_@ap(funx=>x$@_) (fmap_id_strong__)^).exact(cat_idr_strong_)^.Defined.Definitionequiv_path_hfiber_cxfib'`{Univalence} {ABC:AbGroup} {E:AbSESCB}(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt)(UV:hfiber_cxfib'EFp):path_hfiber_cxfib'UV<~>U=V.Proof.refine(equiv_path_sigma___oE_).srapply(equiv_functor_sigma'equiv_path_abses_iso);introq;lazybeta.refine(equiv_path_sigma_hprop__oE_).refine(equiv_concat_l__oE_).1:applytransport_hfiber_abses_path_cxfib'_l.refine(equiv_path_sigma_hprop__oEequiv_concat_l__oE_).1: {refine(ap(funx=> (fmap(abses_pullback_)x$@_).1)_).nrefine(ap_(abses_path_data_Vq) @_).applyeissect. }refine(equiv_concat_l__oE_).1: {refine(ap(funx=> (x$@_).1)_).rapplygpd_strong_1functor_V. }applyequiv_path_groupisomorphism.Defined.The fibre ofcxfib'over(F;p)is inhabited.Definitionhfiber_cxfib'_inhabited`{Univalence} {ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt):hfiber_cxfib'EFp.Proof.exists(abses_pullback_trivial_preimageEFp).srefine(_^$;_).1:byrapply(abses_pullback_component1_id'(abses_pullback_inclusion0_map'EFp)).lazybeta;unfoldpr2.refine(cat_assoc___$@_).refine(cat_assoc___$@_).applygpd_moveR_Vh.applygpd_moveL_hM.applyequiv_ab_biprod_ind_homotopy.split;applyequiv_path_pullback_rec_hset;split;cbn.-introa.exact(ap(class_of_opullback_pr1) (fstp^$.2a)).-introa.exact((sndp^$.2_)^).-introb;applyqglue.exists(-b).applygrp_moveL_Vg.refine((grp_homo_op(grp_pullback_pr1__$op^$.1 $oab_biprod_inr)__)^ @_).exact(ap_(right_inverse_) @grp_homo_unit_@ (grp_homo_unit_)^).-introb.exact(sndp^$.2_)^.Defined.To conclude exactness in terms of path data, we show that the fibre is a proposition, hence contractible.Given a point(Y;Q)in the fiber ofcxfib'over(F;p)there is an induced map as follows.Local Definitionhfiber_cxfib'_induced_map{ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt)(Y:hfiber_cxfib'EFp):ab_biprodAB$->abses_pullback(projectionE)Y.1.Proof.destructYas[Yq].refine(grp_homo_compose_(grp_iso_inversep.1)).refine(_$ogrp_pullback_pr1__).exact(q.1^$.1).Defined.There is "another" obvious induced map.Definitionabses_pullback_splits_induced_map'{ABC:AbGroup}(E:AbSESCB) (Y:AbSESCA):ab_biprodAB$->abses_pullback(projectionE)Y.Proof.srapply(ab_biprod_rec(inclusion_)).srapplygrp_pullback_corec.-exactgrp_homo_const.-exact(inclusionE).-introx.refine(grp_homo_unit_@_).symmetry;applyiscomplex_abses.Defined.Lemmafmap_hfiber_abses_lemma`{Univalence} {ABB':AbGroup} (f:B'$->B)(XY:graph_hfiber(abses_pullback(A:=A)f)pt) (Q:hfiber_abses_pathXY):fmap(abses_pullbackf)Q.1^$ $oY.2^$ $==X.2^$.Proof.generalizeQ.equiv_intro(equiv_hfiber_abses_pullback_XY)^-1%equivp;inductionp.refine((_$@R_) $@_).{Unshelve.2:exact(Id_).refine(fmap2__$@fmap_id__).introx;reflexivity. }exact(cat_idl_).Defined.Lemmainduced_map_eq`{Univalence} {ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt)(Y:hfiber_cxfib'EFp):hfiber_cxfib'_induced_mapEFpY==abses_pullback_splits_induced_map'EY.1.Proof.intros[ab];cbn.refine(appullback_pr1(fmap_hfiber_abses_lemma__(F;p)Y.2_) @_).srapplyequiv_path_pullback_hset;split;cbn.-exact(grp_unit_r_)^.-exact(grp_unit_l_)^.Defined.Given another point(Y,Q)in the fibre ofcxfib'over(F;p), we get path data inAbSESCA.Lemmahfiber_cxfib'_induced_path'0`{Univalence} {ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt)(Y:hfiber_cxfib'EFp):abses_pullback_trivial_preimageEFp$==Y.1.Proof.destructYas[YQ].applyabses_path_data_to_iso;srefine(_; (_,_)).-snrapply(ab_cokernel_embedding_rec_(grp_pullback_pr1__$o(Q.1^$).1)).1-3:exact_.introf.nrefine(ap_(induced_map_eqEFp(Y;Q)_) @_);cbn.exact(grp_unit_r_@grp_homo_unit_).-introa.refine(_@ap(grp_pullback_pr1__) (fst(Q.1^$).2a)).exact(grp_quotient_rec_beta'_F__(inclusionFa)).-nrapply(conn_map_elim_grp_quotient_map).1:applyissurj_class_of.1:intros?;applyistrunc_paths;applygroup_isgroup.introf.refine(ap(projectionE) (snd(Q.1^$).2f) @_);unfoldpr1.exact(pullback_commsq__((Q.1^$).1f))^.Defined.Lemmahfiber_cxfib'_induced_path'`{Univalence} {ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt)(Y:hfiber_cxfib'EFp):path_hfiber_cxfib'(hfiber_cxfib'_inhabitedEFp)Y.Proof.exists(hfiber_cxfib'_induced_path'0EFpY).rapplygpd_moveR_Vh.rapplygpd_moveL_hM.rapplygpd_moveR_Vh.introx.srapplyequiv_path_pullback_hset;split.2:exact(sndY.2.1^$.2x)^.reflexivity.Defined.It follows thathfiber_cxfib'is contractible.Lemmacontr_hfiber_cxfib'`{Univalence} {ABC:AbGroup} (E:AbSESCB)(F:AbSES(middleE)A) (p:abses_pullback(inclusionE)F$==pt):Contr(hfiber_cxfib'EFp).Proof.srapplyBuild_Contr.1:applyhfiber_cxfib'_inhabited.intros[Yq].applyequiv_path_hfiber_cxfib'.applyhfiber_cxfib'_induced_path'.Defined.From this we deduce exactness.Global Instanceisexact_abses_pullback`{Univalence} {ABC:AbGroup} {E:AbSESCB}:IsExactpurely(abses_pullback_pmap(A:=A) (projectionE)) (abses_pullback_pmap(inclusionE)).Proof.srapplyBuild_IsExact.1:applyiscomplex_pullback_abses.srapply(equiv_ind(equiv_hfiber_abses(abses_pullback(inclusionE)) (point(AbSESBA)))).intros[Fp].rapplycontr_equiv'.1:applyequiv_hfiber_cxfib'.applycontr_hfiber_cxfib'.Defined.

--- Miscellaneous\Pushout.html ---
PushoutLibrary PushoutRequireImportBasics.RequireImportTypes.PathsTypes.ArrowTypes.SigmaTypes.SumTypes.Universe.RequireExportColimits.Coeq.Local OpenScopepath_scope.Homotopy PushoutsWe define pushouts in terms of coproducts and coequalizers.DefinitionPushout@{ijkl} {A:Type@{i}} {B:Type@{j}} {C:Type@{k}}(f:A->B) (g:A->C) :Type@{l}:=Coeq@{ll_} (inlof) (inrog).Definitionpush{ABC:Type} {f:A->B} {g:A->C}:B+C->Pushoutfg:= @coeq__(inlof) (inrog).Definitionpushl{ABC} {f:A->B} {g:A->C} (b:B):Pushoutfg:=push(inlb).Definitionpushr{ABC} {f:A->B} {g:A->C} (c:C):Pushoutfg:=push(inrc).Definitionpglue{ABC:Type} {f:A->B} {g:A->C} (a:A):pushl(fa) =pushr(ga):= @cglueA(B+C) (inlof) (inrog)a.(* Some versions with explicit parameters. *)Definitionpushl'{ABC} (f:A->B) (g:A->C) (b:B) :Pushoutfg:=pushlb.Definitionpushr'{ABC} (f:A->B) (g:A->C) (c:C) :Pushoutfg:=pushrc.Definitionpglue'{ABC:Type} (f:A->B) (g:A->C) (a:A) :pushl(fa) =pushr(ga):=pgluea.SectionPushoutInd.Context{ABC:Type} {f:A->B} {g:A->C}(P:Pushoutfg->Type)(pushb:forallb:B,P(pushlb))(pushc:forallc:C,P(pushrc))(pusha:foralla:A, (pgluea) # (pushb(fa)) =pushc(ga)).DefinitionPushout_ind:forall(w:Pushoutfg),Pw:=Coeq_indP(sum_ind(Popush)pushbpushc)pusha.DefinitionPushout_ind_beta_pushl(b:B) :Pushout_ind(pushlb) =pushbb:= 1.DefinitionPushout_ind_beta_pushr(c:C) :Pushout_ind(pushrc) =pushcc:= 1.DefinitionPushout_ind_beta_pglue(a:A):apDPushout_ind(pgluea) =pushaa:=Coeq_ind_beta_cglueP(funbc=>matchbcwithinlb=>pushbb|inrc=>pushccend)pushaa.EndPushoutInd.But we want to allow the user to forget that we've defined pushouts in terms of coequalizers.ArgumentsPushout:simplnever.Argumentspush:simplnever.Argumentspglue:simplnever.ArgumentsPushout_ind_beta_pglue:simplnever.However, we do allowPushout_indto simplify, as it computes on point constructors.DefinitionPushout_rec{ABC} {f:A->B} {g:A->C} (P:Type)(pushb:B->P)(pushc:C->P)(pusha:foralla:A,pushb(fa) =pushc(ga)): @PushoutABCfg->P:= @Coeq_rec__(inlof) (inrog)P(sum_recPpushbpushc)pusha.DefinitionPushout_rec_beta_pglue{ABCfg} (P:Type)(pushb:B->P)(pushc:C->P)(pusha:foralla:A,pushb(fa) =pushc(ga))(a:A):ap(Pushout_recPpushbpushcpusha) (pgluea) =pushaa.Proof.nrapplyCoeq_rec_beta_cglue.Defined.Universal propertyDefinitionpushout_unrec{ABCP} (f:A->B) (g:A->C)(h:Pushoutfg->P): {psh: (B->P) * (C->P) &foralla,fstpsh(fa) =sndpsh(ga)}.Proof.exists(hopushl,hopushr).introsa;cbn.exact(aph(pgluea)).Defined.Definitionpushout_rec_unrec{ABC} (f:A->B) (g:A->C)P(e:Pushoutfg->P):Pushout_recP(eopushl) (eopushr) (funa=>ape(pgluea)) ==e.Proof.snrapplyPushout_ind.1, 2:reflexivity.introa;cbnbeta.applytransport_paths_FlFr'.applyequiv_p1_1q.nrapplyPushout_rec_beta_pglue.Defined.Definitionisequiv_Pushout_rec`{Funext} {ABC} (f:A->B) (g:A->C)P:IsEquiv(funp: {psh: (B->P) * (C->P) &foralla,fstpsh(fa) =sndpsh(ga) }=>Pushout_recP(fstp.1) (sndp.1)p.2).Proof.srefine(isequiv_adjointify_(pushout_unrecfg)__).-introe.applypath_arrow.applypushout_rec_unrec.-intros[[pushbpushc]pusha];unfoldpushout_unrec;cbn.snrapplypath_sigma'.+reflexivity.+cbn.applypath_forall;introsa.applyPushout_rec_beta_pglue.Defined.Definitionequiv_Pushout_rec`{Funext} {ABC} (f:A->B) (g:A->C)P: {psh: (B->P) * (C->P) &foralla,fstpsh(fa) =sndpsh(ga) }<~> (Pushoutfg->P):=Build_Equiv___(isequiv_Pushout_recfgP).Definitionequiv_pushout_unrec`{Funext} {ABC} (f:A->B) (g:A->C)P: (Pushoutfg->P)<~> {psh: (B->P) * (C->P) &foralla,fstpsh(fa) =sndpsh(ga) }:=equiv_inverse(equiv_Pushout_recfgP).SymmetryDefinitionpushout_sym_map{ABC} {f:A->B} {g:A->C}:Pushoutfg->Pushoutgf:=Pushout_rec(Pushoutgf)pushrpushl(funa:A=> (pgluea)^).Lemmasect_pushout_sym_map{ABCfg}: (@pushout_sym_mapABCfg)o(@pushout_sym_mapACBgf) ==idmap.Proof.srapply@Pushout_ind.-intros;reflexivity.-intros;reflexivity.-introa.simpl.abstract(rewritetransport_paths_FFlr,Pushout_rec_beta_pglue,ap_V,Pushout_rec_beta_pglue;hott_simpl).Defined.Definitionpushout_sym{ABC} {f:A->B} {g:A->C}:Pushoutfg<~>Pushoutgf:=equiv_adjointifypushout_sym_mappushout_sym_mapsect_pushout_sym_mapsect_pushout_sym_map.FunctorialityDefinitionfunctor_pushout{ABC} {f:A->B} {g:A->C}{A'B'C'} {f':A'->B'} {g':A'->C'}(h:A->A') (k:B->B') (l:C->C')(p:kof==f'oh) (q:log==g'oh):Pushoutfg->Pushoutf'g'.Proof.unfoldPushout;srapplyfunctor_coeq.-exacth.-exact(functor_sumkl).-introsa;cbn.applyap,p.-introsa;cbn.applyap,q.Defined.Lemmafunctor_pushout_homotopic{ABC:Type} {f:A->B} {g:A->C}{A'B'C':Type} {f':A'->B'} {g':A'->C'}{hh':A->A'} {kk':B->B'} {ll':C->C'}{p:kof==f'oh} {q:log==g'oh}{p':k'of==f'oh'} {q':l'og==g'oh'}(t:h==h') (u:k==k') (v:l==l')(i:foralla,pa@ (apf') (ta) =u(fa) @p'a)(j:foralla,qa@ (apg') (ta) =v(ga) @q'a):functor_pushouthklpq==functor_pushouth'k'l'p'q'.Proof.srapplyfunctor_coeq_homotopy.1:exactt.1:exact(functor_sum_homotopicuv).1,2:introsb;simpl.1,2:refine(_@ap_pp___@ap_(ap_compose___)^).1,2:refine((ap_pp___)^ @ap__^).1:exact(ib).exact(jb).Defined.EquivalencesPushouts preserve equivalences.SectionEquivPushout.Context{ABCfgA'B'C'f'g'}(eA:A<~>A') (eB:B<~>B') (eC:C<~>C')(p:eBof==f'oeA) (q:eCog==g'oeA).Lemmaequiv_pushout:Pushoutfg<~>Pushoutf'g'.Proof.refine(equiv_functor_coeq'eA(equiv_functor_sum'eBeC)__).all:unfoldpointwise_paths.all:intro;simpl;applyap.+applyp.+applyq.Defined.Lemmaequiv_pushout_pglue(a:A):apequiv_pushout(pgluea)=appushl(pa) @pglue(eAa) @appushr(qa)^.Proof.refine(functor_coeq_beta_cglue____a@_).refine(_@@ 1 @@_).-symmetry;refine(ap_composeinlcoeq_).-refine(ap(apcoeq) (ap_V__)^ @_).symmetry;refine(ap_composeinrcoeq_).Defined.EndEquivPushout.ContractibilityThe pushout of a span of contractible types is contractibleGlobal Instancecontr_pushout{ABC:Type} `{ContrA,ContrB,ContrC}(f:A->B) (g:A->C):Contr(Pushoutfg).Proof.apply(Build_Contr_(pushl(centerB))).srapplyPushout_ind.-introsb;applyap,path_contr.-introsc.refine(_@pglue(centerA) @_).+applyap,path_contr.+applyap,path_contr.-introsa.rewritetransport_paths_r.assert(p:=path_contr(centerA)a).destructp.refine((concat_p1_)^ @_).applywhiskerL.change1with(ap(@pushrABCfg) (idpath(g(centerA)))).apply(ap(appushr)).applypath_contr.Defined.SigmasPushouts commute with sigmasSectionEquivSigmaPushout.Context{X:Type}(A:X->Type) (B:X->Type) (C:X->Type)(f:forallx,Ax->Bx) (g:forallx,Ax->Cx).Local Definitionesp1: {x:X&Pushout(fx) (gx) }->Pushout(functor_sigmaidmapf) (functor_sigmaidmapg).Proof.intros[xp].srefine(Pushout_rec____p).+introsb.exact(pushl(x;b)).+introsc.exact(pushr(x;c)).+introsa;cbn.exact(pglue(x;a)).Defined.Local Definitionesp1_beta_pglue(x:X) (a:Ax):apesp1(path_sigma'(funx=>Pushout(fx) (gx)) 1 (pgluea))=pglue(x;a).Proof.rewrite(ap_path_sigma(funx=>Pushout(fx) (gx))(funxa=>esp1(x;a)) 1 (pgluea));cbn.rewrite!concat_p1.unfoldesp1;rewritePushout_rec_beta_pglue.reflexivity.Qed.Local Definitionesp2:Pushout(functor_sigmaidmapf) (functor_sigmaidmapg)-> {x:X&Pushout(fx) (gx) }.Proof.srefine(Pushout_rec____).+exact(functor_sigmaidmap(funx=> @pushl___(fx) (gx))).+exact(functor_sigmaidmap(funx=> @pushr___(fx) (gx))).+intros[xa];unfoldfunctor_sigma;cbn.srefine(path_sigma'_1_);cbn.applypglue.Defined.Local Definitionesp2_beta_pglue(x:X) (a:Ax):apesp2(pglue(x;a)) =path_sigma'(funx:X=>Pushout(fx) (gx)) 1 (pgluea).Proof.unfoldesp2.rewritePushout_rec_beta_pglue.reflexivity.Qed.Definitionequiv_sigma_pushout: {x:X&Pushout(fx) (gx) }<~>Pushout(functor_sigmaidmapf) (functor_sigmaidmapg).Proof.srefine(equiv_adjointifyesp1esp2__).-srefine(Pushout_ind____);cbn.+reflexivity.+reflexivity.+intros[xa].refine(transport_paths_FFlr__@_).refine(concat_p1_@@ 1 @_).applymoveR_Vp;symmetry.refine(concat_p1_@_).refine(ap_(esp2_beta_pglue__) @_).applyesp1_beta_pglue.-intros[xa];reverta.srefine(Pushout_ind____);cbn.+reflexivity.+reflexivity.+introsa.rewritetransport_paths_FlFr.rewriteconcat_p1;applymoveR_Vp;rewriteconcat_p1.rewrite(ap_compose(exist_x) (esp2oesp1)).rewrite(ap_composeesp1esp2).rewrite(ap_exist(funx=>Pushout(fx) (gx))x__(pgluea)).rewriteesp1_beta_pglue,esp2_beta_pglue.reflexivity.Defined.EndEquivSigmaPushout.Pushouts are associativeSectionPushoutAssoc.Context{A1A2BCD:Type}(f1:A1->B) (g1:A1->C) (f2:A2->C) (g2:A2->D).Definitionpushout_assoc_left:=Pushout(pushr'f1g1of2)g2.Letpushll:B->pushout_assoc_left:=pushl'(pushr'f1g1of2)g2opushl'f1g1.Letpushlm:C->pushout_assoc_left:=pushl'(pushr'f1g1of2)g2opushr'f1g1.Letpushlr:D->pushout_assoc_left:=pushr'(pushr'f1g1of2)g2.Letpgluell:foralla1,pushll(f1a1) =pushlm(g1a1):=funa1=>ap(pushl'(pushr'f1g1of2)g2) (pglue'f1g1a1).Letpgluelr:foralla2,pushlm(f2a2) =pushlr(g2a2):=funa2=>pglue'(pushr'f1g1of2)g2a2.Definitionpushout_assoc_left_ind(P:pushout_assoc_left->Type)(pushb:forallb,P(pushllb))(pushc:forallc,P(pushlmc))(pushd:foralld,P(pushlrd))(pusha1:foralla1, (pgluella1) #pushb(f1a1) =pushc(g1a1))(pusha2:foralla2, (pgluelra2) #pushc(f2a2) =pushd(g2a2)):forallx,Px.Proof.srefine(Pushout_ind__pushd_).-srefine(Pushout_ind_pushbpushc_).introsa1.exact(transport_composePpushl__@pusha1a1).-exactpusha2.Defined.SectionPushout_Assoc_Left_Rec.Context(P:Type)(pushb:B->P)(pushc:C->P)(pushd:D->P)(pusha1:foralla1,pushb(f1a1) =pushc(g1a1))(pusha2:foralla2,pushc(f2a2) =pushd(g2a2)).Definitionpushout_assoc_left_rec:pushout_assoc_left->P.Proof.srefine(Pushout_rec__pushd_).-srefine(Pushout_rec_pushbpushcpusha1).-exactpusha2.Defined.Definitionpushout_assoc_left_rec_beta_pgluella1:appushout_assoc_left_rec(pgluella1) =pusha1a1.Proof.unfoldpgluell.rewrite<- (ap_compose(pushl'(pushr'f1g1of2)g2)pushout_assoc_left_rec).change(ap(Pushout_recPpushbpushcpusha1) (pglue'f1g1a1) =pusha1a1).applyPushout_rec_beta_pglue.Defined.Definitionpushout_assoc_left_rec_beta_pgluelra2:appushout_assoc_left_rec(pgluelra2) =pusha2a2.Proof.unfoldpushout_assoc_left_rec,pgluelr.apply(Pushout_rec_beta_pglue(f:=pushr'f1g1of2) (g:=g2)).Defined.EndPushout_Assoc_Left_Rec.Definitionpushout_assoc_right:=Pushoutf1(pushl'f2g2og1).Letpushrl:B->pushout_assoc_right:=pushl'f1(pushl'f2g2og1).Letpushrm:C->pushout_assoc_right:=pushr'f1(pushl'f2g2og1)opushl'f2g2.Letpushrr:D->pushout_assoc_right:=pushr'f1(pushl'f2g2og1)opushr'f2g2.Letpgluerl:foralla1,pushrl(f1a1) =pushrm(g1a1):=funa1=>pglue'f1(pushl'f2g2og1)a1.Letpgluerr:foralla2,pushrm(f2a2) =pushrr(g2a2):=funa2=>ap(pushr'f1(pushl'f2g2og1)) (pglue'f2g2a2).Definitionpushout_assoc_right_ind(P:pushout_assoc_right->Type)(pushb:forallb,P(pushrlb))(pushc:forallc,P(pushrmc))(pushd:foralld,P(pushrrd))(pusha1:foralla1, (pgluerla1) #pushb(f1a1) =pushc(g1a1))(pusha2:foralla2, (pgluerra2) #pushc(f2a2) =pushd(g2a2)):forallx,Px.Proof.srefine(Pushout_ind_pushb__).-srefine(Pushout_ind_pushcpushd_).introsa2.exact(transport_composePpushr__@pusha2a2).-exactpusha1.Defined.SectionPushout_Assoc_Right_Rec.Context(P:Type)(pushb:B->P)(pushc:C->P)(pushd:D->P)(pusha1:foralla1,pushb(f1a1) =pushc(g1a1))(pusha2:foralla2,pushc(f2a2) =pushd(g2a2)).Definitionpushout_assoc_right_rec:pushout_assoc_right->P.Proof.srefine(Pushout_rec_pushb__).-srefine(Pushout_rec_pushcpushdpusha2).-exactpusha1.Defined.Definitionpushout_assoc_right_rec_beta_pgluerla1:appushout_assoc_right_rec(pgluerla1) =pusha1a1.Proof.unfoldpushout_assoc_right_rec,pgluerl.apply(Pushout_rec_beta_pglue(f:=f1) (g:=pushl'f2g2og1)).Defined.Definitionpushout_assoc_right_rec_beta_pgluerra2:appushout_assoc_right_rec(pgluerra2) =pusha2a2.Proof.unfoldpgluerr.rewrite<- (ap_compose(pushr'f1(pushl'f2g2og1))pushout_assoc_right_rec).change(ap(Pushout_recPpushcpushdpusha2) (pglue'f2g2a2) =pusha2a2).applyPushout_rec_beta_pglue.Defined.EndPushout_Assoc_Right_Rec.Definitionequiv_pushout_assoc:Pushout(pushr'f1g1of2)g2<~>Pushoutf1(pushl'f2g2og1).Proof.srefine(equiv_adjointify____).-exact(pushout_assoc_left_rec_pushrlpushrmpushrrpgluerlpgluerr).-exact(pushout_assoc_right_rec_pushllpushlmpushlrpgluellpgluelr).-abstract(srefine(pushout_assoc_right_ind_(fun_=> 1) (fun_=> 1) (fun_=> 1)__);intros;simpl;rewritetransport_paths_FlFr,ap_compose;[rewritepushout_assoc_right_rec_beta_pgluerl,pushout_assoc_left_rec_beta_pgluell|rewritepushout_assoc_right_rec_beta_pgluerr,pushout_assoc_left_rec_beta_pgluelr];rewriteconcat_p1,ap_idmap;applyconcat_Vp).-abstract(srefine(pushout_assoc_left_ind_(fun_=> 1) (fun_=> 1) (fun_=> 1)__);intros;simpl;rewritetransport_paths_FlFr,ap_compose;[rewritepushout_assoc_left_rec_beta_pgluell,pushout_assoc_right_rec_beta_pgluerl|rewritepushout_assoc_left_rec_beta_pgluelr,pushout_assoc_right_rec_beta_pgluerr];rewriteconcat_p1,ap_idmap;applyconcat_Vp).Defined.EndPushoutAssoc.Pushouts of equvialences are equivalencesGlobal Instanceisequiv_pushout_isequiv{ABC} (f:A->B) (g:A->C)`{IsEquiv__f} :IsEquiv(pushr'fg).Proof.srefine(isequiv_adjointify____).-srefine(Pushout_recC(gof^-1)idmap_).introsa;cbn;applyap,eissect.-srefine(Pushout_ind____);cbn.+introsb;change(pushr'fg(g(f^-1b)) =pushlb).transitivity(pushl'fg(f(f^-1b))).*symmetry;applypglue.*applyap,eisretr.+introsc;reflexivity.+introsa.abstract(rewritetransport_paths_FlFr,ap_compose, !concat_pp_p;applymoveR_Vp;applymoveR_Vp;rewritePushout_rec_beta_pglue,eisadj,ap_idmap,concat_p1;rewrite<-ap_compose, <- (ap_composeg(pushr'fg));exact(concat_Ap(pglue'fg) (eissectfa)) ).-introsc;reflexivity.Defined.Global Instanceisequiv_pushout_isequiv'{ABC} (f:A->B) (g:A->C)`{IsEquiv__g} :IsEquiv(pushl'fg).Proof.srefine(isequiv_adjointify____).-srefine(Pushout_recBidmap(fog^-1)_).introsa;cbn.symmetry;applyap,eissect.-srefine(Pushout_ind____);cbn.+introsb;reflexivity.+introsc;change(pushl'fg(f(g^-1c)) =pushrc).transitivity(pushr'fg(g(g^-1c))).*applypglue.*applyap,eisretr.+introsa.abstract(rewritetransport_paths_FlFr,ap_compose, !concat_pp_p;applymoveR_Vp;rewritePushout_rec_beta_pglue,eisadj,ap_idmap,concat_1p,ap_V;applymoveL_Vp;rewrite<- !ap_compose;exact(concat_Ap(pglue'fg) (eissectga)) ).-introsc;reflexivity.Defined.Flattening lemma for pushoutsThe flattening lemma for pushouts follows from the flattening lemma for coequalizers.SectionFlattening.Context`{Univalence} {ABC} {f:A->B} {g:A->C}(F:B->Type) (G:C->Type) (e:foralla,F(fa) <~>G(ga)).Definitionpushout_flatten_fam:Pushoutfg->Type:=Pushout_recTypeFG(funa=>path_universe(ea)).In this result, the vertex of the pushout is taken to be{a:A&F(f(a))}, the pullback ofFalongf.Definitionequiv_pushout_flatten:sigpushout_flatten_fam<~>Pushout(functor_sigmaf(fun_=>idmap)) (functor_sigmage).Proof.unfoldpushout_flatten_fam.refine(_oEequiv_coeq_flatten__).unfoldPushout.snrapplyequiv_functor_coeq'.-reflexivity.-applyequiv_sigma_sum.-reflexivity.-reflexivity.Defined.EndFlattening.

--- Miscellaneous\QuotientGroup.html ---
QuotientGroupLibrary QuotientGroupRequireImportBasicsTypes.RequireImportTruncations.Core.RequireImportAlgebra.Congruence.RequireImportAlgebra.Groups.Group.RequireImportAlgebra.Groups.Subgroup.RequireExportAlgebra.Groups.Image.RequireExportAlgebra.Groups.Kernel.RequireExportColimits.Quotient.RequireImportHSet.RequireImportSpaces.Finite.Finite.RequireImportWildCat.RequireImportModalities.Modality.Quotient groupsLocal OpenScopemc_scope.Local OpenScopemc_mult_scope.Local OpenScopewc_iso_scope.SectionGroupCongruenceQuotient.A congruence on a group is a relation satisfyingRxx'->Ryy'->R(x*y)(x'*y').  Because we also require thatRis reflexive, we also know thatRyy'->R(x*y)(x*y')for anyx, and similarly for multiplication on the right byx.  We don't need to assume thatRis symmetric or transitive.Context{G:Group} {R:RelationG} `{!IsCongruenceR, !ReflexiveR}.The type underlying the quotient group isQuotientR.DefinitionCongruenceQuotient:=G/R.Global Instancecongquot_sgop:SgOpCongruenceQuotient.Proof.srapplyQuotient_rec2.-introsxy.exact(class_of_(x*y)).-introsxx'yp.applyqglue.byapplyiscong.-introsxyy'q.applyqglue.byapplyiscong.Defined.Global Instancecongquot_mon_unit:MonUnitCongruenceQuotient.Proof.applyclass_of,mon_unit.Defined.Global Instancecongquot_negate:NegateCongruenceQuotient.Proof.srapplyQuotient_rec.1:exact(class_ofRonegate).introsxyp;cbn.symmetry.rewrite<- (left_identity(-x)).destruct(left_inversey).set(-y*y* -x).rewrite<- (right_identity(-y)).destruct(right_inversex).unfoldg;clearg.rewrite<-simple_associativity.applyqglue.applyiscong;tryreflexivity.applyiscong;tryreflexivity.exactp.Defined.Global Instancecongquot_sgop_associative:Associativecongquot_sgop.Proof.srapplyQuotient_ind3_hprop;introsxyz.simpl;byrewriteassociativity.Qed.Global Instanceissemigroup_congquot:IsSemiGroupCongruenceQuotient:= {}.Global Instancecongquot_leftidentity:LeftIdentitycongquot_sgopcongquot_mon_unit.Proof.srapplyQuotient_ind_hprop;introx.bysimpl;rewriteleft_identity.Qed.Global Instancecongquot_rightidentity:RightIdentitycongquot_sgopcongquot_mon_unit.Proof.srapplyQuotient_ind_hprop;introx.bysimpl;rewriteright_identity.Qed.Global Instanceismonoid_quotientgroup:IsMonoidCongruenceQuotient:= {}.Global Instancequotientgroup_leftinverse:LeftInversecongquot_sgopcongquot_negatecongquot_mon_unit.Proof.srapplyQuotient_ind_hprop;introx.bysimpl;rewriteleft_inverse.Qed.Global Instancequotientgroup_rightinverse:RightInversecongquot_sgopcongquot_negatecongquot_mon_unit.Proof.srapplyQuotient_ind_hprop;introx.bysimpl;rewriteright_inverse.Qed.Global Instanceisgroup_quotientgroup:IsGroupCongruenceQuotient:= {}.EndGroupCongruenceQuotient.Now we can define the quotient group by a normal subgroup.SectionQuotientGroup.Context(G:Group) (N:NormalSubgroupG).Global Instanceiscongruence_in_cosetL:IsCongruence(in_cosetLN).Proof.srapplyBuild_IsCongruence.intros;byapplyin_cosetL_cong.Defined.Global Instanceiscongruence_in_cosetR:IsCongruence(in_cosetRN).Proof.srapplyBuild_IsCongruence.intros;byapplyin_cosetR_cong.Defined.Now we have to make a choice whether to pick the left or right cosets. Due to existing convention we shall pick left cosets but we note that we could equally have picked right.DefinitionQuotientGroup:Group:=Build_Group(G/ (in_cosetLN))____.Definitiongrp_quotient_map:G$->QuotientGroup.Proof.snrapplyBuild_GroupHomomorphism.1:exact(class_of_).intros??;reflexivity.Defined.Definitiongrp_quotient_rec{A:Group} (f:G$->A)(h:foralln:G,Nn->fn=mon_unit):QuotientGroup$->A.Proof.snrapplyBuild_GroupHomomorphism.-srapplyQuotient_rec.+exactf.+cbn;introsxyn.applygrp_moveR_M1.rhs_Vnrapply(ap(.*fy) (grp_homo_inv__)).rhs_Vnrapplygrp_homo_op.symmetry;applyh;assumption.-introx.refine(Quotient_ind_hprop___).introy.revertx.refine(Quotient_ind_hprop___).introx;simpl.applygrp_homo_op.Defined.Definitiongrp_quotient_ind_hprop(P:QuotientGroup->Type)`{forallx,IsHProp(Px)}(H1:forallx,P(grp_quotient_mapx)):forallx,Px.Proof.srapplyQuotient_ind_hprop.exactH1.Defined.EndQuotientGroup.ArgumentsQuotientGroupGN:simplnever.Argumentsgrp_quotient_map{__}.Notation"G / N" := (QuotientGroupGN) :group_scope.Rephrasing that lets you specify the normality proofDefinitionQuotientGroup'(G:Group) (N:SubgroupG) (H:IsNormalSubgroupN):=QuotientGroupG(Build_NormalSubgroupGNH).Local OpenScopegroup_scope.Computation rule for grp_quotient_rec.Corollarygrp_quotient_rec_beta`{F:Funext} {G:Group}(N:NormalSubgroupG) (H:Group){A:Group} (f:G$->A)(h:foralln:G,Nn->fn=mon_unit): (grp_quotient_recGNfh) $ogrp_quotient_map=f.Proof.applyequiv_path_grouphomomorphism;reflexivity.Defined.Computation rule for grp_quotient_rec.Definitiongrp_quotient_rec_beta'{G:Group}(N:NormalSubgroupG) (H:Group){A:Group} (f:G$->A)(h:foralln:G,Nn->fn=mon_unit): (grp_quotient_recGNfh) $ogrp_quotient_map==f:=fun_=>idpath.The proof of normality is irrelevent up to equivalence. This is unfortunate that it doesn't hold definitionally.Definitiongrp_iso_quotient_normal(G:Group) (H:SubgroupG){kk':IsNormalSubgroupH}:QuotientGroup'GHk≅QuotientGroup'GHk'.Proof.snrapplyBuild_GroupIsomorphism'.1:reflexivity.introx.srapplyQuotient_ind_hprop;introy;revertx.srapplyQuotient_ind_hprop;introx.reflexivity.Defined.The universal mapping property for groupsTheoremequiv_grp_quotient_ump{F:Funext} {G:Group} (N:NormalSubgroupG) (H:Group): {f:G$->H&forall(n:G),Nn->fn=mon_unit}<~> (G/N$->H).Proof.srapplyequiv_adjointify.-intros[fp].exact(grp_quotient_rec__fp).-introf.exists(f$ogrp_quotient_map).introsnh;cbn.refine(_@grp_homo_unitf).applyap.applyqglue;cbn.rewriteright_identity;byapplyissubgroup_in_inv.-introsf.rapplyequiv_path_grouphomomorphism.bysrapplyQuotient_ind_hprop.-intros[fp].srapplypath_sigma_hprop;simpl.exact(grp_quotient_rec_betaNHfp).Defined.SectionFirstIso.Context`{Funext} {AB:Group} (phi:A$->B).First we define a map from the quotient by the kernel of phi into the image of phiDefinitiongrp_image_quotient:A/grp_kernelphi$->grp_imagephi.Proof.srapplygrp_quotient_rec.+srapplygrp_image_in.+introsnx.byapplypath_sigma_hprop.Defined.The underlying map of this homomorphism is an equivalenceGlobal Instanceisequiv_grp_image_quotient:IsEquivgrp_image_quotient.Proof.snrapplyisequiv_surj_emb.1:srapplycancelR_conn_map.srapplyisembedding_isinj_hset.refine(Quotient_ind_hprop___);introx.refine(Quotient_ind_hprop___);introy.introsh;simplinh.applyqglue;cbn.apply(equiv_path_sigma_hprop__)^-1%equivinh;cbninh.cbn.rewritegrp_homo_op,grp_homo_inv,h.srapplynegate_l.Defined.First isomorphism theorem for groupsTheoremgrp_first_iso:A/grp_kernelphi≅grp_imagephi.Proof.exact(Build_GroupIsomorphism__grp_image_quotient_).Defined.EndFirstIso.Quotient groups are finite.  Note that we cannot constructively conclude that the normal subgroupHmust be finite sinceGis, therefore we keep it as an assumption.Global Instancefinite_quotientgroup{U:Univalence} (G:Group) (H:NormalSubgroupG)(fin_G:FiniteG) (fin_H:FiniteH):Finite(QuotientGroupGH).Proof.nrapplyfinite_quotient.1-5:exact_.introsxy.pose(dec_H:=detachable_finite_subsetH).applydec_H.Defined.Definitiongrp_kernel_quotient_iso`{Univalence} {G:Group} (N:NormalSubgroupG):GroupIsomorphismN(grp_kernel(@grp_quotient_mapGN)).Proof.srapplyBuild_GroupIsomorphism.-srapply(grp_kernel_corec(subgroup_inclN)).introx;cbn.applyqglue.applyissubgroup_in_op.+exact(issubgroup_in_inv_x.2).+exactissubgroup_in_unit.-applyisequiv_surj_emb.2:apply(cancelL_isembedding(g:=pr1)).intros[gp].rapplycontr_inhabited_hprop.srefine(tr((g;_);_)).+rewrite<-grp_unit_l, <-negate_mon_unit.apply(related_quotient_paths(funxy=>N(-x*y))).exactp^.+srapplypath_sigma_hprop.reflexivity.Defined.

--- Miscellaneous\QuotientRing.html ---
QuotientRingLibrary QuotientRingRequireImportWildCat.CoreWildCat.Equiv.RequireImportAlgebra.Congruence.RequireImportAlgebra.AbGroups.RequireImportClasses.interfaces.abstract_algebra.RequireImportAlgebra.Rings.Ring.RequireImportAlgebra.Rings.Ideal.Quotient RingsIn this file we define the quotient of a ring by an ideal.ImportIdeal.Notation.Local OpenScopering_scope.Local OpenScopewc_iso_scope.SectionQuotientRing.Context(R:Ring) (I:IdealR).Instanceplus_quotient_group:Plus(QuotientAbGroupRI) :=group_sgop.Instanceiscong_mult_incosetL: @IsCongruenceRring_mult(in_cosetLI).Proof.snrapplyBuild_IsCongruence.introsxx'yy'pq.change(I( - (x*y) + (x'*y'))).rewrite<- (rng_plus_zero_l(x'*y')).rewrite<- (rng_plus_negate_r(x'*y)).rewrite2rng_plus_assoc.rewrite<-rng_mult_negate_l.rewrite<-rng_dist_r.rewrite<-rng_plus_assoc.rewrite<-rng_mult_negate_r.rewrite<-rng_dist_l.rapplysubgroup_in_op.-byrapplyisrightideal.-byrapplyisleftideal.Defined.Instancemult_quotient_group:Mult(QuotientAbGroupRI).Proof.srapplyQuotient_rec2.-exact(funxy=>class_of_(x*y)).-introsxx'yp.applyqglue.byapplyiscong.-introsxyy'q.applyqglue.byapplyiscong.Defined.Instanceone_quotient_abgroup:One(QuotientAbGroupRI) :=class_of_one.Instanceisring_quotient_abgroup:IsRing(QuotientAbGroupRI).Proof.split.1:exact_.1:repeatsplit.1:exact_.Associativity follows from the underlying operation{srapplyQuotient_ind3_hprop;introsxyz.unfoldsg_op,mult_is_sg_op,mult_quotient_group;simpl.applyap.applyassociativity. }(* Left and right identity follow from the underlying structure *)1,2:snrapplyQuotient_ind_hprop; [exact_|introx].1-2:unfoldsg_op,mult_is_sg_op,mult_quotient_group;simpl.1-2:applyap.1:applyleft_identity.1:applyright_identity.Finally distributivity also follows{srapplyQuotient_ind3_hprop;introsxyz.unfoldsg_op,mult_is_sg_op,mult_quotient_group,plus,mult,plus_quotient_group;simpl.applyap.applysimple_distribute_l. }{srapplyQuotient_ind3_hprop;introsxyz.unfoldsg_op,mult_is_sg_op,mult_quotient_group,plus,mult,plus_quotient_group;simpl.applyap.applysimple_distribute_r. }Defined.DefinitionQuotientRing:Ring:=Build_Ring(QuotientAbGroupRI)_______.EndQuotientRing.Infix"/" :=QuotientRing:ring_scope.Quotient mapDefinitionrng_quotient_map{R:Ring} (I:IdealR):RingHomomorphismR(R/I).Proof.snrapplyBuild_RingHomomorphism'.1:rapplygrp_quotient_map.repeatsplit.Defined.Global Instanceissurj_rng_quotient_map{R:Ring} (I:IdealR):IsSurjection(rng_quotient_mapI).Proof.exact_.Defined.Specialized induction principlesWe provide some specialized induction principes forQuotientRingthat require cleaner hypotheses than the ones given byQuotient_ind.DefinitionQuotientRing_ind{R:Ring} {I:IdealR} (P:R/I->Type)`{forallx,IsHSet(Px)}(c:forall(x:R),P(rng_quotient_mapIx))(g:forall(xy:R) (h:I(-x+y)),qglueh#cx=cy):forall(r:R/I),Pr:=Quotient_ind_Pcg.And a version eliminating into hprops. This one is especially useful.DefinitionQuotientRing_ind_hprop{R:Ring} {I:IdealR} (P:R/I->Type)`{forallx,IsHProp(Px)} (c:forall(x:R),P(rng_quotient_mapIx)):forall(r:R/I),Pr:=Quotient_ind_hprop_Pc.DefinitionQuotientRing_ind2_hprop{R:Ring} {I:IdealR} (P:R/I->R/I->Type)`{forallxy,IsHProp(Pxy)}(c:forall(xy:R),P(rng_quotient_mapIx) (rng_quotient_mapIy)):forall(rs:R/I),Prs:=Quotient_ind2_hprop_Pc.DefinitionQuotientRing_rec{R:Ring} {I:IdealR} (S:Ring)(f:R$->S) (H:forallx,Ix->fx= 0):R/I$->S.Proof.snrapplyBuild_RingHomomorphism'.-snrapply(grp_quotient_rec__f).exactH.-split.+srapplyQuotientRing_ind2_hprop.nrapplyrng_homo_mult.+nrapplyrng_homo_one.Defined.Quotient theoryFirst isomorphism theorem for commutative ringsDefinitionrng_first_iso`{Funext} {AB:Ring} (f:A$->B):A/ideal_kernelf≅rng_imagef.Proof.snrapplyBuild_RingIsomorphism''.1:rapplyabgroup_first_iso.split.{srapplyQuotientRing_ind2_hprop;introsxy.srapplypath_sigma_hprop.exact(rng_homo_mult___). }srapplypath_sigma_hprop.exact(rng_homo_one_).Defined.Invariance of equal idealsLemmarng_quotient_invar{R:Ring} {IJ:IdealR} (p: (I↔J)%ideal):R/I≅R/J.Proof.snrapplyBuild_RingIsomorphism'.{srapplyequiv_quotient_functor'.1:exactequiv_idmap.introsxy;cbn.applyp. }repeatsplit.1,2:srapplyQuotient_ind2_hprop;introsxy;rapplyqglue.1:change(J( - (x+y) + (x+y))).2:change(J(- (x*y) + (x*y))).1,2:rewriterng_plus_negate_l.1,2:applyideal_in_zero.Defined.We phrase the first ring isomorphism theroem in a slightly differnt way so that it is easier to use. This form specifically asks for a surjective mapDefinitionrng_first_iso'`{Funext} {AB:Ring} (f:A$->B)(issurj_f:IsSurjectionf)(I:IdealA) (p: (I↔ideal_kernelf)%ideal):A/I≅B.Proof.etransitivity.1:apply(rng_quotient_invarp).etransitivity.2:rapply(rng_image_issurjf).applyrng_first_iso.Defined.

--- Miscellaneous\rationals.html ---
rationalsLibrary rationalsRequireImportHoTT.Classes.implementations.peano_naturalsHoTT.Classes.implementations.natpair_integersHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.naturalsHoTT.Classes.interfaces.rationalsHoTT.Classes.interfaces.ordersHoTT.Classes.theory.groupsHoTT.Classes.theory.integersHoTT.Classes.theory.dec_fieldsHoTT.Classes.orders.sumHoTT.Classes.orders.dec_fieldsHoTT.Classes.orders.latticesHoTT.Classes.theory.additional_operationsHoTT.Classes.tactics.ring_quoteHoTT.Classes.tactics.ring_tac.ImportQuoting.Instances.ImportNatPair.Instances.LocalSetUniverseMinimizationToSet.Sectioncontents.Context`{Funext} `{Univalence}.UniverseUQ.Context{Q:Type@{UQ} } {Qap:Apart@{UQUQ}Q}{Qplus:PlusQ} {Qmult:MultQ}{Qzero:ZeroQ} {Qone:OneQ} {Qneg:NegateQ} {Qrecip:DecRecipQ}{Qle:Le@{UQUQ}Q} {Qlt:Lt@{UQUQ}Q}{QtoField:RationalsToField@{UQUQUQUQ}Q}{Qrats:Rationals@{UQUQUQUQUQUQUQUQUQUQ}Q}{Qtrivialapart:TrivialApartQ} {Qdec:DecidablePathsQ}{Qmeet:MeetQ} {Qjoin:JoinQ} {Qlattice:LatticeOrderQle}{Qle_total:TotalRelation(@leQ_)}{Qabs:AbsQ}.Global Instancerational_1_neq_0:PropHolds(@apartQ_1 0).Proof.red.applytrivial_apart.solve_propholds.Qed.RecordQpos@{} :Type@{UQ} :=mkQpos{pos:Q;is_pos: 0 <pos}.Notation"Q+" :=Qpos.Global InstanceQpos_Q@{} :CastQposQ:=pos.ArgumentsQpos_Q/.LemmaQpos_plus_pr@{} :forallab:Qpos, 0 < 'a+ 'b.Proof.intros.applysemirings.pos_plus_compat;applyis_pos.Qed.Global InstanceQpos_plus@{} :PlusQpos:=funab=>mkQpos_(Qpos_plus_prab).Global Instancepos_is_pos@{} :forallq:Q+,PropHolds(0 < 'q):=is_pos.Lemmapos_eq@{} :forallab:Q+, @pathsQ('a) ('b) ->a=b.Proof.intros[aEa] [bEb]E.change(a=b)inE.destructE;applyap;applypath_ishprop.Qed.Global InstanceQpos_isset:IsHSetQ+.Proof.apply(@HSet.ishset_hrel_subpaths_(funed=> 'e= 'd)).-introse;reflexivity.-apply_.-exactpos_eq.Qed.Global InstanceQpos_one@{} :OneQ+.Proof.exists1.applylt_0_1.Defined.Global InstanceQpos_mult@{} :MultQ+.Proof.introsab;exists('a* 'b).solve_propholds.Defined.Global Instanceqpos_plus_comm@{} :Commutative(@plusQ+_).Proof.hnf.intros.applypos_eq.change('x+ 'y= 'y+ 'x).applyplus_comm.Qed.Global Instanceqpos_mult_comm@{} :Commutative(@multQ+_).Proof.hnf;intros;applypos_eq,mult_comm.Qed.Global Instancepos_recip@{} :DecRecipQ+.Proof.introse.exists(/ 'e).applypos_dec_recip_compat.solve_propholds.Defined.Global Instancepos_of_nat@{} :CastnatQ+.Proof.introsn.destructnas[|k].-exists1;applylt_0_1.-exists(naturals_to_semiringnatQ(Sk)).inductionkas[|kIk].+change(0 < 1).applylt_0_1.+change(0 < 1 +naturals_to_semiringnatQ(Sk)).set(K:=naturals_to_semiringnatQ(Sk))in*;clearbodyK.applypos_plus_compat.*applylt_0_1.*trivial.Defined.Lemmapos_recip_r@{} :foralle:Q+,e/e= 1.Proof.intros;applypos_eq.unfolddec_recip,cast,pos_recip;simpl.change('e/ 'e= 1).applydec_recip_inverse.applylt_ne_flip.solve_propholds.Qed.Lemmapos_recip_r'@{} :foralle:Q+, @pathsQ('e/ 'e) 1.Proof.intros.change(' (e/e) = 1).rewritepos_recip_r.reflexivity.Qed.Lemmapos_mult_1_r@{} :foralle:Q+,e* 1 =e.Proof.intros;applypos_eq.applymult_1_r.Qed.Lemmapos_split2@{} :foralle:Q+,e=e/ 2 +e/ 2.Proof.intros.path_via(e* (2 / 2)).-rewritepos_recip_r,pos_mult_1_r;reflexivity.-applypos_eq.change('e* (2 / 2) = 'e/ 2 + 'e/ 2).ring_tac.ring_with_nat.Qed.Lemmapos_split3@{} :foralle:Q+,e=e/ 3 +e/ 3 +e/ 3.Proof.intros.path_via(e* (3 / 3)).-rewritepos_recip_r,pos_mult_1_r;reflexivity.-applypos_eq.change('e* (3 / 3) = 'e/ 3 + 'e/ 3 + 'e/ 3).ring_tac.ring_with_nat.Qed.Global InstanceQpos_mult_assoc@{} :Associative(@multQ+_).Proof.hnf.intros;applypos_eq.applymult_assoc.Qed.Global InstanceQpos_plus_assoc@{} :Associative(@plusQ+_).Proof.hnf.intros;applypos_eq.applyplus_assoc.Qed.Global InstanceQpos_mult_1_l@{} :LeftIdentity(@multQ+_) 1.Proof.hnf;intros;applypos_eq;applymult_1_l.Qed.Global InstanceQpos_mult_1_r@{} :RightIdentity(@multQ+_) 1.Proof.hnf;intros;applypos_eq;applymult_1_r.Qed.Lemmapos_recip_through_plus@{} :forallabc:Q+,a+b=c* (a/c+b/c).Proof.intros.path_via((a+b) * (c/c)).-rewritepos_recip_r;applypos_eq,symmetry,mult_1_r.-applypos_eq;ring_tac.ring_with_nat.Qed.Lemmapos_unconjugate@{} :forallab:Q+,a*b/a=b.Proof.intros.path_via(a/a*b).-applypos_eq;ring_tac.ring_with_nat.-rewritepos_recip_r;applyQpos_mult_1_l.Qed.LemmaQpos_recip_1: / 1 = 1 :>Q+.Proof.applypos_eq.exactdec_recip_1.Qed.LemmaQpos_plus_mult_distr_l: @LeftDistributeQ+multplus.Proof.hnf.intros;applypos_eq,plus_mult_distr_l.Qed.Global InstanceQpos_meet@{} :MeetQ+.Proof.introsab.exists(meet('a) ('b)).applynot_le_lt_flip.introsE.destruct(total_meet_either('a) ('b))as[E1|E1];rewriteE1inE;(eapplyle_iff_not_lt_flip;[exactE|]);solve_propholds.Defined.Global InstanceQpos_join@{} :JoinQ+.Proof.introsab.exists(join('a) ('b)).applynot_le_lt_flip.introsE.destruct(total_join_either('a) ('b))as[E1|E1];rewriteE1inE;(eapplyle_iff_not_lt_flip;[exactE|]);solve_propholds.Defined.LemmaQ_sum_eq_join_meet@{} :forallabcd:Q,a+b=c+d->a+b=joinac+meetbd.Proof.intros????E.destruct(totalleac)as[E1|E1].-rewrite(join_r__E1).rewritemeet_r;trivial.apply(order_preserving(+b))inE1.rewriteEinE1.apply(order_reflecting(c+)).trivial.-rewrite(join_l__E1).rewritemeet_l;trivial.apply(order_reflecting(a+)).rewriteE.apply(order_preserving(+d)).trivial.Qed.LemmaQpos_sum_eq_join_meet@{} :forallabcd:Q+,a+b=c+d->a+b=joinac+meetbd.Proof.intros????E.applypos_eq;applyQ_sum_eq_join_meet.change('a+ 'b)with(' (a+b)).rewriteE;reflexivity.Qed.LemmaQpos_le_lt_min:forallab:Q+, 'a<= 'b->existsccacb,a=c+ca/\b=c+cb.Proof.introsabE.exists(a/2),(a/2).simplerefine(exist___);simpl.-exists(' (a/ 2) + ('b- 'a)).applynonneg_plus_lt_compat_r.+apply(snd(flip_nonneg_minus__)).trivial.+solve_propholds.-split.+applypos_split2.+applypos_eq.unfoldcastat2;simpl.unfoldcastat3;simpl.set(a':=a/2);rewrite(pos_split2a);unfolda';cleara'.ring_tac.ring_with_integers(NatPair.Znat).Qed.LemmaQpos_lt_min@{} :forallab:Q+,existsccacb:Q+,a=c+ca/\b=c+cb.Proof.intros.destruct(totalle('a) ('b))as[E|E].-applyQpos_le_lt_min;trivial.-applyQpos_le_lt_mininE.destructEas[c[cb[ca[E1E2]]]].existsc,ca,cb;auto.Qed.DefinitionQpos_diff:forallqr:Q,q<r->Q+.Proof.introsqrE;exists(r-q).apply(snd(flip_pos_minus__)E).Defined.LemmaQpos_diff_pr@{} :forallqrE,r=q+ ' (Qpos_diffqrE).Proof.introsqrE.change(r=q+ (r-q)).abstractring_tac.ring_with_integers(NatPair.Znat).Qed.LemmaQmeet_plus_l:forallabc:Q,meet(a+b) (a+c) =a+meetbc.Proof.intros.destruct(totallebc)as[E|E].-rewrite(meet_l__E).applymeet_l.apply(order_preserving(a+)),E.-rewrite(meet_r__E).applymeet_r.apply(order_preserving(a+)),E.Qed.LemmaQabs_nonneg@{} :forallq:Q, 0 <=absq.Proof.introsq;destruct(total_abs_eitherq)as[E|E];destructEas[E1E2];rewriteE2.-trivial.-applyflip_nonneg_negate.rewriteinvolutive;trivial.Qed.LemmaQabs_nonpos_0@{} :forallq:Q,absq<= 0 ->q= 0.Proof.introsqE.poseproof(antisymmetryle__E(Qabs_nonneg_))asE1.destruct(total_abs_eitherq)as[[E2E3]|[E2E3]];rewriteE3inE1.-trivial.-apply(injective(-)).rewritenegate_0.trivial.Qed.LemmaQabs_0_or_pos:forallq:Q,q= 0 |_| 0 <absq.Proof.introsq.destruct(le_or_lt(absq) 0)as[E|E].-left.applyQabs_nonpos_0.trivial.-right.trivial.Qed.LemmaQabs_of_nonneg@{} :forallq:Q, 0 <=q->absq=q.Proof.intro;apply((abs_sig_).2).Qed.LemmaQabs_of_nonpos:forallq:Q,q<= 0 ->absq= -q.Proof.intro;apply((abs_sig_).2).Qed.LemmaQabs_le_raw@{} :forallx:Q,x<=absx.Proof.introsx;destruct(total_abs_eitherx)as[[E1E2]|[E1E2]].-rewriteE2;reflexivity.-transitivity(0:Q);trivial.rewriteE2.applyflip_nonpos_negate.trivial.Qed.LemmaQabs_neg@{} :forallx:Q,abs(-x) =absx.Proof.introsx.destruct(total_abs_eitherx)as[[E1E2]|[E1E2]].-rewriteE2.path_via(- -x);[|rewriteinvolutive;trivial].apply((abs_sig(-x)).2).applyflip_nonneg_negate;trivial.-rewriteE2.apply((abs_sig(-x)).2).applyflip_nonpos_negate;trivial.Qed.LemmaQabs_le_neg_raw:forallx:Q, -x<=absx.Proof.introsx.rewrite<-Qabs_neg.applyQabs_le_raw.Qed.LemmaQ_abs_le_pr@{} :forallxy:Q,absx<=y<-> -y<=x/\x<=y.Proof.introsxy;split.-introsE.split.+applyflip_le_negate.rewriteinvolutive.transitivity(absx);trivial.applyQabs_le_neg_raw.+transitivity(absx);trivial.applyQabs_le_raw.-intros[E1E2].destruct(total_abs_eitherx)as[[E3E4]|[E3E4]];rewriteE4.+trivial.+applyflip_le_negate;rewriteinvolutive;trivial.Qed.LemmaQabs_is_join@{} :forallq:Q,absq=join(-q)q.Proof.introsq.symmetry.destruct(total_abs_eitherq)as[[E1E2]|[E1E2]];rewriteE2.-applyjoin_r.transitivity(0:Q);trivial.applyflip_nonneg_negate;trivial.-applyjoin_l.transitivity(0:Q);trivial.applyflip_nonpos_negate;trivial.Qed.LemmaQlt_join:forallabc:Q,a<c->b<c->joinab<c.Proof.introsabcE1E2.destruct(totalleab)as[E3|E3];rewrite?(join_r__E3),?(join_l__E3);trivial.Qed.LemmaQ_average_between@{} :forallqr:Q,q<r->q< (q+r) / 2 <r.Proof.introsqrE.split.-applyflip_pos_minus.assert(Hrw: (q+r) / 2 -q= (r-q) / 2);[|rewriteHrw;clearHrw].{path_via((q+r) / 2 - 2 / 2 *q).{rewritedec_recip_inverse;[|solve_propholds].rewritemult_1_l;trivial.}ring_tac.ring_with_integers(NatPair.Znat).}applypos_mult_compat;[|apply_].red.apply(snd(flip_pos_minus__)).trivial.-applyflip_pos_minus.assert(Hrw:r- (q+r) / 2 = (r-q) / 2);[|rewriteHrw;clearHrw].{path_via(2 / 2 *r- (q+r) / 2).{rewritedec_recip_inverse;[|solve_propholds].rewritemult_1_l;trivial.}ring_tac.ring_with_integers(NatPair.Znat).}applypos_mult_compat;[|apply_].red.apply(snd(flip_pos_minus__)).trivial.Qed.Lemmapath_avg_split_diff_l(qr:Q) :q+ ((r-q) / 2) = (r+q) / 2.Proof.patternqat1.rewrite<- (mult_1_rq).pattern(1 :Q)at1.rewrite<- (dec_recip_inverse2)bysolve_propholds.rewrite(associativityq2 (/2)).rewrite<- (distribute_r(q*2) (r-q) (/2)).rewrite(distribute_lq1 1).rewrite(mult_1_rq).rewrite(commutativity(q+q) (r-q)).rewrite<- (associativityr(-q) (q+q)).rewrite(associativity(-q)qq).rewrite(plus_negate_lq).rewrite(plus_0_lq).reflexivity.Qed.Lemmapath_avg_split_diff_r(qr:Q) :r- ((r-q) / 2) = (r+q) / 2.Proof.patternrat1.rewrite<- (mult_1_rr).pattern(1 :Q)at1.rewrite<- (dec_recip_inverse2)bysolve_propholds.rewrite(associativityr2 (/2)).rewritenegate_mult_distr_l.rewrite<- (distribute_r(r*2) (-(r-q)) (/2)).rewrite(distribute_lr1 1).rewrite(mult_1_rr).rewrite(commutativity(r+r) (-(r-q))).rewrite<-negate_swap_r.rewrite<- (associativityq(-r) (r+r)).rewrite(associativity(-r)rr).rewrite(plus_negate_lr).rewrite(plus_0_lr).rewrite(plus_commqr).reflexivity.Qed.Lemmapos_gt_both:forallab:Q,foralle,a< 'e->b< 'e->existsdd',a< 'd/\b< 'd/\e=d+d'.Proof.assert(Haux:forallab:Q,a<=b->foralle,a< 'e->b< 'e->existsdd',a< 'd/\b< 'd/\e=d+d').{introsabEeE1E2.poseproof(Q_average_between__(Qlt_join_0_E2prop_holds))as[E3E4].exists(mkQpos_(le_lt_trans___(join_ub_r__)E3)).unfoldcastat1 4;simpl.exists(Qpos_diff__E4).repeatsplit.-applyle_lt_transwithb;trivial.applyle_lt_transwith(joinb0);trivial.applyjoin_ub_l.-applyle_lt_transwith(joinb0);trivial.applyjoin_ub_l.-applypos_eq.unfoldcastat2;simpl.unfoldcastat2;simpl.unfoldcastat3;simpl.abstractring_tac.ring_with_integers(NatPair.Znat).}introsabeE1E2.destruct(totalleab)as[E|E];auto.destruct(Haux__Ee)as[d[d'[E3[E4E5]]]];trivial.eauto.Qed.Lemmatwo_fourth_is_one_half@{} : 2/4 =  1/2 :>Q+.Proof.assert(Hrw: 4 = 2 * 2 :>Q)byring_tac.ring_with_nat.applypos_eq.repeat(unfoldcast;simpl).rewriteHrw;clearHrw.rewritedec_recip_distr.rewritemult_assoc.rewritedec_recip_inverse;[|solve_propholds].reflexivity.Unshelve.exact(fun_=> 1).(* <- wtf *)Qed.LemmaQ_triangle_le:forallqr:Q,abs(q+r) <=absq+absr.Proof.intros.rewrite(Qabs_is_join(q+r)).applyjoin_le.-rewritenegate_plus_distr.applyplus_le_compat;applyQabs_le_neg_raw.-applyplus_le_compat;applyQabs_le_raw.Qed.LemmaQabs_triangle_alt_aux:forallxy:Q,absx-absy<=abs(x-y).Proof.introsqr.apply(order_reflecting(+ (absr))).assert(Hrw:absq-absr+absr=absq)byring_tac.ring_with_integers(NatPair.Znat);rewriteHrw;clearHrw.etransitivity;[|applyQ_triangle_le].assert(Hrw:q-r+r=q)byring_tac.ring_with_integers(NatPair.Znat);rewriteHrw;clearHrw.reflexivity.Qed.LemmaQabs_triangle_alt:forallxy:Q,abs(absx-absy) <=abs(x-y).Proof.introsqr.rewrite(Qabs_is_join(absq-absr)).applyjoin_le.-rewrite<-(Qabs_neg(q-r)),<-!negate_swap_r.applyQabs_triangle_alt_aux.-applyQabs_triangle_alt_aux.Qed.LemmaQ_dense@{} :forallqr:Q,q<r->existss,q<s<r.Proof.introsqrE;econstructor;applyQ_average_between,E.Qed.LemmaQabs_neg_flip@{} :forallab:Q,abs(a-b) =abs(b-a).Proof.introsab.rewrite<-Qabs_neg.rewrite<-negate_swap_r.trivial.Qed.Definitionpos_of_Q:Q->Q+:=funq=> {|pos:=absq+ 1;is_pos:=le_lt_trans___(Qabs_nonnegq)(fst(pos_plus_lt_compat_r__)lt_0_1) |}.LemmaQ_abs_plus_1_bounds@{} :forallq:Q,- ' (pos_of_Qq) ≤q≤ ' (pos_of_Qq).Proof.intros.change(- (absq+ 1) ≤q≤ (absq+ 1)).split.-applyflip_le_negate.rewriteinvolutive.transitivity(absq).+applyQabs_le_neg_raw.+applynonneg_plus_le_compat_r.solve_propholds.-transitivity(absq).+applyQabs_le_raw.+applynonneg_plus_le_compat_r.solve_propholds.Qed.LemmaQabs_mult@{} :forallab:Q,abs(a*b) =absa*absb.Proof.introsab.destruct(total_abs_eithera)as[Ea|Ea];destructEaas[Ea1Ea2];rewriteEa2;destruct(total_abs_eitherb)as[Eb|Eb];destructEbas[Eb1Eb2];rewriteEb2.-apply((abs_sig(a*b)).2).applynonneg_mult_compat;trivial.-rewrite<-negate_mult_distr_r.apply((abs_sig(a*b)).2).applynonneg_nonpos_mult;trivial.-rewrite<-negate_mult_distr_l.apply((abs_sig(a*b)).2).applynonpos_nonneg_mult;trivial.-rewritenegate_mult_negate.apply((abs_sig(a*b)).2).applynonpos_mult;trivial.Qed.LemmaQpos_neg_le@{} :foralla:Q+, - 'a<= 'a.Proof.introsa;applybetween_nonneg;solve_propholds.Qed.DefinitionQpos_upper(e:Q+) :=existsx:Q, 'e<=x.DefinitionQpos_upper_injecte:Q->Qpos_uppere.Proof.introsx.exists(joinx('e)).applyjoin_ub_r.Defined.Global InstanceQLe_dec:forallqr:Q,Decidable(q<=r).Proof.introsqr;destruct(le_or_ltqr).-left;trivial.-right;intros?.apply(irreflexivityltq).applyle_lt_transwithr;trivial.Qed.Global InstanceQLt_dec:forallqr:Q,Decidable(q<r).Proof.introsqr;destruct(le_or_ltrq).-right;intros?.apply(irreflexivityltq).applylt_le_transwithr;trivial.-left;trivial.Qed.Sectionenumerable.Context`{EnumerableQ}.DefinitionQpos_enumerator:nat->Q+.Proof.introsn.destruct(le_or_lt(enumeratorQn) 0)as[E|E].-exact1.-exists(enumeratorQn);trivial.Defined.LemmaQpos_is_enumerator:IsSurjection@{UQ}Qpos_enumerator.Proof.applyBuildIsSurjection.unfoldhfiber.introse;generalize(@center_(enumerator_issurjQ('e))).apply(Trunc_ind_).intros[nE].applytr;existsn.unfoldQpos_enumerator.destruct(le_or_lt(enumeratorQn) 0)as[E1|E1].-destruct(irreflexivitylt0).applylt_le_transwith(enumeratorQn);trivial.rewriteE;solve_propholds.-applypos_eq,E.Qed.Global InstanceQpos_enumerable:EnumerableQ+.Proof.existsQpos_enumerator.first[exactQpos_is_enumerator@{UhugeUlarge}|exactQpos_is_enumerator@{}].Qed.Endenumerable.Endcontents.ArgumentsQposQ{__}.

--- Miscellaneous\ReflectiveSubuniverse.html ---
ReflectiveSubuniverseLibrary ReflectiveSubuniverseRequireImportHoTT.BasicsHoTT.Types.RequireImportEquiv.BiInvExtensionsHPropHFiberNullHomotopyLimits.Pullback.RequireImportPathAny.RequireImportColimits.Pushout.Local OpenScopenat_scope.Local OpenScopepath_scope.Reflective SubuniversesReferencesReflective subuniverses (and modalities) are studied in the following papers, which we will refer to below by their abbreviations:The Book: The Homotopy Type Theory Book, chapter 7.  Bare references to "Theorem 7.x.x" are always to the Book.RSS: Rijke, Spitters, and Shulman, "Modalities in homotopy type theory", https://arxiv.org/abs/1706.07526.CORS: Christensen, Opie, Rijke, and Scoccola, "Localization in Homotopy Type Theory", https://arxiv.org/abs/1807.04155.DefinitionsSubuniversesRecordSubuniverse@{i} :={In_internal:Type@{i} ->Type@{i} ;hprop_inO_internal:Funext->forall(T:Type@{i}),IsHProp(In_internalT) ;inO_equiv_inO_internal:forall(TU:Type@{i}) (T_inO:In_internalT)(f:T->U) {feq:IsEquivf},In_internalU;}.Work around Coq bug that fields of records can't be typeclasses.ClassIn(O:Subuniverse) (T:Type) :=in_internal:In_internalOT.Being in the subuniverse is a mere predicate (by hypothesis).  We include funext in the hypotheses of hprop_inO so that it doesn't have to be assumed in all definitions of (reflective) subuniverses, since in most examples it is required for this and this only.  Here we redefine it using the replacedIn.Global Instancehprop_inO`{Funext} (O:Subuniverse) (T:Type):IsHProp(InOT):= @hprop_inO_internal__T.We assumed repleteness of the subuniverse in the definition.  Of course, with univalence this would be automatic, but we include it as a hypothesis since most of the theory of reflective subuniverses and modalities doesn't need univalence, and most or all examples can be shown to be replete without using univalence.  Here we redefine it using the replacedIn.DefinitioninO_equiv_inO{O:Subuniverse} (T:Type) {U:Type}`{T_inO:InOT} (f:T->U) `{IsEquivTUf}:InOU:= @inO_equiv_inO_internalOTUT_inOf_.DefinitioninO_equiv_inO'{O:Subuniverse}(T:Type) {U:Type} `{InOT} (f:T<~>U):InOU:=inO_equiv_inOTf.Definitioniff_inO_equiv(O:Subuniverse){T:Type} {U:Type} (f:T<~>U):InOT<->InOU:= (funH=>inO_equiv_inO'_f,funH=>inO_equiv_inO'_f^-1).Definitionequiv_inO_equiv`{Funext} (O:Subuniverse){T:Type} {U:Type} (f:T<~>U):InOT<~>InOU:=equiv_iff_hprop_uncurried(iff_inO_equiv_f).The universe of types in the subuniverseDefinitionType_@{ij} (O:Subuniverse@{i}) :Type@{j}:= @sig@{ji}Type@{i} (fun(T:Type@{i}) =>InOT).CoercionTypeO_pr1O(T:Type_O) := @pr1Type(InO)T.The second component ofTypeOis unique.Definitionpath_TypeO@{ij} {fs:Funext}O(TT':Type_@{ij}O) (p:T.1 =T'.1):T=T':=path_sigma_hprop@{jij}TT'p.Definitionequiv_path_TypeO@{ij} {fs:Funext}O(TT':Type_@{ij}O): (paths@{j}T.1T'.1) <~> (T=T'):=equiv_path_sigma_hprop@{jij}TT'.Types inTypeOare always inO.Global InstanceinO_TypeO{O:Subuniverse} (A:Type_O) :InOA:=A.2.Properties of SubuniversesA map is O-local if all its fibers are.ClassMapIn(O:Subuniverse) {AB:Type} (f:A->B):=inO_hfiber_ino_map:forall(b:B),InO(hfiberfb).Global Existing InstanceinO_hfiber_ino_map.SectionSubuniverse.Context(O:Subuniverse).Being a local map is an hpropGlobal Instanceishprop_mapinO`{Funext} {AB:Type} (f:A->B):IsHProp(MapInOf).Proof.applyistrunc_forall.Defined.Anything homotopic to a local map is local.DefinitionmapinO_homotopic{AB:Type} (f:A->B) {g:A->B}(p:f==g) `{MapInO__f}:MapInOg.Proof.introsb.exact(inO_equiv_inO(hfiberfb)(equiv_hfiber_homotopicfgpb)).Defined.The projection from a family of local types is local.Global InstancemapinO_pr1{A:Type} {B:A->Type}`{foralla,InO(Ba)}:MapInO(@pr1AB).Proof.introsa.exact(inO_equiv_inO(Ba) (hfiber_fibrationaB)).Defined.A family of types is local if and only if the associated projection map is local.Lemmaiff_forall_inO_mapinO_pr1{A:Type} (B:A->Type): (foralla,InO(Ba)) <->MapInO(@pr1AB).Proof.split.-exact_.(* Uses the instance mapinO_pr1 above. *)-rapplyfunctor_forall;introsax.exact(inO_equiv_inO(hfiberpr1a)(hfiber_fibrationaB)^-1%equiv).Defined.Lemmaequiv_forall_inO_mapinO_pr1`{Funext} {A:Type} (B:A->Type): (foralla,InO(Ba)) <~>MapInO(@pr1AB).Proof.exact(equiv_iff_hprop_uncurried(iff_forall_inO_mapinO_pr1B)).Defined.EndSubuniverse.ReflectionsA pre-reflection is a map to a type in the subuniverse.ClassPreReflects@{i} (O:Subuniverse@{i}) (T:Type@{i}) :={O_reflector:Type@{i} ;O_inO:InOO_reflector;to:T->O_reflector;}.ArgumentsO_reflectorOT{_}.ArgumentstoOT{_}.ArgumentsO_inO{O}T{_}.Global Existing InstanceO_inO.It is a reflection if it has the requisite universal property.ClassReflects@{i} (O:Subuniverse@{i}) (T:Type@{i})`{PreReflects@{i}OT} :={extendable_to_O:forall{Q:Type@{i}} {Q_inO:InOQ},ooExtendableAlong(toOT) (fun_=>Q)}.Argumentsextendable_to_OO{T__QQ_inO}.Here's a modified version that applies to types in possibly-smaller universes without collapsing those universes toi.Definitionextendable_to_O'@{ijk|j<=i,k<=i} (O:Subuniverse@{i}) (T:Type@{j})`{ReflectsOT} {Q:Type@{k}} {Q_inO:InOQ}:ooExtendableAlong(toOT) (fun_=>Q).Proof.applylift_ooextendablealong.rapplyextendable_to_O.Defined.In particular, every type in the subuniverse automatically reflects into it.Definitionprereflects_in(O:Subuniverse) (T:Type) `{InOT} :PreReflectsOT.Proof.unshelveeconstructor.-exactT.-assumption.-exactidmap.Defined.Definitionreflects_in(O:Subuniverse) (T:Type) `{InOT} : @ReflectsOT(prereflects_inOT).Proof.constructor;intros;rapplyooextendable_equiv.Defined.A reflective subuniverse is one for which every type reflects into it.RecordReflectiveSubuniverse@{i} :={rsu_subuniv:Subuniverse@{i} ;rsu_prereflects:forall(T:Type@{i}),PreReflectsrsu_subunivT;rsu_reflects:forall(T:Type@{i}),Reflectsrsu_subunivT;}.Coercionrsu_subuniv:ReflectiveSubuniverse>->Subuniverse.Global Existing Instancersu_prereflects.Global Existing Instancersu_reflects.We allow the name of a subuniverse or modality to be used as the name of its reflector.  This means that when defining a particular example, you should generally put the parametrizing family in a wrapper, so that you can notate the subuniverse as parametrized by, rather than identical to, its parameter.  See Modality.v, Truncations.v, and Localization.v for examples.Definitionrsu_reflector(O:ReflectiveSubuniverse) (T:Type) :Type:=O_reflectorOT.Coercionrsu_reflector:ReflectiveSubuniverse>->Funclass.Recursion principlesWe now extract the recursion principle and the restricted induction principles for paths.SectionORecursion.Context{O:Subuniverse} {PQ:Type} {Q_inO:InOQ} `{ReflectsOP}.DefinitionO_rec(f:P->Q):O_reflectorOP->Q:= (fst(extendable_to_OO1%nat)f).1.DefinitionO_rec_beta(f:P->Q) (x:P):O_recf(toOPx) =fx:= (fst(extendable_to_OO1%nat)f).2x.DefinitionO_indpaths(gh:O_reflectorOP->Q)(p:gotoOP==hotoOP):g==h:= (fst(snd(extendable_to_OO2)gh)p).1.DefinitionO_indpaths_beta(gh:O_reflectorOP->Q)(p:go(toOP) ==ho(toOP)) (x:P):O_indpathsghp(toOPx) =px:= (fst(snd(extendable_to_OO2)gh)p).2x.DefinitionO_ind2paths{gh:O_reflectorOP->Q} (pq:g==h)(r:poD(toOP) ==qoD(toOP)):p==q:= (fst(snd(snd(extendable_to_OO3)gh)pq)r).1.DefinitionO_ind2paths_beta{gh:O_reflectorOP->Q} (pq:g==h)(r:poD(toOP) ==qoD(toOP)) (x:P):O_ind2pathspqr(toOPx) =rx:= (fst(snd(snd(extendable_to_OO3)gh)pq)r).2x.Clearly we can continue indefinitely as needed.EndORecursion.(* We never want to seeextendable_to_O.  The!xallowscbnto unfold these when passed a constructor, such astrx.  This, for example, means thatO_rec(O:=Trn)f(trx)will compute tofxandTrunc_functornf(trx)will compute totr(fx). *)ArgumentsO_rec{O} {PQ}%_type_scope{Q_inOHH0}f%_function_scope!x.ArgumentsO_rec_beta{O} {PQ}%_type_scope{Q_inOHH0}f%_function_scope!x.ArgumentsO_indpaths{O} {PQ}%_type_scope{Q_inOHH0} (gh)%_function_scopep!x.ArgumentsO_indpaths_beta{O} {PQ}%_type_scope{Q_inOHH0} (gh)%_function_scopep!x.ArgumentsO_ind2paths{O} {PQ}%_type_scope{Q_inOHH0} {gh}%_function_scopepqr!x.ArgumentsO_ind2paths_beta{O} {PQ}%_type_scope{Q_inOHH0} {gh}%_function_scopepqr!x.A tactic that generalizesstrip_truncationsto reflective subuniverses.strip_truncationsintroduces fewer universe variables, so tends to work better when removing truncations.strip_modalitiesin Modality.v also applies dependent elimination whenOis a modality.Ltacstrip_reflections:=Search for hypotheses of typeOXfor someOsuch that the goal isO-local.progressrepeatmatchgoalwith| [T:_|-_]=>revert_opaqueT;refine(@O_rec_______) ||refine(@O_indpaths_________);Ensure that we didn't generate more than one subgoal, i.e. that the goal was appropriately local.[];introTend.GivenFunext, we prove the definition of reflective subuniverse in the book.Global Instanceisequiv_o_to_O`{Funext}(O:ReflectiveSubuniverse) (PQ:Type) `{InOQ}:IsEquiv(fung:OP->Q=>gotoOP):=isequiv_ooextendable__(extendable_to_OO).Definitionequiv_o_to_O`{Funext}(O:ReflectiveSubuniverse) (PQ:Type) `{InOQ}: (OP->Q) <~> (P->Q):=Build_Equiv__(fung:OP->Q=>gotoOP)_.isequiv_ooextendableis defined in a way that makesO_recdefinitionally equal to the inverse ofequiv_o_to_O.Global Instanceisequiv_O_rec_to_O`{Funext}(O:ReflectiveSubuniverse) (PQ:Type) `{InOQ}:IsEquiv(fung:P->Q=>O_recg):= (equiv_isequiv(equiv_o_to_OOPQ)^-1).Properties of Reflective SubuniversesWe now prove a bunch of things about an arbitrary reflective subuniverse.SectionReflective_Subuniverse.Context(O:ReflectiveSubuniverse).Functoriality ofO_rechomotopiesDefinitionO_rec_homotopy{PQ:Type} `{InOQ} (fg:P->Q) (pi:f==g):O_rec(O:=O)f==O_recg.Proof.applyO_indpaths;introx.etransitivity.{applyO_rec_beta. }{etransitivity.{exact(pi_). }{symmetry;applyO_rec_beta. } }Defined.IfTis in the subuniverse, thentoOTis an equivalence.Global Instanceisequiv_to_O_inO(T:Type) `{InOT} :IsEquiv(toOT).Proof.pose(g:=O_recidmap:OT->T).refine(isequiv_adjointify(toOT)g__).-refine(O_indpaths(toOTog)idmap_).introsx.applyap.applyO_rec_beta.-introsx.applyO_rec_beta.Defined.Definitionequiv_to_O(T:Type) `{InOT} :T<~>OT:=Build_EquivT(OT) (toOT)_.SectionFunctor.In this section, we see thatOis a functor.DefinitionO_functor{AB:Type} (f:A->B) :OA->OB:=O_rec(toOBof).Naturality oftoODefinitionto_O_natural{AB:Type} (f:A->B): (O_functorf)o(toOA) == (toOB)of:= (O_rec_beta_).Functoriality on compositionDefinitionO_functor_compose{ABC:Type} (f:A->B) (g:B->C): (O_functor(gof)) == (O_functorg)o(O_functorf).Proof.srapplyO_indpaths;introsx.refine(to_O_natural(gof)x@_).transitivity(O_functorg(toOB(fx))).-symmetry.exact(to_O_naturalg(fx)).-applyap;symmetry.exact(to_O_naturalfx).Defined.Functoriality on homotopies (2-functoriality)DefinitionO_functor_homotopy{AB:Type} (fg:A->B) (pi:f==g):O_functorf==O_functorg.Proof.refine(O_indpaths___);introsx.refine(to_O_naturalfx@_).refine(_@ (to_O_naturalgx)^).applyap,pi.Defined.Functoriality for inverses of homotopiesDefinitionO_functor_homotopy_V{AB:Type} (fg:A->B) (pi:f==g):O_functor_homotopygf(funx=> (pix)^)==funx=> (O_functor_homotopyfgpix)^.Proof.refine(O_ind2paths___);introsx.unfoldcomposeD,O_functor_homotopy.rewrite!O_indpaths_beta, !ap_V, !inv_pp,inv_V, !concat_p_pp.reflexivity.Qed.Hence functoriality on commutative squaresDefinitionO_functor_square{ABCX:Type} (pi1:X->A) (pi2:X->B)(f:A->C) (g:B->C) (comm: (fopi1) == (gopi2)): ( (O_functorf)o(O_functorpi1) )== ( (O_functorg)o(O_functorpi2) ).Proof.introsx.transitivity(O_functor(fopi1)x).-symmetry;rapplyO_functor_compose.-transitivity(O_functor(gopi2)x).*applyO_functor_homotopy,comm.*rapplyO_functor_compose.Defined.Functoriality on identitiesDefinitionO_functor_idmap(A:Type): @O_functorAAidmap==idmap.Proof.refine(O_indpaths___);introsx.applyO_rec_beta.Defined.3-functoriality, as an example use ofO_ind2pathsDefinitionO_functor_2homotopy{AB:Type} {fg:A->B}(pq:f==g) (r:p==q):O_functor_homotopyfgp==O_functor_homotopyfgq.Proof.refine(O_ind2paths___);introsx.unfoldO_functor_homotopy,composeD.do2rewriteO_indpaths_beta.applywhiskerL,whiskerR,ap,r.Of course, if we wanted to prove 4-functoriality, we'd need to make this transparent.Qed.2-naturality: Functoriality on homotopies is also naturalDefinitionO_functor_homotopy_beta{AB:Type} (fg:A->B) (pi:f==g) (x:A):O_functor_homotopyfgpi(toOAx)=to_O_naturalfx@ap(toOB) (pix)@ (to_O_naturalgx)^.Proof.unfoldO_functor_homotopy,to_O_natural.refine(O_indpaths_beta___x@_).refine(concat_p_pp___).Defined.The pointed endofunctor (O,toO) is well-pointedDefinitionO_functor_wellpointed(A:Type):O_functor(toOA) ==toO(OA).Proof.refine(O_indpaths___);introsx.applyto_O_natural.Defined."Functoriality of naturality": the pseudonaturality axiom for compositionDefinitionto_O_natural_compose{ABC:Type}(f:A->B) (g:B->C) (a:A):ap(O_functorg) (to_O_naturalfa)@to_O_naturalg(fa)= (O_functor_composefg(toOAa))^@to_O_natural(gof)a.Proof.unfoldO_functor_compose,to_O_natural.rewriteO_indpaths_beta.rewrite!inv_pp,ap_V, !inv_V, !concat_pp_p.rewriteconcat_Vp,concat_p1;reflexivity.Qed.The pseudofunctoriality axiomDefinitionO_functor_compose_compose{ABCD:Type} (f:A->B) (g:B->C) (h:C->D)(a:OA):O_functor_composef(hog)a@O_functor_composegh(O_functorfa)=O_functor_compose(gof)ha@ap(O_functorh) (O_functor_composefga).Proof.reverta;refine(O_ind2paths___).introsa;unfoldcomposeD,O_functor_compose;cbn.OpenScopelong_path_scope.rewrite!O_indpaths_beta, !ap_pp, !ap_V, !concat_p_pp.refine(whiskerL_(apD_(to_O_naturalfa)^)^ @_).rewriteO_indpaths_beta.rewritetransport_paths_FlFr, !concat_p_pp.rewrite!ap_V,inv_V.rewrite!concat_pV_p.applywhiskerL.applyinverse2.applyap_compose.CloseScopelong_path_scope.Qed.Preservation of equivalencesGlobal Instanceisequiv_O_functor{AB:Type} (f:A->B) `{IsEquiv__f}:IsEquiv(O_functorf).Proof.refine(isequiv_adjointify(O_functorf) (O_functorf^-1)__).-introsx.refine((O_functor_compose__x)^ @_).refine(O_functor_homotopy_idmap_x@_).+introsy;applyeisretr.+applyO_functor_idmap.-introsx.refine((O_functor_compose__x)^ @_).refine(O_functor_homotopy_idmap_x@_).+introsy;applyeissect.+applyO_functor_idmap.Defined.Definitionequiv_O_functor{AB:Type} (f:A<~>B):OA<~>OB:=Build_Equiv__(O_functorf)_.This is sometimes useful to have a separate name for, to facilitate rewriting along it.Definitionto_O_equiv_natural{AB} (f:A<~>B): (equiv_O_functorf)o(toOA) == (toOB)of:=to_O_naturalf.This corresponds toapOon the universe.Definitionap_O_path_universe'`{Univalence}{AB:Type} (f:A<~>B):apO(path_universe_uncurriedf)=path_universe_uncurried(equiv_O_functorf).Proof.revertf.equiv_intro(equiv_pathAB)p.refine(ap(apO) (eta_path_universep) @_).destructp;simpl.applymoveL_equiv_V.applypath_equiv,path_arrow,O_indpaths;introsx.symmetry;applyto_O_natural.Defined.Definitionap_O_path_universe`{Univalence}{AB:Type} (f:A->B) `{IsEquiv__f}:apO(path_universef) =path_universe(O_functorf):=ap_O_path_universe'(Build_Equiv__f_).Postcomposition respectsO_recDefinitionO_rec_postcompose{ABC:Type@{i}} `{InOB} {C_inO:InOC}(f:A->B) (g:B->C):goO_rec(O:=O)f==O_rec(O:=O) (gof).Proof.refine(O_indpaths___);introsx.transitivity(g(fx)).-applyap.applyO_rec_beta.-symmetry.exact(O_rec_beta(gof)x).Defined.In particular, we have:DefinitionO_rec_postcompose_to_O{AB:Type} (f:A->B) `{InOB}:toOBoO_recf==O_functorf:=O_rec_postcomposef(toOB).EndFunctor.SectionReplete.An equivalent formulation of repleteness is that a type lies in the subuniverse as soon as its unit map is an equivalence.DefinitioninO_isequiv_to_O(T:Type):IsEquiv(toOT) ->InOT:=fun_=>inO_equiv_inO(OT) (toOT)^-1.We don't make this an ordinary instance, but we allow it to solveInOconstraints if we already haveIsEquivas a hypothesis.#[local]HintImmediateinO_isequiv_to_O:typeclass_instances.DefinitioninO_iff_isequiv_to_O(T:Type):InOT<->IsEquiv(toOT).Proof.split;exact_.Defined.Thus,Tis in a subuniverse as soon astoOTadmits a retraction.DefinitioninO_to_O_retract(T:Type) (mu:OT->T):muo(toOT) ==idmap->InOT.Proof.introsH.applyinO_isequiv_to_O.applyisequiv_adjointifywith(g:=mu).-refine(O_indpaths(toOTomu)idmap_).introsx;exact(ap(toOT) (Hx)).-exactH.Defined.It follows that reflective subuniverses are closed under retracts.DefinitioninO_retract_inO(AB:Type) `{InOB} (s:A->B) (r:B->A)(K:ros==idmap):InOA.Proof.nrapply(inO_to_O_retractA(ro(toOB)^-1o(O_functors))).introa.lhsexact(ap(ro(toOB)^-1) (to_O_naturalsa)).lhsnrefine(apr(eissect_(sa))).applyK.Defined.EndReplete.The maps that are inverted by the reflector.  Note that this notation is not (yet) global (because notations in a section cannot be made global); it only exists in this section.  After the section is over, we will redefine it globally.Local NotationO_invertsf:= (IsEquiv(O_functorf)).SectionOInverts.Global InstanceO_inverts_O_unit(A:Type):O_inverts(toOA).Proof.refine(isequiv_homotopic(toO(OA))_).introsx;symmetry;applyO_functor_wellpointed.Defined.A map between modal types that is inverted byOis already an equivalence.  This can't be anInstance, probably because it causes an infinite regress applying more and moreO_functor.Definitionisequiv_O_inverts{AB:Type} `{InOA} `{InOB}(f:A->B) `{O_invertsf}:IsEquivf.Proof.refine(isequiv_commsq'f(O_functorf) (toOA) (toOB)_).applyto_O_natural.Defined.Strangely, even this seems to cause infinite loopsHintImmediateisequiv_O_inverts:typeclass_instances.Definitionequiv_O_inverts{AB:Type} `{InOA} `{InOB}(f:A->B) `{O_invertsf}:A<~>B:=Build_Equiv__f(isequiv_O_invertsf).Definitionisequiv_O_rec_O_inverts{AB:Type} `{InOB} (f:A->B) `{O_invertsf}:IsEquiv(O_rec(O:=O)f).Proof.(* Not sure why we needC:=OBon the next line to get Coq to use two typeclass instances. *)rapply(cancelL_isequiv(C:=OB) (toOB)).rapply(isequiv_homotopic(O_functorf) (funx=> (O_rec_postcompose_to_Ofx)^)).Defined.Definitionequiv_O_rec_O_inverts{AB:Type} `{InOB} (f:A->B) `{O_invertsf}:OA<~>B:=Build_Equiv___(isequiv_O_rec_O_invertsf).Definitionisequiv_to_O_O_inverts{AB:Type} `{InOA} (f:A->B) `{O_invertsf}:IsEquiv(toOBof):=isequiv_homotopic(O_functorfotoOA) (to_O_naturalf).Definitionequiv_to_O_O_inverts{AB:Type} `{InOA} (f:A->B) `{O_invertsf}:A<~>OB:=Build_Equiv___(isequiv_to_O_O_invertsf).Iffis inverted byO, then mapping out of it into any modal type is an equivalence.  First we prove a version not requiring funext.  For use inO_inverts_O_leqbelow, we allow the typesA,B, andZto perhaps live in smaller universes than the oneion which our subuniverse lives.  This the first half of Lemma 1.23 of RSS.Definitionooextendable_O_inverts@{abzi}{A:Type@{a}} {B:Type@{b}} (f:A->B) `{O_invertsf}(Z:Type@{z}) `{In@{i}OZ}:ooExtendableAlong@{abzi}f(fun_=>Z).Proof.refine(cancelL_ooextendable@{abiziiiii}__(toOB)__).1:exact(extendable_to_O'@{ibz}OB).refine(ooextendable_homotopic_(O_functorfotoOA)__).1:applyto_O_natural.refine(ooextendable_compose_(toOA) (O_functorf)__).-srapplyooextendable_equiv.-exact(extendable_to_O'@{iaz}OA).Defined.And now the funext versionDefinitionisequiv_precompose_O_inverts`{Funext}{AB:Type} (f:A->B) `{O_invertsf}(Z:Type) `{InOZ}:IsEquiv(fung:B->Z=>gof).Proof.srapply(equiv_extendable_isequiv0).exact(ooextendable_O_invertsfZ2).Defined.Conversely, if a map is inverted by the representable functor?->Zfor allO-modal typesZ, then it is inverted byO.  As before, first we prove a version that doesn't require funext.DefinitionO_inverts_from_extendable{A:Type@{i}} {B:Type@{j}} (f:A->B)Without the universe annotations, the result ends up insufficiently polymorphic.(e:forall(Z:Type@{k}),InOZ->ExtendableAlong@{ijkl} 2f(fun_=>Z)):O_invertsf.Proof.srapplyisequiv_adjointify.-exact(O_rec(fst(e(OA)_) (toOA)).1).-srapplyO_indpaths.introsb.rewriteO_rec_beta.assert(e1:=funhk=>fst(snd(e(OB)_)hk)).cbnine1.refine((e1(funy=>O_functorf((fst(e(OA)_) (toOA)).1y)) (toOB)_).1b).introsa.rewrite((fst(e(OA) (O_inOA)) (toOA)).2a).applyto_O_natural.-srapplyO_indpaths.introsa.rewriteto_O_natural,O_rec_beta.exact((fst(e(OA) (O_inOA)) (toOA)).2a).Defined.#[local]HintExtern4 =>progress(cbvbetaiota) :typeclass_instances.And the version with funext.  Use it with universe parametersijkllplusllll.DefinitionO_inverts_from_isequiv_precompose`{Funext}{AB:Type} (f:A->B)(e:forall(Z:Type),InOZ->IsEquiv(fung:B->Z=>gof)):O_invertsf.Proof.applyO_inverts_from_extendable.introsZ?.rapply((equiv_extendable_isequiv0__)^-1%equiv).Defined.This property also characterizes the types in the subuniverse, which is the other half of Lemma 1.23.DefinitioninO_ooextendable_O_inverts(Z:Type@{k})(E:forall(A:Type@{i}) (B:Type@{j}) (f:A->B)(Oif:O_invertsf),ooExtendableAlongf(fun_=>Z)):InOZ.Proof.pose(EZ:=fst(EZ(OZ) (toOZ)_1%nat)idmap).exact(inO_to_O_retract_EZ.1EZ.2).Defined.A version with the equivalence form of the extension condition.DefinitioninO_isequiv_precompose_O_inverts(Z:Type)(Yo:forall(A:Type) (B:Type) (f:A->B)(Oif:O_invertsf),IsEquiv(fung:B->Z=>gof)):InOZ.Proof.pose(EZ:=extension_isequiv_precompose(toOZ)_(YoZ(OZ) (toOZ)_)idmap).exact(inO_to_O_retract_EZ.1EZ.2).Defined.Definitionto_O_inv_natural{AB:Type} `{InOA} `{InOB}(f:A->B): (toOB)^-1o(O_functorf) ==fo(toOA)^-1.Proof.refine(O_indpaths___);introsx.applymoveR_equiv_V.refine(to_O_naturalfx@_).do2applyap.symmetry;applyeissect.Defined.Two maps between modal types that become equal after applyingO_functorare already equal.DefinitionO_functor_faithful_inO{AB:Type} `{InOA} `{InOB}(fg:A->B) (e:O_functorf==O_functorg):f==g.Proof.introsx.refine(apf(eissect(toOA)x)^ @_).refine(_@apg(eissect(toOA)x)).transitivity((toOB)^-1 (O_functorf(toOAx))).+symmetry;applyto_O_inv_natural.+transitivity((toOB)^-1 (O_functorg(toOAx))).*applyap,e.*applyto_O_inv_natural.Defined.Any map to a type in the subuniverse that is inverted byOmust be equivalent totoO.  More precisely, the type of such maps is contractible.Definitiontypeof_to_O(A:Type):= {OA:Type& {Ou:A->OA& ((InOOA) * (O_invertsOu)) }}.Global Instancecontr_typeof_O_unit`{Univalence} (A:Type):Contr(typeof_to_OA).Proof.apply(Build_Contr_(OA; (toOA; (_,_)))).intros[OA[Ou[? ?]]].pose(f:=O_recOu:OA->OA).pose(g:= (O_functorOu)^-1otoOOA: (OA->OA)).assert(IsEquivf).{refine(isequiv_adjointifyfg__).-applyO_functor_faithful_inO;introsx.rewriteO_functor_idmap.rewriteO_functor_compose.unfoldg.rewrite(O_functor_compose(toOOA) (O_functorOu)^-1).rewriteO_functor_wellpointed.rewrite(to_O_natural(O_functorOu)^-1x).refine(to_O_naturalf_@_).set(y:= (O_functorOu)^-1x).transitivity(O_functorOuy); [ |applyeisretr].unfoldf,O_functor.applyO_rec_postcompose.-refine(O_indpaths___);introsx.unfoldf.rewriteO_rec_beta.unfoldg.applymoveR_equiv_V.symmetry;applyto_O_natural.}simplerefine(path_sigma_____);cbn.-exact(path_universef).-rewritetransport_sigma.simplerefine(path_sigma_____);cbn; [ |applypath_ishprop].applypath_arrow;introsx.rewritetransport_arrow_fromconst.rewritetransport_path_universe.unfoldf;applyO_rec_beta.Qed.EndOInverts.SectionTypes.TheUnittypeGlobal InstanceinO_unit:InOUnit.Proof.applyinO_to_O_retract@{Set}with(mu:=funx=>tt).exact(@contr@{Set}Unit_).Defined.It follows that any contractible type is inO.Global InstanceinO_contr{A:Type} `{ContrA} :InOA.Proof.exact(inO_equiv_inO@{Set__}Unitequiv_contr_unit^-1).Defined.And that the reflection of a contractible type is still contractible.Global Instancecontr_O_contr{A:Type} `{ContrA} :Contr(OA).Proof.exact(contr_equivA(toOA)).Defined.Dependent product and arrowsTheorem 7.7.2Global InstanceinO_forall{fs:Funext} (A:Type) (B:A->Type): (forallx, (InO(Bx)))-> (InO(forallx:A, (Bx))).Proof.introH.pose(ev:=funx=> (fun(f:(forallx, (Bx))) =>fx)).pose(zz:=funx:A=>O_rec(O:=O) (evx)).applyinO_to_O_retractwith(mu:=funz=>funx=>zzxz).introphi.unfoldzz,ev;clearzz;clearev.applypath_forall;introx.exact(O_rec_beta(funf:forallx0, (Bx0) =>fx)phi).Defined.Global InstanceinO_arrow{fs:Funext} (AB:Type) `{InOB}:InO(A->B).Proof.applyinO_forall.introa.exact_.Defined.ProductGlobal InstanceinO_prod(AB:Type) `{InOA} `{InOB}:InO(A*B).Proof.applyinO_to_O_retractwith(mu:=funX=> (@O_rec_(A*B)A___fstX,O_recsndX)).intros[ab];applypath_prod;simpl.-exact(O_rec_betafst(a,b)).-exact(O_rec_betasnd(a,b)).Defined.Two ways to define a mapO(A*B)->X*Yagree.DefinitionO_rec_functor_prod{ABXY:Type} `{InOX} `{InOY}(f:A->X) (g:B->Y):O_rec(functor_prodfg) ==prod_coind(O_rec(fofst:A*B->X))(O_rec(gosnd:A*B->Y)).Proof.applyO_indpaths;introab.unfoldfunctor_prod,prod_coind,prod_coind_uncurried;simpl.lhs(nrapplyO_rec_beta).applypath_prod;cbn;symmetry;nrapplyO_rec_beta.Defined.We show thatOA*OBhas the same universal property asO(A*B)Here is the map witnessing the universal property.DefinitionO_prod_unit(AB:Type) :A*B->OA*OB:=functor_prod(toOA) (toOB).We express the universal property without funext, using extensions.Definitionooextendable_O_prod_unit(ABC:Type) `{InOC}:ooExtendableAlong(O_prod_unitAB) (fun_=>C).Proof.applyooextendable_functor_prod.all:intros;rapplyextendable_to_O.Defined.Here's the version with funext.Definitionisequiv_O_prod_unit_precompose{fs:Funext} (ABC:Type) `{InOC}:IsEquiv(fun(f: (OA) * (OB) ->C) =>foO_prod_unitAB).Proof.rapplyisequiv_ooextendable.rapplyooextendable_O_prod_unit.Defined.Definitionequiv_O_prod_unit_precompose{fs:Funext} (ABC:Type) `{InOC}: ((OA) * (OB) ->C) <~> (A*B->C):=Build_Equiv___(isequiv_O_prod_unit_precomposeABC).The (funext-free) universal property implies thatO_prod_unitis anO-equivalence, hence induces an equivalence betweenO(A*B)andOA*OB.Global InstanceO_inverts_O_prod_unit(AB:Type):O_inverts(O_prod_unitAB).Proof.rapplyO_inverts_from_extendable.intros;rapplyooextendable_O_prod_unit.Defined.DefinitionO_prod_cmp(AB:Type) :O(A*B) ->OA*OB:=O_rec(O_prod_unitAB).Global Instanceisequiv_O_prod_cmp(AB:Type):IsEquiv(O_prod_cmpAB).Proof.rapplyisequiv_O_rec_O_inverts.Defined.Definitionequiv_O_prod_cmp(AB:Type):O(A*B) <~> (OA*OB):=Build_Equiv__(O_prod_cmpAB)_.Definitionequiv_path_O_prod{XY:Type} {x0x1:X} {y0y1:Y}: (toO_(x0,y0) =toO_(x1,y1))<~> (toO_x0=toO_x1) * (toO_y0=toO_y1).Proof.refine(_oEequiv_ap'(equiv_O_prod_cmp__)__).refine(_oEequiv_concat_lr__);only2:symmetry.2,3:applyO_rec_beta.exact(equiv_path_prod__)^-1%equiv.Defined.DefinitionO_prod_cmp_coind(AB:Type):O_prod_cmpAB==prod_coind(O_rec(toO_ofst:A*B->OA))(O_rec(toO_osnd:A*B->OB)):=O_rec_functor_prod__.PullbacksGlobal InstanceinO_pullback{ABC} (f:B->A) (g:C->A)`{InOA} `{InOB} `{InOC}:InO(Pullbackfg).Proof.srapplyinO_to_O_retract.-introsop.exists(O_recpr1op).exists(O_rec(funp=>p.2.1)op).revertop;applyO_indpaths;intros[b[ca]].refine(apf(O_rec_beta__) @_);cbn.refine(a@apg(O_rec_beta__)^).-intros[b[ca]];cbn.srapplypath_sigma'.{applyO_rec_beta. }refine(transport_sigma'__@_);cbn.srapplypath_sigma'.{applyO_rec_beta. }abstract(rewritetransport_paths_Fr;rewritetransport_paths_Fl;rewriteO_indpaths_beta;rewriteconcat_V_pp;rewriteap_V;applyconcat_pV_p).Defined.FibersGlobal InstanceinO_hfiber{AB:Type} `{InOA} `{InOB}(f:A->B) (b:B):InO(hfiberfb).Proof.simplerefine(inO_to_O_retract___).-introsx;simplerefine(_;_).+exact(O_recpr1x).+revertx;applyO_indpaths;introsx;simpl.refine(apf(O_rec_betapr1x) @_).exact(x.2).-intros[ap];simplerefine(path_sigma'___).+exact(O_rec_betapr1(a;p)).+refine(ap(transport__) (O_indpaths_beta____) @_);simpl.refine(transport_paths_Fl__@_).applyconcat_V_pp.Defined.DefinitioninO_unsigma{A:Type} (B:A->Type)`{InOA} {B_inO:InO{x:A&Bx}} (x:A):InO(Bx):=inO_equiv_inO_(hfiber_fibrationxB)^-1.#[local]HintImmediateinO_unsigma:typeclass_instances.The reflector preserving hfibers is a characterization of lex modalities.  Here is the comparison map.DefinitionO_functor_hfiber{AB} (f:A->B) (b:B):O(hfiberfb) ->hfiber(O_functorf) (toOBb).Proof.applyO_rec.intros[ap].exists(toOAa).refine(to_O_naturalfa@_).applyap,p.Defined.DefinitionO_functor_hfiber_natural{AB} (f:A->B) (b:B): (O_functor_hfiberfb)otoO(hfiberfb) ==functor_hfiber(funu=> (to_O_naturalfu)^)b.Proof.intros[ap];unfoldO_functor_hfiber,functor_hfiber,functor_sigma;cbn.refine(O_rec_beta__@_).exact(ap_(inv_V_@@ 1))^.Defined.functor_sigmaoveridmappreservesO-equivalences.DefinitionO_inverts_functor_sigma_id{A} {PQ:A->Type}(g:foralla,Pa->Qa) `{foralla,O_inverts(ga)}:O_inverts(functor_sigmaidmapg).Proof.applyO_inverts_from_extendable;introsZZ_inO.applyooextendable_functor_sigma_id;introsa.nrapplyooextendable_O_inverts;exact_.Defined.Theorem 7.3.9: The reflectorOcan be discarded inside a reflected sum.  This can be obtained fromO_inverts_functor_sigma_idapplied to the family of unitstoO(Px), but unfortunately the definitional behavior of the inverse obtained thereby (which here we take as the "forwards" direction) is poor.  So instead we give an explicit proof, but note that the "backwards" direction here is preciselyfunctor_sigma.Definitionequiv_O_sigma_O{A} (P:A->Type):O{x:A&O(Px)} <~>O{x:A&Px}.:= (Build_Equiv _   (O_inverts_functor_sigma_id (fun x => to O (P x))))^-1.Proof.srapplyequiv_adjointify.-applyO_rec;intros[aop];revertop.applyO_rec;introsp.exact(toO_(a;p)).-applyO_functor.exact(functor_sigmaidmap(funx=>toO(Px))).-unfoldO_functor;rapplyO_indpaths.intros[ap];simpl.abstract(repeat(rewriteO_rec_beta);reflexivity).-unfoldO_functor;rapplyO_indpaths.intros[aop];revertop;rapplyO_indpaths;introsp;simpl.abstract(repeat(rewriteO_rec_beta);reflexivity).Defined.EquivalencesNaively it might seem that we need closure under Sigmas (hence a modality) to deduce closure underEquiv, but in fact the above closure under fibers is sufficient.  This appears as part of the proof of Proposition 2.18 of CORS.  For later use, we try to reduce the number of universe parameters (but we don't completely control them all).Global InstanceinO_equiv`{Funext} (A:Type@{i}) (B:Type@{j})`{InOA} `{InOB}:InO(A<~>B).Proof.refine(inO_equiv_inO_(issig_equiv@{ijk}AB)).refine(inO_equiv_inO_(equiv_functor_sigmaequiv_idmap@{k}(funf=>equiv_biinv_isequiv@{ijk}f))).transparentassert(c: (prod@{kk} (A->B) (prod@{kk} (B->A) (B->A)) ->prod@{kk} (A->A) (B->B))).{intros[f[gh]];exact(hof,fog). }pose(U:=hfiber@{kk}c(idmap,idmap)).refine(inO_equiv_inO'@{kkk}U_).Introduces some extra copies ofkby typeclass inference.unfoldhfiber,BiInv;cbnin*.srefine(equiv_adjointify____).-intros[[f[gh]]p].apply(equiv_inverse(equiv_path_prod__))inp.destructpas[pq];cbnin*.existsf;split; [existsh|existsg].all:applyap10;assumption.-intros[f[[gp] [hq]]].exists(f,(h,g));cbn.applypath_prod;applypath_arrow;assumption.-intros[f[[gp] [hq]]];cbn.apply(path_sigma'_1);applypath_prod;apply(path_sigma'_1);cbn;rewritetransport_1.1:rewriteap_fst_path_prod.2:rewriteap_snd_path_prod.all:applypath_forall;introsx;rewriteap10_path_arrow;reflexivity.-introsfghp.cbn.apply(path_sigma'_1);cbn.refine(_@eta_path_prod(pr2fghp));applyap011;applyeta_path_arrow.Defined.PathsDefinitioninO_paths@{i} (S:Type@{i}) {S_inO:InOS} (xy:S):InO(x=y).Proof.simplerefine(inO_to_O_retract@{i}___);introu.-assert(p: (fun_:O(x=y) =>x) == (fun_=>y)).{refine(O_indpaths___);simpl.introv;exactv. }exact(pu).-simpl.rewriteO_indpaths_beta;reflexivity.Qed.Global Existing InstanceinO_paths.LemmaO_concat{A:Type} {a0a1a2:A}:O(a0=a1) ->O(a1=a2) ->O(a0=a2).Proof.introspq.strip_reflections.exact(toO_(p@q)).Defined.TruncationsThe reflector preserves hprops (and, as we have already seen, contractible types), although it doesn't generally preserven-types for othern.Global Instanceishprop_O_ishprop{A} `{IsHPropA} :IsHProp(OA).Proof.refineishprop_isequiv_diag.refine(isequiv_homotopic(O_prod_cmpAAoO_functor(fun(a:A) => (a,a)))_).applyO_indpaths;introsx;simpl.refine(ap(O_prod_cmpAA) (to_O_natural(fun(a:A) => (a,a))x) @_).unfoldO_prod_cmp;applyO_rec_beta.Defined.IfAisInO, then so isIsTruncnA.Global InstanceinO_istrunc`{Funext} {n} {A} `{InOA}:InO(IsTruncnA).Proof.generalizedependentA;simple_inductionnnIH;introsA?.-We have to be slightly clever here: the actual definition ofContrinvolves a sigma, whichOis not generally closed under, but fortunately we haveequiv_contr_inhabited_allpath.refine(inO_equiv_inO_equiv_contr_inhabited_allpath^-1).-refine(inO_equiv_inO_(equiv_istrunc_unfoldn.+1A)^-1).Defined.CoproductsDefinitionO_inverts_functor_sum{ABA'B'} (f:A->A') (g:B->B')`{O_invertsf} `{O_invertsg}:O_inverts(functor_sumfg).Proof.applyO_inverts_from_extendable;intros.applyextendable_functor_sum;applyooextendable_O_inverts;assumption.Defined.Definitionequiv_O_functor_sum{ABA'B'} (f:A->A') (g:B->B')`{O_invertsf} `{O_invertsg}:O(A+B) <~>O(A'+B'):=Build_Equiv___(O_inverts_functor_sumfg).Definitionequiv_O_sum{AB} :O(A+B) <~>O(OA+OB):=equiv_O_functor_sum(toOA) (toOB).CoequalizersSectionOCoeq.Context{BA:Type} (fg:B->A).DefinitionO_inverts_functor_coeq{B'A':Type} {f'g':B'->A'}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)`{O_invertsk} `{O_invertsh}:O_inverts(functor_coeqhkpq).Proof.applyO_inverts_from_extendable.introsZZ_inO.applyextendable_functor_coeq'.all:nrapplyooextendable_O_inverts;assumption.Defined.Definitionequiv_O_functor_coeq{B'A':Type} (f'g':B'->A')(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)`{O_invertsk} `{O_invertsh}:O(Coeqfg) <~>O(Coeqf'g'):=Build_Equiv___(O_inverts_functor_coeqhkpq).Definitioncoeq_cmp:Coeqfg->Coeq(O_functorf) (O_functorg):=functor_coeq(toOB) (toOA)(funy=> (to_O_naturalfy)^)(funy=> (to_O_naturalgy)^).Global Instanceisequiv_O_coeq_cmp:O_invertscoeq_cmp.Proof.rapplyO_inverts_functor_coeq.Defined.Definitionequiv_O_coeq:O(Coeqfg) <~>O(Coeq(O_functorf) (O_functorg)):=Build_Equiv__(O_functorcoeq_cmp)_.Definitionequiv_O_coeq_to_O(a:A):equiv_O_coeq(toO(Coeqfg) (coeqa))=toO(Coeq(O_functorf) (O_functorg)) (coeq(toOAa)).Proof.refine(to_O_natural__).Defined.Definitioninverse_equiv_O_coeq_to_O(a:A):equiv_O_coeq^-1 (toO(Coeq(O_functorf) (O_functorg)) (coeq(toOAa)))=toO(Coeqfg) (coeqa).Proof.applymoveR_equiv_V;symmetry;applyequiv_O_coeq_to_O.Defined.EndOCoeq.PushoutsSectionOPushout.Context{ABC:Type} (f:A->B) (g:A->C).DefinitionO_inverts_functor_pushout{A'B'C'} {f':A'->B'} {g':A'->C'}(h:A->A') (k:B->B') (l:C->C')(p:kof==f'oh) (q:log==g'oh)`{O_invertsh} `{O_invertsk} `{O_invertsl}:O_inverts(functor_pushouthklpq).Proof.rapplyO_inverts_functor_coeq;rapplyO_inverts_functor_sum.Defined.Definitionequiv_O_pushout:O(Pushoutfg) <~>O(Pushout(O_functorf) (O_functorg)):=Build_Equiv___(O_inverts_functor_pushout(toOA) (toOB) (toOC)(funx=> (to_O_naturalfx)^)(funx=> (to_O_naturalgx)^)).Definitionequiv_O_pushout_to_O_pushl(b:B):equiv_O_pushout(toO(Pushoutfg) (pushlb))=toO(Pushout(O_functorf) (O_functorg)) (pushl(toOBb)).Proof.cbn.rapplyto_O_natural.Defined.Definitionequiv_O_pushout_to_O_pushr(c:C):equiv_O_pushout(toO(Pushoutfg) (pushrc))=toO(Pushout(O_functorf) (O_functorg)) (pushr(toOCc)).Proof.cbn.rapplyto_O_natural.Defined.Definitioninverse_equiv_O_pushout_to_O_pushl(b:B):equiv_O_pushout^-1 (toO(Pushout(O_functorf) (O_functorg)) (pushl(toOBb)))=toO(Pushoutfg) (pushlb).Proof.applymoveR_equiv_V;symmetry;applyequiv_O_pushout_to_O_pushl.Qed.Definitioninverse_equiv_O_pushout_to_O_pushr(c:C):equiv_O_pushout^-1 (toO(Pushout(O_functorf) (O_functorg)) (pushr(toOCc)))=toO(Pushoutfg) (pushrc).Proof.applymoveR_equiv_V;symmetry;applyequiv_O_pushout_to_O_pushr.Qed.EndOPushout.EndTypes.SectionDecidable.IfEmptybelongs toO, thenOpreserves decidability.Global Instancedecidable_O`{InOEmpty} (A:Type) `{DecidableA}:Decidable(OA).Proof.destruct(decA)as[y|n].-exact(inl(toOAy)).-exact(inr(O_recn)).Defined.Dually, ifOAis decidable, thenO(DecidableA).DefinitionO_decidable(A:Type) `{Decidable(OA)}:O(DecidableA).Proof.destruct(dec(OA))as[y|n].-exact(O_functorinly).-refine(O_functorinr_).applyto;introsa.exact(n(toOAa)).Defined.EndDecidable.SectionMonad.DefinitionO_monad_mult(A:Type) :O(OA) ->OA:=O_recidmap.DefinitionO_monad_mult_natural{AB} (f:A->B):O_functorfoO_monad_multA==O_monad_multBoO_functor(O_functorf).Proof.applyO_indpaths;introsx;unfoldO_monad_mult.rewrite(to_O_natural(O_functorf)x).rewrite(O_rec_betaidmapx).rewrite(O_rec_betaidmap(O_functorfx)).reflexivity.Qed.DefinitionO_monad_unitlaw1(A:Type):O_monad_multAo(toO(OA)) ==idmap.Proof.applyO_indpaths;introsx;unfoldO_monad_mult.exact(O_rec_betaidmap(toOAx)).Defined.DefinitionO_monad_unitlaw2(A:Type):O_monad_multAo(O_functor(toOA)) ==idmap.Proof.applyO_indpaths;introsx;unfoldO_monad_mult,O_functor.repeatrewriteO_rec_beta.reflexivity.Qed.DefinitionO_monad_mult_assoc(A:Type):O_monad_multAoO_monad_mult(OA) ==O_monad_multAoO_functor(O_monad_multA).Proof.applyO_indpaths;introsx;unfoldO_monad_mult,O_functor.repeatrewriteO_rec_beta.reflexivity.Qed.EndMonad.SectionStrongMonad.Context{fs:Funext}.DefinitionO_monad_strength(AB:Type) :A*OB->O(A*B):=funaob=>O_rec(funba=>toO(A*B) (a,b)) (sndaob) (fstaob).DefinitionO_monad_strength_natural(AA'BB':Type) (f:A->A') (g:B->B'):O_functor(functor_prodfg)oO_monad_strengthAB==O_monad_strengthA'B'ofunctor_prodf(O_functorg).Proof.intros[ab].reverta.applyap10.strip_reflections.applypath_arrow;introsa.unfoldO_monad_strength,O_functor;simpl.repeatrewriteO_rec_beta.reflexivity.Qed.The diagrams for strength, see http://en.wikipedia.org/wiki/Strong_monadDefinitionO_monad_strength_unitlaw1(A:Type):O_functor(@sndUnitA)oO_monad_strengthUnitA== @sndUnit(OA).Proof.intros[[]a].strip_reflections.unfoldO_monad_strength,O_functor.simpl.rewriteO_rec_beta.nrapplyO_rec_beta.Qed.DefinitionO_monad_strength_unitlaw2(AB:Type):O_monad_strengthABofunctor_prodidmap(toOB) ==toO(A*B).Proof.intros[ab].unfoldO_monad_strength,functor_prod.simpl.reverta;applyap10.nrapplyO_rec_beta.Qed.DefinitionO_monad_strength_assoc1(ABC:Type):O_functor(equiv_prod_assocABC)^-1oO_monad_strength(A*B)C==O_monad_strengthA(B*C)ofunctor_prodidmap(O_monad_strengthBC)o(equiv_prod_assocAB(OC))^-1.Proof.intros[[ab]c].reverta;applyap10.revertb;applyap10.strip_reflections.applypath_arrow;introsb.applypath_arrow;introsa.unfoldO_monad_strength,O_functor,functor_prod.simpl.repeatrewriteO_rec_beta.reflexivity.Qed.DefinitionO_monad_strength_assoc2(AB:Type):O_monad_mult(A*B)oO_functor(O_monad_strengthAB)oO_monad_strengthA(OB) ==O_monad_strengthABofunctor_prodidmap(O_monad_multB).Proof.intros[ab].reverta;applyap10.strip_reflections.applypath_arrow;introsa.unfoldO_monad_strength,O_functor,O_monad_mult,functor_prod.simpl.repeat(rewriteO_rec_beta;simpl).reflexivity.Qed.EndStrongMonad.EndReflective_Subuniverse.Now we make theO_invertsnotation global.NotationO_invertsOf:= (IsEquiv(O_functorOf)).Modally connected typesConnectedness of a type, relative to a modality or reflective subuniverse, can be defined in two equivalent ways: quantifying over all maps into modal types, or by considering just the universal case, the modal reflection of the type itself.  The former requires only core Coq, but blows up the size (universe level) ofIsConnected, since it quantifies over types; moreover, it is not even quite correct since (at least with a polymorphic modality) it should really be quantified over all universes.  Thus, we use the latter, although in most examples it requires HITs to define the modal reflection.Question: is there a definition of connectedness (say, for n-types) that neither blows up the universe level, nor requires HIT's?We give annotations to reduce the number of universe parameters.ClassIsConnected(O:ReflectiveSubuniverse@{i}) (A:Type@{i}):=isconnected_contr_O:Contr@{i} (OA).Global Existing Instanceisconnected_contr_O.SectionConnectedTypes.Context(O:ReflectiveSubuniverse).Being connected is an hpropGlobal Instanceishprop_isconnected`{Funext}A:IsHProp(IsConnectedOA).Proof.unfoldIsConnected;exact_.Defined.Anything equivalent to a connected type is connected.Definitionisconnected_equiv(A:Type) {B:Type} (f:A->B) `{IsEquiv__f}:IsConnectedOA->IsConnectedOB.Proof.intros?;refine(contr_equiv(OA) (O_functorOf)).Defined.Definitionisconnected_equiv'(A:Type) {B:Type} (f:A<~>B):IsConnectedOA->IsConnectedOB:=isconnected_equivAf.The O-connected types form a subuniverse.DefinitionConn:Subuniverse.Proof.rapply(Build_Subuniverse(IsConnectedO)).simpl;introsTUisconnTfisequivf.exact(isconnected_equivTfisconnT).Defined.Connectedness of a typeAcan equivalently be characterized by the fact that any map to anO-typeCis nullhomotopic.  Here is one direction of that equivalence.Definitionisconnected_elim{A:Type} `{IsConnectedOA} (C:Type) `{InOC} (f:A->C):NullHomotopyf.Proof.set(ff:= @O_recO_____f).exists(ff(center_)).introsa.symmetry.refine(apff(contr(toO_a)) @_).applyO_rec_beta.Defined.For the other direction of the equivalence, it's sufficient to consider the case whenCisOA.Definitionisconnected_from_elim_to_O{A:Type}:NullHomotopy(toOA) ->IsConnectedOA.Proof.introsnh.apply(Build_Contr_(nh.1)).rapplyO_indpaths.introsx;symmetry;apply(nh.2).Defined.Now the general case follows.Definitionisconnected_from_elim{A:Type}: (forall(C:Type) `{InOC} (f:A->C),NullHomotopyf)->IsConnectedOA.Proof.introsH.exact(isconnected_from_elim_to_O(H(OA) (O_inOA) (toOA))).Defined.Connected types are closed under sigmas.Global Instanceisconnected_sigma{A:Type} {B:A->Type}`{IsConnectedOA} `{foralla,IsConnectedO(Ba)}:IsConnectedO{a:A&Ba}.Proof.applyisconnected_from_elim;introsC?f.pose(nB:=funa=> @isconnected_elim(Ba)_C_(funb=>f(a;b))).pose(nA:=isconnected_elimC(funa=> (nBa).1)).exists(nA.1);intros[ab].exact((nBa).2b@nA.2a).Defined.Contractible types are connected.Global Instanceisconnected_contr{A:Type} `{ContrA}:IsConnectedOA.Proof.rapplycontr_O_contr.Defined.A type which is both connected and modal is contractible.Definitioncontr_trunc_conn{A:Type} `{InOA} `{IsConnectedOA}:ContrA.Proof.apply(contr_equiv_(toOA)^-1).Defined.Any map between connected types is inverted by O.Global InstanceO_inverts_isconnected{AB:Type} (f:A->B)`{IsConnectedOA} `{IsConnectedOB}:O_invertsOf.Proof.exact_.Defined.Here's another way of stating the universal property for mapping out of connected types into modal ones.Definitionextendable_const_isconnected_inO(n:nat)(A:Type) `{IsConnectedOA}(C:Type) `{InOC}:ExtendableAlongn(const_ttA) (fun_=>C).Proof.generalizedependentC;simple_inductionnnIHn;introsC?;[exacttt|split].-introsf.exists(fun_:Unit=> (isconnected_elimCf).1);introsa.symmetry;apply((isconnected_elimCf).2).-introshk.refine(extendable_postcompose'n____(IHn(htt=ktt) (inO_paths____))).intros[];applyequiv_idmap.Defined.Definitionooextendable_const_isconnected_inO(A:Type@{i}) `{IsConnected@{i}OA}(C:Type@{j}) `{InOC}:ooExtendableAlong(const_ttA) (fun_=>C):=funn=>extendable_const_isconnected_inOnAC.Definitionisequiv_const_isconnected_inO`{Funext}{A:Type} `{IsConnectedOA} (C:Type) `{InOC}:IsEquiv(@constAC).Proof.refine(@isequiv_compose__(funcu=>c)___(isequiv_ooextendable(fun_=>C) (const_ttA)(ooextendable_const_isconnected_inOAC))).Defined.Definitionequiv_const_isconnected_inO`{Funext}{A:Type} `{IsConnectedOA} (C:Type) `{InOC}:C<~> (A->C) :=Build_Equiv__const(isequiv_const_isconnected_inOC).EndConnectedTypes.Modally truncated mapsSectionModalMaps.Context(O:ReflectiveSubuniverse).Any equivalence is modalGlobal InstancemapinO_isequiv{AB:Type} (f:A->B) `{IsEquiv__f}:MapInOf.Proof.introsb;exact_.Defined.A slightly specialized result: ifEmptyis modal, then a map with decidable hprop fibers (such asinlorinr) is modal.Global InstancemapinO_hfiber_decidable_hprop{AB:Type} (f:A->B)`{InOEmpty}`{forallb,IsHProp(hfiberfb)}`{forallb,Decidable(hfiberfb)}:MapInOf.Proof.introsb.destruct(equiv_decidable_hprop(hfiberfb))as[e|e].-exact(inO_equiv_inOUnite^-1).-exact(inO_equiv_inOEmptye^-1).Defined.Any map between modal types is modal.Global InstancemapinO_between_inO{AB:Type} (f:A->B)`{InOA} `{InOB}:MapInOf.Proof.introsb;exact_.Defined.Modal maps cancel on the left.DefinitioncancelL_mapinO{ABC:Type} (f:A->B) (g:B->C):MapInOg->MapInO(gof) ->MapInOf.Proof.intros? ?b.refine(inO_equiv_inO_(hfiber_hfiber_compose_mapfgb)).Defined.Modal maps also cancel with equivalences on the other side.DefinitioncancelR_isequiv_mapinO{ABC:Type} (f:A->B) (g:B->C)`{IsEquiv__f} `{MapInO__(gof)}:MapInOg.Proof.introsb.srefine(inO_equiv_inO'(hfiber(gof)b)_).exact(equiv_functor_sigmaf(funa=> 1%equiv)).Defined.DefinitioncancelR_equiv_mapinO{ABC:Type} (f:A<~>B) (g:B->C)`{MapInO__(gof)}:MapInOg:=cancelR_isequiv_mapinOfg.The pullback of a modal map is modal.Global InstancemapinO_pullback{ABC}(f:B->A) (g:C->A) `{MapInO__g}:MapInO(f^*g).Proof.introsb.refine(inO_equiv_inO_(hfiber_pullback_alongfgb)^-1).Defined.Global InstancemapinO_pullback'{ABC}(g:C->A) (f:B->A) `{MapInO__f}:MapInO(g^*'f).Proof.introsc.refine(inO_equiv_inO_(hfiber_pullback_along'gfc)^-1).Defined.functor_sumpreserves modal maps.Global InstancemapinO_functor_sum{AA'BB'}(f:A->A') (g:B->B') `{MapInO__f} `{MapInO__g}:MapInO(functor_sumfg).Proof.intros[a|b].-refine(inO_equiv_inO_(hfiber_functor_sum_lfga)^-1).-refine(inO_equiv_inO_(hfiber_functor_sum_rfgb)^-1).Defined.So doesunfunctor_sum, if both summands are preserved.  These can't beInstances since they requireHaandHbto be supplied.DefinitionmapinO_unfunctor_sum_l{AA'BB'}(h:A+B->A'+B')(Ha:foralla:A,is_inl(h(inla)))(Hb:forallb:B,is_inr(h(inrb)))`{MapInO__h}:MapInO(unfunctor_sum_lhHa).Proof.introsa.refine(inO_equiv_inO_(hfiber_unfunctor_sum_lhHaHba)^-1).Defined.DefinitionmapinO_unfunctor_sum_r{AA'BB'}(h:A+B->A'+B')(Ha:foralla:A,is_inl(h(inla)))(Hb:forallb:B,is_inr(h(inrb)))`{MapInO__h}:MapInO(unfunctor_sum_rhHb).Proof.introsb.refine(inO_equiv_inO_(hfiber_unfunctor_sum_rhHaHbb)^-1).Defined.Given a family of mapsf:foralla,Pa->Qawhich are inO, the induced map on Pi types is also inO.DefinitionmapinO_functor_forall_id`{Funext}{A:Type} {PQ:A->Type} (f:foralla,Pa->Qa) `{foralla,MapInO(fa)}:MapInO(functor_forall_idf).Proof.introg.rapply(inO_equiv_inO_(hfiber_functor_forall_idfg)^-1%equiv).Defined.EndModalMaps.Modally connected mapsConnectedness of a map can again be defined in two equivalent ways: by connectedness of its fibers (as types), or by the lifting property/elimination principle against modal types.  We use the former; the equivalence with the latter is given below inconn_map_elim,conn_map_comp, andconn_map_from_extension_elim.ClassIsConnMap(O:ReflectiveSubuniverse@{i}){A:Type@{i}} {B:Type@{i}} (f:A->B):=isconnected_hfiber_conn_mapThe extra universekis >= max(i,j).:forallb:B,IsConnected@{i}O(hfiber@{ii}fb).Global Existing Instanceisconnected_hfiber_conn_map.SectionConnectedMaps.Universei.Context(O:ReflectiveSubuniverse@{i}).Any equivalence is connectedGlobal Instanceconn_map_isequiv{AB:Type} (f:A->B) `{IsEquiv__f}:IsConnMapOf.Proof.introsb;exact_.Defined.Anything homotopic to a connected map is connected.Definitionconn_map_homotopic{AB:Type} (fg:A->B) (h:f==g):IsConnMapOf->IsConnMapOg.Proof.intros?b.exact(isconnected_equivO(hfiber@{ii}fb)(equiv_hfiber_homotopic@{iii}fghb)_).Defined.The pullback of a connected map is connectedGlobal Instanceconn_map_pullback{ABC}(f:B->A) (g:C->A) `{IsConnMapO__g}:IsConnMapO(f^*g).Proof.introsb.refine(isconnected_equiv__(hfiber_pullback_alongfgb)^-1_).Defined.Global Instanceconn_map_pullback'{ABC}(g:C->A) (f:B->A) `{IsConnMapO__f}:IsConnMapO(g^*'f).Proof.introsc.refine(isconnected_equiv__(hfiber_pullback_along'gfc)^-1_).Defined.The projection from a family of connected types is connected.Global Instanceconn_map_pr1{A:Type} {B:A->Type}`{foralla,IsConnectedO(Ba)}:IsConnMapO(@pr1AB).Proof.introsa.refine(isconnected_equivO(Ba) (hfiber_fibrationaB)_).Defined.Being connected is an hpropGlobal Instanceishprop_isconnmap`{Funext} {AB:Type} (f:A->B):IsHProp(IsConnMapOf).Proof.applyistrunc_forall.Defined.Connected maps are orthogonal to modal maps (i.e. familes of modal types).Definitionconn_map_elim{AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}(d:foralla:A,P(fa)):forallb:B,Pb.Proof.introsb.refine(pr1(isconnected_elimO(A:=hfiberfb)__)).intros[ap].exact(transportPp(da)).Defined.Definitionconn_map_comp{AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}(d:foralla:A,P(fa)):foralla:A,conn_map_elimfPd(fa) =da.Proof.introsa.unfoldconn_map_elim.set(fibermap:= (funa0p:hfiberf(fa)=>let(a0,p) :=a0pintransportPp(da0))).destruct(isconnected_elimO(P(fa))fibermap)as[xe].change(da)with(fibermap(a;1)).applyinverse,e.Defined.A map which is both connected and modal is an equivalence.Definitionisequiv_conn_ino_map{AB:Type} (f:A->B)`{IsConnMapO__f} `{MapInO__f}:IsEquivf.Proof.applyisequiv_contr_map.introsb.apply(contr_trunc_connO).Defined.We can re-express this in terms of extensions.Lemmaextension_conn_map_elim{AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}(d:foralla:A,P(fa)):ExtensionAlongfPd.Proof.exists(conn_map_elimfPd).applyconn_map_comp.Defined.Definitionextendable_conn_map_inO(n:nat){AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}:ExtendableAlongnfP.Proof.generalizedependentP.simple_inductionnnIHn;introsP?; [exacttt|split].-introsd;applyextension_conn_map_elim;exact_.-introshk;applyIHn;exact_.Defined.Definitionooextendable_conn_map_inO{AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}:ooExtendableAlongfP:=funn=>extendable_conn_map_inOnfP.Lemmaallpath_extension_conn_map`{Funext}{AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}(d:foralla:A,P(fa))(ee':ExtensionAlongfPd):e=e'.Proof.applypath_extension.refine(extension_conn_map_elim___).Defined.It follows thatconn_map_elimis actually an equivalence.Theoremisequiv_o_conn_map`{Funext}{AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}:IsEquiv(fun(g:forallb:B,Pb) =>goDf).Proof.applyisequiv_contr_map;introsd.applycontr_inhabited_hprop.-nrefine(@istrunc_equiv_istrunc{g:forallb,Pb&goDf==d}____).{refine(equiv_functor_sigma_id_);introsg.applyequiv_path_forall. }applyhprop_allpath.introsgh.exact(allpath_extension_conn_mapfPdgh).-exists(conn_map_elimfPd).applypath_forall;introsx;applyconn_map_comp.Defined.Definitionequiv_o_conn_map`{Funext}{AB:Type} (f:A->B) `{IsConnMapO__f}(P:B->Type) `{forallb:B,InO(Pb)}: (forallb,Pb) <~> (foralla,P(fa)):=Build_Equiv___(isequiv_o_conn_mapfP).When considering lexness properties, we often want to consider the property of the universe of modal types being modal.  We can't say this directly (except in the accessible, hence liftable, case) because it lives in a higher universe, but we can make a direct extendability statement.  Here we prove a lemma that oo-extendability into the universe follows from plain extendability, essentially because the type of equivalences between twoO-modal types isO-modal.Definitionooextendable_TypeO_from_extension`{Univalence}{AB:Type} (f:A->B) `{IsConnMapO__f}(extP:forallP:A->Type_O,ExtensionAlongf(fun_:B=>Type_O)P):ooExtendableAlongf(fun_=>Type_O).Proof.By definition, in addition to our assumptionextPthat maps intoType_Oextend alongf, we must show that sections of families of equivalences areooExtendableAlongit.intros[|[|n]].-exacttt.(* n = 0 *)Note that due to the implementation ofooExtendableAlong, we actually have to useextPtwice (there should probably be a general cofixpoint lemma for this).-split; [applyextP|intros;exacttt].(* n = 1 *)-split; [applyextP| ].(* n > 1 *)What remains is to extend families of paths.introsPQ;rapply(ooextendable_postcompose'(funb=>Pb<~>Qb)).+introsx;refine(equiv_path_TypeO___oEequiv_path_universe__).+rapplyooextendable_conn_map_inO.Defined.Conversely, if a map satisfies this elimination principle (expressed via extensions), then it is connected.  This completes the proof of Lemma 7.5.7 from the book.Lemmaconn_map_from_extension_elim{AB:Type} (f:A->B): (forall(P:B->Type) {P_inO:forallb:B,InO(Pb)}(d:foralla:A,P(fa)),ExtensionAlongfPd)->IsConnMapOf.Proof.introsHfb.applyisconnected_from_elim_to_O.assert(e:=Hf(funb=>O(hfiberfb))_(funa=>toO_(a;1))).exists(e.1b).intros[ap].destructp.symmetry;apply(e.2).Defined.Lemma 7.5.6: Connected maps compose and cancel on the right.Global Instanceconn_map_compose{ABC:Type} (f:A->B) (g:B->C)`{IsConnMapO__f} `{IsConnMapO__g}:IsConnMapO(gof).Proof.applyconn_map_from_extension_elim;introsP?d.exists(conn_map_elimgP(conn_map_elimf(funb=>P(gb))d));introsa.exact(conn_map_compgP__@conn_map_compf(funb=>P(gb))da).Defined.DefinitioncancelR_conn_map{ABC:Type} (f:A->B) (g:B->C)`{IsConnMapO__f} `{IsConnMapO__(gof)}:IsConnMapOg.Proof.applyconn_map_from_extension_elim;introsP?d.exists(conn_map_elim(gof)P(doDf));introsb.patternb;refine(conn_map_elimf__b);introsa.exact(conn_map_comp(gof)P(doDf)a).Defined.Connected maps also cancel with equivalences on the other side.DefinitioncancelL_isequiv_conn_map{ABC:Type} (f:A->B) (g:B->C)`{IsEquiv__g} `{IsConnMapO__(gof)}:IsConnMapOf.Proof.introsb.srefine(isconnected_equiv'O(hfiber(gof) (gb))__).exact(equiv_inverse(equiv_functor_sigma_id(funa=>equiv_apg(fa)b))).Defined.DefinitioncancelL_equiv_conn_map{ABC:Type} (f:A->B) (g:B<~>C)`{IsConnMapO__(gof)}:IsConnMapOf:=cancelL_isequiv_conn_mapfg.The constant map toUnitis connected just when its domain is.Definitionisconnected_conn_map_to_unit{A:Type}`{IsConnMapO__(const_ttA)}:IsConnectedOA.Proof.refine(isconnected_equivO(hfiber(const_ttA)tt)(equiv_sigma_contr_)_).Defined.#[local]HintImmediateisconnected_conn_map_to_unit:typeclass_instances.Global Instanceconn_map_to_unit_isconnected{A:Type}`{IsConnectedOA}:IsConnMapO(const_ttA).Proof.introsu.refine(isconnected_equivOA(equiv_sigma_contr_)^-1_).Defined.(* Lemma 7.5.10: A map to a type inOexhibits its codomain as theO-reflection of its domain if it isO-connected.  (The converse is true if and only ifOis a modality.) *)Definitionisequiv_O_rec_conn_map{AB:Type} `{InOB}(f:A->B) `{IsConnMapO__f}:IsEquiv(O_rec(O:=O)f).Proof.refine(isequiv_adjointify_(conn_map_elimf(fun_=>OA) (toOA))__).-introsx.patternx.refine(conn_map_elimf__x);introsa.exact(ap(O_recf)(conn_map_compf(fun_=>OA) (toOA)a)@O_rec_betafa).-applyO_indpaths;introsa;simpl.refine(ap_(O_rec_betafa) @_).refine(conn_map_compf(fun_=>OA) (toOA)a).Defined.Lemma 7.5.12SectionConnMapFunctorSigma.Context{AB:Type} {P:A->Type} {Q:B->Type}(f:A->B) (g:foralla,Pa->Q(fa))`{foralla,IsConnMapO(ga)}.Definitionequiv_O_hfiber_functor_sigma(b:B) (v:Qb):O(hfiber(functor_sigmafg) (b;v)) <~>O(hfiberfb).Proof.equiv_via(O{w:hfiberfb&hfiber(gw.1) ((w.2)^ #v)}).{applyequiv_O_functor,hfiber_functor_sigma. }equiv_via(O{w:hfiberfb&O(hfiber(gw.1) ((w.2)^ #v))}).{symmetry;applyequiv_O_sigma_O. }applyequiv_O_functor.applyequiv_sigma_contr;intros[ap];simpl;exact_.Defined.Global Instanceconn_map_functor_sigma`{IsConnMapO__f}:IsConnMapO(functor_sigmafg).Proof.intros[bv].refine(contr_equiv'_(equiv_inverse(equiv_O_hfiber_functor_sigmabv))).Defined.Definitionconn_map_base_inhabited(inh:forallb,Qb)`{IsConnMapO__(functor_sigmafg)}:IsConnMapOf.Proof.introsb.refine(contr_equiv_(equiv_O_hfiber_functor_sigmab(inhb))).Defined.EndConnMapFunctorSigma.Lemma 7.5.13.  The "if" direction is a special case ofconn_map_functor_sigma, so we prove only the "only if" direction.Definitionconn_map_fiber{A:Type} {PQ:A->Type} (f:foralla,Pa->Qa)`{IsConnMapO__(functor_sigmaidmapf)}:foralla,IsConnMapO(fa).Proof.introsaq.refine(isconnected_equiv'O(hfiber(functor_sigmaidmapf) (a;q))__).exact(hfiber_functor_sigma_idmapPQfaq).Defined.Lemma 7.5.14: Connected maps are inverted byO.Global InstanceO_inverts_conn_map{AB:Type} (f:A->B)`{IsConnMapO__f}:O_invertsOf.Proof.rapplyO_inverts_from_extendable.intros;rapplyextendable_conn_map_inO.Defined.As a consequence, connected maps between modal types are equivalences.Definitionisequiv_conn_map_ino{AB:Type} (f:A->B)`{InOA} `{InOB} `{IsConnMapO__f}:IsEquivf:=isequiv_commsq'f(O_functorOf) (toOA) (toOB) (to_O_naturalOf).Connectedness is preserved byO_functor.Global Instanceconn_map_O_functor{AB} (f:A->B) `{IsConnMapO__f}:IsConnMapO(O_functorOf).Proof.unfoldO_functor.rapplyconn_map_compose.Defined.Connected maps are preserved by coproductsDefinitionconn_map_sum{ABA'B'} (f:A->A') (g:B->B')`{IsConnMapO__f} `{IsConnMapO__g}:IsConnMapO(functor_sumfg).Proof.applyconn_map_from_extension_elim;intros.applyextension_functor_sum;rapplyooextendable_conn_map_inO.Defined.Connected maps are preserved by coequalizersDefinitionconn_map_functor_coeq{BAB'A'}{fg:B->A} {f'g':B'->A'}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)`{IsConnMapO__k} `{IsConnMapO__h}:IsConnMapO(functor_coeqhkpq).Proof.applyconn_map_from_extension_elim;intros.applyextension_functor_coeq.-rapplyooextendable_conn_map_inO.-intros;rapplyooextendable_conn_map_inO.Defined.And by pushoutsDefinitionconn_map_functor_pushout{ABCA'B'C'}(f:A->B) (g:A->C) {f':A'->B'} {g':A'->C'}(h:A->A') (k:B->B') (l:C->C')(p:kof==f'oh) (q:log==g'oh)`{IsConnMapO__h} `{IsConnMapO__k} `{IsConnMapO__l}:IsConnMapO(functor_pushouthklpq).Proof.applyconn_map_from_extension_elim;intros.applyextension_functor_coeq.-applyextendable_functor_sum;rapplyooextendable_conn_map_inO.-intros;rapplyooextendable_conn_map_inO.Defined.EndConnectedMaps.Containment of (reflective) subuniversesOne subuniverse is contained in another if everyO1-modal type isO2-modal.  We define this parametrized by three universes:O1andO2are reflective subuniverses ofType@{i1}andType@{i2}respectively, and the relation says that all types inType@{j}thatO1-modal are alsoO2-modal.  This impliesj<=i1andj<=i2, of course.  The most common application is wheni1=i2=j, but it's sometimes useful to talk about a subuniverse of a larger universe agreeing with a subuniverse of a smaller universe on the smaller universe.ClassO_leq@{i1i2j} (O1:Subuniverse@{i1}) (O2:Subuniverse@{i2}):=inO_leq:forall(A:Type@{j}),InO1A->InO2A.ArgumentsinO_leqO1O2{_}A_.Declare Scopesubuniverse_scope.Notation"O1 <= O2" := (O_leqO1O2) :subuniverse_scope.OpenScopesubuniverse_scope.Global Instancereflexive_O_leq:ReflexiveO_leq| 10.Proof.introsOA?;assumption.Defined.Global Instancetransitive_O_leq:TransitiveO_leq| 10.Proof.introsO1O2O3O12O23A?.rapply(@inO_leqO2O3).rapply(@inO_leqO1O2).Defined.DefinitionmapinO_O_leq(O1O2:Subuniverse) `{O1<=O2}{AB:Type} (f:A->B) `{MapInO1ABf}:MapInO2f.Proof.introsb;rapply(inO_leqO1O2).Defined.This implies that everyO2-connected type isO1-connected, and similarly for maps and equivalences.  We give universe annotations so thatO1andO2don't have to be on the same universe, but we do have to havei1<=i2for this statement.  Wheni2<=i1it seems that the statement might not be true unless the RSU on the larger universe is accessibly extended from the smaller one; seeLocalization.v.Definitionisconnected_O_leq@{i1i2}(O1:ReflectiveSubuniverse@{i1}) (O2:ReflectiveSubuniverse@{i2}) `{O_leq@{i1i2i1}O1O2}(A:Type@{i1}) `{IsConnectedO2A}:IsConnectedO1A.Proof.applyisconnected_from_elim.introsCC1f.apply(isconnected_elimO2);srapplyinO_leq;exact_.Defined.This one has the same universe constrainti1<=i2.Definitionconn_map_O_leq@{i1i2}(O1:ReflectiveSubuniverse@{i1}) (O2:ReflectiveSubuniverse@{i2}) `{O_leq@{i1i2i1}O1O2}{AB:Type@{i1}} (f:A->B) `{IsConnMapO2ABf}:IsConnMapO1f.Proof.We could prove this by applyingisconnected_O_leqfiberwise, but unless we were very careful that would collapse the two universesi1andi2.  So instead we just give an analogous direct proof.applyconn_map_from_extension_elim.introsPP_inOg.rapply(extension_conn_map_elimO2).introsb;rapply(inO_leqO1).Defined.This is Lemma 2.12(i) in CORS, again with the same universe constrainti1<=i2.DefinitionO_inverts_O_leq@{i1i2}(O1:ReflectiveSubuniverse@{i1}) (O2:ReflectiveSubuniverse@{i2}) `{O_leq@{i1i2i1}O1O2}{AB:Type@{i1}} (f:A->B) `{O_invertsO2f}:O_invertsO1f.Proof.applyO_inverts_from_extendable@{i1i1i1i1i1};introsZZ_inO.pose(inO_leqO1O2Z_).apply(lift_extendablealong@{i1i1i1i1i1i1i2i1i1i2i1}).apply(ooextendable_O_invertsO2);exact_.Defined.Equality of (reflective) subuniversesTwo subuniverses are the same if they have the same modal types.  The universe parameters are the same as forO_leq:O1andO2are reflective subuniverses ofType@{i1}andType@{i2}, and the relation says that they agree when restricted toType@{j}, wherej<=i1andj<=i2.ClassO_eq@{i1i2j} (O1:Subuniverse@{i1}) (O2:Subuniverse@{i2}) :={O_eq_l:O_leq@{i1i2j}O1O2;O_eq_r:O_leq@{i2i1j}O2O1;}.Global Existing InstancesO_eq_lO_eq_r.Infix"<=>" :=O_eq:subuniverse_scope.Definitionissig_O_eqO1O2:_<~>O_eqO1O2:=ltac:(issig).Global Instancereflexive_O_eq:ReflexiveO_eq| 10.Proof.intros;split;reflexivity.Defined.Global Instancetransitive_O_eq:TransitiveO_eq| 10.Proof.introsO1O2O3;split;refine(transitivity(y:=O2)__).Defined.Global Instancesymmetric_O_eq:SymmetricO_eq| 10.Proof.introsO1O2[? ?];split;assumption.Defined.Definitionissig_subuniverse:_<~>Subuniverse:=ltac:(issig).Definitionequiv_path_subuniverse`{Univalence} (O1O2:Subuniverse): (O1<=>O2) <~> (O1=O2).Proof.refine(_oE(issig_O_eqO1O2)^-1).revertO1O2;refine(equiv_path_along_equivissig_subuniverse_).cbn;introsO1O2.refine(equiv_path_sigma_hpropO1O2oE_).destructO1as[O1[O1h?]];destructO2as[O2[O2h?]];cbn.refine(equiv_path_arrow__oE_).srapply(equiv_iff_hprop).-srapplyistrunc_sigma;unfoldO_leq;exact_.-intros[hk]A;specialize(hA);specialize(kA);cbnin*.applypath_universe_uncurried,equiv_iff_hprop;assumption.-introsh;split;introsAe;specialize(hA);cbnin*.1:rewrite<-h.2:rewriteh.all:exacte.Defined.It should also be true that ifO1andO2are reflective subuniverses, thenO1<=>O2is equivalent toO1=O2:>ReflectiveSubuniverse.  Probablycontr_typeof_O_unitshould be useful in proving that.Reflections into one subuniverse are also reflections into an equal one.  Unfortunately these almost certainly can't beInstances for fear of infinite loops, since<=>is reflexive.Definitionprereflects_O_leq(O1O2:Subuniverse) `{O1<=O2}(A:Type) `{PreReflectsO1A}:PreReflectsO2A.Proof.unshelveeconstructor.-exact(O_reflectorO1A).-rapply(inO_leqO1O2).-exact(toO1A).Defined.Definitionreflects_O_eq(O1O2:Subuniverse) `{O1<=>O2}(A:Type) `{ReflectsO1A}: @ReflectsO2A(prereflects_O_leqO1O2A).Proof.constructor;introsBB_inO2.poseproof(inO_leqO2O1_B_inO2).apply(extendable_to_OO1).Defined.Separated subuniversesFor any subuniverseO, a type isO-separated iff all its identity types areO-modal.  We will study these further inSeparated.v, but we put the definition here because it's needed inDescent.v.DefinitionSep(O:Subuniverse) :Subuniverse.Proof.unshelveeconstructor.-introsA;exact(forall(xy:A),InO(x=y)).-exact_.-introsTU?f?xy;cbnin*.refine(inO_equiv_inO'_(equiv_apf^-1xy)^-1).Defined.Global InstanceinO_paths_SepO(O:Subuniverse){A:Type} {A_inO:In(SepO)A} (xy:A):InO(x=y):=A_inOxy.TODO: Where to put this?  Morally it goes with the study of<<inModality.vand<<<inDescent.vandSepinSeparated.v, but it doesn't actually need any of those relations, onlyO'<=SepO, and it would also be nice to have it next toO_inverts_functor_coeq.  It's a variation on the latter: ifO'<=SepO, then forO'to invertfunctor_coeqhkit suffices that it invertkand thathbeO-connected (byconn_map_OO_inverts, which has different hypotheses but applies in many of the same examples, that is a weaker assumption).DefinitionOO_inverts_functor_coeq(OO':ReflectiveSubuniverse) `{O'<=SepO}{BA:Type} (fg:B->A){B'A':Type} (f'g':B'->A')(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)`{O_invertsO'k} `{IsConnMapO__h}:O_invertsO'(functor_coeqhkpq).Proof.applyO_inverts_from_extendable.introsZZ_inO.applyextendable_functor_coeq.-nrapply(ooextendable_O_invertsO');assumption.-pose(inO_leqO'(SepO)).introsuv;rapply(extendable_conn_map_inOO).Defined.And a similar property for pushoutsDefinitionOO_inverts_functor_pushout(OO':ReflectiveSubuniverse) `{O'<=SepO}{ABCA'B'C'}(f:A->B) (g:A->C) {f':A'->B'} {g':A'->C'}(h:A->A') (k:B->B') (l:C->C')(p:kof==f'oh) (q:log==g'oh)`{IsConnMapO__h} `{O_invertsO'k} `{O_invertsO'l}:O_invertsO'(functor_pushouthklpq).Proof.nrapply(OO_inverts_functor_coeqOO').1,3:exact_.rapplyO_inverts_functor_sum.Defined.And similar properties for connected mapsDefinitionOO_conn_map_functor_coeq(OO':ReflectiveSubuniverse) `{O'<=SepO}{BAB'A'}{fg:B->A} {f'g':B'->A'}(h:B->B') (k:A->A')(p:kof==f'oh) (q:kog==g'oh)`{IsConnMapO'__k} `{IsConnMapO__h}:IsConnMapO'(functor_coeqhkpq).Proof.applyconn_map_from_extension_elim;intros.applyextension_functor_coeq.-rapplyooextendable_conn_map_inO.-pose(inO_leqO'(SepO));intros;rapply(ooextendable_conn_map_inOO).Defined.DefinitionOO_conn_map_functor_pushout(OO':ReflectiveSubuniverse) `{O'<=SepO}{ABCA'B'C'}(f:A->B) (g:A->C) {f':A'->B'} {g':A'->C'}(h:A->A') (k:B->B') (l:C->C')(p:kof==f'oh) (q:log==g'oh)`{IsConnMapO__h} `{IsConnMapO'__k} `{IsConnMapO'__l}:IsConnMapO'(functor_pushouthklpq).Proof.applyconn_map_from_extension_elim;intros.applyextension_functor_coeq.-applyextendable_functor_sum;rapplyooextendable_conn_map_inO.-pose(inO_leqO'(SepO));intros;rapplyooextendable_conn_map_inO.Defined.#[export]HintImmediateinO_isequiv_to_O:typeclass_instances.#[export]HintImmediateinO_unsigma:typeclass_instances.#[export]HintImmediateisconnected_conn_map_to_unit:typeclass_instances.

--- Miscellaneous\Relational.html ---
RelationalLibrary RelationalRequireImportHoTT.BasicsHoTT.Types.Local OpenScopenat_scope.Local OpenScopepath_scope.Generalizable VariablesABf.Relational equivalencesThis definition is due to Peter LeFanu Lumsdaine on the HoTT mailing list.  This definition gives more judgmental properties, though has the downside of jumping universe levels.RecordRelEquivAB:={equiv_rel:A->B->Type;relequiv_contr_f:foralla,Contr{b:B&equiv_relab};relequiv_contr_g:forallb,Contr{a:A&equiv_relab} }.Argumentsequiv_rel{AB}___.Global Existing Instancerelequiv_contr_f.Global Existing Instancerelequiv_contr_g.Definitionissig_relequiv{AB}: {equiv_rel:A->B->Type| {f:foralla,Contr{b:B&equiv_relab}|forallb,Contr{a:A&equiv_relab} } }<~>RelEquivAB.Proof.issig.Defined.Definitionrelequiv_of_equiv{AB} (e:A<~>B) :RelEquivAB.Proof.refine{|equiv_relab:=ea=b|}.The rest is found by typeclass inference!Defined.Definitionequiv_of_relequiv{AB} (e:RelEquivAB) :A<~>B.Proof.refine(equiv_adjointify(funa=> (center{b:B&equiv_releab}).1)(funb=> (center{a:A&equiv_releab}).1)__);introx;cbn.{refine(appr1(contr_) :_.1 = (x;_).1).exact(center{a:A&equiv_releax}).2. }{refine(appr1(contr_) :_.1 = (x;_).1).exact(center{b:B&equiv_relexb}).2. }Defined.DefinitionRelIsEquiv{AB} (f:A->B):= {r:RelEquivAB|forallx, (center{b:B&equiv_relrxb}).1 =fx}.TODO: Proveishprop_relisequiv`{Funext}{AB}f:IsHProp(@RelIsEquivABf)Judgmental propertyDefinitioninverse_relequiv{AB} (e:RelEquivAB) :RelEquivBA:= {|equiv_relab:=equiv_releba|}.Definitionreinv_V{AB} (e:RelEquivAB):inverse_relequiv(inverse_relequive) =e:= 1.TODO: Is there a definition of this that makesinverse_relequiv(relequiv_idmapA)berelequiv_idmapA, judgmentally?Definitionrelequiv_idmapA:RelEquivAA:= {|equiv_relab:=a=b|}.TODO: Define composition; we probably need truncation to do this?

--- Miscellaneous\Representable.html ---
RepresentableLibrary RepresentableRepresentable profunctorsRequireImportCategory.CoreFunctor.CoreFunctor.Prod.CoreProfunctor.CoreFunctor.DualProfunctor.IdentityFunctor.Composition.CoreFunctor.Identity.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.Local OpenScopeprofunctor_scope.Sectionrepresentable.Quoting nCatLab on profunctors:Every functorf:C→Dinduces two profunctorsD(1,f):C⇸DandD(f,1):D⇸C, defined byD(1,f)(d,c)=D(d,f(c))andD(f,1)(c,d)=D(f(c),d). These profunctors are called representable (or sometimes one of them is corepresentable).Context`{Funext}.DefinitionrepresentableCD(F:FunctorCD) :C-|->D:= 1%profunctoro(1,F).TODO: Is there a define this so that we get proofs by duality about representable functors?  If we had judgemental eta expansion, maybe we could do it asswapo(representableF^op)^op?DefinitioncorepresentableCD(F:FunctorCD) :D-|->C:= 1%profunctoro(F^op, 1).Endrepresentable.

--- Miscellaneous\RewriteLaws.html ---
RewriteLawsLibrary RewriteLawsPseudofunctor rewriting helper lemmasRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportCategory.MorphismsFunctorCategory.Morphisms.RequireImportFunctor.Composition.Core.RequireImportNaturalTransformation.Composition.CoreNaturalTransformation.Composition.Laws.RequireImportNaturalTransformation.Isomorphisms.RequireImportNaturalTransformation.Paths.RequireImportFunctorCategory.Core.RequireImportPseudofunctor.Core.RequireImportHoTT.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.Sectionlemmas.Local OpenScopenatural_transformation_scope.Context`{Funext}.VariableC:PreCategory.VariableF:PseudofunctorC.Lemmap_composition_of_coherent_for_rewrite_helperwxyz(f:morphismCwx) (g:morphismCxy) (h:morphismCyz)(pp0p1p2:PreCategory) (f0:morphismCwz->Functorp2p1)(f1:Functorp0p1) (f2:Functorp2p) (f3:Functorpp0)(f4:Functorp2p0) `(@IsIsomorphism(_->_)f4(f3of2)%functorn)`(@IsIsomorphism(_->_) (f0(ho(gof))%morphism) (f1of4)%functorn0): @paths(NaturalTransformation__)(@morphism_isomorphic___(Category.Morphisms.idtoiso(p2->p1) (apf0(Category.Core.associativityCwxyzfgh))))(n0^-1o((f1oLn^-1)o((f1oLn)o(n0o(@morphism_isomorphic___(Category.Morphisms.idtoiso(p2->p1) (apf0(Category.Core.associativityCwxyzfgh))))))))%natural_transformation.Proof.simplin*.letC:=matchgoalwith|- @paths(@NaturalTransformation?C?D?F?G)__=>constr:((C->D)%category)endinapply(@iso_moveL_VpC);apply(@iso_moveL_MpC______(iso_whisker_l_______)).path_natural_transformation.reflexivity.Qed.Argumentsp_composition_of_coherent_for_rewrite_helper{____________________}.Sectionhelper.Context{wxyz}{f:Functor(Fw) (Fz)} {f0:Functor(Fw) (Fy)}{f1:Functor(Fx) (Fy)} {f2:Functor(Fy) (Fz)}{f3:Functor(Fw) (Fx)} {f4:Functor(Fx) (Fz)}{f5:Functor(Fw) (Fz)} {n:f5<~=~> (f4of3)%functor}{n0:f4<~=~> (f2of1)%functor} {n1:f0<~=~> (f1of3)%functor}{n2:f<~=~> (f2of0)%functor}.Lemmap_composition_of_coherent_iso_for_rewrite__isisomorphism_helper': @IsIsomorphism(_->_)__(n2^-1o(f2oLn1^-1o(associator_1f2f1f3o(n0oRf3on))))%natural_transformation.Proof.eapplyisisomorphism_compose;[eapplyisisomorphism_inverse|eapplyisisomorphism_compose;[eapplyiso_whisker_l;eapplyisisomorphism_inverse|eapplyisisomorphism_compose;[typeclasseseauto|eapplyisisomorphism_compose;[eapplyiso_whisker_r;typeclasseseauto|typeclasseseauto] ] ] ].Defined.Definitionp_composition_of_coherent_iso_for_rewrite__isisomorphism_helper:=Evalhnfinp_composition_of_coherent_iso_for_rewrite__isisomorphism_helper'.Local Argumentsp_composition_of_coherent_iso_for_rewrite__isisomorphism_helper/ .Letinv:=Evalsimplin@morphism_inverse____p_composition_of_coherent_iso_for_rewrite__isisomorphism_helper.Definitionp_composition_of_coherent_iso_for_rewrite__isisomorphism_helper__to_inverseX(H':X= @Build_Isomorphic(_->_)___p_composition_of_coherent_iso_for_rewrite__isisomorphism_helper): @morphism_inverse____X=inv:=ap(funi=> @morphism_inverse____(@isisomorphism_isomorphic___i))H'.Endhelper.Lemmap_composition_of_coherent_iso_for_rewritewxyz(f:morphismCwx) (g:morphismCxy) (h:morphismCyz): (Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__Fwz) (Category.Core.associativityCwxyzfgh)))= @Build_Isomorphic(_->_)__((((p_composition_ofFwyzh(gof))^-1)o((p_morphism_ofFhoL(p_composition_ofFwxygf)^-1)o((associator_1(p_morphism_ofFh) (p_morphism_ofFg) (p_morphism_ofFf))o((p_composition_ofFxyzhgoRp_morphism_ofFf)op_composition_ofFwxz(hog)f)))))%natural_transformationp_composition_of_coherent_iso_for_rewrite__isisomorphism_helper.Proof.applypath_isomorphic;simpl.simplrewrite(@p_composition_of_coherent_CFwxyzfgh).exactp_composition_of_coherent_for_rewrite_helper.Qed.Lemmap_left_identity_of_coherent_iso_for_rewritexy(f:morphismCxy): (Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__Fxy) (Category.Core.left_identityCxyf)))= @Build_Isomorphic(_->_)__((left_identity_natural_transformation_1(p_morphism_ofFf))o((p_identity_ofFyoRp_morphism_ofFf)op_composition_ofFxyy1f))%natural_transformation_.Proof.applypath_isomorphic;simpl.simplrewrite(@p_left_identity_of_coherent_CFxyf).path_natural_transformation.symmetry.etransitivity;applyCategory.Core.left_identity.Qed.Lemmap_right_identity_of_coherent_iso_for_rewritexy(f:morphismCxy): (Category.Morphisms.idtoiso(_->_) (ap(@p_morphism_of__Fxy) (Category.Core.right_identityCxyf)))= @Build_Isomorphic(_->_)__((right_identity_natural_transformation_1(p_morphism_ofFf))o((p_morphism_ofFfoLp_identity_ofFx)op_composition_ofFxxyf1))%natural_transformation_.Proof.applypath_isomorphic;simpl.simplrewrite(@p_right_identity_of_coherent_CFxyf).path_natural_transformation.symmetry.etransitivity;applyCategory.Core.left_identity.Qed.Local Notationtypeofx:= ((funT(_:T) =>T)_x) (onlyparsing).Letp_composition_of_coherent_for_rewrite_typewxyzfgh:=Evalsimplintypeof(ap(@morphism_isomorphic___)(@p_composition_of_coherent_iso_for_rewritewxyzfgh)).Definitionp_composition_of_coherent_for_rewritewxyzfgh:p_composition_of_coherent_for_rewrite_typewxyzfgh:=ap(@morphism_isomorphic___)(@p_composition_of_coherent_iso_for_rewritewxyzfgh).Letp_composition_of_coherent_inverse_for_rewrite_typewxyzfgh:=Evalsimplintypeof(ap(funi=> @morphism_inverse____(@isisomorphism_isomorphic___i))(@p_composition_of_coherent_iso_for_rewritewxyzfgh)).Definitionp_composition_of_coherent_inverse_for_rewritewxyzfgh:p_composition_of_coherent_inverse_for_rewrite_typewxyzfgh:=p_composition_of_coherent_iso_for_rewrite__isisomorphism_helper__to_inverse(p_composition_of_coherent_iso_for_rewritewxyzfgh).Letp_left_identity_of_coherent_for_rewrite_typexyf:=Evalsimplintypeof(ap(@morphism_isomorphic___)(@p_left_identity_of_coherent_iso_for_rewritexyf)).Definitionp_left_identity_of_coherent_for_rewritexyf:p_left_identity_of_coherent_for_rewrite_typexyf:=ap(@morphism_isomorphic___)(@p_left_identity_of_coherent_iso_for_rewritexyf).Letp_left_identity_of_coherent_inverse_for_rewrite_typexyf:=Evalsimplintypeof(ap(funi=> @morphism_inverse____(@isisomorphism_isomorphic___i))(@p_left_identity_of_coherent_iso_for_rewritexyf)).Definitionp_left_identity_of_coherent_inverse_for_rewritexyf:p_left_identity_of_coherent_inverse_for_rewrite_typexyf:=ap(funi=> @morphism_inverse____(@isisomorphism_isomorphic___i))(@p_left_identity_of_coherent_iso_for_rewritexyf).Letp_right_identity_of_coherent_for_rewrite_typexyf:=Evalsimplintypeof(ap(@morphism_isomorphic___)(@p_right_identity_of_coherent_iso_for_rewritexyf)).Definitionp_right_identity_of_coherent_for_rewritexyf:p_right_identity_of_coherent_for_rewrite_typexyf:=Evalsimplinap(@morphism_isomorphic___)(@p_right_identity_of_coherent_iso_for_rewritexyf).Letp_right_identity_of_coherent_inverse_for_rewrite_typexyf:=Evalsimplintypeof(ap(funi=> @morphism_inverse____(@isisomorphism_isomorphic___i))(@p_right_identity_of_coherent_iso_for_rewritexyf)).Definitionp_right_identity_of_coherent_inverse_for_rewritexyf:p_right_identity_of_coherent_inverse_for_rewrite_typexyf:=ap(funi=> @morphism_inverse____(@isisomorphism_isomorphic___i))(@p_right_identity_of_coherent_iso_for_rewritexyf).Endlemmas.

--- Miscellaneous\RewriteModuloAssociativity.html ---
RewriteModuloAssociativityLibrary RewriteModuloAssociativityTactics for rewriting modulo assciativityRequireImportOverturePathGroupoids.RequireImportTactics.BinderApply.Local OpenScopepath_scope.Throughout this file, we prefix withidtac;all imperative tactics (those not returning constrs) which would otherwise start withletormatch.  This prevents them from being evaluated at the call site.  See https://coq.inria.fr/bugs/show_bug.cgi?id=3498 for more details on this difference between tactics and tactic expressions.rewritelemmodulo associativity using:assoc_tac:unitto associate the goal (in place)assoc_in_tac:hyp->unitto associate the hypothesis (in place)prepostcompose_any_tac:constr->constrto pre/post compose an arbitrary morphism onto the lemmarew_tac:hyp->unitto do the actual rewriting (in place).  This tactic is called first with the non-associated version of  the lemma, then with the associated version.LtacrewriteA_using_helperrew_taclemprepostcompose_any_tacassoc_tacassoc_in_tac:=idtac;letlem':=prepostcompose_any_tacleminletH:=freshinposeprooflem'asH;assoc_tac;matchgoalwith|_=>rew_tacH|_=>assoc_in_tacH;rew_tacHend;clearH.This tactic is similar to the above, except that it passes both the unassociated lemma and the associated lemma torepeat_rew_tac, which may then contain optimizations over a manualrepeatsuch as beingrewrite?lem,?lem'.Ltacrepeat_rewriteA_using_helperrepeat_rew_taclemprepostcompose_any_tacassoc_tacassoc_in_tac:=idtac;letlem':=prepostcompose_any_tacleminletH:=freshinposeprooflem'asH;assoc_in_tacH;assoc_tac;repeat_rew_taclem'H;clearH.ModuleExportCompose.Rewriting modulo associativity of composition (o)Sincefogis just a notation, we need to define a constant
      that isn't reduced bycbvbeta.Local Definitioncompose{ABC} (g:B->C) (f:A->B) (x:A) :C:=g(fx).Ltacto_composeT:=matchTwith|contextG[?go?f] =>letT':=contextG[composegf]into_composeT'| ?T'=>constr:(T')end.Turns a lemma of typef=gintoforallh,hof=hogLtacprecompose_anyH:=letret:=make_tac_under_binders_using_inltac:(funH=> (letH':=freshinrenameHintoH';letT:=typeofH'inletT':=to_composeTinposeproof(funsrc(g:_->src) => @ap__(funf=>composegf)__(H':T'))asH))ltac:(idtac)HinletT:=typeofretinletT':= (evalcbvbetainT)inconstr:(ret:T').Associates a type fully to the leftLtacleft_associate_compose_typeT:=letrec_tac:=left_associate_compose_typeinmatchto_composeTwith|foralla: ?A, @?Pa=>letret:=constr:(foralla:A,letT':=Painltac:(letT'':= (evalunfoldT'inT')inletret:=rec_tacT''inexactret))inevalcbvbetazetainret|contextT'[compose?a(compose?b?c)]=>letT'':=contextT'[compose(composeab)c]inrec_tacT''| ?T'=>constr:(T')end.Ltacleft_associate_compose_in_type_ofH:=letT:=typeofHinletT':=left_associate_compose_typeTinconstr:(H:T').Ltacleft_associate_compose:=idtac;(lazymatchgoalwith| [ |- ?G] =>letG':=left_associate_compose_typeGinchangeG'end).Ltacleft_associate_compose_inH:=idtac;(lazymatchtypeofHwith| ?T=>letT':=left_associate_compose_typeTinchangeT'inHend).Ltacafter_rewrite:=repeatmatchgoalwith| [ |-contextG[compose?g?f] ] =>letG':=contextG[gof]inchangeG'|_=>matchgoalwith| [ |-contextG[@compose?A?B?C?g] ] =>letG':=contextG[funf:A->B=>gof]inchangeG'| [ |-contextG[@compose?A?B?C] ] =>letG':=contextG[fun(g:B->C) (f:A->B) =>gof]inchangeG'|_=>progresscbvdelta[compose]end;idtac"Warning: could not fully restore pre-rewrite state.""Try introducing more things or removing binders."end.Tactic Notation"rewriteoA"constr(lem) :=rewriteA_using_helperltac:(funlem'=>rewritelem')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "->"constr(lem) :=rewriteA_using_helperltac:(funlem'=>rewrite->lem')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "<-"constr(lem) :=rewriteA_using_helperltac:(funlem'=>rewrite<-lem')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progressrewrite?lem', ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>rewrite?lem', ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "->" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progressrewrite-> ?lem', -> ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "<-" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progressrewrite<- ?lem', <- ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "->" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>rewrite-> ?lem', -> ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewriteoA" "<-" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>rewrite<- ?lem', <- ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA"constr(lem) :=rewriteA_using_helperltac:(funlem'=>erewritelem')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "->"constr(lem) :=rewriteA_using_helperltac:(funlem'=>erewrite->lem')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "<-"constr(lem) :=rewriteA_using_helperltac:(funlem'=>erewrite<-lem')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progresserewrite?lem', ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>erewrite?lem', ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "->" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progresserewrite-> ?lem', -> ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "<-" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progresserewrite<- ?lem', <- ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "->" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>erewrite-> ?lem', -> ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"erewriteoA" "<-" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>erewrite<- ?lem', <- ?lem'')lemltac:(precompose_any)ltac:(left_associate_compose)ltac:(left_associate_compose_in);after_rewrite.Tactic Notation"rewrite∘A"constr(lem) :=rewriteoAlem.Tactic Notation"rewrite∘A" "->"constr(lem) :=rewriteoA->lem.Tactic Notation"rewrite∘A" "<-"constr(lem) :=rewriteoA<-lem.Tactic Notation"rewrite∘A" "!"constr(lem) :=rewriteoA!lem.Tactic Notation"rewrite∘A" "?"constr(lem) :=rewriteoA?lem.Tactic Notation"rewrite∘A" "->" "!"constr(lem) :=rewriteoA-> !lem.Tactic Notation"rewrite∘A" "<-" "!"constr(lem) :=rewriteoA<- !lem.Tactic Notation"rewrite∘A" "->" "?"constr(lem) :=rewriteoA-> ?lem.Tactic Notation"rewrite∘A" "<-" "?"constr(lem) :=rewriteoA<- ?lem.Tactic Notation"erewrite∘A"open_constr(lem) :=erewriteoAlem.Tactic Notation"erewrite∘A" "->"open_constr(lem) :=erewriteoA->lem.Tactic Notation"erewrite∘A" "<-"open_constr(lem) :=erewriteoA<-lem.Tactic Notation"erewrite∘A" "!"open_constr(lem) :=erewriteoA!lem.Tactic Notation"erewrite∘A" "?"open_constr(lem) :=erewriteoA?lem.Tactic Notation"erewrite∘A" "->" "!"open_constr(lem) :=erewriteoA-> !lem.Tactic Notation"erewrite∘A" "<-" "!"open_constr(lem) :=erewriteoA<- !lem.Tactic Notation"erewrite∘A" "->" "?"open_constr(lem) :=erewriteoA-> ?lem.Tactic Notation"erewrite∘A" "<-" "?"open_constr(lem) :=erewriteoA<- ?lem.EndCompose.ModuleExportConcat.Rewriting modulo associativity of concatenation (@)Turns a lemma of typef=gintoforallh,h@f=h@gLtacpreconcat_anyH:=letret:=make_tac_under_binders_using_inltac:(funH=> (letH':=freshinrenameHintoH';poseproof(fundst(g:dst=_) => @ap__(funf=>g@f)__H')asH))ltac:(idtac)HinletT:=typeofretinletT':= (evalcbvbetainT)inconstr:(ret:T').Associates a path fully to the leftLtacleft_associate_concat_inH:=letrec_tac:=left_associate_concat_ininletT:=typeofHinletT':= (evalcbvbetainT)inmatchT'with|foralla: ?A, @?Pa=>letret:=constr:(funa:A=>letH':=Hainltac:(letH'':= (evalunfoldH'inH')inletret:=rec_tacH''inexactret))inletT:=typeofretinletT':= (evalcbvbetazetainT)inletret':= (evalcbvbetazetainret)inconstr:(ret':T')|context[@concat?A1?x1?y1?z1?a(@concat?A2?x2?y2?z2?b?c)] =>(lazymatchevalpattern(@concatA1x1y1z1a(@concatA2x2y2z2bc))inT'with| ?P_=>letH':=constr:(transportP(concat_p_ppabc)H)inrec_tacH'end)| ?T'=>constr:(H:T')end.We really should just usesetoid_rewrite->!concat_p_pphere, to take care of binders, but we threw away Setoids.Ltacleft_associate_concat:=repeatmatchgoalwith|_=>rewrite-> !concat_p_pp| [ |-foralla: ?A,_] =>letH:=freshinintroH;left_associate_concat;revertHend.Ltacleft_associate_concat_in_hypH:=letH':=freshinrenameHintoH';letH_rep:=left_associate_concat_inH'inposeproofH_repasH;clearH'.Tactic Notation"rewrite@A"constr(lem) :=rewriteA_using_helperltac:(funlem'=>rewritelem')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "->"constr(lem) :=rewriteA_using_helperltac:(funlem'=>rewrite->lem')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "<-"constr(lem) :=rewriteA_using_helperltac:(funlem'=>rewrite<-lem')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progressrewrite?lem', ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>rewrite?lem', ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "->" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progressrewrite-> ?lem', -> ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "<-" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progressrewrite<- ?lem', <- ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "->" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>rewrite-> ?lem', -> ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite@A" "<-" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>rewrite<- ?lem', <- ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A"constr(lem) :=rewriteA_using_helperltac:(funlem'=>erewritelem')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "->"constr(lem) :=rewriteA_using_helperltac:(funlem'=>erewrite->lem')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "<-"constr(lem) :=rewriteA_using_helperltac:(funlem'=>erewrite<-lem')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progresserewrite?lem', ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>erewrite?lem', ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "->" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progresserewrite-> ?lem', -> ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "<-" "!"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>progresserewrite<- ?lem', <- ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "->" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>erewrite-> ?lem', -> ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"erewrite@A" "<-" "?"constr(lem) :=repeat_rewriteA_using_helperltac:(funlem'lem''=>erewrite<- ?lem', <- ?lem'')lemltac:(preconcat_any)ltac:(left_associate_concat)ltac:(left_associate_concat_in_hyp).Tactic Notation"rewrite•A"constr(lem) :=rewrite@Alem.Tactic Notation"rewrite•A" "->"constr(lem) :=rewrite@A->lem.Tactic Notation"rewrite•A" "<-"constr(lem) :=rewrite@A<-lem.Tactic Notation"rewrite•A" "!"constr(lem) :=rewrite@A!lem.Tactic Notation"rewrite•A" "?"constr(lem) :=rewrite@A?lem.Tactic Notation"rewrite•A" "->" "!"constr(lem) :=rewrite@A-> !lem.Tactic Notation"rewrite•A" "<-" "!"constr(lem) :=rewrite@A<- !lem.Tactic Notation"rewrite•A" "->" "?"constr(lem) :=rewrite@A-> ?lem.Tactic Notation"rewrite•A" "<-" "?"constr(lem) :=rewrite@A<- ?lem.Tactic Notation"erewrite•A"open_constr(lem) :=erewrite@Alem.Tactic Notation"erewrite•A" "->"open_constr(lem) :=erewrite@A->lem.Tactic Notation"erewrite•A" "<-"open_constr(lem) :=erewrite@A<-lem.Tactic Notation"erewrite•A" "!"open_constr(lem) :=erewrite@A!lem.Tactic Notation"erewrite•A" "?"open_constr(lem) :=erewrite@A?lem.Tactic Notation"erewrite•A" "->" "!"open_constr(lem) :=erewrite@A-> !lem.Tactic Notation"erewrite•A" "<-" "!"open_constr(lem) :=erewrite@A<- !lem.Tactic Notation"erewrite•A" "->" "?"open_constr(lem) :=erewrite@A-> ?lem.Tactic Notation"erewrite•A" "<-" "?"open_constr(lem) :=erewrite@A<- ?lem.EndConcat.Sectionexamples.Sectioncompose.Examplesimple_01{A} (fghij:A->A) :fog=h-> (iof)o(goj) =iohoj.Proof.introH.rewrite∘AH.reflexivity.Abort.Examplesimple_02{A} (fghij:A->A) :fog=h-> (iof)o(gofogoj) =iohohoj.Proof.introH.rewrite∘A!H.reflexivity.Abort.Endcompose.Sectionconcat.Examplesimple_01{A} {a:A} (fghij:a=a) :f@g=h-> (i@f) @ (g@j) =i@h@j.Proof.introH.rewrite@AH.reflexivity.Abort.Examplesimple_02{A} {a:A} (fghij:A=A) :f@g=h-> (i@f) @ (g@f@g@j) =i@h@h@j.Proof.introH.rewrite@A!H.reflexivity.Abort.Endconcat.Endexamples.

--- Miscellaneous\Rigid.html ---
RigidLibrary RigidRequireImportHoTT.BasicsHoTT.Types.RequireImportHFiber.RequireImportTruncations.RequireImportUniverses.BAut.Local OpenScopetrunc_scope.Local OpenScopepath_scope.Rigid typesClassIsRigid(A:Type) :=path_aut_rigid:forallfg:A<~>A,f==g.Assuming funext, rigidity is equivalent to contractibility ofA<~>A.Global Instancecontr_aut_rigid`{Funext} (A:Type) `{IsRigidA}:Contr(A<~>A).Proof.apply(Build_Contr_equiv_idmap).introsf;applypath_equiv,path_arrow,path_aut_rigid.Defined.Assuming univalence, rigidity is equivalent to contractibility ofBAutA.Global Instancecontr_baut_rigid`{Univalence} {A:Type} `{IsRigidA}:Contr(BAutA).Proof.refine(contr_change_center(point(BAutA))).refine(contr_trunc_conn(Tr0)).applyistrunc_S.introsZW;baut_reduce.refine(istrunc_equiv_istrunc(n:= -1) (A<~>A)(path_baut(point(BAutA)) (point(BAutA)))).Defined.Definitionrigid_contr_Baut`{Univalence} {A:Type} `{Contr(BAutA)}:IsRigidA.Proof.unfoldIsRigid.equiv_intro((path_baut(point(BAutA)) (point(BAutA)))^-1)f.equiv_intro((path_baut(point(BAutA)) (point(BAutA)))^-1)g.applyap10,ap,ap,path_contr.Defined.HProps are rigidGlobal Instancerigid_ishprop(A:Type) `{IsHPropA} :IsRigidA.Proof.introsfgx;applypath_ishprop.Defined.Equivalences of BAutUnder a truncatedness/connectedness assumption, multiplying by a rigid type doesn't change the automorphism oo-group.A lemma: a "monoid homomorphism up to homotopy" between endomorphism monoids restricts to automorphism groups.Definitionaut_homomorphism_end`{Funext} {XY:Type}(M: (X->X) -> (Y->Y))(Mid:Midmap==idmap)(MC:forallfg,M(gof) ==MgoMf): (X<~>X) -> (Y<~>Y).Proof.assert(MS:forallfg,gof==idmap-> (Mg)o(Mf) ==idmap).{introsgfsx.transitivity(M(fog)x).+symmetry.refine(MCgfx).+transitivity(Midmapx).*applyap10,ap,path_arrow.introsy;applys.*applyMid. }assert(ME: (forallf,IsEquivf->IsEquiv(Mf))).{introsf?.refine(isequiv_adjointify(Mf) (Mf^-1)__);applyMS; [applyeisretr|applyeissect]. }exact(funf=> (Build_Equiv__(Mf) (MEf_))).Defined.Definitionbaut_prod_rigid_equiv`{Univalence}(XA:Type) (n:trunc_index)`{IsTruncn.+1X} `{IsRigidA} `{IsConnectedn.+1A}:BAutX<~>BAut(X*A).Proof.refine(Build_Equiv__(baut_prod_rXA)_).applyisequiv_surj_emb.{applyBuildIsSurjection;introsZ.baut_reduce.refine(tr(point_;_)).applypath_sigma_hprop;reflexivity. }{applyisembedding_isequiv_ap.introsZW.pose(L:=fune:Z<~>W=>equiv_functor_prod_r(B:=A)e).refine(isequiv_commsqL(ap(baut_prod_rXA))(path_bautZW)(path_baut(baut_prod_rXAZ) (baut_prod_rXAW))(fune=> (ap_baut_prod_rXAe)^)).refine((isconnected_elim(Tr(-1)) (A:=A)__).1).{applycontr_inhabited_hprop;[exact_|refine(merely_isconnectednA) ]. }introsa0.baut_reduce.pose(M:=funf:X*A->X*A=>funx=>fst(f(x,a0))).assert(MH:forall(a:A) (f:X*A->X*A) (x:X),fst(f(x,a)) =fst(f(x,a0))).{refine(conn_map_elim(Trn) (unit_namea0)__).intros;reflexivity. }assert(MC:forall(fg:X*A->X*A),M(gof) ==MgoMf).{introsfgx;unfoldM.transitivity(fst(g(fst(f(x,a0)),snd(f(x,a0))))).-reflexivity.-applyMH. }pose(M':=aut_homomorphism_endM(funx=> 1)MC).assert(Mker:forallf,M'f== 1%equiv->f== 1%equiv).{unfoldM',M;cbn.introsfp.pose(fh:=funxa=> (MHafx) @px).pose(g:=funxa=>snd(f(x,a))).assert(ge:forallx,IsEquiv(gx)).{applyisequiv_from_functor_sigma.refine(isequiv_commsq'_f(equiv_sigma_prod0XA) (equiv_sigma_prod0XA)_).intros[xa];cbn.applypath_prod; [applyfh|reflexivity]. }intros[xa].pose(gisid:=path_aut_rigid(Build_Equiv__(gx) (gex)) 1).applypath_prod.-applyfh.-applygisid. }assert(Minj:forallfg,M'f==M'g->f==g).{introsfgpz.applymoveL_equiv_M.revertz.refine(Mker(g^-1oEf)_).introsx.refine(MCfg^-1x@_).change((M'g)^-1 (Mfx) =x).applymoveR_equiv_V,p. }refine(isequiv_adjointifyLM'__);introse;applypath_equiv,path_arrow;tryapplyMinj;introsx;reflexivity. }Defined.

--- Miscellaneous\Ring.html ---
RingLibrary RingRequireImportWildCat.RequireImportSpaces.Nat.CoreSpaces.Nat.Arithmetic.(* Some of the material in abstract_algebra and canonical names could be selectively exported to the user, as is done in Groups/Group.v. *)RequireImportClasses.interfaces.abstract_algebra.RequireImportAlgebra.Groups.GroupAlgebra.Groups.Subgroup.RequireExportAlgebra.AbGroups.RequireExportClasses.theory.rings.RequireImportModalities.ReflectiveSubuniverse.RingsDeclare Scopering_scope.Local OpenScopering_scope.We want to print equivalences as≅.Local OpenScopewc_iso_scope.A ring consists of the following data:RecordRing:=Build_Ring'{An underlying abelian group.ring_abgroup:>AbGroup;A multiplication operation.ring_mult::Multring_abgroup;A multiplicative identity calledone.ring_one::Onering_abgroup;Such that all they all satisfy the axioms of a ring.ring_isring::IsRingring_abgroup;This field only exists so that opposite rings are definitionally involutive and can safely be ignored.ring_mult_assoc_opp:forallzyx, (x*y) *z=x* (y*z);}.Argumentsring_mult{R} :rename.Argumentsring_one{R} :rename.Argumentsring_isring{R} :rename.Definitionissig_Ring:_<~>Ring:=ltac:(issig).Global Instancering_plus{R:Ring} :PlusR:=plus_abgroup(ring_abgroupR).Global Instancering_zero{R:Ring} :ZeroR:=zero_abgroup(ring_abgroupR).Global Instancering_negate{R:Ring} :NegateR:=negate_abgroup(ring_abgroupR).A ring homomorphism between rings is a map of the underlying type and a proof that this map is a ring homomorphism.RecordRingHomomorphism(AB:Ring) := {rng_homo_map:>A->B;rng_homo_ishomo::IsSemiRingPreservingrng_homo_map;}.ArgumentsBuild_RingHomomorphism{__}__.Definitionissig_RingHomomorphism(AB:Ring):_<~>RingHomomorphismAB:=ltac:(issig).Definitionequiv_path_ringhomomorphism`{Funext} {AB:Ring}{fg:RingHomomorphismAB} :f==g<~>f=g.Proof.refine((equiv_ap(issig_RingHomomorphismAB)^-1__)^-1oE_).refine(equiv_path_sigma_hprop__oE_).applyequiv_path_forall.Defined.Definitionrng_homo_id(A:Ring) :RingHomomorphismAA:=Build_RingHomomorphismidmap(Build_IsSemiRingPreserving___).Definitionrng_homo_compose{ABC:Ring}(f:RingHomomorphismBC) (g:RingHomomorphismAB):RingHomomorphismAC.Proof.snrapplyBuild_RingHomomorphism.1:exact(fog).rapplycompose_sr_morphism.Defined.Ring lawsSectionRingLaws.Many of these ring laws have already been proven. But we give them names here so that they are easy to find and use.Context{A:Ring} (xyz:A).Definitionrng_dist_l:x* (y+z) =x*y+x*z:=simple_distribute_l___.Definitionrng_dist_r: (x+y) *z=x*z+y*z:=simple_distribute_r___.Definitionrng_plus_zero_l: 0 +x=x:=left_identity_.Definitionrng_plus_zero_r:x+ 0 =x:=right_identity_.Definitionrng_plus_negate_l: (-x) +x= 0 :=left_inverse_.Definitionrng_plus_negate_r:x+ (-x) = 0 :=right_inverse_.Definitionrng_plus_comm:x+y=y+x:=commutativityxy.Definitionrng_plus_assoc:x+ (y+z) = (x+y) +z:=simple_associativityxyz.Definitionrng_mult_assoc:x* (y*z) = (x*y) *z:=simple_associativityxyz.Definitionrng_negate_negate: - (-x) =x:=groups.negate_involutive_.Definitionrng_negate_zero: - (0 :A) = 0 :=groups.negate_mon_unit.Definitionrng_negate_plus: - (x+y) = -x-y:=negate_plus_distr__.Definitionrng_mult_one_l: 1 *x=x:=left_identity_.Definitionrng_mult_one_r:x* 1 =x:=right_identity_.Definitionrng_mult_zero_l: 0 *x= 0 :=left_absorb_.Definitionrng_mult_zero_r:x* 0 = 0 :=right_absorb_.Definitionrng_mult_negate: -1 *x= -x:= (negate_mult_l_)^.Definitionrng_mult_negate_negate: -x* -y=x*y:=negate_mult_negate__.Definitionrng_mult_negate_l: -x*y= -(x*y) :=inverse(negate_mult_distr_l__).Definitionrng_mult_negate_r:x* -y= -(x*y) :=inverse(negate_mult_distr_r__).EndRingLaws.Definitionrng_dist_l_negate{A:Ring} (xyz:A):x* (y-z) =x*y-x*z.Proof.lhsnrapplyrng_dist_l.nrapplyap.nrapplyrng_mult_negate_r.Defined.Definitionrng_dist_r_negate{A:Ring} (xyz:A): (x-y) *z=x*z-y*z.Proof.lhsnrapplyrng_dist_r.nrapplyap.nrapplyrng_mult_negate_l.Defined.SectionRingHomoLaws.Context{AB:Ring} (f:RingHomomorphismAB) (xy:A).Definitionrng_homo_plus:f(x+y) =fx+fy:=preserves_plusxy.Definitionrng_homo_mult:f(x*y) =fx*fy:=preserves_multxy.Definitionrng_homo_zero:f0 = 0 :=preserves_0.Definitionrng_homo_one:f1 = 1 :=preserves_1.Definitionrng_homo_negate:f(-x) = -(fx) :=preserves_negatex.Definitionrng_homo_minus_one:f(-1) = -1:=preserves_negate1%mc@apnegatepreserves_1.EndRingHomoLaws.Isomorphisms of commutative ringsRecordRingIsomorphism(AB:Ring) := {rng_iso_homo:RingHomomorphismAB;isequiv_rng_iso_homo:IsEquivrng_iso_homo;}.Argumentsrng_iso_homo{__}.Coercionrng_iso_homo:RingIsomorphism>->RingHomomorphism.Global Existing Instanceisequiv_rng_iso_homo.Definitionissig_RingIsomorphism{AB:Ring}:_<~>RingIsomorphismAB:=ltac:(issig).We can construct a ring isomorphism from an equivalence that preserves addition and multiplication.DefinitionBuild_RingIsomorphism'(AB:Ring) (e:A<~>B)`{!IsSemiRingPreservinge}:RingIsomorphismAB:=Build_RingIsomorphismAB(Build_RingHomomorphisme_)_.The inverse of a Ring isomorphismDefinitionrng_iso_inverse{AB:Ring}:RingIsomorphismAB->RingIsomorphismBA.Proof.intros[fe].snrapplyBuild_RingIsomorphism.{snrapplyBuild_RingHomomorphism.1:exactf^-1.exact_. }exact_.Defined.Ring isomorphisms are a reflexive relationGlobal Instancereflexive_ringisomorphism:ReflexiveRingIsomorphism:=funx=>Build_RingIsomorphism__(rng_homo_idx)_.Ring isomorphisms are a symmetric relationGlobal Instancesymmetry_ringisomorphism:SymmetricRingIsomorphism:=funxy=>rng_iso_inverse.Ring isomorphisms are a transitive relationGlobal Instancetransitive_ringisomorphism:TransitiveRingIsomorphism:=funxyzfg=>Build_RingIsomorphism__(rng_homo_composegf)_.Underlying group homomorphism of a ring homomorphismDefinitiongrp_homo_rng_homo{RS:Ring}:RingHomomorphismRS->GroupHomomorphismRS:=funf=> @Build_GroupHomomorphismRSf_.Coerciongrp_homo_rng_homo:RingHomomorphism>->GroupHomomorphism.We can construct a ring homomorphism from a group homomorphism that preserves multiplicationDefinitionBuild_RingHomomorphism'(AB:Ring) (map:GroupHomomorphismAB){H:IsMonoidPreserving(Aop:=ring_mult) (Bop:=ring_mult)(Aunit:=one) (Bunit:=one)map}:RingHomomorphismAB:=Build_RingHomomorphismmap(Build_IsSemiRingPreserving_(ismonoidpreserving_grp_homomap)H).We can construct a ring isomorphism from a group isomorphism that preserves multiplicationDefinitionBuild_RingIsomorphism''(AB:Ring) (e:GroupIsomorphismAB){H:IsMonoidPreserving(Aop:=ring_mult) (Bop:=ring_mult) (Aunit:=one) (Bunit:=one)e}:RingIsomorphismAB:= @Build_RingIsomorphism'ABe(Build_IsSemiRingPreservinge_H).Here is an alternative way to build a ring using the underlying abelian group.DefinitionBuild_Ring(R:AbGroup)`(MultR,OneR, !Associative(.*.),!LeftDistribute(.*.) (+), !RightDistribute(.*.) (+),!LeftIdentity(.*.) 1, !RightIdentity(.*.) 1):Ring.Proof.rapply(Build_Ring'R).2:exact(funzyx=> (associativityxyz)^).split;only1,3,4:exact_.repeatsplit;exact_.Defined.Scalar multiplication on the left is a group homomorphism.Definitiongrp_homo_rng_left_mult{R:Ring} (r:R):GroupHomomorphismRR:= @Build_GroupHomomorphismRR(funs=>r*s) (rng_dist_lr).Scalar multiplication on the right is a group homomorphism.Definitiongrp_homo_rng_right_mult{R:Ring} (r:R):GroupHomomorphismRR:= @Build_GroupHomomorphismRR(funs=>s*r) (funxy=>rng_dist_rxyr).Ring movement lemmasSectionRingMovement.We adopt a similar naming convention to themoveR_equivstyle lemmas that can be found in Types.Paths.Context{R:Ring} {xyz:R}.Definitionrng_moveL_Mr: -y+x=z<~>x=y+z:= @grp_moveL_MgRxyz.Definitionrng_moveL_rM:x+ -z=y<~>x=y+z:= @grp_moveL_gMRxyz.Definitionrng_moveR_Mr:y= -x+z<~>x+y=z:= @grp_moveR_MgRxyz.Definitionrng_moveR_rM:x=z+ -y<~>x+y=z:= @grp_moveR_gMRxyz.Definitionrng_moveL_Vr:x+y=z<~>y= -x+z:= @grp_moveL_VgRxyz.Definitionrng_moveL_rV:x+y=z<~>x=z+ -y:= @grp_moveL_gVRxyz.Definitionrng_moveR_Vr:x=y+z<~> -y+x=z:= @grp_moveR_VgRxyz.Definitionrng_moveR_rV:x=y+z<~>x+ -z=y:= @grp_moveR_gVRxyz.Definitionrng_moveL_M0: -y+x= 0 <~>x=y:= @grp_moveL_M1Rxy.Definitionrng_moveL_0M:x+ -y= 0 <~>x=y:= @grp_moveL_1MRxy.Definitionrng_moveR_M0: 0 = -x+y<~>x=y:= @grp_moveR_M1Rxy.Definitionrng_moveR_0M: 0 =y+ -x<~>x=y:= @grp_moveR_1MRxy.TODO: Movement laws about multEndRingMovement.Wild category of ringsGlobal Instanceisgraph_ring:IsGraphRing:=Build_IsGraph_RingHomomorphism.Global Instanceis01cat_ring:Is01CatRing:=Build_Is01Cat__rng_homo_id(@rng_homo_compose).Global Instanceis2graph_ring:Is2GraphRing:=funAB=>isgraph_induced(@rng_homo_mapAB:_-> (group_type_$->_)).Global Instanceis01cat_ringhomomorphism{AB:Ring} :Is01Cat(A$->B):=is01cat_induced(@rng_homo_mapAB).Global Instanceis0gpd_ringhomomorphism{AB:Ring} :Is0Gpd(A$->B):=is0gpd_induced(@rng_homo_mapAB).Global Instanceis0functor_postcomp_ringhomomorphism{ABC:Ring} (h:B$->C):Is0Functor(@cat_postcompRing__ABCh).Proof.applyBuild_Is0Functor.intros[f?] [g?]pa;exact(aph(pa)).Defined.Global Instanceis0functor_precomp_ringhomomorphism{ABC:Ring} (h:A$->B):Is0Functor(@cat_precompRing__ABCh).Proof.applyBuild_Is0Functor.intros[f?] [g?]pa;exact(p(ha)).Defined.Ring forms a 1-category.Global Instanceis1cat_ring:Is1CatRing.Proof.byrapplyBuild_Is1Cat.Defined.Global Instancehasmorext_ring`{Funext} :HasMorExtRing.Proof.srapplyBuild_HasMorExt.introsABfg;cbnin*.snrapply@isequiv_homotopic.1:exact(equiv_path_ringhomomorphism^-1%equiv).1:exact_.intros[];reflexivity.Defined.Global Instancehasequivs_ring:HasEquivsRing.Proof.unshelveeconstructor.+exactRingIsomorphism.+exact(funGHf=>IsEquivf).+introsGHf;exactf.+exactBuild_RingIsomorphism.+introsGH;exactrng_iso_inverse.+cbn;exact_.+reflexivity.+intros????;applyeissect.+intros????;applyeisretr.+introsGHfgpq.exact(isequiv_adjointifyfgpq).Defined.SubringsTODO: factor out this definition as a submonoid  A subring is a subgorup of the underlying abelian group of a ring that is closed under multiplication and contains1.ClassIsSubring{R:Ring} (S:R->Type) := {issubring_issubgroup::IsSubgroupS;issubring_mult{xy} :Sx->Sy->S(x*y);issubring_one:S1;}.Definitionissig_IsSubring{R:Ring} (S:R->Type):_<~>IsSubringS:=ltac:(issig).Global Instanceishprop_issubring`{Funext} {R:Ring} (S:R->Type):IsHProp(IsSubringS).Proof.exact(istrunc_equiv_istrunc_(issig_IsSubringS)).Defined.Subring criterion.DefinitionBuild_IsSubring'{R:Ring} (S:R->Type)(H:forallx,IsHProp(Sx))(H1:forallxy,Sx->Sy->S(x-y))(H2:forallxy,Sx->Sy->S(x*y))(H3:S1):IsSubringS.Proof.snrapplyBuild_IsSubring.-snrapplyBuild_IsSubgroup'.+exact_.+pose(p:=H11 1H3H3).rewriterng_plus_negate_rinp.exactp.+exactH1.-exactH2.-exactH3.Defined.RecordSubring(R:Ring) := {#[reversible=no]subring_pred:>R->Type;subring_issubring::IsSubringsubring_pred;}.DefinitionBuild_Subring''{R:Ring} (S:SubgroupR)(H1:forallxy,Sx->Sy->S(x*y))(H2:S1):SubringR.Proof.snrapply(Build_Subring_S).snrapplyBuild_IsSubring.-exact_.-exactH1.-exactH2.Defined.DefinitionBuild_Subring'{R:Ring} (S:R->Type)(H:forallx,IsHProp(Sx))(H1:forallxy,Sx->Sy->S(x-y))(H2:forallxy,Sx->Sy->S(x*y))(H3:S1):SubringR:=Build_SubringRS(Build_IsSubring'SHH1H2H3).The underlying subgroup of a subring.Coercionsubgroup_subring{R} :SubringR->SubgroupR:=funS=>Build_SubgroupRS_.The ring given by a subring.Coercionring_subring{R:Ring} (S:SubringR) :Ring.Proof.snrapply(Build_Ring(subgroup_subringS)).3-7:hnf;intros;srapplypath_sigma_hprop.-intros[r?] [s?];exists(r*s).byapplyissubring_mult.-exists1.applyissubring_one.-snrapplyrng_mult_assoc.-snrapplyrng_dist_l.-snrapplyrng_dist_r.-snrapplyrng_mult_one_l.-snrapplyrng_mult_one_r.Defined.Product ringDefinitionring_product:Ring->Ring->Ring.Proof.introsRS.snrapplyBuild_Ring.-exact(ab_biprodRS).-exact(fun'(r1,s1) '(r2,s2) => (r1*r2,s1*s2)).-exact(ring_one,ring_one).-intros[r1s1] [r2s2] [r3s3].applypath_prod;cbn;applyrng_mult_assoc.-intros[r1s1] [r2s2] [r3s3].applypath_prod;cbn;applyrng_dist_l.-intros[r1s1] [r2s2] [r3s3].applypath_prod;cbn;applyrng_dist_r.-intros[r1s1];applypath_prod;cbn;applyrng_mult_one_l.-intros[r1s1];applypath_prod;cbn;applyrng_mult_one_r.Defined.Infix"×" :=ring_product:ring_scope.Definitionring_product_fst{RS:Ring} :R×S$->R.Proof.snrapplyBuild_RingHomomorphism.1:exactfst.repeatsplit.Defined.Definitionring_product_snd{RS:Ring} :R×S$->S.Proof.snrapplyBuild_RingHomomorphism.1:exactsnd.repeatsplit.Defined.Definitionring_product_corec(RST:Ring): (R$->S) -> (R$->T) -> (R$->S×T).Proof.introsfg.srapplyBuild_RingHomomorphism'.1:apply(ab_biprod_corecfg).repeatsplit.1:cbn;introsxy;applypath_prod;applyrng_homo_mult.cbn;applypath_prod;applyrng_homo_one.Defined.Definitionequiv_ring_product_corec`{Funext} (RST:Ring): (R$->S) * (R$->T) <~> (R$->S×T).Proof.snrapplyequiv_adjointify.1:exact(uncurry(ring_product_corec___)).{introsf.exact(ring_product_fst$of,ring_product_snd$of). }{hnf;introsf.byapplypath_hom. }intros[fg].applypath_prod.1,2:byapplypath_hom.Defined.Global Instancehasbinaryproducts_ring:HasBinaryProductsRing.Proof.introsRS.snrapplyBuild_BinaryProduct.-exact(R×S).-exactring_product_fst.-exactring_product_snd.-exact(funT=>ring_product_corecTRS).-cbn;reflexivity.-cbn;reflexivity.-introsTfgpqx.exact(path_prod'(px) (qx)).Defined.Image ringThe image of a ring homomorphismDefinitionrng_image{RS:Ring} (f:R$->S) :SubringS.Proof.snrapply(Build_Subring''(grp_imagef)).-simpl.introsxypq.strip_truncations;applytr.destructpas[ap'],qas[bq'].exists(a*b).refine(rng_homo_mult___@_).f_ap.-applytr.exists1.exact(rng_homo_onef).Defined.Lemmarng_homo_image_incl{RS} (f:RingHomomorphismRS): (rng_imagef:Ring) $->S.Proof.snrapplyBuild_RingHomomorphism.1:exactpr1.repeatsplit.Defined.Image of a surjective ring homomorphismLemmarng_image_issurj{RS} (f:RingHomomorphismRS) {issurj:IsSurjectionf}: (rng_imagef:Ring) ≅S.Proof.snrapplyBuild_RingIsomorphism.1:exact(rng_homo_image_inclf).exact_.Defined.Opposite RingGiven a ringRwe can reverse the order of the multiplication to get another ringR^op.Definitionrng_op:Ring->Ring.Proof.Let's carefully pull apart the ring structure and put it back together. Unfortunately, our definition of ring has some redundant data such as multiple hset assumptions, due to the mixing of algebraic strucutres. This isn't a problem in practice, but it does mean using typeclass inference here will pick up the wrong instance, therefore we carefully put it back together. See test/Algebra/Rings/Ring.v for a test checking this operation is definitionally involutive.intros[Rmultone[is_abgroup[[monoid_ishsetmult_assoc]liri]ldrd]mult_assoc_opp].snrapplyBuild_Ring'.4:split.5:split.5:split.-exactR.-exact(funxy=>multyx).-exactone.-exactis_abgroup.-exactmonoid_ishset.-exactmult_assoc_opp.-exactri.-exactli.-exact(funxyz=>rdyzx).-exact(funxyz=>ldzxy).-exactmult_assoc.Defined.The opposite ring is a functor.Global Instanceis0functor_rng_op:Is0Functorrng_op.Proof.snrapplyBuild_Is0Functor.introsRSf.snrapplyBuild_RingHomomorphism'.-exactf.-split.+exact(funxy=>rng_homo_multfyx).+exact(rng_homo_onef).Defined.Global Instanceis1functor_rng_op:Is1Functorrng_op.Proof.snrapplyBuild_Is1Functor.-introsRSfgp.exactp.-introsR;cbn;reflexivity.-introsRSTfg;cbn;reflexivity.Defined.PowersPowers of ring elementsDefinitionrng_power{R:Ring} (x:R) (n:nat) :R:=nat_itern(x*.)ring_one.Power lawsLemmarng_power_mult_law{R:Ring} (x:R) (nm:nat): (rng_powerxn) * (rng_powerxm) =rng_powerx(n+m).Proof.inductionnas[|nIHn].1:applyrng_mult_one_l.refine((rng_mult_assoc___)^ @_).exact(ap(x*.)IHn).Defined.Finite SumsRing multiplication distributes over finite sums on the left.Definitionrng_sum_dist_l{R:Ring} (n:nat) (f:forallk, (k<n)%nat->R) (r:R):r*ab_sumnf=ab_sumn(funkHk=>r*fkHk).Proof.inductionnas[|nIHn].1:applyrng_mult_zero_r.lhsnrapplyrng_dist_l;simpl;f_ap.Defined.Ring multiplication distributes over finite sums on the right.Definitionrng_sum_dist_r{R:Ring} (n:nat) (f:forallk, (k<n)%nat->R) (r:R):ab_sumnf*r=ab_sumn(funkHk=>fkHk*r).Proof.inductionnas[|nIHn].1:applyrng_mult_zero_l.lhsnrapplyrng_dist_r;simpl;f_ap.Defined.Invertible elementsAn elementxof a ringRis left invertible if there exists an elementysuch thaty*x=1.ClassIsLeftInvertible(R:Ring) (x:R) := {left_inverse_elem:R;left_inverse_eq:left_inverse_elem*x= 1;}.Argumentsleft_inverse_elem{R}x{_}.Argumentsleft_inverse_eq{R}x{_}.Definitionissig_IsLeftInvertible{R:Ring} (x:R):_<~>IsLeftInvertibleRx:=ltac:(issig).An elementxof a ringRis right invertible if there exists an elementysuch thatx*y=1. We state this as a left invertible element of the opposite ring.ClassIsRightInvertible(R:Ring) (x:R):=isleftinvertible_rng_op::IsLeftInvertible(rng_opR)x.Definitionright_inverse_elem{R}x`{!IsRightInvertibleRx} :R:=left_inverse_elem(R:=rng_opR)x.Definitionright_inverse_eq{R}x`{!IsRightInvertibleRx}:x*right_inverse_elemx= 1:=left_inverse_eq(R:=rng_opR)x.An elementxof a ringRis invertible if it is both left and right invertible.ClassIsInvertible(R:Ring) (x:R) :=Build_IsInvertible'{isleftinvertible_isinvertible::IsLeftInvertibleRx;isrightinvertible_isinvertible::IsRightInvertibleRx;}.We can show an element is invertible by providing an inverse element which is a left and right inverse similtaneously. We will later show that the two inverses of an invertible element must be equal anyway.DefinitionBuild_IsInvertible{R:Ring} (x:R)(inv:R) (inv_l:inv*x= 1) (inv_r:x*inv= 1):IsInvertibleRx.Proof.split.-byexistsinv.-unfoldIsRightInvertible.byexists(inv:rng_opR).Defined.The invertible elements inRandrng_opRagree, by swapping the proofs of left and right invertibility.Definitionisinvertible_rng_op(R:Ring) (x:R) `{!IsInvertibleRx}:IsInvertible(rng_opR)x.Proof.split.-exact(isrightinvertible_isinvertible).-exact(isleftinvertible_isinvertible).Defined.Uniqueness of inversesThis general lemma will be used for uniqueness results.Definitionpath_left_right_inverse{R:Ring} (xx'x'':R)(p:x'*x= 1) (q:x*x''= 1):x'=x''.Proof.rhs_Vnrapplyrng_mult_one_l.rewrite<-p.rewrite<-simple_associativity.rewriteq.symmetry.applyrng_mult_one_r.Defined.The left and right inverse of an invertible element are necessarily equal.Definitionpath_left_inverse_elem_right_inverse_elem{R:Ring}x`{!IsInvertibleRx}:left_inverse_elemx=right_inverse_elemx.Proof.nrapply(path_left_right_inversex).-applyleft_inverse_eq.-applyright_inverse_eq.Defined.It is therefore well-defined to talk about the inverse of an invertible element.Definitioninverse_elem{R:Ring} (x:R) `{IsInvertibleRx} :R:=left_inverse_elemx.Left cancellation for an invertible element.Definitionrng_inv_l{R:Ring} (x:R) `{IsInvertibleRx}:inverse_elemx*x= 1.Proof.applyleft_inverse_eq.Defined.Right cancellation for an invertible element.Definitionrng_inv_r{R:Ring} (x:R) `{IsInvertibleRx}:x*inverse_elemx= 1.Proof.rhs_Vnrapply(right_inverse_eqx).f_ap.applypath_left_inverse_elem_right_inverse_elem.Defined.Equal elements have equal inverses.  Note that we don't require that the proofs of invertibility are equal (overp).  It follows that the inverse of an invertible elementxdepends only onx.Definitionisinvertible_unique{R:Ring} (xy:R) `{IsInvertibleRx} `{IsInvertibleRy} (p:x=y):inverse_elemx=inverse_elemy.Proof.destructp.snrapply(path_left_right_inversex).-applyrng_inv_l.-applyrng_inv_r.Defined.We can show that being invertible is equivalent to having an inverse element that is simultaneously a left and right inverse.Definitionequiv_isinvertible_left_right_inverse{R:Ring} (x:R): {inv:R&prod(inv*x= 1) (x*inv= 1)} <~>IsInvertibleRx.Proof.equiv_via{i:IsInvertibleRx&right_inverse_elemx=left_inverse_elemx}.1:make_equiv_contr_basedpaths.applyequiv_sigma_contr;introi.rapplycontr_inhabited_hprop.symmetry;applypath_left_inverse_elem_right_inverse_elem.Defined.Being invertible is a proposition.Global Instanceishprop_isinvertible{Rx} :IsHProp(IsInvertibleRx).Proof.nrapply(istrunc_equiv_istrunc_(equiv_isinvertible_left_right_inversex)).snrapplyhprop_allpath;intros[y[p1p2]] [z[q1q2]].rapplypath_sigma_hprop;cbn.exact(path_left_right_inversexyzp1q2).Defined.Closure of invertible elements under multiplicationLeft invertible elements are closed under multiplication.Global Instanceisleftinvertible_mult{R:Ring} (xy:R):IsLeftInvertibleRx->IsLeftInvertibleRy->IsLeftInvertibleR(x*y).Proof.intros[x'p] [y'q].exists(y'*x').rhs_Vnrapplyq.lhsnrapplyrng_mult_assoc.f_ap.rhs_Vnrapplyrng_mult_one_r.lhs_Vnrapplyrng_mult_assoc.f_ap.Defined.Right invertible elements are closed under multiplication.Global Instanceisrightinvertible_mult{R:Ring} (xy:R):IsRightInvertibleRx->IsRightInvertibleRy->IsRightInvertibleR(x*y).Proof.change(x*y)with(ring_mult(R:=rng_opR)yx).unfoldIsRightInvertible.exact_.Defined.Invertible elements are closed under multiplication.Global Instanceisinvertible_mult{R:Ring} (xy:R):IsInvertibleRx->IsInvertibleRy->IsInvertibleR(x*y):= {}.Left invertible elements are closed under negation.Global Instanceisleftinvertible_neg{R:Ring} (x:R):IsLeftInvertibleRx->IsLeftInvertibleR(-x).Proof.introsH.exists(-left_inverse_elemx).lhsnrapplyrng_mult_negate_negate.applyleft_inverse_eq.Defined.Right invertible elements are closed under negation.Global Instanceisrightinvertible_neg{R:Ring} (x:R):IsRightInvertibleRx->IsRightInvertibleR(-x).Proof.introsH.rapplyisleftinvertible_neg.Defined.Invertible elements are closed under negation.Global Instanceisinvertible_neg{R:Ring} (x:R):IsInvertibleRx->IsInvertibleR(-x):= {}.Inverses of left invertible elements are themselves right invertible.Global Instanceisrightinvertible_left_inverse_elem{R:Ring} (x:R)`{IsLeftInvertibleRx}:IsRightInvertibleR(left_inverse_elemx).Proof.exists(x:rng_opR).exact(left_inverse_eqx).Defined.Inverses of right invertible elements are themselves left invertible.Global Instanceisleftinvertible_right_inverse_elem{R:Ring} (x:R)`{IsRightInvertibleRx}:IsLeftInvertibleR(right_inverse_elemx).Proof.existsx.exact(right_inverse_eqx).Defined.Inverses of invertible elements are themselves invertible.  We take both inverses ofinverse_elemxto bex.Global Instanceisinvertible_inverse_elem{R:Ring} (x:R)`{IsInvertibleRx}:IsInvertibleR(inverse_elemx).Proof.split.-existsx;applyrng_inv_r.-applyisrightinvertible_left_inverse_elem.Defined.Sinceinverse_elem(inverse_elemx)=x, we get the following equivalence.Definitionequiv_path_inverse_elem{R:Ring} {xy:R}`{IsInvertibleRx,IsInvertibleRy}:x=y<~>inverse_elemx=inverse_elemy.Proof.srapplyequiv_iff_hprop.-exact(isinvertible_uniquexy).-exact(isinvertible_unique(inverse_elemx) (inverse_elemy)).Defined.1is always invertible, and by the above-1.Global Instanceisinvertible_one{R} :IsInvertibleR1.Proof.snrapplyBuild_IsInvertible.-exactone.-applyrng_mult_one_l.-applyrng_mult_one_l.Defined.Ring homomorphisms preserve invertible elements.Global Instanceisinvertible_rng_homo{RS} (f:R$->S):forallx,IsInvertibleRx->IsInvertibleS(fx).Proof.introsxH.snrapplyBuild_IsInvertible.1:exact(f(inverse_elemx)).1,2:lhs_Vnrapplyrng_homo_mult.1,2:rhs_Vnrapply(rng_homo_onef).1,2:nrapply(apf).-exact(rng_inv_lx).-exact(rng_inv_rx).Defined.Group of unitsInvertible elements are typically called "units" in ring theory and the collection of units forms a group under the ring multiplication.Definitionrng_unit_group(R:Ring) :Group.Proof.TODO: Use a generalised version ofBuild_Subgroupthat works for subgroups of monoids.snrapplyBuild_Group.-exact{x:R&IsInvertibleRx}.-intros[xp] [yq].exists(x*y).exact_.-exists1.exact_.-intros[xp].exists(inverse_elemx).exact_.-repeatsplit.1:exact_.1-5:hnf;intros;applypath_sigma_hprop.+rapplysimple_associativity.+rapplyleft_identity.+rapplyright_identity.+applyrng_inv_l.+applyrng_inv_r.Defined.Multiplication by an invertible element is an equivalenceGlobal Instanceisequiv_rng_inv_mult_l{R:Ring} {x:R}`{IsInvertibleRx}:IsEquiv(x*.).Proof.snrapplyisequiv_adjointify.1:exact(inverse_elemx*.).1,2:introsy.1,2:lhsnrapplyrng_mult_assoc.1,2:rhs_Vnrapplyrng_mult_one_l.1,2:snrapply(ap(.*y)).-nrapplyrng_inv_r.-nrapplyrng_inv_l.Defined.This can be proved by combiningisequiv_rng_inv_mult_l(R:=rng_opR)withisinvertible_rng_op, but then the inverse map is given by multiplying byright_inverse_elemxnotinverse_elemx, which complicates calculations.Global Instanceisequiv_rng_inv_mult_r{R:Ring} {x:R}`{IsInvertibleRx}:IsEquiv(.*x).Proof.snrapplyisequiv_adjointify.1:exact(.*inverse_elemx).1,2:introsy.1,2:lhs_Vnrapplyrng_mult_assoc.1,2:rhs_Vnrapplyrng_mult_one_r.1,2:snrapply(ap(y*.)).-nrapplyrng_inv_l.-nrapplyrng_inv_r.Defined.Invertible element movement lemmasThese cannot be proven using the corresponding group laws in the group of units since not all elements involved are invertible.Definitionrng_inv_moveL_Vr{R:Ring} {xyz:R} `{IsInvertibleRy}:y*x=z<~>x=inverse_elemy*z:=equiv_moveL_equiv_V(f:= (y*.))zx.Definitionrng_inv_moveL_rV{R:Ring} {xyz:R} `{IsInvertibleRy}:x*y=z<~>x=z*inverse_elemy:=equiv_moveL_equiv_V(f:= (.*y))zx.Definitionrng_inv_moveR_Vr{R:Ring} {xyz:R} `{IsInvertibleRy}:x=y*z<~>inverse_elemy*x=z:=equiv_moveR_equiv_V(f:= (y*.))xz.Definitionrng_inv_moveR_rV{R:Ring} {xyz:R} `{IsInvertibleRy}:x=z*y<~>x*inverse_elemy=z:=equiv_moveR_equiv_V(f:= (.*y))xz.TODO: The group of units construction is a functor fromRing->Groupand is right adjoint to the group ring construction.

--- Miscellaneous\ring_pol.html ---
ring_polLibrary ring_polRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.theory.additional_operationsHoTT.Classes.tactics.ring_quoteHoTT.Classes.theory.rings.Generalizable VariablesVlt.ImportQuoting.LocalSetUniverseMinimizationToSet.Sectioncontent.Local Existing Instancealmost_ring_semiring.Local Existing Instancealmostring_mor_sr_mor.UniverseUC.Context{C:Type@{UC} } {V:Type0}.InductivePol:Type@{UC} :=|Pconst(c:C)|PX(P:Pol) (v:V) (Q:Pol).(*Cis the scalar semiring: Z when working on rings,N on semirings, other sometimes. *)Context`{AlmostRingC} `{DecidablePathsC}.(*Vis the type of variables, ie we are defining polynomialsC[V].It has a computable compare so we can normalise polynomials. *)Context`{Trichotomy@{SetSetSet}VVlt}.(* Polynomials are supposed (at the meta level) to be in normal form:PX P v Q verifies+ P <> 0+ forall w in P, w <= v+ forall w in Q, w <  v *)FixpointPeqbPQ:Bool:=matchP,Qwith|Pconstc,Pconstd=>c=?d|PXP1vP2,PXQ1wQ2=>andb(v=?w) (andb(PeqbP1Q1) (PeqbP2Q2))|_,_=>falseend.Global InstancePeqb_instance:EqbPol:=Peqb.ArgumentsPeqb_instance__/.Global InstanceP0:canonical_names.ZeroPol:=Pconst0.Global InstanceP1:canonical_names.OnePol:=Pconst1.UniverseUR.Context{R:Type@{UR} } `{AlmostRingR}(phi:C->R) `{!AlmostRingPreservingphi}.NotationVarsV:= (V->R).Fixpointeval(vs:VarsV) (P:Pol) :R:=matchPwith|Pconstc=>phic|PXPvQ=>(evalvsP) * (vsv) + (evalvsQ)end.Lemmaandb_true:forallab:Bool,andbab=true->a=true/\b=true.Proof.intros[|] [|];simpl;auto.Qed.Lemmaeval_eqb':forallPQ:Pol,P=?Q=true->forallvs:VarsV,evalvsP=evalvsQ.Proof.inductionPas[c|P1IHP1vP2IHP2];destructQas[d|Q1wQ2];introsEvs;changeeqbwithPeqbinE;simplinE.-simpl.applyap.applydecide_eqb_ok;trivial.-destruct(false_ne_trueE).-destruct(false_ne_trueE).-applyandb_trueinE.destructEas[E1E2].applyandb_trueinE2.destructE2as[E2E3].simpl.applycompare_eqb_eq,tricho_compare_eqinE1.applyap011;auto.applyap011;auto.Qed.Definitioneval_eqb@{} :=ltac:(first[exacteval_eqb'@{Ularge}|exacteval_eqb']).Lemmaeval_0':forallP,P=? 0 =true->forallvs,evalvsP= 0.Proof.inductionP;simpl;introsEvs.-changeeqbwithPeqbinE;simplinE.applydecide_eqb_okinE.rewriteE.applypreserves_0.-changeeqbwithPeqbinE;simplinE.destruct(false_ne_trueE).Qed.Definitioneval_0@{} :=ltac:(first[exacteval_0'@{Ularge}|exacteval_0']).FixpointaddCcP:=matchPwith|Pconstd=>Pconst(c+d)|PXPvQ=>PXPv(addCcQ)end.Lemmaeval_addCvs:forallcP,evalvs(addCcP) = (phic) +evalvsP.Proof.inductionP;simpl.-applypreserves_plus.-rewriteIHP2.rewrite2!plus_assoc.rewrite(plus_comm(phic)).reflexivity.Qed.(* c * v + Q *)FixpointaddX'cvQ:=matchQwith|Pconstd=>PX(Pconstc)vQ|PXQ1wQ2=>matchv?=wwith|LT=>PXQ1w(addX'cvQ2)|EQ=>PX(addCcQ1)vQ2|GT=>PX(Pconstc)vQendend.DefinitionaddXcvQ:=ifc=? 0thenQelseaddX'cvQ.Lemmaeval_addX'@{}vs:forallc(v:V)Q,evalvs(addX'cvQ) =phic*vsv+evalvsQ.Proof.inductionQas[d|Q1IH1wQ2IH2].-simpl.reflexivity.-simpl.poseproof(tricho_compare_eqvw)asE.destruct(v?=w);[clearE|rewrite<-Ebysplit;clearEw|clearE].+simpl.rewriteIH2.rewrite2!plus_assoc.applyap011;trivial.applyplus_comm.+simpl.rewriteeval_addC.rewriteplus_mult_distr_r.symmetry;applyplus_assoc.+simpl.reflexivity.Qed.Lemmaeval_addXvs:forallc(v:V)Q,evalvs(addXcvQ) =phic*vsv+evalvsQ.Proof.intros.unfoldaddX.poseproof(decide_eqb_okc0)asE.destruct(c=? 0).-rewrite(fstE)bysplit.rewrite(preserves_0(f:=phi)).rewritemult_0_l,plus_0_l.split.-applyeval_addX'.Qed.DefinitionPXguard@{}PvQ:=ifeqbP0thenQelsePXPvQ.Lemmaeval_PXguardvs:forallP(v:V)Q,evalvs(PXguardPvQ) =evalvsP*vsv+evalvsQ.Proof.intros.unfoldPXguard.poseproof(eval_0P)asE.destruct(P=? 0).-rewriteEbysplit.rewritemult_0_l,plus_0_l.split.-reflexivity.Qed.FixpointmulCcP:=matchPwith|Pconstd=>Pconst(c*d)|PXPvQ=>(* in some semirings we can have zero divisors, so P' might be zero *)PXguard(mulCcP)v(mulCcQ)end.Lemmaeval_mulCvs:forallcP,evalvs(mulCcP) = (phic) *evalvsP.Proof.inductionPas[d|P1IH1vP2IH2];simpl.-applypreserves_mult.-rewriteeval_PXguard.rewriteIH1,IH2,plus_mult_distr_l,mult_assoc.reflexivity.Qed.(* if P <= v, P <> 0, and addP Q = P + Q then P * v + Q *)Fixpointadd_auxaddPPvQ:=matchQwith|Pconst_=>PXPvQ|PXQ1wQ2=>matchv?=wwith|LT=>PXQ1w(add_auxaddPPvQ2)|EQ=>PXguard(addPQ1)vQ2|GT=>PXPvQendend.FixpointaddPQ:=matchPwith|Pconstc=>addCcQ|PXP1vP2=>add_aux(addP1)P1v(addP2Q)end.Lemmaeval_add_auxvsPaddP(Eadd:forallQ,evalvs(addPQ) =evalvsP+evalvsQ):forall(v:V)Q,evalvs(add_auxaddPPvQ) =evalvsP*vsv+evalvsQ.Proof.inductionQas[d|Q1IH1wQ2IH2].-simpl.reflexivity.-simpl.poseproof(tricho_compare_eqvw)asE.destruct(v?=w);[clearE|rewrite<-Ebysplit;clearEw|clearE].+simpl.rewriteIH2.rewrite2!plus_assoc.rewrite(plus_comm(evalvsQ1*vsw)).reflexivity.+rewriteeval_PXguard.rewriteEadd.rewriteplus_mult_distr_r.symmetry;applyplus_assoc.+simpl.reflexivity.Qed.Lemmaeval_add'vs:forallPQ,evalvs(addPQ) =evalvsP+evalvsQ.Proof.inductionPas[c|P1IH1vP2IH2];introsQ.-simpl.applyeval_addC.-simpl.rewriteeval_add_aux;auto.rewriteIH2.applyplus_assoc.Qed.Definitioneval_add@{} :=ltac:(first[exacteval_add'@{Ularge}|exacteval_add'@{}]).FixpointmulXvP:=matchPwith|Pconstc=>addXcv0|PXP1wP2=>matchv?=wwith|LT=>PX(mulXvP1)w(mulXvP2)|_=>PXPv0endend.Lemmaeval_mulX@{}vs:forall(v:V) (P:Pol),evalvs(mulXvP) =evalvsP*vsv.Proof.inductionPas[c|P1IH1wP2IH2].-simpl.rewriteeval_addX.simpl.rewrite(preserves_0(f:=phi)),plus_0_r.split.-simpl.poseproof(tricho_compare_eqvw)asE.destruct(v?=w);[clearE|rewrite<-Ebysplit;clearEw|clearE].+simpl.rewriteplus_mult_distr_r,IH1,IH2.applyap011;trivial.rewrite<-2!mult_assoc;applyap,mult_comm.+simpl.rewrite(preserves_0(f:=phi)),plus_0_r.reflexivity.+simpl.rewrite(preserves_0(f:=phi)),plus_0_r.reflexivity.Qed.DefinitionmkPXPvQ:=add(mulXvP)Q.Lemmaeval_mkPXvs:forallPvQ,evalvs(mkPXPvQ) = (evalvsP) * (vsv) +evalvsQ.Proof.intros.unfoldmkPX.rewriteeval_add,eval_mulX.reflexivity.Qed.FixpointmulPQ:=matchP,Qwith|Pconstc,_=>mulCcQ|_,Pconstd=>mulCdP|PXP1vP2,PXQ1wQ2=>(* P1 Q1 v w + P1 Q2 v + P2 Q1 w + P2 Q2 *)add(mulXv(add(mulXw(mulP1Q1)) (mulP1Q2)))(add(mulXw(mulP2Q1)) (mulP2Q2))end.Lemmaeval_mul'vs:forallPQ,evalvs(mulPQ) =evalvsP*evalvsQ.Proof.inductionPas[c|P1IHP1vP2IHP2];[applyeval_mulC|].destructQas[d|Q1wQ2].-change(mul(PXP1vP2) (Pconstd))with(mulCd(PXP1vP2)).rewriteeval_mulC.applymult_comm.-simpl.rewriteplus_mult_distr_r,!plus_mult_distr_l.repeat(rewriteeval_add||rewriteeval_mulX).rewriteplus_mult_distr_r,(plus_mult_distr_l(evalvsP2)).rewriteIHP1,IHP2.applyap011;applyap011.+rewrite<-!mult_assoc.applyap.rewrite(mult_comm(vsv)).applymult_assoc.+rewrite<-mult_assoc,(mult_comm(vsv)),mult_assoc.rewriteIHP1;reflexivity.+symmetry;applymult_assoc.+auto.Qed.Definitioneval_mul@{} :=ltac:(first[exacteval_mul'@{Ularge}|exacteval_mul'@{}]).FixpointtoPol(e:ExprV) :=matchewith|Varv=>PX1v0|Zero=> 0|One=> 1|Plusab=>add(toPola) (toPolb)|Multab=>mul(toPola) (toPolb)|Nega=>mulC(almost_negate1) (toPola)end.Lemmaeval_toPol@{}vs:foralle:ExprV,evalvs(toPole) =Quoting.eval_vse.Proof.inductioneas[v| | |aIHabIHb|aIHabIHb|aIHa];simpl.-rewrite(preserves_1(f:=phi)),(preserves_0(f:=phi)),plus_0_r,mult_1_l.reflexivity.-applypreserves_0.-applypreserves_1.-rewriteeval_add,IHa,IHb.reflexivity.-rewriteeval_mul,IHa,IHb.reflexivity.-rewriteeval_mulC.rewrite(almostring_mor_neg(f:=phi)),preserves_1.rewrite<-almost_ring_neg_pr.applyap,IHa.Qed.Endcontent.

--- Miscellaneous\ring_quote.html ---
ring_quoteLibrary ring_quoteRequireImportHoTT.Classes.interfaces.abstract_algebra.ClassAlmostNegateA:=almost_negate:A->A.ClassAlmostRingA{Aplus:PlusA} {Amult:MultA}{Azero:ZeroA} {Aone:OneA} {Anegate:AlmostNegateA} :={almost_ring_semiring:IsSemiCRingA;almost_ring_neg_pr:forallx:A,almost_negatex= (almost_negate1) *x}.Sectionalmostring_mor.Context{AB:Type} {Aplus:PlusA} {Bplus:PlusB}{Amult:MultA} {Bmult:MultB} {Azero:ZeroA} {Bzero:ZeroB}{Aone:OneA} {Bone:OneB} {Aneg:AlmostNegateA} {Bneg:AlmostNegateB}.ClassAlmostRingPreserving(f:A->B) :={almostring_mor_sr_mor:IsSemiRingPreservingf;almostring_mor_neg:forallx,f(almost_negatex) =almost_negate(fx) }.Endalmostring_mor.ModuleQuoting.InductiveExpr(V:Type0) :Type0:=|Var(v:V)|Zero|One|Plus(ab:ExprV)|Mult(ab:ExprV)|Neg(a:ExprV).ArgumentsVar{V}v.ArgumentsZero{V}.ArgumentsOne{V}.ArgumentsPlus{V}ab.ArgumentsMult{V}ab.ArgumentsNeg{V}a.Sectioncontents.UniverseU.Context(R:Type@{U}) `{AlmostRingR}.NotationVarsV:= (V->R).Fixpointeval{V:Type0} (vs:VarsV) (e:ExprV) :R:=matchewith|Varv=>vsv|Zero=> 0|One=> 1|Plusab=>evalvsa+evalvsb|Multab=>evalvsa*evalvsb|Nega=>almost_negate(evalvsa)end.Lemmaeval_ext{V:Type0} (vsvs':VarsV) :pointwise_paths@{SetU}vsvs'->pointwise_paths@{SetU} (evalvs) (evalvs').Proof.introsEe;inductione;simpl;auto;applyap011;auto.Qed.DefinitionnoVars:VarsEmpty.Proof.intros[].Defined.Definitionsingletonx:VarsUnit:=fun_=>x.Definitionmerge{AB:Type0} (va:VarsA) (vb:VarsB) :Vars(sum@{SetSet}AB):=funi=>matchiwithinli=>vai|inri=>vbiend.SectionLookup.ClassLookup{A:Type0} (x:R) (f:VarsA):= {lookup:A;lookup_correct:flookup=x}.Global Argumentslookup{A}xf{_}.Context(x:R) {AB:Type0} (va:VarsA) (vb:VarsB).Local Instancelookup_l`{!Lookupxva} :Lookupx(mergevavb).Proof.exists(inl(lookupxva)).applylookup_correct.Defined.Local Instancelookup_r`{!Lookupxvb} :Lookupx(mergevavb).Proof.exists(inr(lookupxvb)).applylookup_correct.Defined.Local Instancelookup_single:Lookupx(singletonx).Proof.existstt.reflexivity.Defined.EndLookup.Fixpointexpr_map{VW:Type0} (f:V->W) (e:ExprV) :ExprW:=matchewith|Varv=>Var(fv)|Zero=>Zero|One=>One|Plusab=>Plus(expr_mapfa) (expr_mapfb)|Multab=>Mult(expr_mapfa) (expr_mapfb)|Nega=>Neg(expr_mapfa)end.Lemmaeval_map{VW:Type0} (f:V->W)ve:evalv(expr_mapfe) =eval(Compose@{SetSetU}vf)e.Proof.inductione;simpl;tryreflexivity;applyap011;auto.Qed.SectionQuote.ClassQuote{V:Type0} (l:VarsV) (n:R) {V':Type0} (r:VarsV') :={quote:Expr(V|_|V');eval_quote: @eval(V|_|V') (mergelr)quote=n}.Global Argumentsquote{Vl}n{V'r_}.Global Argumentseval_quote{Vl}n{V'r_}.Definitionsum_assoc{ABC}: (A|_|B) |_|C->A|_| (B|_|C).Proof.intros[[?|?]|?];auto.Defined.Definitionsum_aux{ABC}: (A|_|B) ->A|_| (B|_|C).Proof.intros[?|?];auto.Defined.Local Instancequote_zero(V:Type0) (v:VarsV):Quotev0noVars.Proof.existsZero.reflexivity.Defined.Local Instancequote_one(V:Type0) (v:VarsV):Quotev1noVars.Proof.existsOne.reflexivity.Defined.Lemmaquote_plus_ok(V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')m(V'':Type0) (v'':VarsV'')`{!Quotevnv'} `{!Quote(mergevv')mv''}:eval(mergev(mergev'v''))(Plus(expr_mapsum_aux(quoten)) (expr_mapsum_assoc(quotem))) =n+m.Proof.simpl.rewrite<-(eval_quoten), <-(eval_quotem),2!eval_map.applyap011;applyeval_ext.-intros[?|?];reflexivity.-intros[[?|?]|?];reflexivity.Qed.Local Instancequote_plus(V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')m(V'':Type0) (v'':VarsV'')`{!Quotevnv'} `{!Quote(mergevv')mv''}:Quotev(n+m) (mergev'v'').Proof.econstructor.applyquote_plus_ok.Defined.Lemmaquote_mult_ok(V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')m(V'':Type0) (v'':VarsV'')`{!Quotevnv'} `{!Quote(mergevv')mv''}:eval(mergev(mergev'v''))(Mult(expr_mapsum_aux(quoten)) (expr_mapsum_assoc(quotem))) =n*m.Proof.simpl.rewrite<-(eval_quoten), <-(eval_quotem),2!eval_map.applyap011;applyeval_ext.-intros[?|?];reflexivity.-intros[[?|?]|?];reflexivity.Qed.Local Instancequote_mult(V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')m(V'':Type0) (v'':VarsV'')`{!Quotevnv'} `{!Quote(mergevv')mv''}:Quotev(n*m) (mergev'v'').Proof.econstructor.applyquote_mult_ok.Defined.Lemmaquote_neg_ok@{} (V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')`{!Quotevnv'}:eval(mergevv') (Neg(quoten)) =almost_negaten.Proof.simpl.applyap,eval_quote.Qed.Local Instancequote_neg(V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')`{!Quotevnv'}:Quotev(almost_negaten)v'.Proof.exists(Neg(quoten)).applyquote_neg_ok.Defined.Local Instancequote_old_var(V:Type0) (v:VarsV)x{i:Lookupxv}:QuotevxnoVars| 8.Proof.exists(Var(inl(lookupxv))).applylookup_correct.Defined.Local Instancequote_new_var(V:Type0) (v:VarsV)x:Quotevx(singletonx) | 9.Proof.exists(Var(inrtt)).reflexivity.Defined.EndQuote.Definitionquote':forallx{V':Type0} {v:VarsV'} {d:QuotenoVarsxv},Expr_:= @quote__.Definitioneval_quote':forallx{V':Type0} {v:VarsV'} {d:QuotenoVarsxv},eval(mergenoVarsv) (quotex) =x:= @eval_quote__.ClassEqQuote{V:Type0} (l:VarsV) (nm:R) {V':Type0} (r:VarsV') :={eqquote_l:ExprV;eqquote_r:Expr(V|_|V');eval_eqquote:eval(mergelr) (expr_mapinleqquote_l)=eval(mergelr)eqquote_r->n=m}.Lemmaeq_quote_ok(V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')m(V'':Type0) (v'':VarsV'')`{!Quotevnv'} `{!Quote(mergevv')mv''}:eval(mergev(mergev'v'')) (expr_mapsum_aux(quoten))=eval(mergev(mergev'v'')) (expr_mapsum_assoc(quotem))->n=m.Proof.introsE.rewrite<-(eval_quoten), <-(eval_quotem).path_via(eval(mergev(mergev'v'')) (expr_mapsum_aux(quoten)));[|path_via(eval(mergev(mergev'v'')) (expr_mapsum_assoc(quotem)))].-rewriteeval_map.applyeval_ext.intros[?|?];reflexivity.-rewriteeval_map.applyeval_ext.intros[[?|?]|?];reflexivity.Qed.Local Instanceeq_quote(V:Type0) (v:VarsV)n(V':Type0) (v':VarsV')m(V'':Type0) (v'':VarsV'')`{!Quotevnv'} `{!Quote(mergevv')mv''}:EqQuote(mergevv')nmv''.Proof.econstructor.introsE.apply(@eq_quote_ok________Quote0Quote1).etransitivity;[etransitivity;[|exactE]|].-rewrite2!eval_map.applyeval_ext.intros[?|?];reflexivity.-rewrite(eval_mapsum_assoc).applyeval_ext.intros[[?|?]|?];reflexivity.Defined.Definitionsum_forget{AB} :Empty|_|A->A|_|B.Proof.intros[[]|?];auto.Defined.Lemmaquote_equality{V:Type0} {v:VarsV}{V':Type0} {v':VarsV'} (lr:R)`{!QuotenoVarslv} `{!Quotevrv'}:letheap:= (mergevv')inevalheap(expr_mapsum_forget(quotel)) =evalheap(quoter) ->l=r.Proof.intros?E.rewrite<-(eval_quotel),<-(eval_quoter).path_via(evalheap(expr_mapsum_forget(quotel))).rewriteeval_map.applyeval_ext.intros[[]|?].reflexivity.Qed.Endcontents.ModuleExportInstances.Global Existing Instanceslookup_llookup_rlookup_singlequote_zeroquote_onequote_plusquote_multquote_negeq_quote.Global Existing Instancequote_old_var| 8.Global Existing Instancequote_new_var| 9.EndInstances.EndQuoting.

--- Miscellaneous\ring_tac.html ---
ring_tacLibrary ring_tacRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.tactics.ring_quoteHoTT.Classes.tactics.ring_polHoTT.Classes.theory.ringsHoTT.Classes.orders.sumHoTT.Classes.interfaces.naturalsHoTT.Classes.interfaces.integers.Generalizable VariablesABCRVflnmVlt.ImportQuoting.Instances.Sectioncontent.Context`{DecidablePathsC}.Context`(phi:C->R) `{AlmostRingPreservingCRphi}`{!AlmostRingC} `{!AlmostRingR}.Lemmanormalize_eq`{Q: @Quoting.EqQuoteR_____VlnmV'l'}`{TrichotomyVVlt} `{TrichotomyV'Vlt'}:evalphi(Quoting.mergeRll')(toPol(Quoting.expr_mapinl(Quoting.eqquote_lR)))=evalphi(Quoting.mergeRll') (toPol(Quoting.eqquote_rR))->n=m.Proof.introsE.eapplyQuoting.eval_eqquote.etransitivity;[symmetry;apply(eval_toPol_)|].etransitivity;[|apply(eval_toPol_)].exactE.Qed.Lemmaby_quoting`{Q: @Quoting.EqQuoteR_____VlnmV'l'}`{TrichotomyVVlt} `{TrichotomyV'Vlt'}:toPol(Quoting.expr_mapinl(@Quoting.eqquote_lR___________Q))=?toPol(@Quoting.eqquote_rR___________Q) =true->n=m.Proof.introsE.applynormalize_eq.applyeval_eqb,E.Qed.Lemmanormalize_prequoted`{TrichotomyVVlt} (ab:Quoting.ExprV)vs:evalphivs(toPola) =evalphivs(toPolb) ->Quoting.eval_vsa=Quoting.eval_vsb.Proof.rewrite!(eval_toPol_).trivial.Qed.Lemmaprove_prequoted`{TrichotomyVVlt} (ab:Quoting.ExprV)vs:toPola=?toPolb=true->Quoting.eval_vsa=Quoting.eval_vsb.Proof.intros.applynormalize_prequoted.applyeval_eqb;trivial.Qed.Endcontent.Global Instancedefault_almostneg`{ZeroA} :AlmostNegateA| 20:=fun_=> 0.Argumentsdefault_almostneg___/.Global Instancenegate_almostneg`{Aneg:NegateA} :AlmostNegateA:= (-).Argumentsnegate_almostneg___/.Global Instancesemiring_almostring`{IsSemiCRingA} :AlmostRingA| 10.Proof.split;tryapply_.intros.unfoldalmost_negate;simpl.symmetry;applymult_0_l.Qed.Global Instancering_almostring`{IsCRingA} :AlmostRingA.Proof.split;tryapply_.intros.unfoldalmost_negate;simpl.applynegate_mult_l.Qed.Global Instancesr_mor_almostring_mor`{IsSemiRingPreservingABf}:AlmostRingPreservingf| 10.Proof.split;tryapply_.unfoldalmost_negate;simpl.intros_.applypreserves_0.Qed.SectionVarSec.Context`{IsCRingA} `{IsCRingB} {f:A->B} `{!IsSemiRingPreservingf}.Global Instancering_mor_almostring_mor:AlmostRingPreservingf.Proof.split;tryapply_.unfoldalmost_negate;simpl.applypreserves_negate.Qed.EndVarSec.Argumentsnormalize_eq{C_R}phi{_______________________}_.Argumentsby_quoting{C_R}phi{_______________________}_.Ltacring_with_nat:=matchgoalwith|- @paths?R__=>((poseproof(_:IsSemiCRingR)) ||fail"target equality not on a semiring");apply(by_quoting(naturals_to_semiringnatR));reflexivityend.Ltacring_with_integersZ:=matchgoalwith|- @paths?R__=>((poseproof(_:IsCRingR)) ||fail"target equality not on a ring");apply(by_quoting(integers_to_ringZR));reflexivityend.Ltacring_with_self:=matchgoalwith|- @paths?R__=>((poseproof(_:IsSemiCRingR)) ||fail"target equality not on a ring");apply(by_quoting(@idR));reflexivityend.Ltacring_replab:=letHrw:=fresh"Hrw"inassert(Hrw:a=b);[ring_with_nat|rewriteHrw;clearHrw].Tactic Notation"ring_replace"constr(x) "with"constr(y) :=ring_replxy.

--- Miscellaneous\round.html ---
roundLibrary roundRequireImportHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.interfaces.naturalsHoTT.Classes.implementations.peano_naturals.Sectionround_up.ClassRoundUpStrictA`{IsSemiCRingA} `{StrictSemiRingOrderA}:=round_up_strict:foralla:A, {n:nat&a<naturals_to_semiringnatAn}.Global Argumentsround_up_strictA{____________}_.Endround_up.

--- Miscellaneous\semirings.html ---
semiringsLibrary semiringsRequireImportHoTT.Classes.theory.apartnessHoTT.Classes.interfaces.abstract_algebraHoTT.Classes.interfaces.ordersHoTT.Classes.theory.rings.RequireExportHoTT.Classes.orders.ordersHoTT.Classes.orders.maps.Generalizable VariablesRRltf.Sectionsemiring_order.Context`{SemiRingOrderR} `{!IsSemiCRingR}.(*   Add Ring R : (stdlib_semiring_theory R). *)Global Instanceplus_le_embed_l:forall(z:R),OrderEmbedding(+z).Proof.intro.split.-applyorder_preserving_flip.-applyorder_reflecting_flip.Qed.Global Instanceplus_ordered_cancel_l:forallz,LeftCancellation(+)z.Proof.introszxyE.apply(antisymmetry(≤));apply(order_reflecting(z+));applyeq_le;trivial.applysymmetry;trivial.Qed.Global Instanceplus_ordered_cancel_r:forallz,RightCancellation(+)z.Proof.intros.apply(right_cancel_from_left(+)).Qed.Lemmanonneg_plus_le_compat_rxz: 0 ≤z<->x≤x+z.Proof.patternxat1.apply(transport_(plus_0_rx)).split;intros.-apply(order_preserving_).trivial.-apply(order_reflecting(x+)).trivial.Qed.Lemmanonneg_plus_le_compat_lxz: 0 ≤z<->x≤z+x.Proof.rewrite(commutativity(f:=plus)).applynonneg_plus_le_compat_r.Qed.Lemmaplus_le_compatx₁y₁x₂y₂:x₁≤y₁->x₂≤y₂->x₁+x₂≤y₁+y₂.Proof.introsE1E2.transitivity(y₁+x₂).-apply(order_preserving(+x₂));trivial.-apply(order_preserving(y₁+));trivial.Qed.Lemmaplus_le_compat_rxyz: 0 ≤z->x≤y->x≤y+z.Proof.intros.rewrite<-(plus_0_rx).applyplus_le_compat;trivial.Qed.Lemmaplus_le_compat_lxyz: 0 ≤z->x≤y->x≤z+y.Proof.rewrite(commutativity(f:=plus)).applyplus_le_compat_r.Qed.Lemmanonpos_plus_compatxy:x≤ 0 ->y≤ 0 ->x+y≤ 0.Proof.intros.rewrite<-(plus_0_r0).applyplus_le_compat;trivial.Qed.Instancenonneg_plus_compat(xy:R):PropHolds(0 ≤x) ->PropHolds(0 ≤y) ->PropHolds(0 ≤x+y).Proof.intros.applyplus_le_compat_l;trivial.Qed.Lemmadecompose_le{xy} :x≤y->existsz, 0 ≤z/\y=x+z.Proof.introsE.destruct(srorder_partial_minusxyE)as[zEz].existsz.split; [|trivial].apply(order_reflecting(x+)).rewriteplus_0_r, <-Ez.trivial.Qed.Lemmacompose_lexyz: 0 ≤z->y=x+z->x≤y.Proof.introsE1E2.rewriteE2.applynonneg_plus_le_compat_r.trivial.Qed.Global Instancenonneg_mult_le_l:forall(z:R),PropHolds(0 ≤z) ->OrderPreserving(z*.).Proof.introszE.repeat(split;tryapply_).introsxyF.destruct(decompose_leF)as[a[Ea1Ea2]].rewriteEa2,plus_mult_distr_l.applynonneg_plus_le_compat_r.applynonneg_mult_compat;trivial.Qed.Global Instancenonneg_mult_le_r:forall(z:R),PropHolds(0 ≤z) ->OrderPreserving(.*z).Proof.intros.applyorder_preserving_flip.Qed.Lemmamult_le_compatx₁y₁x₂y₂:0 ≤x₁-> 0 ≤x₂->x₁≤y₁->x₂≤y₂->x₁*x₂≤y₁*y₂.Proof.introsEx₁Ey₁E1E2.transitivity(y₁*x₂).-apply(order_preserving_flip_nonneg(.*.)x₂);trivial.-apply(order_preserving_nonneg(.*.)y₁); [|trivial].transitivityx₁;trivial.Qed.Lemmage_1_mult_le_compat_rxyz: 1 ≤z-> 0 ≤y->x≤y->x≤y*z.Proof.intros.transitivityy; [trivial|].patternyat1;apply(transport_(mult_1_ry)).apply(order_preserving_nonneg(.*.)y);trivial.Qed.Lemmage_1_mult_le_compat_lxyz: 1 ≤z-> 0 ≤y->x≤y->x≤z*y.Proof.rewrite(commutativity(f:=mult)).applyge_1_mult_le_compat_r.Qed.Lemmaflip_nonpos_mult_lxyz:z≤ 0 ->x≤y->z*y≤z*x.Proof.introsEzExy.destruct(decompose_leEz)as[a[Ea1Ea2]], (decompose_leExy)as[b[Eb1Eb2]].rewriteEb2.applycompose_lewith(a*b).-applynonneg_mult_compat;trivial.-transitivity(z*x+ (z+a) *b).+rewrite<-Ea2.rewritemult_0_l,plus_0_r.reflexivity.+rewriteplus_mult_distr_r,plus_mult_distr_l.applyassociativity.Qed.Lemmaflip_nonpos_mult_rxyz:z≤ 0 ->x≤y->y*z≤x*z.Proof.rewrite2!(commutativity_z).applyflip_nonpos_mult_l.Qed.Lemmanonpos_multxy:x≤ 0 ->y≤ 0 -> 0 ≤x*y.Proof.intros.rewrite<-(mult_0_rx).applyflip_nonpos_mult_l;trivial.Qed.Lemmanonpos_nonneg_multxy:x≤ 0 -> 0 ≤y->x*y≤ 0.Proof.intros.rewrite<-(mult_0_rx).applyflip_nonpos_mult_l;trivial.Qed.Lemmanonneg_nonpos_multxy: 0 ≤x->y≤ 0 ->x*y≤ 0.Proof.intros.rewrite(commutativity(f:=mult)).applynonpos_nonneg_mult;trivial.Qed.Endsemiring_order.(* Due to bug 2528 *)#[export]HintExtern7 (PropHolds(0 ≤_+_)) =>eapply@nonneg_plus_compat:typeclass_instances.Sectionstrict_semiring_order.Context`{IsSemiCRingR} `{!StrictSemiRingOrderRlt}.(*   Add Ring Rs : (stdlib_semiring_theory R). *)Global Instanceplus_lt_embed:forall(z:R),StrictOrderEmbedding(+z).Proof.intro.split.-applystrictly_order_preserving_flip.-applystrictly_order_reflecting_flip.Qed.Lemmapos_plus_lt_compat_rxz: 0 <z<->x<x+z.Proof.patternxat1;apply(transport_(plus_0_rx)).split;intros.-apply(strictly_order_preserving_);trivial.-apply(strictly_order_reflecting(x+));trivial.Qed.Lemmapos_plus_lt_compat_lxz: 0 <z->x<z+x.Proof.rewrite(commutativity(f:=plus)).applypos_plus_lt_compat_r.Qed.Lemmaplus_lt_compatx₁y₁x₂y₂:x₁<y₁->x₂<y₂->x₁+x₂<y₁+y₂.Proof.introsE1E2.transitivity(y₁+x₂).-apply(strictly_order_preserving(+x₂));trivial.-apply(strictly_order_preserving(y₁+));trivial.Qed.Lemmaplus_lt_compat_rxyz: 0 <z->x<y->x<y+z.Proof.intros.rewrite<-(plus_0_rx).applyplus_lt_compat;trivial.Qed.Lemmaplus_lt_compat_lxyz: 0 <z->x<y->x<z+y.Proof.rewrite(commutativity(f:=plus)).applyplus_lt_compat_r.Qed.Lemmaneg_plus_compatxy:x< 0 ->y< 0 ->x+y< 0.Proof.intros.rewrite<-(plus_0_r0).applyplus_lt_compat;trivial.Qed.Instancepos_plus_compat(xy:R):PropHolds(0 <x) ->PropHolds(0 <y) ->PropHolds(0 <x+y).Proof.intros.applyplus_lt_compat_l;trivial.Qed.Lemmacompose_ltxyz: 0 <z->y=x+z->x<y.Proof.introsE1E2.rewriteE2.applypos_plus_lt_compat_r;trivial.Qed.Lemmadecompose_lt{xy} :x<y->existsz, 0 <z/\y=x+z.Proof.introsE.destruct(strict_srorder_partial_minusxyE)as[zEz].existsz.split; [|trivial].apply(strictly_order_reflecting(x+)).rewrite<-Ez,rings.plus_0_r.trivial.Qed.Global Instancepos_mult_lt_l:forall(z:R),PropHolds(0 <z) ->StrictlyOrderPreserving(z*.).Proof.introszExyF.destruct(decompose_ltF)as[a[Ea1Ea2]].rewriteEa2,plus_mult_distr_l.applypos_plus_lt_compat_r.applypos_mult_compat;trivial.Qed.Global Instancepos_mult_lt_r:forall(z:R),PropHolds(0 <z) ->StrictlyOrderPreserving(.*z).Proof.intros.applystrictly_order_preserving_flip.Qed.Lemmamult_lt_compatx₁y₁x₂y₂:0 <x₁-> 0 <x₂->x₁<y₁->x₂<y₂->x₁*x₂<y₁*y₂.Proof.introsEx₁Ey₁E1E2.transitivity(y₁*x₂).-apply(strictly_order_preserving_flip_pos(.*.)x₂);trivial.-apply(strictly_order_preserving_pos(.*.)y₁); [|trivial].transitivityx₁;trivial.Qed.Lemmagt_1_mult_lt_compat_rxyz: 1 <z-> 0 <y->x<y->x<y*z.Proof.intros.transitivityy; [trivial|].patternyat1;apply(transport_(mult_1_ry)).apply(strictly_order_preserving_pos(.*.)y);trivial.Qed.Lemmagt_1_mult_lt_compat_lxyz: 1 <z-> 0 <y->x<y->x<z*y.Proof.rewrite(commutativity(f:=mult)).applygt_1_mult_lt_compat_r.Qed.Lemmaflip_neg_mult_lxyz:z< 0 ->x<y->z*y<z*x.Proof.introsEzExy.destruct(decompose_ltEz)as[a[Ea1Ea2]], (decompose_ltExy)as[b[Eb1Eb2]].rewriteEb2.applycompose_ltwith(a*b).-applypos_mult_compat;trivial.-transitivity(z*x+ (z+a) *b).+rewrite<-Ea2.rewritemult_0_l,plus_0_r;reflexivity.+rewriteplus_mult_distr_r,plus_mult_distr_l.applyassociativity.Qed.Lemmaflip_neg_mult_rxyz:z< 0 ->x<y->y*z<x*z.Proof.rewrite2!(commutativity_z).applyflip_neg_mult_l.Qed.Lemmaneg_multxy:x< 0 ->y< 0 -> 0 <x*y.Proof.intros.rewrite<-(mult_0_rx).applyflip_neg_mult_l;trivial.Qed.Lemmapos_multxy: 0 <x-> 0 <y-> 0 <x*y.Proof.introsxposypos.rewrite<-(mult_0_rx).apply(pos_mult_lt_l);assumption.Qed.Lemmaneg_pos_multxy:x< 0 -> 0 <y->x*y< 0.Proof.intros.rewrite<-(mult_0_rx).applyflip_neg_mult_l;trivial.Qed.Lemmapos_neg_multxy: 0 <x->y< 0 ->x*y< 0.Proof.intros.rewrite(commutativity(f:=mult)).applyneg_pos_mult;trivial.Qed.Endstrict_semiring_order.(* Due to bug 2528 *)#[export]HintExtern7 (PropHolds(0 <_+_)) =>eapply@pos_plus_compat:typeclass_instances.Sectionpseudo_semiring_order.Context`{PseudoSemiRingOrderR} `{!IsSemiCRingR}.(*   Add Ring Rp : (stdlib_semiring_theory R). *)Local Existing Instancepseudo_order_apart.Global Instancepseudosrorder_strictsrorder:StrictSemiRingOrder(_:LtR).Proof.split;tryapply_.-intros.applypseudo_srorder_partial_minus,lt_flip.trivial.-applypseudo_srorder_pos_mult_compat.Qed.Global Instanceplus_strong_ext:StrongBinaryExtensionality(+).Proof.assert(forallz,StrongExtensionality(z+)).-intros.applypseudo_order_embedding_ext.-applyapartness.strong_binary_setoid_morphism_commutative.Qed.Global Instanceplus_strong_cancel_l:forallz,StrongLeftCancellation(+)z.Proof.introszxyE.applyapart_iff_total_ltinE;applyapart_iff_total_lt.destructE; [left|right];apply(strictly_order_preserving(z+));trivial.Qed.Global Instanceplus_strong_cancel_r:forallz,StrongRightCancellation(+)z.Proof.intros.apply(strong_right_cancel_from_left(+)).Qed.Lemmaneg_mult_decomposexy:x*y< 0 -> (x< 0 /\ 0 <y) |_| (0 <x/\y< 0).Proof.intros.assert(0 ≶x)asEx;[|assert(apart0y)asEy].-apply(strong_extensionality(.*y)).rewritemult_0_l.applypseudo_order_lt_apart_flip;trivial.-apply(strong_extensionality(x*.)).rewritemult_0_r.applypseudo_order_lt_apart_flip;trivial.-applyapart_iff_total_ltinEx;applyapart_iff_total_ltinEy.destructExas[Ex|Ex],Eyas[Ey|Ey];tryauto.+destruct(irreflexivity(<) 0).transitivity(x*y); [|trivial].applypos_mult_compat;trivial.+destruct(irreflexivity(<) 0).transitivity(x*y); [|trivial].applyneg_mult;trivial.Qed.Lemmapos_mult_decomposexy: 0 <x*y-> (0 <x/\ 0 <y) |_| (x< 0 /\y< 0).Proof.intros.assert(0 ≶x/\apart0y)as[ExEy];[split|].-apply(strong_extensionality(.*y)).rewritemult_0_l.applypseudo_order_lt_apart;trivial.-apply(strong_extensionality(x*.)).rewritemult_0_r.applypseudo_order_lt_apart;trivial.-applyapart_iff_total_ltinEx;applyapart_iff_total_ltinEy.destructExas[Ex|Ex],Eyas[Ey|Ey];tryauto.+destruct(irreflexivity(<) 0).transitivity(x*y); [trivial|].applypos_neg_mult;trivial.+destruct(irreflexivity(<) 0).transitivity(x*y); [trivial|].applyneg_pos_mult;trivial.Qed.Global Instancepos_mult_reflect_l:forall(z:R),PropHolds(0 <z) ->StrictlyOrderReflecting(z*.).Proof.introszEzxyE1.applynot_lt_apart_lt_flip.+introsE2.apply(lt_flip__E1).apply(strictly_order_preserving(z*.));trivial.+apply(strong_extensionality(z*.)).applypseudo_order_lt_apart_flip;trivial.Qed.Global Instancepos_mult_reflect_r:forall(z:R),PropHolds(0 <z) ->StrictlyOrderReflecting(.*z).Proof.intros.applystrictly_order_reflecting_flip.Qed.Global  Instanceapartzero_mult_strong_cancel_l:forallz,PropHolds(z≶ 0) ->StrongLeftCancellation(.*.)z.Proof.introszEzxyE.redinEz.applyapart_iff_total_ltinE;applyapart_iff_total_ltinEz;applyapart_iff_total_lt.destructEas[E|E],Ezas[Ez|Ez].-right.applyflip_neg_mult_l;trivial.-left.apply(strictly_order_preserving_pos(.*.)z);trivial.-left.applyflip_neg_mult_l;trivial.-right.apply(strictly_order_preserving_pos(.*.)z);trivial.Qed.Global Instanceapartzero_mult_strong_cancel_r:forallz,PropHolds(z≶ 0) ->StrongRightCancellation(.*.)z.Proof.intros.apply(strong_right_cancel_from_left(.*.)).Qed.Global Instanceapartzero_mult_cancel_l:forallz,PropHolds(z≶ 0) ->LeftCancellation(.*.)z.Proof.intros.apply_.Qed.Global Instanceapartzero_mult_cancel_r:forallz,PropHolds(z≶ 0) ->RightCancellation(.*.)z.Proof.intros.apply_.Qed.Lemmasquare_posx:x≶ 0 -> 0 <x*x.Proof.introsE.applyapart_iff_total_ltinE.destructEas[E|E].-destruct(decompose_ltE)as[z[Ez1Ez2]].applycompose_ltwith(z*z).+applypos_mult_compat;trivial.+rewriteplus_0_l.apply(left_cancellation(+) (x*z)).rewrite<-plus_mult_distr_r, <-plus_mult_distr_l.rewrite(commutativity(f:=plus)zx), <-!Ez2.rewritemult_0_l,mult_0_r.reflexivity.-applypos_mult_compat;trivial.Qed.Lemmapos_mult_rev_lxy: 0 <x*y-> 0 <y-> 0 <x.Proof.intros.apply(strictly_order_reflecting(.*y)).rewriterings.mult_0_l;trivial.Qed.Lemmapos_mult_rev_rxy: 0 <x*y-> 0 <x-> 0 <y.Proof.intros.applypos_mult_rev_lwithx.-rewrite(commutativity(f:=mult));trivial.-trivial.Qed.Context`{PropHolds(1 ≶ 0)}.Instancelt_0_1:PropHolds(0 < 1).Proof.red.rewrite<-(mult_1_l1).applysquare_pos;trivial.Qed.Instancelt_0_2:PropHolds(0 < 2).Proof.apply_.Qed.Instancelt_0_3:PropHolds(0 < 3).Proof.apply_.Qed.Instancelt_0_4:PropHolds(0 < 4).Proof.apply_.Qed.Lemmalt_1_2: 1 < 2.Proof.applypos_plus_lt_compat_r,lt_0_1.Qed.Lemmalt_1_3: 1 < 3.Proof.applypos_plus_lt_compat_r,lt_0_2.Qed.Lemmalt_1_4: 1 < 4.Proof.applypos_plus_lt_compat_r,lt_0_3.Qed.Lemmalt_2_3: 2 < 3.Proof.apply(strictly_order_preserving(1+)),lt_1_2.Qed.Lemmalt_2_4: 2 < 4.Proof.apply(strictly_order_preserving(1+)),lt_1_3.Qed.Lemmalt_3_4: 3 < 4.Proof.apply(strictly_order_preserving(1+)),lt_2_3.Qed.Instanceapart_0_2:PropHolds(2 ≶ 0).Proof.red.applysymmetry.applypseudo_order_lt_apart,lt_0_2.Qed.Endpseudo_semiring_order.#[export]HintExtern7 (PropHolds(0 < 1)) =>eapply@lt_0_1:typeclass_instances.#[export]HintExtern7 (PropHolds(0 < 2)) =>eapply@lt_0_2:typeclass_instances.#[export]HintExtern7 (PropHolds(0 < 3)) =>eapply@lt_0_3:typeclass_instances.#[export]HintExtern7 (PropHolds(0 < 4)) =>eapply@lt_0_4:typeclass_instances.#[export]HintExtern7 (PropHolds(2 ≶ 0)) =>eapply@apart_0_2:typeclass_instances.Sectionfull_pseudo_semiring_order.Context`{FullPseudoSemiRingOrderR} `{!IsSemiCRingR}.(*   Add Ring Rf : (stdlib_semiring_theory R). *)Global Instancefullpseudosrorder_fullpseudoorder:FullPseudoOrder(_:LeR) (_:LtR).Proof.split.-apply_.-apply_.-applyfull_pseudo_srorder_le_iff_not_lt_flip.Qed.Global Instancefullpseudosrorder_srorder:SemiRingOrder(_:LeR).Proof.split;tryapply_.-introsxyE.applyle_iff_not_lt_flipinE.applypseudo_srorder_partial_minus;trivial.-introsz.repeat(split;tryapply_).+introsxyE1.applyle_iff_not_lt_flipinE1;applyle_iff_not_lt_flip.introsE2.applyE1.apply(strictly_order_reflecting(z+)).trivial.+introsxyE1.applyle_iff_not_lt_flipinE1;applyle_iff_not_lt_flip.introsE2.applyE1.apply(strictly_order_preserving_);trivial.-introsxyExEy.applyle_iff_not_lt_flipinEx;applyle_iff_not_lt_flipinEy;applyle_iff_not_lt_flip.introsE.destruct(neg_mult_decomposexyE)as[[? ?]|[? ?]];auto.Qed.Global Instance:forall(z:R),PropHolds(0 <z) ->OrderReflecting(z*.).Proof.introszE.applyfull_pseudo_order_reflecting.Qed.Global Instance:forall(z:R),PropHolds(0 <z) ->OrderReflecting(.*z).Proof.intros.applyorder_reflecting_flip.Qed.Lemmaplus_lt_le_compatx₁y₁x₂y₂:x₁<y₁->x₂≤y₂->x₁+x₂<y₁+y₂.Proof.introsE1E2.applylt_le_transwith(y₁+x₂).-apply(strictly_order_preserving(+x₂));trivial.-apply(order_preserving(y₁+));trivial.Qed.Lemmaplus_le_lt_compatx₁y₁x₂y₂:x₁≤y₁->x₂<y₂->x₁+x₂<y₁+y₂.Proof.introsE1E2.applyle_lt_transwith(y₁+x₂).-apply(order_preserving(+x₂));trivial.-apply(strictly_order_preserving(y₁+));trivial.Qed.Lemmanonneg_plus_lt_compat_rxyz: 0 ≤z->x<y->x<y+z.Proof.intros.rewrite<-(plus_0_rx).applyplus_lt_le_compat;trivial.Qed.Lemmanonneg_plus_lt_compat_lxyz: 0 ≤z->x<y->x<z+y.Proof.intros.rewrite(commutativity(f:=plus)).applynonneg_plus_lt_compat_r;trivial.Qed.Lemmapos_plus_le_lt_compat_rxyz: 0 <z->x≤y->x<y+z.Proof.intros.rewrite<-(plus_0_rx).applyplus_le_lt_compat;trivial.Qed.Lemmapos_plus_le_lt_compat_lxyz: 0 <z->x≤y->x<z+y.Proof.intros.rewrite(commutativity(f:=plus)).applypos_plus_le_lt_compat_r;trivial.Qed.Lemmasquare_nonnegx: 0 ≤x*x.Proof.applynot_lt_le_flip.introsE.destruct(lt_antisym(x*x) 0).split; [trivial|].applysquare_pos.poseproofpseudo_order_apart.apply(strong_extensionality(x*.)).rewritemult_0_r.applylt_apart.trivial.Qed.Lemmanonneg_mult_rev_lxy: 0 ≤x*y-> 0 <y-> 0 ≤x.Proof.intros.apply(order_reflecting(.*y)).rewriterings.mult_0_l.trivial.Qed.Lemmanonneg_mult_rev_rxy: 0 ≤x*y-> 0 <x-> 0 ≤y.Proof.intros.applynonneg_mult_rev_lwithx.-rewrite(commutativity(f:=mult)).trivial.-trivial.Qed.Instancele_0_1:PropHolds(0 ≤ 1).Proof.red.rewrite<-(mult_1_r1).applysquare_nonneg.Qed.Instancele_0_2:PropHolds(0 ≤ 2).Proof.solve_propholds.Qed.Instancele_0_3:PropHolds(0 ≤ 3).Proof.solve_propholds.Qed.Instancele_0_4:PropHolds(0 ≤ 4).Proof.solve_propholds.Qed.Lemmale_1_2: 1 ≤ 2.Proof.applynonneg_plus_le_compat_r,le_0_1.Qed.Lemmale_1_3: 1 ≤ 3.Proof.applynonneg_plus_le_compat_r,le_0_2.Qed.Lemmale_1_4: 1 ≤ 4.Proof.applynonneg_plus_le_compat_r,le_0_3.Qed.Lemmale_2_3: 2 ≤ 3.Proof.apply(order_preserving(1+)),le_1_2.Qed.Lemmale_2_4: 2 ≤ 4.Proof.apply(order_preserving(1+)),le_1_3.Qed.Lemmale_3_4: 3 ≤ 4.Proof.apply(order_preserving(1+)),le_2_3.Qed.Lemmage_1_mult_compatxy: 1 ≤x-> 1 ≤y-> 1 ≤x*y.Proof.intros.applyge_1_mult_le_compat_r;trivial.transitivity1.-applyle_0_1.-trivial.Qed.Lemmagt_1_ge_1_mult_compatxy: 1 <x-> 1 ≤y-> 1 <x*y.Proof.intros.applylt_le_transwithx;trivial.applyge_1_mult_le_compat_r;[trivial| |applyreflexivity].transitivity1.-applyle_0_1.-applylt_le;trivial.Qed.Lemmage_1_gt_1_mult_compatxy: 1 ≤x-> 1 <y-> 1 <x*y.Proof.intros.rewrite(commutativity(f:=mult)).applygt_1_ge_1_mult_compat;trivial.Qed.Lemmapos_mult_le_lt_compat:forallabcd, 0 <=a/\a<=b-> 0 <b->0 <=c/\c<d->a*c<b*d.Proof.introsabcd[E1E2]E3[E4E5] .applyle_lt_transwith(b*c).-applymult_le_compat;auto.-apply(strictly_order_preserving(b*.)).trivial.Qed.Context`{PropHolds(1 ≶ 0)}.Lemmanot_le_1_0: ~(1 ≤ 0).Proof.applylt_not_le_flip,lt_0_1.Qed.Lemmanot_le_2_0: ~(2 ≤ 0).Proof.applylt_not_le_flip,lt_0_2.Qed.Lemmarepeat_nat_nonneg:foralln, 0 <=Core.nat_itern(plus1) 0.Proof.inductionn;simpl.-reflexivity.-applynonneg_plus_compat.+apply_.+applyIHn.Qed.Lemmarepeat_nat_pos:foralln, 0 <Core.nat_iter(Sn) (plus1) 0.Proof.introsn.simpl.applypos_plus_le_lt_compat_l.-solve_propholds.-applyrepeat_nat_nonneg.Qed.Local Existing Instancepseudo_order_apart.Global Instanceordered_characteristic_0:FieldCharacteristicR0.Proof.hnf.intros[|n]_;split.-introsE'.destruct(E'O).reflexivity.-introsE';apply(irreflexivity_)inE';destructE'.-intros_;applyapart_iff_total_lt;right;applyrepeat_nat_pos.-intros_m;simpl.introsE.apply(ap(funn=>matchnwith|S_=>Unit|_=>Emptyend))inE;simplinE.rewrite<-E.trivial.Qed.Endfull_pseudo_semiring_order.(* Due to bug 2528 *)#[export]HintExtern7 (PropHolds(0 ≤ 1)) =>eapply@le_0_1:typeclass_instances.#[export]HintExtern7 (PropHolds(0 ≤ 2)) =>eapply@le_0_2:typeclass_instances.#[export]HintExtern7 (PropHolds(0 ≤ 3)) =>eapply@le_0_3:typeclass_instances.#[export]HintExtern7 (PropHolds(0 ≤ 4)) =>eapply@le_0_4:typeclass_instances.Sectiondec_semiring_order.(* Maybe these assumptions can be weakened? *)Context`{SemiRingOrderR} `{ApartR} `{!TrivialApartR}`{!NoZeroDivisorsR} `{!TotalRelation(≤)} `{DecidablePathsR}.Context`{Rlt:LtR} `{is_mere_relationRlt}(lt_correct:forallxy,x<y<->x≤y/\x<>y).Instancedec_srorder_fullpseudo:FullPseudoOrder__:=dec_full_pseudo_orderlt_correct.Local Existing Instancepseudo_order_apart.Instancedec_pseudo_srorder:PseudoSemiRingOrder(<).Proof.split;tryapply_.-introsxyE.applysrorder_partial_minus,not_lt_le_flip;trivial.-introsz.repeat(split;tryapply_).introsxyE.applylt_correctinE;applylt_correct.destructEas[E2aE2b].split.+apply(order_preserving(z+));trivial.+introsE3.applyE2b.apply(left_cancellation(+)z);trivial.-apply(apartness.dec_strong_binary_morphism(.*.)).-introsxyE1E2.applylt_correctinE1;applylt_correctinE2;applylt_correct.destructE1as[E1aE1b],E2as[E2aE2b].split.+applynonneg_mult_compat;trivial.+applysymmetric_neq.applymult_ne_0;applysymmetric_neq;trivial.Qed.Instancedec_full_pseudo_srorder:FullPseudoSemiRingOrder(≤) (<).Proof.split;tryapply_.applyle_iff_not_lt_flip.Qed.Enddec_semiring_order.Sectionanother_semiring.Context`{SemiRingOrderR1}.Lemmaprojected_srorder`{IsSemiCRingR2} `{R2le:LeR2}`{is_mere_relationR2R2le} (f:R2->R1)`{!IsSemiRingPreservingf} `{!IsInjectivef}: (forallxy,x≤y<->fx≤fy) -> (forallxy:R2,x≤y->existsz,y=x+z) ->SemiRingOrderR2le.Proof.introsP.poseproof(projected_partial_orderfP).repeat(split;tryapply_).-assumption.-red;intros.applyP.rewrite2!(preserves_plus(f:=f)).apply(order_preserving_),P.trivial.-red;intros.applyP.apply(order_reflecting(fz+)).rewrite<-2!preserves_plus.applyP.trivial.-intros.applyP.rewritepreserves_mult,preserves_0.applynonneg_mult_compat;rewrite<-(preserves_0(f:=f));applyP;trivial.Qed.Context`{!IsSemiCRingR1} `{SemiRingOrderR2} `{!IsSemiCRingR2}`{!IsSemiRingPreserving(f:R1->R2)}.(* If a morphism agrees on the positive cone then it is order preserving *)Lemmapreserving_preserves_nonneg: (forallx, 0 ≤x-> 0 ≤fx) ->OrderPreservingf.Proof.introsE.repeat(split;tryapply_).introsxyF.destruct(decompose_leF)as[z[Ez1Ez2]].applycompose_lewith(fz).-applyE;trivial.-rewriteEz2, (preserves_plus(f:=f)).trivial.Qed.Instancepreserves_nonneg`{!OrderPreservingf}x:PropHolds(0 ≤x) ->PropHolds(0 ≤fx).Proof.intros.rewrite<-(preserves_0(f:=f)).apply(order_preservingf);trivial.Qed.Lemmapreserves_nonpos`{!OrderPreservingf}x:x≤ 0 ->fx≤ 0.Proof.intros.rewrite<-(preserves_0(f:=f)).apply(order_preservingf);trivial.Qed.Lemmapreserves_ge_1`{!OrderPreservingf}x: 1 ≤x-> 1 ≤fx.Proof.intros.rewrite<-(preserves_1(f:=f)).apply(order_preservingf);trivial.Qed.Lemmapreserves_le_1`{!OrderPreservingf}x:x≤ 1 ->fx≤ 1.Proof.intros.rewrite<-(preserves_1(f:=f)).apply(order_preservingf);trivial.Qed.Endanother_semiring.Sectionanother_semiring_strict.Context`{StrictSemiRingOrderR1} `{StrictSemiRingOrderR2}`{!IsSemiCRingR1} `{!IsSemiCRingR2}`{!IsSemiRingPreserving(f:R1->R2)}.Lemmastrictly_preserving_preserves_pos: (forallx, 0 <x-> 0 <fx) ->StrictlyOrderPreservingf.Proof.introsE.repeat(split;tryapply_).introsxyF.destruct(decompose_ltF)as[z[Ez1Ez2]].applycompose_ltwith(fz).-applyE.trivial.-rewriteEz2, (preserves_plus(f:=f)).trivial.Qed.Instancepreserves_pos`{!StrictlyOrderPreservingf}x:PropHolds(0 <x) ->PropHolds(0 <fx).Proof.intros.rewrite<-(preserves_0(f:=f)).apply(strictly_order_preservingf);trivial.Qed.Lemmapreserves_neg`{!StrictlyOrderPreservingf}x:x< 0 ->fx< 0.Proof.intros.rewrite<-(preserves_0(f:=f)).apply(strictly_order_preservingf);trivial.Qed.Lemmapreserves_gt_1`{!StrictlyOrderPreservingf}x: 1 <x-> 1 <fx.Proof.intros.rewrite<-(preserves_1(f:=f)).apply(strictly_order_preservingf);trivial.Qed.Lemmapreserves_lt_1`{!StrictlyOrderPreservingf}x:x< 1 ->fx< 1.Proof.intros.rewrite<-(preserves_1(f:=f)).apply(strictly_order_preservingf);trivial.Qed.Endanother_semiring_strict.(* Due to bug 2528 *)#[export]HintExtern15 (PropHolds(_≤__)) =>eapply@preserves_nonneg:typeclass_instances.#[export]HintExtern15 (PropHolds(_<__)) =>eapply@preserves_pos:typeclass_instances.(* Oddly enough, the above hints do not work for goals of the following shape? *)#[export]HintExtern15 (PropHolds(_≤ '_)) =>eapply@preserves_nonneg:typeclass_instances.#[export]HintExtern15 (PropHolds(_< '_)) =>eapply@preserves_pos:typeclass_instances.

--- Miscellaneous\SemiSimplicialSets.html ---
SemiSimplicialSetsLibrary SemiSimplicialSetsThe category of semisimplicial setsRequireImportTypesBasics.Trunc.RequireImportCategory.CoreFunctor.Core.RequireImportCategory.Morphisms.RequireImportCategory.DualFunctorCategory.Core.RequireImportSetCategory.Core.RequireImportSimplicialSets.RequireImportCategory.Sigma.OnMorphismsCategory.Subcategory.Wide.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.ModuleExportCore.Sectionsemisimplicial_sets.Context`{Funext}.Quoting David Spivak:Consider the subcategory ofΔwith the same objects (wide)
        but only injective morphisms.  If we call thatΓ(which is
        nonstandard), then semi-simplicial sets (also a non-standard
        term) (sic) areFun(Γᵒᵖ,Set). Define the obvious inclusionΓ->Δ, which we will use to make simplicial sets without
        having to worry about "degeneracies".Definitionsemisimplex_category:PreCategory:=widesimplex_category(@IsMonomorphism_)___.Definitionsemisimplicial_inclusion_functor:semisimplex_category->simplex_category:=pr1_mor.Definitionsemisimplicial_category(C:PreCategory) :PreCategory:=semisimplex_category^op->C.Definitionsemisimplicial_set:=semisimplicial_categoryset_cat.Definitionsemisimplicial_prop:=semisimplicial_categoryprop_cat.Endsemisimplicial_sets.Notationsemisimplicial_ofobj:= (semisimplicial_category(cat_ofobj)).EndCore.

--- Miscellaneous\Separated.html ---
SeparatedLibrary SeparatedRequireImportHoTT.BasicsHoTT.TypesHoTT.Cubical.DPath.RequireImportHFiberExtensionsFactorizationLimits.Pullback.RequireImportModalityAccessibleDescent.RequireImportTruncations.Core.RequireImportHomotopy.Suspension.Local OpenScopepath_scope.Local OpenScopesubuniverse_scope.Subuniverses of separated typesThe basic reference for subuniverses of separated types isChristensen, Opie, Rijke, and Scoccola, "Localization in Homotopy Type Theory", https://arxiv.org/abs/1807.04155.hereinafter referred to as "CORS".DefinitionThe definition is inReflectiveSubuniverse.v.Basic propertiesA function is (fiberwise) inSepOexactly when its diagonal is inO.SectionDiagonal.Context(O:Subuniverse) {XY:Type} (f:X->Y).DefinitionmapinO_diagonal`{MapIn(SepO)__f} :MapInO(diagonalf).Proof.introsp.refine(inO_equiv_inO'_(hfiber_diagonalfp)^-1).Defined.DefinitionmapinO_from_diagonal`{MapInO__(diagonalf)} :MapIn(SepO)f.Proof.introsx1uv.destructvas[x2p].destructp.refine(inO_equiv_inO'_(hfiber_diagonalf(u.1;x2;u.2))).Defined.EndDiagonal.Lemma 2.15 of CORS: IfOis accessible, so isSepO.  Its generators are the suspension of those ofO, in the following sense:Definitionsusp_localgen(f:LocalGenerators@{a}) :LocalGenerators@{a}.Proof.econstructor;introsi.exact(functor_susp(fi)).Defined.Global Instanceisaccrsu_sep(O:Subuniverse) `{IsAccRSUO}:IsAccRSU(SepO).Proof.exists(susp_localgen(acc_lgenO)).introsA;split;introsA_inO.{introsi.apply(ooextendable_iff_functor_susp(acc_lgenOi)).intros[xy].cbnin*.refine(ooextendable_postcompose'_____).2:applyinO_iff_islocal;exact(A_inOxy).introsb.applydp_const. }{introsxy.apply(inO_iff_islocalO);introsi.specialize(A_inOi).refine(ooextendable_postcompose'_____).2:exact(fst(ooextendable_iff_functor_susp(acc_lgenOi)_)A_inO(x,y)).introsb.symmetry;applydp_const. }Defined.Definitionsusp_nullgen(S:NullGenerators@{a}) :NullGenerators@{a}.Proof.econstructor;introsi.exact(Susp(Si)).Defined.Global Instanceisaccmodality_sep(O:Subuniverse) `{IsAccModalityO}:IsAccModality(SepO).Proof.exists(susp_nullgen(acc_ngenO)).introsA;split;introsA_inO.{introsi.apply(ooextendable_compose_(functor_susp(fun_:acc_ngenOi=>tt)) (fun_:SuspUnit=>tt)).1:applyooextendable_equiv,isequiv_contr_contr.apply(ooextendable_iff_functor_susp(fun_:acc_ngenOi=>tt)).intros[xy].refine(ooextendable_postcompose'_____).2:applyinO_iff_isnull;exact(A_inOxy).introsb.applydp_const. }{introsxy.apply(inO_iff_isnullO);introsi.specialize(A_inOi).assert(ee:ooExtendableAlong(functor_susp(fun_:acc_ngenOi=>tt)) (fun_=>A)).{refine(cancelL_ooextendable__(fun_=>tt)_A_inO).applyooextendable_equiv.applyisequiv_contr_contr. }assert(e:=fst(ooextendable_iff_functor_susp(fun_:acc_ngenOi=>tt)_)ee(x,y)).cbnine.refine(ooextendable_postcompose'____e).introsb.symmetry;applydp_const. }Defined.Remark 2.16(1) of CORSGlobal InstanceO_leq_SepO(O:ReflectiveSubuniverse):O<=SepO.Proof.introsA?xy;exact_.Defined.Part of Remark 2.16(2) of CORSDefinitionin_SepO_embedding(O:Subuniverse){AB:Type} (i:A->B) `{IsEmbeddingi} `{In(SepO)B}:In(SepO)A.Proof.introsxy.refine(inO_equiv_inO'_(equiv_ap_isembeddingixy)^-1).Defined.(* As a special case, if X embeds into an n-type for n >= -1 then X is an n-type. Note that this doesn't hold for n = -2. *)Corollaryistrunc_embedding_trunc{XY:Type} {n:trunc_index} `{istr:IsTruncn.+1Y}(i:X->Y) `{isem:IsEmbeddingi} :IsTruncn.+1X.Proof.applyistrunc_S.exact(@in_SepO_embedding(Trn)__iisemistr).Defined.Global Instancein_SepO_hprop(O:ReflectiveSubuniverse){A:Type} `{IsHPropA}:In(SepO)A.Proof.srapply(in_SepO_embeddingO(const_tt_)).introsxy;exact_.Defined.Remark 2.16(4) of CORSDefinitionsigma_closed_SepO(O:Modality) {A:Type} (B:A->Type)`{A_inO:In(SepO)A} `{B_inO:foralla,In(SepO) (Ba)}:In(SepO) (sigB).Proof.intros[xu] [yv].specialize(A_inOxy).poseproof(funp:x=y=>B_inOy(p#u)v).pose@inO_sigma.(* Speed up typeclass search. *)refine(inO_equiv_inO'_(equiv_path_sigmaB__)).Defined.Lemma 2.17 of CORSGlobal Instanceissurjective_to_SepO(O:ReflectiveSubuniverse) (X:Type)`{Reflects(SepO)X}:IsSurjection(to(SepO)X).Proof.pose(im:=himage(to(SepO)X)).poseproof(in_SepO_embeddingO(factor2im)).pose(s:=O_rec(factor1im)).assert(h:factor2imos==idmap).-applyO_indpaths;introsx;substs.rewriteO_rec_beta.applyfact_factors.-applyBuildIsSurjection.introsz.specialize(hz);cbninh.set(w:=sz)in*.destructwas[w1w2].destructh.exactw2.Defined.Proposition 2.18 of CORS.Definitionalmost_inSepO_typeO@{ij} `{Univalence}(O:ReflectiveSubuniverse) (AB:Type_@{ij}O): {Z:Type@{i} &InOZ* (Z<~> (A=B)) }.Proof.exists(A<~>B);split.-exact_.-refine(equiv_path_TypeOOABoE_).applyequiv_path_universe.Defined.Lemma 2.21 of CORSGlobal InstanceinSepO_sigma(O:ReflectiveSubuniverse){X:Type} {P:X->Type} `{In(SepO)X} `{forallx,InO(Px)}:In(SepO) (sigP).Proof.introsuv.refine(inO_equiv_inO'_(equiv_path_sigmaP__)).Defined.Proposition 2.22 of CORS (in funext-free form).Global InstancereflectsD_SepO(O:ReflectiveSubuniverse){X:Type} `{Reflects(SepO)X}:ReflectsD(SepO)OX.Proof.srapplyreflectsD_from_inO_sigma.Defined.Once we know thatSepOis a reflective subuniverse, this will mean thatO<<SepO.And now the version with funext.Definitionisequiv_toSepO_inO`{Funext} (O:ReflectiveSubuniverse){X:Type} `{Reflects(SepO)X}(P:O_reflector(SepO)X->Type) `{forallx,InO(Px)}:IsEquiv(fung: (forally,Py) =>goto(SepO)X):=isequiv_ooextendable__(extendable_to_OOP).Definitionequiv_toSepO_inO`{Funext} (O:ReflectiveSubuniverse){X:Type} `{Reflects(SepO)X}(P:O_reflector(SepO)X->Type) `{forallx,InO(Px)}: (forally,Py) <~> (forallx,P(to(SepO)Xx)):=Build_Equiv___(isequiv_toSepO_inOOP).TODO: Actually prove this, and put it somewhere more appropriate.SectionJoinConstruction.Universesij.Context{X:Type@{i}} {Y:Type@{j}} (f:X->Y)(ls:forall(y1y2:Y),@sig@{jj}Type@{i} (fun(Z:Type@{i}) =>Equiv@{ij}Z(y1=y2))).Definitionjc_image@{} :Type@{i}.Admitted.Definitionjc_factor1@{} :X->jc_image.Admitted.Definitionjc_factor2@{} :jc_image->Y.Admitted.Definitionjc_factors@{} :jc_factor2ojc_factor1==f.Admitted.Global Instancejc_factor1_issurj@{} :IsSurjectionjc_factor1.Admitted.Global Instancejc_factor2_isemb:IsEmbeddingjc_factor2.Admitted.EndJoinConstruction.We'd like to say that the universe ofO-modal types isO-separated, i.e. belongs toSepO.  But since a given subuniverse likeSepOlives only on a single universe size, trying to say that in the naive way yields a universe inconsistency.FailGoalforall(O:ReflectiveSubuniverse),In(SepO) (Type_O).Instead, we do as in Lemma 2.19 of CORS and prove the morally-equivalent "descent" property, using Lemma 2.18 and the join construction.Global InstanceSepO_lex_leq`{Univalence}(O:ReflectiveSubuniverse) {X:Type} `{Reflects(SepO)X}:Descends(SepO)OX.Proof.assert(e:forall(P:X->Type_O),{Q: (O_reflector(SepO)X->Type_O) &forallx,Q(to(SepO)Xx) <~>Px}).2:{unshelveeconstructor;introsP'P_inO;pose(P:=funx=> (P'x;P_inOx) :Type_O);pose(ee:=eP).-exactee.1.-simpl;exact_.-introsx;cbn;applyee.2. }introsP.assert(ls:forallAB:Type_O, {Z:Type&Z<~> (A=B) }).{introsAB.pose(q:=almost_inSepO_typeOOAB).exact(q.1;sndq.2). }pose(p:=jc_factor2Pls).set(J:=jc_imagePls)inp.assert(In(SepO)J).{introsxy.pose(q:=almost_inSepO_typeOO(px) (py)).refine(inO_equiv_inO'q.1_).refine(_oE_).-symmetry;srapply(equiv_ap_isembeddingp).-exact(sndq.2). }pose(O_rec(O:=SepO) (jc_factor1Pls)).exists(poj).introsx;substpj.rewriteO_rec_beta.applyequiv_path.exact((jc_factorsPlsx)..1).Defined.Once we know thatSepOis a reflective subuniverse, this will implyO<<<SepO, and that ifSepOis accessible (such as ifOis) thenType_Obelongs to its accessible lifting (seeinO_TypeO_lex_leq.Reflectiveness ofSepOTODOLeft-exactness propertiesNearly all of these are true in the generality of a pair of reflective subuniverses withO<<<O'and/orO'<=SepO, and as such can be found inDescent.v.

--- Miscellaneous\SeparatedTrunc.html ---
SeparatedTruncLibrary SeparatedTruncRequireImportBasicsTypes.RequireImportTruncType.RequireImportTruncations.CoreModalities.ModalityModalities.Descent.Separatedness and path-spaces of truncationsSectionSeparatedTrunc.Local OpenScopesubuniverse_scope.Then.+1-truncation modality consists of the separated types for then-truncation modality.Global InstanceO_eq_Tr(n:trunc_index):Trn.+1 <=>Sep(Trn).Proof.split;introsAA_inO.-introsxy;exact_.-rapplyistrunc_S.Defined.It follows thatTrn<<<Trn.+1.  However, it is easier to prove this directly than to go through separatedness.Global InstanceO_leq_Tr(n:trunc_index):Trn<=Trn.+1.Proof.introsA?;exact_.Defined.Global InstanceO_strong_leq_Tr(n:trunc_index):Trn<<Trn.+1.Proof.srapplyO_strong_leq_trans_l.Defined.For some reason, this causes typeclass search to spin.Local InstanceO_lex_leq_Tr`{Univalence} (n:trunc_index):Trn<<<Trn.+1.Proof.introsA;unshelveeconstructor;introsP'P_inO;pose(P:=funx=>Build_TruncTypen(P'x)).-refine(Trunc_recP).-intros;simpl;exact_.-intros;cbn.reflexivity.Defined.Definitionpath_Tr{nA} {xy:A}:Trn(x=y) -> (trx=try:>Trn.+1A):=path_OO(Trn.+1) (Trn)xy.Definitionequiv_path_Tr`{Univalence} {n} {A:Type} (xy:A):Trn(x=y) <~> (trx=try:>Trn.+1A):=equiv_path_OO(Trn.+1) (Trn)xy.EndSeparatedTrunc.

--- Miscellaneous\Sequence.html ---
SequenceLibrary SequenceRequireImportBasics.RequireImportDiagrams.Graph.RequireImportDiagrams.Diagram.Local OpenScopenat_scope.Local OpenScopepath_scope.SequenceA Sequence is a sequence of maps fromX(n)toX(n+1).Definitionsequence_graph:Graph.Proof.srapply(Build_Graphnat).introsnm;exact(Sn=m).Defined.DefinitionSequence:=Diagramsequence_graph.DefinitionBuild_Sequence(X:nat->Type)(f:foralln,Xn->Xn.+1):Sequence.Proof.srapplyBuild_Diagram.1:exactX.intros? ?p.destructp.applyf.Defined.A useful lemma to show than two sequences are equivalent.Definitionequiv_sequence(D1D2:Sequence)(H0: (D10) <~> (D20))(Hn:foralln(e: (D1n) <~> (D2n)),{e': (D1n.+1) <~> (D2n.+1) & (D2_f1)oe==e'o(D1_f1)}):D1~d~D2.Proof.srapply(Build_diagram_equiv(Build_DiagramMap__));intron;simpl.-applyequiv_fun.inductionn.+applyH0.+exact(HnnIHn).1.-introsmq;destructq.inductionn;simpl.+exact(Hn0H0).2.+simplerefine(Hnn.+1_).2.-inductionn;simpl.+applyH0.+apply(Hnn_).1.Defined.

--- Miscellaneous\Sequential.html ---
SequentialLibrary SequentialSequential colimitsWe present a proof of the conjecture that sequential colimits in HoTT appropriately commute with Σ-types. As a corollary, we characterize the path space of a sequential colimit as a sequential colimit of path spaces. For the written account of these results see https://www.cs.cornell.edu/~ks858/papers/sequential_colimits_homotopy.pdf.RequireImportBasics.RequireImportTypes.RequireImportDiagrams.Diagram.RequireImportDiagrams.Sequence.RequireImportDiagrams.Cocone.RequireImportColimits.Colimit.RequireImportSpaces.Nat.Core.RequireImportPathAny.Local OpenScopenat_scope.Local OpenScopepath_scope.coeistransportidmap:(A=B)->(A->B), but is described as the underlying map of an equivalence so that Coq knows that it is an equivalence.Notationcoe:= (funp=>equiv_fun(equiv_path__p)).Notation"a ^+" := (@arrsequence_graph___1a).Mapping spaces into hprops from colimits of sequences can be characterized.Lemmaequiv_colim_seq_rec`{Funext} (A:Sequence) (P:Type) `{IsHPropP}: (ColimitA->P) <~> (foralln,An->P).Proof.symmetry.refine(equiv_colimit_recPoE_).refine(issig_Cocone__oE_).symmetry.srapplyBuild_Equiv.1:exactpr1.exact_.Defined.If a sequential colimit has maps homotopic to a constant map then the colimit is contractible.Global Instancecontr_colim_seq_into_prop{funext:Funext} (A:Sequence)(a:foralln,An) (H:foralln,const(an.+1) ==A_fidpath):Contr(ColimitA).Proof.transparentassert(B:Sequence).{srapplyBuild_Sequence.1:exactA.introsn.exact(const(an.+1)). }rapplycontr_equiv'.1:rapplyequiv_functor_colimit.1:rapply(equiv_sequenceBA).1:reflexivity.{introsne.existsequiv_idmap.introsx.symmetry.exact(H_(ex)). }srapplyBuild_Contr.1:exact(colim(D:=B) 1%nat(a1%nat)).srapplyColimit_ind.{introsix.inductioni.1:exact(colimp(D:=B)__idpathx).refine(IHi(ai) @_).refine((colimp(D:=B)__idpath(ai))^ @_).refine((colimp(D:=B)__idpath(ai.+1))^ @_).exact(colimp(D:=B)__idpathx). }introsnm[]x.rewritetransport_paths_FlFr.rewriteap_const.rewriteap_idmap.destructn;simpl;hott_simpl.Qed.Definitionseq_shift_from_zero_by{A:Sequence} (a:A0)k:Ak.Proof.inductionkas[ |kq].-exacta.-exactq^+.Defined.Notation"a ^+ k" := (seq_shift_from_zero_byak).Shiftings; described in the paragraph after Lemma 3.7.Definitionseq_pair_shift{A:Sequence} (x:sigA) :sigA.Proof.destructxas[na];exact(n.+1;a^+).Defined.Definitionseq_pair_shift_by{A:Sequence} (x:sigA) (k:nat) :sigA.Proof.inductionkas[ |ky].-exactx.-exact(seq_pair_shifty).Defined.Notation"x ^++" := (seq_pair_shiftx).Notation"x ^++ k" := (seq_pair_shift_byxk).Definitionseq_pair_shift_assoc{A:Sequence} (x:sigA) (k:nat): (x^++)^++k=x^++(k.+1).Proof.inductionkas[ |kq].-reflexivity.-exact(apseq_pair_shiftq).Defined.Definitionseq_shift_pair_from_zero{A:Sequence} (a:A0)k: (0;a)^++k= (k;a^+k).Proof.inductionkas[ |kq].-reflexivity.-exact(apseq_pair_shiftq).Defined.NotationinjA:= (@colimsequence_graphA).NotationglueA:= (funn=> @colimpsequence_graphAnn.+1 1).The uniqueness principle for sequential colimits; Lemma 3.3.Definitionseq_colimit_uniq{A:Sequence}E(FG:ColimitA->E)(h:foralln,FoinjAn==GoinjAn)(H:forallna,apF(glueAna) @hna=hn.+1a^+ @apG(glueAna)):F==G.Proof.srapply(Colimit_ind_h);introsnmpa;destructp.generalize(Hna);generalize(hna);destruct(glueAna).introspq;srefine((concat_p1_)^ @_);srefine(_@ (concat_1p_));exactq^.Defined.The successor sequence from Lemma 3.6.Definitionsucc_seq(A:Sequence) :Sequence:=Build_Sequence(funk=>Ak.+1) (funka=>a^+).The shifted sequence from Lemma 3.7.Definitionshift_seq(A:Sequence)n:Sequence:=Build_Sequence(funk=>A(k+n)%nat) (funka=>a^+).The canonical equivalence between the colimit of the succesor sequence and the colimit of the original sequence; Lemma 3.6.Definitioncolim_succ_seq_to_colim_seqA:Colimit(succ_seqA) ->ColimitA.Proof.srapplyColimit_rec;srapplyBuild_Cocone.+exact(funna=>inj_n.+1a).+introsnmp;destructp;exact(glueAn.+1).Defined.Definitioncolim_succ_seq_to_colim_seq_beta_glueAna:ap(colim_succ_seq_to_colim_seqA) (glue(succ_seqA)na) =glueA(n.+1)a.Proof.srapplyColimit_rec_beta_colimp.Defined.Definitioncolim_succ_seq_to_colim_seq_ap_injAn(a1a2:succ_seqAn) (p:a1=a2):ap(colim_succ_seq_to_colim_seqA) (ap(inj_n)p) =ap(inj_n.+1)p.Proof.destructp;reflexivity.Defined.Global Instanceisequiv_colim_succ_seq_to_colim_seqA:IsEquiv(colim_succ_seq_to_colim_seqA).Proof.srapplyisequiv_adjointify.+srapplyColimit_rec;srapplyBuild_Cocone.*exact(funna=>inj(succ_seqA)na^+).*introsnmpa;destructp;exact(glue(succ_seqA)na^+).+srapplyseq_colimit_uniq.*exact(funna=>glue_na).*introsna;rewriteap_idmap,ap_compose,Colimit_rec_beta_colimp.rewritecolim_succ_seq_to_colim_seq_beta_glue;reflexivity.+srapplyseq_colimit_uniq.*exact(funna=>glue_na).*introsna;rewriteap_idmap,ap_compose,Colimit_rec_beta_colimp.rewrite(@Colimit_rec_beta_colimp_A____1);reflexivity.Defined.Definitionequiv_colim_succ_seq_to_colim_seqA:Colimit(succ_seqA) <~>ColimitA:=Build_Equiv__(colim_succ_seq_to_colim_seqA)_.The canonical equivalence between the colimit of the shifted sequence and the colimit of the original sequence; Lemma 3.6.Definitioncolim_shift_seq_to_colim_seqAn:Colimit(shift_seqAn) ->ColimitA.Proof.srapplyColimit_rec;srapplyBuild_Cocone.+exact(funka=>injA(k+n)%nata).+introsklp;destructp;exact(glueA(k+n)%nat).Defined.Definitioncolim_shift_seq_to_colim_seq_beta_glueAnka:ap(colim_shift_seq_to_colim_seqAn) (glue(shift_seqAn)ka) =glueA(k+n)%nata.Proof.srapplyColimit_rec_beta_colimp.Defined.Definitioncolim_shift_seq_to_colim_seq_ap_injAnk(a1a2:shift_seqAnk) (p:a1=a2):ap(colim_shift_seq_to_colim_seqAn) (ap(inj_k)p) =ap(inj_(k+n)%nat)p.Proof.destructp;reflexivity.Defined.Local DefinitionJ{XYZ} {x1x2:X} {y} {I:forallx,Yx->Z} (p:x2=x1):Ix2y=Ix1(coe(apYp)y).Proof.destructp;reflexivity.Defined.Local DefinitionK{XY} {x1x2:X} {y}FG(p:x1=x2) :Gx2(coe(apYp)y) =coe(apY(apFp)) (Gx1y).Proof.destructp;reflexivity.Defined.Local DefinitionL{XYZ} {x1x2:X} {y} {FG} {I:forallx,Yx->Z} {p:x2=x1}(Q:forallxy,I(Fx) (Gxy) =Ixy):Qx2y@Jp=J(apFp) @ (ap(I(Fx1)) (KFGp)^ @Qx1(coe(apYp)y)).Proof.destructp;cbn.applyequiv_p1_1q.symmetry;applyconcat_1p.Defined.Global Instanceisequiv_colim_shift_seq_to_colim_seq`{Funext}An:IsEquiv(colim_shift_seq_to_colim_seqAn).Proof.inductionnas[ |ne];srapplyisequiv_homotopic'.-srapplyequiv_functor_colimit;srapplyBuild_diagram_equiv.+srapplyBuild_DiagramMap.*exact(funk=>coe(apA(nat_add_zero_rk))).*introsklpa;destructp.srapply(KS(funna=>a^+)_).+exact_.-symmetry;srapplyseq_colimit_uniq.+introska;exact(J(nat_add_zero_rk)).+introska;rewrite!Colimit_rec_beta_colimp;srapply(L(glueA)).-transitivity(Colimit(succ_seq(shift_seqAn))).+srapplyequiv_functor_colimit;srapplyBuild_diagram_equiv.*srapplyBuild_DiagramMap.{exact(funk=>coe(apA(nat_add_succ_rkn))). }{introsklpa;destructp;rapply(KS(funna=>a^+) (nat_add_succ_rkn)). }*exact_.+srefine(transitivity(equiv_colim_succ_seq_to_colim_seq_) (Build_Equiv___e)).-symmetry;srapplyseq_colimit_uniq.+introska;exact(J(nat_add_succ_rkn)).+introska;rewriteColimit_rec_beta_colimp;simpl.rewrite2(ap_compose'__(glue_ka)),Colimit_rec_beta_colimp, 2ap_pp.rewritecolim_succ_seq_to_colim_seq_ap_inj,colim_shift_seq_to_colim_seq_ap_inj.rewrite(colim_succ_seq_to_colim_seq_beta_glue(shift_seqAn)).rewritecolim_shift_seq_to_colim_seq_beta_glue;srapply(L(glueA)).Defined.Definitionequiv_colim_shift_seq_to_colim_seq`{Funext}An:Colimit(shift_seqAn) <~>ColimitA:=Build_Equiv__(colim_shift_seq_to_colim_seqAn)_.Corollary 7.7.1 for k := -2; implies Lemma 7.2.Definitioncontr_colim_contr_seq`{Funext} (A:Sequence): (forallk,Contr(Ak)) ->Contr(ColimitA).Proof.introh_seqcontr;pose(unit_seq:=Build_Sequence(fun_=>Unit) (fun__=>tt)).srapply(contr_equiv'(Colimitunit_seq)).-symmetry;srapplyequiv_functor_colimit.srapplyBuild_diagram_equiv;srapplyBuild_DiagramMap.*exact(fun__=>tt).*introsnmpa;destructp;reflexivity.-srapply(Build_Contr_(injunit_seq0tt));introy;symmetry;reverty.srapplyseq_colimit_uniq.*introsna;destructa;inductionnas[ |nr].+reflexivity.+exact(glueunit_seqntt@r).*intron;destructa;rewriteap_idmap,ap_const,concat_p1;reflexivity.Defined.Fibered sequences; Section 4.RecordFibSequence(A:Sequence) := {fibSequence:sigA->Type;fibSequenceArrx:fibSequencex->fibSequencex^++}.CoercionfibSequence:FibSequence>->Funclass.ArgumentsfibSequence{A}.ArgumentsfibSequenceArr{A}.Notation"b ^+f" := (fibSequenceArr__b).The Sigma of a fibered type sequence; Definition 4.3.Definitionsig_seq{A} (B:FibSequenceA) :Sequence.Proof.srapplyBuild_Sequence.-exact(funn=> {a:An&B(n;a)}).-introsn[ab];exact(a^+;b^+f).Defined.The canonical projection from the sequential colimit of Sigmas to the sequential colimit of the first component; Definition 4.3.Definitionseq_colim_sum_to_seq_colim_fst{A} (B:FibSequenceA):Colimit(sig_seqB) ->ColimitA.Proof.srapplyColimit_rec;srapplyBuild_Cocone.-introsn[a_];exact(inj_na).-introsnmp[ab];destructp;exact(glue_na).Defined.Given a sequence fibered over A, aach point x : sig A induces a new type sequence; Section 4.Definitionfib_seq_to_seq{A} (B:FibSequenceA) (x:sigA) :Sequence.Proof.srapplyBuild_Sequence;introk;revertx;inductionkas[ |kh].*exact(funx=>Bx).*exact(funx=>hx^++).*exact(funxb=>b^+f).*exact(funx=>hx^++).Defined.The induced sequence can be equivalently described by using shifting; Lemma 7.1.Definitionfib_seq_to_seq'{A} (B:FibSequenceA) (x:sigA) :Sequence:=Build_Sequence(funk=>Bx^++k) (funkb=>b^+f).Definitionequiv_fib_seq_to_seq{A} (B:FibSequenceA) (x:sigA):fib_seq_to_seqBx~d~fib_seq_to_seq'Bx.Proof.srapplyBuild_diagram_equiv.+srapplyBuild_DiagramMap.*intron;revertx;inductionnas[ |ne].-exact(fun_=>idmap).-exact(funx=>coe(apB(seq_pair_shift_assocxn))oex^++).*introsnmp;destructp;revertx;inductionnas[ |np].-exact(fun__=>idpath).-exact(funxb=>K___@ (ap_(p(x^++)b))).+intron;revertx;inductionnas[ |ne].*exact(fun_=>isequiv_idmap_).*introx;srapplyisequiv_compose.Defined.A fibered type sequence defines a type family; Section 4.Definitionfib_seq_to_type_fam`{Univalence} {A} (B:FibSequenceA) :ColimitA->Type.Proof.srapplyColimit_rec;srapplyBuild_Cocone.-exact(funna=>Colimit(fib_seq_to_seqB(n;a))).-introsnmpa;destructp;applypath_universe_uncurried.exact(equiv_colim_succ_seq_to_colim_seq(fib_seq_to_seqB(n;a))).Defined.Definitionfib_seq_to_type_fam_beta_glue`{Univalence} {A}Bna:coe(ap(fib_seq_to_type_famB) (glueAna))=colim_succ_seq_to_colim_seq(fib_seq_to_seqB(n;a)).Proof.srapply(ap_(Colimit_rec_beta_colimp______) @_).srapply(transport_idmap_path_universe_uncurried_).Defined.Local DefinitionDelta{XY} {x1x2:X} {F} (p:x1=x2) (psi:coe(apYp) =F)y: (x1;y) = (x2;Fy).Proof.destructp;destructpsi;reflexivity.Defined.Local DefinitionDelta_proj{XY} {x1x2:X} {F} (p:x1=x2) (psi:coe(apYp) =F)y:appr1(Deltappsiy) =p.Proof.destructp;destructpsi;reflexivity.Defined.The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits; Definition 5.1.Definitionseq_colim_sum_to_sum_seq_colim`{Univalence} {A} (B:FibSequenceA):Colimit(sig_seqB) ->sig(fib_seq_to_type_famB).Proof.srapplyColimit_rec;srapplyBuild_Cocone.-introsn[ab];exact(injAna;inj(fib_seq_to_seq__) 0b).-introsnmp[ab];destructp;srefine(_@ap_(glue(fib_seq_to_seq__) 0b)).srapply(Delta_(fib_seq_to_type_fam_beta_glueBna)).Defined.Definitionseq_colim_sum_to_sum_seq_colim_beta_glue`{Univalence} {A}Bnab:ap(seq_colim_sum_to_sum_seq_colimB) (glue(sig_seqB)n(a;b)) =Delta_(fib_seq_to_type_fam_beta_glueBna) (inj___) @ap(exist_(injAna)) (glue(fib_seq_to_seq__) 0b).Proof.srapplyColimit_rec_beta_colimp.Defined.An alternative induction principle for the sum of colimits; Lemma 5.2 and Section 6.SectionSeqColimitSumInd.Context`{Univalence} {A} (B:FibSequenceA).Context(E:sig(fib_seq_to_type_famB) ->Type).Context(e:forallnab,E(seq_colim_sum_to_sum_seq_colimB(inj(sig_seqB)n(a;b)))).Context(t:forallnab,ap(seq_colim_sum_to_sum_seq_colimB) (glue(sig_seqB)n(a;b))#en.+1 (a^+) (b^+f) =enab).The point-point case of the nested induction; corresponds to "h" in the paper.Local DefinitionQk:forallnab,E(inj_na;inj_kb).Proof.inductionkas[ |kh].-exacte.-introsnab;exact(Delta_(fib_seq_to_type_fam_beta_glueBna)_#hn.+1 (a^+)b).Defined.The path-point case of the nested induction is just reflexivity; corresponds to "mu" in the paper.Local DefinitionEta{XYZ} {x:X} {y1y2:Yx} {z:sigY} {p:y1=y2}{q1:z= (x;y1)} {q2:z= (x;y2)} (theta:q2=q1@ap_p):transport(ZoexistYx)potransportZq1==transportZq2.Proof.symmetryintheta;destructtheta;destructp;simpl;destructq1.reflexivity.Defined.Local DefinitionEpsilon{XYZ} {x1x2:X} {y1y2} {F} (p:x1=x2) {q:y1=y2}{psi:coe(apYp) =F} {r:Fy1=Fy2} (theta:apFq=r):transport(ZoexistYx2)rotransportZ(Deltappsiy1) ==transportZ(Deltappsiy2)otransport(ZoexistYx1)q.Proof.destructtheta;destructq;reflexivity.Defined.The point-path case of the nested induction; corresponds to "H" in the paper.Local DefinitionRk:forallnab,transport(Eoexist_(injAna)) (glue_kb) (Qk.+1na(b^+)) =Qknab.Proof.inductionkas[ |kh].-introsnab;srapply(_@tnab).srapply(Eta(seq_colim_sum_to_sum_seq_colim_beta_glueBnab)).-introsnab;srefine(_@ap_(hn.+1 (a^+)b)).srapply(Epsilon(glueAna) (colim_succ_seq_to_colim_seq_beta_glue___)).Defined.The point case of the nested induction; corresponds to "g" in the paper.Local DefinitionFna:forallx,E(inj_na;x).Proof.srapplyColimit_ind.-exact(funk=>Qkna).-introsklp;destructp;exact(Rkna).Defined.Local DefinitionF_beta_gluenab:apD(Fna) (glue_0b) =R0nab.Proof.srapplyColimit_ind_beta_colimp.Defined.Local DefinitionPhi{XYZ} {x1x2:X} {y1y2} {F} (p:x1=x2) {q:y1=y2}{psi:coe(apYp) =F} {G1:forally,Z(x1;y)} {G2:forally,Z(x2;y)}{r:Fy1=Fy2} (theta:apFq=r):forallu1u2,apDG2r@u2=ap(transport_r)u1@Epsilonptheta(G1y1) @ap(transportZ(Deltappsiy2)) (apDG1q)->transport(funy=>G2(Fy) =Deltappsiy#G1y)qu1=u2.Proof.destructtheta;destructq;introsu1u2;rewriteap_idmap, !concat_p1.simpl.intros;destructs;srefine(concat_1p_).Defined.The path case of the nested induction; corresponds to "omega" in the paper.Local DefinitionGna:forally,Fna_=Delta_(fib_seq_to_type_fam_beta_glueBna)y#Fn.+1 (a^+)y.Proof.srapplyColimit_ind.-exact(funkb=>idpath).-introsklpb;destructp.snrapply(Phi(glueAna) (colim_succ_seq_to_colim_seq_beta_glue___)).rewrite(Colimit_ind_beta_colimp_(funk=>Qkna)___idpath).rewrite(Colimit_ind_beta_colimp_(funk=>Qkn.+1a^+)___idpath).rewriteconcat_p1,concat_1p;reflexivity.Defined.Local DefinitionI{XYZ} {x1x2:X} {p:x1=x2} {F} (psi:coe(apYp) =F) {G1G2}:transport(funx=>forally,Z(x;y))pG1=G2<~>forally,G2(Fy) =Deltappsiy#G1y.Proof.destructp;destructpsi.srefine(transitivity(equiv_path_inverse__) (equiv_apD10___)).Defined.The alternative induction rule in curried form; corresponds to curried "G" in
      the paper.Definitionseq_colim_sum_ind_cur:forallxy,E(x;y).Proof.srapply(Colimit_ind_F);introsnmpa;destructp.exact((I(fib_seq_to_type_fam_beta_glueBna))^-1 (Gna)).Defined.The computation rule for the alternative induction rule in curried form.Definitionseq_colim_sum_ind_cur_beta_gluena:I(fib_seq_to_type_fam_beta_glueBna) (apDseq_colim_sum_ind_cur(glue_na)) =Gna.Proof.applymoveR_equiv_M;srapplyColimit_ind_beta_colimp.Defined.The alternative induction rule; corresponds to "G" in the paper.Definitionseq_colim_sum_ind:forallx,Ex.Proof.intros[xy];applyseq_colim_sum_ind_cur.Defined.Local DefinitionXi{XYZ}G{x:X} {y1y2:Yx} {z:sigY} {p:y1=y2}{q1:z= (x;y1)} {q2:z= (x;y2)} (theta:q2=q1@ap_p):apD(GoexistYx)p=ap(transport(ZoexistYx)p) (apDGq1)^ @Etatheta(Gz) @apDGq2.Proof.reverttheta;srapply(equiv_ind(equiv_path_inverse__)).intros;destructs.revertq1;srapply(equiv_ind(equiv_path_inverse__));intros;destructs.destructp;reflexivity.Defined.Local DefinitionMu{XYZ} {x1x2:X} (p:x1=x2) {F} (G:forallz,Zz){psi:coe(apYp) =F} {q} (theta:Ipsi(apD(funxy=>G(x;y))p) =q)y:apDG(Deltappsiy) = (qy)^.Proof.destructp;destructpsi;destructtheta;reflexivity.Defined.The computation rule for the alternative induction rule.Definitionseq_colim_sum_ind_beta_glue:forallnab,apDseq_colim_sum_ind(ap(seq_colim_sum_to_sum_seq_colimB) (glue(sig_seqB)n_)) =tnab.Proof.introsnab;pose(h:=F_beta_gluenab).rewrite(Xiseq_colim_sum_ind(seq_colim_sum_to_sum_seq_colim_beta_glueBnab))inh.rewrite(Mu(glue_na)seq_colim_sum_ind(seq_colim_sum_ind_cur_beta_gluena))inh.rewriteconcat_1pinh;exact(cancelL___h).Defined.EndSeqColimitSumInd.An alternative recursion principle for the sum of colimits; Lemma 5.3.SectionSeqColimitSumRec.Context`{Univalence} {A} (B:FibSequenceA).ContextE(e:forallna,B(n;a) ->E).Context(t:forallna(b:B(n;a)),en.+1 (a^+) (b^+f) =enab).Definitionseq_colim_sum_rec:sig(fib_seq_to_type_famB)->E.Proof.exact(seq_colim_sum_indB_e(funnab=>transport_const__@tnab)).Defined.Definitionseq_colim_sum_rec_beta_glue:forallnab,apseq_colim_sum_rec(ap(seq_colim_sum_to_sum_seq_colimB) (glue(sig_seqB)n(a;b))) =tnab.Proof.introsnab;srapply(cancelL___((apD_const__)^ @_)).srapplyseq_colim_sum_ind_beta_glue.Defined.EndSeqColimitSumRec.Lemma 5.4.Definitionseq_colimit_sum_uniq`{Univalence} {A} (B:FibSequenceA)E(FG:sig(fib_seq_to_type_famB) ->E):Fo(seq_colim_sum_to_sum_seq_colimB) ==Go(seq_colim_sum_to_sum_seq_colimB) ->F==G.Proof.introh;srapply(seq_colim_sum_indB_(fun___=>h_));introsnab.srapply((transport_compose____)^ @_);exact(apDh(glue(sig_seqB)n(a;b))).Defined.The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits is an equivalence; Theorem 5.1.Global Instanceisequiv_seq_colim_sum_to_sum_seq_colim`{Univalence} {A} (B:FibSequenceA):IsEquiv(seq_colim_sum_to_sum_seq_colimB).Proof.assert(L: {G:_&Goseq_colim_sum_to_sum_seq_colimB==idmap}).-srapply(_;_).+srapplyseq_colim_sum_rec.*exact(funnab=>inj(sig_seqB)n(a;b)).*exact(funnab=>glue(sig_seqB)n(a;b)).+srapplyseq_colimit_uniq.*exact(funna=>idpath).*introsna;rewriteconcat_1p,concat_p1,ap_compose,ap_idmap.rewriteseq_colim_sum_rec_beta_glue;reflexivity.-srapply(isequiv_adjointify_L.1_L.2);srapplyseq_colimit_sum_uniq.introx;rewriteL.2;reflexivity.Defined.Definitionequiv_seq_colim_sum_to_sum_seq_colim`{Univalence} {A} (B:FibSequenceA):Colimit(sig_seqB) <~>sig(fib_seq_to_type_famB):=Build_Equiv___(isequiv_seq_colim_sum_to_sum_seq_colimB).The canonical map from the sequential colimit of Sigmas to the Sigma of sequential colimits commutes with the first projection; Theorem 5.1.Definitionseq_colim_sum_to_sum_seq_colim_fst`{Univalence} {A} (B:FibSequenceA):pr1o(seq_colim_sum_to_sum_seq_colimB) ==seq_colim_sum_to_seq_colim_fstB.Proof.srapplyseq_colimit_uniq.-exact(funna=>idpath).-introsn[ab];rewriteconcat_1p,concat_p1,ap_compose, !Colimit_rec_beta_colimp.rewriteap_pp, (Delta_proj_(fib_seq_to_type_fam_beta_glueBna)).srapply(whiskerL__@concat_p1_);rewrite(ap_compose___)^;simpl.rewriteap_const;reflexivity.Defined.The characterization of path spaces in sequential colimits; Theorem 7.4, first part.Definitionpath_seq(A:Sequence) (a1a2:A0):=Build_Sequence(funk=>a1^+k=a2^+k) (funkp=>ap(funa=>a^+)p).Definitionequiv_path_colim_zero`{Univalence} {A:Sequence} (a1a2:A0) :(injA0a1=injA0a2) <~>Colimit(path_seqAa1a2).Proof.pose(B:=Build_FibSequenceA(funx=>a1^+(x.1) =x.2) (funx=>ap(funa=>a^+))).transitivity(fib_seq_to_type_famB(injA0a2)).+symmetry;srapplyequiv_path_from_contr.-exact(inj(fib_seq_to_seqB(0;a1)) 0idpath).-srefine(contr_equiv_(seq_colim_sum_to_sum_seq_colimB)).srapplycontr_colim_contr_seq;introk;srapplycontr_basedpaths.+srapplyequiv_functor_colimit;srefine(transitivity(equiv_fib_seq_to_seqB(0;a2))_).srapplyBuild_diagram_equiv.*srapplyBuild_DiagramMap.-exact(funn=>coe(apB(seq_shift_pair_from_zeroa2n))).-introsnmpb;destructp;srapply(K__(seq_shift_pair_from_zeroa2n)).*exact_.Defined.The characterization of path spaces in sequential colimits; Theorem 7.4, second part.Definitionequiv_path_colim`{Univalence} {A:Sequence}n(a1a2:An) :(injAna1=injAna2) <~>Colimit(path_seq(shift_seqAn)a1a2).Proof.srefine(transitivity_(equiv_path_colim_zero__));symmetry.srapply(@equiv_ap__(colim_shift_seq_to_colim_seqAn)).Defined.OpenScopetrunc_scope.Corollary 7.7.1, second part.Global Instancetrunc_seq_colim`{Univalence} {A:Sequence}k:(foralln,IsTrunck(An)) ->IsTrunck(ColimitA) | 100.Proof.revertA;inductionkas[ |kIHk].-srapplycontr_colim_contr_seq.-introsAtrH;applyistrunc_S;srapplyColimit_ind.+intron;reverttrH;revertA;inductionnas[ |nIHn].*introsAtrHa;srapplyColimit_ind.{introsmb;revertb;reverta;reverttrH;revertA;inductionmas[ |mIHm].{introsAtrHab.srefine(istrunc_equiv_istrunc_(equiv_inverse(equiv_path_colim_ab))). }{introsAtrHab.srefine(istrunc_equiv_istrunc_(equiv_inverse(equiv_concat_l(glueA_a)_))).srapply(@istrunc_equiv_istrunc___k(IHm(succ_seqA)_(@arr_A0%nat_1%patha)b)).srapply(equiv_ap(colim_succ_seq_to_colim_seqA)). }}{introsnmpb;snrapplypath_ishprop;snrapplyishprop_istrunc;exact_. }*introsAtrHa;srapply(functor_forall_equiv_pb(colim_succ_seq_to_colim_seqA)).introx;srapply(@istrunc_equiv_istrunc___k(IHn(succ_seqA)_ax));srapplyequiv_ap.+introsnmpa;snrapplypath_ishprop;snrapplyistrunc_forall.introx;srapplyishprop_istrunc.Defined.

--- Miscellaneous\SetCategory.html ---
SetCategoryLibrary SetCategoryCategory of setsDefinitoins ofset_catandprop_catRequireSetCategory.Core.Morphisms in the category of setsRequireSetCategory.Morphisms.If there were aSetCategory.Functors.Core, we'dIncludeit here.IncludeSetCategory.Core.IncludeSetCategory.Morphisms.Functors to/from the category of setsSinceFunctorsis a separate sub-directory, we need to re-create the module structure.  Alas, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.RequireSetCategory.Functors.

--- Miscellaneous\SetProp.html ---
SetPropLibrary SetPropFunctors betweenset_catandprop_catRequireImportCategory.CoreFunctor.CoreSetCategory.Core.RequireImportBasics.Trunc.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Sectionset_coercions_definitions.Context`{Funext}.VariableC:PreCategory.Definitionto_prop:=FunctorCprop_cat.Definitionto_set:=FunctorCset_cat.Definitionfrom_prop:=Functorprop_catC.Definitionfrom_set:=Functorset_catC.Endset_coercions_definitions.IdentityCoercionto_prop_id:to_prop>->Functor.IdentityCoercionto_set_id:to_set>->Functor.IdentityCoercionfrom_prop_id:from_prop>->Functor.IdentityCoercionfrom_set_id:from_set>->Functor.Sectionset_coercions.Context`{Funext}.VariableC:PreCategory.Functors toprop_catgive rise to functors toset_catDefinitionto_prop2set(F:to_propC) :to_setC:=Build_FunctorCset_cat(funx=>Build_HSet(Fx))(funsdm=> (F_1m)%morphism)(funsdd'mm'=>composition_ofFsdd'mm')(funx=>identity_ofFx).Functors fromset_catgive rise to functors toprop_catDefinitionfrom_set2prop(F:from_setC) :from_propC:=Build_Functorprop_catC(funx=>F(Build_HSetx))(funsdm=> (F_1(m:morphismset_cat(Build_HSets)(Build_HSetd)))%morphism)(funsdd'mm'=>composition_ofF(Build_HSets)(Build_HSetd)(Build_HSetd')mm')(funx=>identity_ofF(Build_HSetx)).Endset_coercions.

--- Miscellaneous\Settings.html ---
SettingsLibrary SettingsGeneral SettingsThis file contains all the tweaks and settings we make to Coq.WarningsPluginsLoad the Ltac plugin. This is the tactic language we use for proofs.DeclareMLModule"ltac_plugin:coq-core.plugins.ltac".Load the number string notation plugin. Allowing us to write numbers like1234.DeclareMLModule"number_string_notation_plugin:coq-core.plugins.number_string_notation".ProofsActivate the Ltac tactics language for proofs.GlobalSetDefaultProofMode"Classic".Force use of bullets in proofs.GlobalSetDefaultGoalSelector"!".UniversesActivate universe polymorphism everywhere. This means that whenever you see aType, it's actually aType@{i}for some universe leveli. This allows us to reuse definitions for each universe level without having to redefine them.GlobalSetUniversePolymorphism.This command makes it so that you don't have to declare universes explicitly when mentioning them in the type.  (Without this command, if you want to sayDefinitionfoo:=Type@{i}., you must instead sayDefinitionfoo@{i}:=Type@{i}..GlobalUnsetStrictUniverseDeclaration.This command makes it so that when we say something likeIsHSetnatwe getIsHSet@{i}natinstead ofIsHSet@{Set}nat.GlobalUnsetUniverseMinimizationToSet.Primitive ProjectionsGlobalSetPrimitiveProjections.GlobalSetNonrecursiveEliminationSchemes.Currently Coq doesn't print equivalences correctly (8.6). This fixes that. See https://github.com/HoTT/HoTT/issues/1000GlobalSetPrintingPrimitiveProjectionParameters.Pattern MatchingThis flag revoves parameters from constructors in patterns that appear in a match statement.GlobalSetAsymmetricPatterns.UnificationThis command changes Coq's subterm selection to always use full conversion after finding a subterm whose head/key matches the key of the term we're looking for.  This applies torewriteand higher-order unification inapply/elim/destruct.  Again, if you don't know what that means, ignore it.GlobalSetKeyedUnification.Typeclasses and Hint settingsThis tells Coq that when weRequirea module withoutImporting it, typeclass instances defined in that module should also not be imported.  In other words, the only effect ofRequirewithoutImportis to make qualified names available.GlobalSetLooseHintBehavior"Strict".Create HintDbrewritediscriminated.#[export]HintVariablesOpaque:rewrite.Create HintDbtypeclass_instancesdiscriminated.Reversible CoercionsCoercions in Coq since 8.16 have the ability to be reversible. These are coercions that are not regular functions but rely on some meta-procedure like typeclass resolution to fill in missing pieces. Examples include marking fields of a record with:>which allows Coq to elaborate the projected term to the original term.This behaviour can have some surprising effects in some places, where you might not expect a term to be elaborated. When inspecting proofs withSetPrintingAllyou will not be able to see the reverisble coercion. In order to help with inspecting such situations, Coq exposes a register for a dummy term calledreverse_coercionwhich gets inserted during an application of a reversible coercion. This way you can see the application clearly in a proof term.We register this here. This is standard from the Coq stdlib prelude.#[universes(polymorphic=yes)]DefinitionReverseCoercionSource(T:Type) :=T.#[universes(polymorphic=yes)]DefinitionReverseCoercionTarget(T:Type) :=T.#[warning="-uniform-inheritance",reversible=no,universes(polymorphic=yes)]Coercionreverse_coercion{T'T} (x':T') (x:ReverseCoercionSourceT):ReverseCoercionTargetT':=x'.Registerreverse_coercionascore.coercion.reverse_coercion.Search SettingsKeywords for blacklisting from search functionAddSearchBlacklist"_admitted" "_subproof" "Private_".

--- Miscellaneous\ShortExactSequence.html ---
ShortExactSequenceLibrary ShortExactSequenceRequireImportBasicsTypes.RequireImportTruncations.Core.RequireImportWildCat.CorePointed.RequireImportGroups.GroupGroups.SubgroupGroups.Kernel.RequireImportHomotopy.ExactSequenceModalities.Identity.Local OpenScopemc_scope.Local OpenScopemc_add_scope.Local OpenScopepath_scope.Complexes of groupsDefinitiongrp_cxfib{ABC:Group} {i:A$->B} {f:B$->C} (cx:IsComplexif):GroupHomomorphismA(grp_kernelf):=grp_kernel_corec_cx.Definitiongrp_iso_cxfib{ABC:Group} {i:A$->B} {f:B$->C}`{IsEmbeddingi} (ex:IsExact(Tr(-1))if):GroupIsomorphismA(grp_kernelf):=Build_GroupIsomorphism__(grp_cxfibcx_isexact) (isequiv_cxfibex).This is the same proof as forequiv_cxfib_beta, but giving the proof is easier than specializing the general result.Propositiongrp_iso_cxfib_beta{ABC:Group} {i:A$->B} {f:B$->C}`{IsEmbeddingi} (ex:IsExact(Tr(-1))if):i$o(grp_iso_inverse(grp_iso_cxfibex)) $==subgroup_incl(grp_kernelf).Proof.rapplyequiv_ind.1:exact(isequiv_cxfibex).introx.exact(ap(funy=>iy) (eissect_x)).Defined.Definitiongrp_iscomplex_trivial{XY:Group} (f:X$->Y):IsComplex(grp_trivial_recX)f.Proof.srapplyphomotopy_homotopy_hset.introx;cbn.exact(grp_homo_unitf).Defined.A complex 0 -> A -> B of groups is purely exact if and only if the map A -> B is an embedding.Lemmaiff_grp_isexact_isembedding{AB:Group} (f:A$->B):IsExactpurely(grp_trivial_recA)f<->IsEmbeddingf.Proof.split.-introsexb.applyhprop_inhabited_contr;introa.rapply(contr_equiv'grp_trivial).exact((equiv_grp_hfiberfba)^-1oEpequiv_cxfib).-introisemb_f.exists(grp_iscomplex_trivialf).introsy;rapplycontr_inhabited_hprop.existstt;applypath_ishprop.Defined.A complex 0 -> A -> B is purely exact if and only if the kernel of the map A -> B is trivial.Definitionequiv_grp_isexact_kernel`{Univalence} {AB:Group} (f:A$->B):IsExactpurely(grp_trivial_recA)f<~> (grp_kernelf=trivial_subgroup:>Subgroup_):= (equiv_kernel_isembeddingf)^-1%equivoEequiv_iff_hprop_uncurried(iff_grp_isexact_isembeddingf).

--- Miscellaneous\Sigma.html ---
SigmaLibrary SigmaRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.Indexed sum of categoriesSectionSigma.Context(A:Type) (B:A->Type)`{foralla,IsGraph(Ba)}`{foralla,Is01Cat(Ba)}`{foralla,Is0Gpd(Ba)}.Global Instanceisgraph_sigma:IsGraph(sigB).Proof.srapplyBuild_IsGraph.intros[xu] [yv].exact{p:x=y&p#u$->v}.Defined.Global Instanceis01cat_sigma:Is01Cat(sigB).Proof.srapplyBuild_Is01Cat.+intros[xu].existsidpath.exact(Idu).+intros[xu] [yv] [zw] [qg] [pf].exists(p@q).destructp,q;cbnin*.exact(g$of).Defined.Global Instanceis0gpd_sigma:Is0Gpd(sigB).Proof.constructor.intros[xu] [yv] [pf].exists(p^).destructp;cbnin*.exact(f^$).Defined.EndSigma.Global Instanceis0functor_sigma{A:Type} (BC:A->Type)`{foralla,IsGraph(Ba)} `{foralla,IsGraph(Ca)}`{foralla,Is01Cat(Ba)} `{foralla,Is01Cat(Ca)}(F:foralla,Ba->Ca) {ff:foralla,Is0Functor(Fa)}:Is0Functor(fun(x:sigB) => (x.1 ;Fx.1x.2)).Proof.constructor;intros[a1b1] [a2b2] [pf];cbn.existsp.destructp;cbnin*.exact(fmap(Fa1)f).Defined.

--- Miscellaneous\SimplicialSets.html ---
SimplicialSetsLibrary SimplicialSetsThe simplex category Δ, and the precategory of simplicial sets,Δᵒᵖ→setRequireImportBasicsTypesSpaces.Nat.Core.RequireImportCategory.CoreFunctor.CoreFunctor.Paths.RequireImportSetCategory.Core.RequireImportChainCategoryFunctorCategory.Core.RequireImportCategory.Dual.RequireImportFunctor.IdentityFunctor.Composition.CoreFunctor.Composition.Laws.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopefunctor_scope.Local OpenScopecategory_scope.We define the precategory Δ of simplexes, or finite non-empty linear
    ordersModuleExportCore.Sectionsimplicial_sets.Context`{Funext}.We say that the objects of Δ are natural numbers, where a
        numbernis morally considered as the canonicaln-simplex,
        a finite linear order onn+1elements.  By declaringchainto be a local coercion fromnattoPreCategory, we
        can rely on on-the-fly eta-expansion to make this moral
        consideration a reality, telling Coq that it can unify, for
        example,nat->nat->TypewithPreCategory->PreCategory->Typeby silently insertingchain.Local Coercionchain:nat>->PreCategory.Definitionsimplex_category:= @Build_PreCategorynatFunctoridentitycomposeassociativityleft_identityright_identity_.Definitionsimplicial_category(C:PreCategory) :PreCategory:=simplex_category^op->C.Definitionsimplicial_set:=simplicial_categoryset_cat.Definitionsimplicial_prop:=simplicial_categoryprop_cat.Endsimplicial_sets.Notationsimplicial_ofobj:= (simplicial_category(cat_ofobj)).EndCore.ModuleUtf8.NotationΔ:=simplex_category.EndUtf8.

--- Miscellaneous\SixTerm.html ---
SixTermLibrary SixTermRequireImportBasicsTypesWildCatHSetPointed.CorePointed.pTruncPointed.pEquivModalities.ReflectiveSubuniverseTruncations.CoreTruncations.SeparatedTruncAbGroupsHomotopy.ExactSequenceSpaces.IntSpaces.FreeIntAbSES.CoreAbSES.PullbackAbSES.PushoutBaerSumExtPullbackFiberSequence.The contravariant six-term sequence of ExtWe construct the contravariant six-term exact sequence of Ext groups associated to any short exact sequenceA->E->Band coefficient groupG. The existence of this exact sequence follows from the final result inPullbackFiberSequence. However, with that definition it becomes a bit tricky to show that the connecting map is given by pushing outE. Instead, we give a direct proof.As an application, we use the six-term exact sequence to show thatExtZ/nAis isomorphic toA/n, for nonzero natural numbersn. (Seeext_cyclic_ab.)Exactness of0->ab_homBG->ab_homEGfollows from the rightmost map being an embedding.Definitionisexact_abses_sixterm_i`{Funext}{BAG:AbGroup} (E:AbSESBA):IsExact(Tr(-1))(pconst:pUnit->*ab_homBG)(fmap10(A:=Group^op)ab_hom(projectionE)G).Proof.applyisexact_purely_O.rapplyisexact_homotopic_i.2:applyiff_grp_isexact_isembedding.1:byapplyphomotopy_homotopy_hset.exact_.(*isembedding_precompose_surjection_ab*)Defined.Exactness ofab_homBG->ab_homEG->ab_homAG. One can also deduce this fromisexact_abses_pullback.Definitionisexact_ext_contra_sixterm_ii`{Funext}{BAG:AbGroup} (E:AbSESBA):IsExact(Tr(-1))(fmap10(A:=Group^op)ab_hom(projectionE)G)(fmap10(A:=Group^op)ab_hom(inclusionE)G).Proof.snrapplyBuild_IsExact.{applyphomotopy_homotopy_hset;introf.applyequiv_path_grouphomomorphism;introb;cbn.refine(apf_@grp_homo_unitf).applyisexact_inclusion_projection. }hnf.intros[fq];rapplycontr_inhabited_hprop.srefine(tr(_;_)).{refine(grp_homo_compose_(abses_cokernel_iso(inclusionE) (projectionE))^-1$).apply(quotient_abgroup_rec__f).introse;rapplyTrunc_ind.intros[br].refine(apfr^ @_).exact(equiv_path_grouphomomorphism^-1q_). }lazybeta.applypath_sigma_hprop.applyequiv_path_grouphomomorphism;unfoldpr1.introx.exact(ap(quotient_abgroup_rec__f_)(abses_cokernel_iso_inv_beta___)).Defined.Exactness ofab_homEG->ab_homAG->ExtBGIf a pushoutabses_pushoutalphaEis trivial, thenalphafactors throughinclusionE.Lemmaabses_pushout_trivial_factors_inclusion`{Univalence}{BAA':AbGroup} (alpha:A$->A') (E:AbSESBA):abses_pushoutalphaE=pt->existsphi,alpha=phi$oinclusionE.Proof.equiv_intros(equiv_path_abses(E:=abses_pushoutalphaE) (F:=pt))p.destructpas[phi[pq]].exists(ab_biprod_pr1$ophi$oab_pushout_inr).applyequiv_path_grouphomomorphism;introa.(* We embed into the biproduct and prove equality there. *)apply(isinj_embedding(@ab_biprod_inlA'B)_).refine((p(alphaa))^ @_).refine(apphi_@_).1:exact(left_square(abses_pushout_morphismEalpha)a).apply(path_prod'idpath).refine((q_)^ @_).refine(right_square(abses_pushout_morphismEalpha)_@_);cbn.applyisexact_inclusion_projection.Defined.Global Instanceisexact_ext_contra_sixterm_iii@{uv+} `{Univalence}{BAG:AbGroup@{u}} (E:AbSES@{uv}BA):IsExact(Tr(-1))(fmap10(A:=Group^op)ab_hom(inclusionE)G)(abses_pushout_extE).Proof.snrapplyBuild_IsExact.-applyphomotopy_homotopy_hset;introg;cbn.(* this equation holds purely *)apply(aptr@{v}).refine(abses_pushout_compose___@ap__@_).1:applyabses_pushout_inclusion.applyabses_pushout_point.-intros[Fp].(* since we are proving a proposition, we may convertpto an actual path *)poseproof(p':= (equiv_path_Tr__)^-1p).(* slightly faster thanstrip_truncations: *)revertp';applyTrunc_rec;introp'.rapplycontr_inhabited_hprop;applytr.(* now we construct a preimage *)pose(g:=abses_pushout_trivial_factors_inclusion_Ep');destructgas[gk].existsg.applypath_sigma_hprop;cbn.exactk^.Defined.Exactness ofab_homAG->Ext1BG->Ext1EG.We construct a morphism which witnesses exactness.Definitionisexact_ext_contra_sixterm_iv_mor`{Univalence}{BAG:AbGroup} (E:AbSESBA)(F:AbSESBG) (p:abses_pullback(projectionE)F=pt):AbSESMorphismEF.Proof.pose(p':=equiv_path_abses^-1p^);destructp'as[p'[plpr]].srefine(Build_AbSESMorphism__grp_homo_id__).-refine(grp_homo_compose(grp_iso_inverse(abses_kernel_iso(inclusionF) (projectionF)))_).(* now it's easy to construct map into the kernel *)snrapplygrp_kernel_corec.1:exact(grp_pullback_pr1__$op'$oab_biprod_inr$oinclusionE).introx.refine(right_square(abses_pullback_morphismF_)_@_).refine(ap(projectionE) (pr_)^ @_);cbn.applyisexact_inclusion_projection.-exact(grp_pullback_pr1__$op'$oab_biprod_inr).-introa.nrapplyabses_kernel_iso_inv_beta.-introe.refine(right_square(abses_pullback_morphismF_)_@ap(projectionE)_).exact(pr_)^.Defined.Global Instanceisexact_ext_contra_sixterm_iv`{Univalence}{BAG:AbGroup@{u}} (E:AbSES@{uv}BA):IsExact(Tr(-1)) (abses_pushout_extE)(fmap(pTr0) (abses_pullback_pmap(A:=G) (projectionE))).Proof.snrapplyBuild_IsExact.-applyphomotopy_homotopy_hset;introg;cbn.(* this equation holds purely *)apply(aptr@{v}).refine((abses_pushout_pullback_reorder___)^@ap__@_).1:exact(abses_pullback_projection_)^.applyabses_pushout_point.(* since we are proving a proposition, we may convertpto an actual path *)-intros[Fp].revertdependentF;nrapply(Trunc_ind(n:=0) (A:=AbSESBG)).(*exact_.works here, but is slow. *){introx;nrapplyistrunc_forall.introy;rapply(istrunc_leq(trunc_index_leq_succ_)). }introF.equiv_intros(equiv_path_Tr(n:=-1) (abses_pullback(projectionE)F)pt)p.strip_truncations.rapplycontr_inhabited_hprop;applytr.pose(g:=isexact_ext_contra_sixterm_iv_morEFp).exists(component1g).applypath_sigma_hprop, (aptr).byrapply(abses_pushout_component3_idg).Defined.Exactness ofExtBG->ExtEG->ExtAGThis is an immediate consequence ofisexact_abses_pullback.Global Instanceisexact_ext_contra_sixterm_v`{Univalence}{BAG:AbGroup} (E:AbSESBA):IsExact(Tr(-1))(fmap(pTr0) (abses_pullback_pmap(A:=G) (projectionE)))(fmap(pTr0) (abses_pullback_pmap(A:=G) (inclusionE))).Proof.rapplyisexact_ptr.rapplyisexact_purely_O.Defined.ExtZ/nAis isomorphic toA/nAn easy consequence of the contravariant six-term exact sequence is thatExtZ/nAis isomorphic to the cokernel of the multiplication-by-n endomorphismA->A, for any abelian groupA. This falls out of the six-term exact sequence associated toZ->Z->Z/nand projectivity ofZ. A minor point is that the library does not currently contain a proof that multiplication by a nonzero natural number is a self-injection ofZ. Thus we work directly with the assumption thatZ1_mul_natnis an embedding.We define our own cyclic groups usingab_cokernel_embeddingunder the assumption thatZ1_mul_natnis an embedding.Definitioncyclic'`{Funext} (n:nat) `{IsEmbedding(Z1_mul_natn)}:AbGroup:=ab_cokernel_embedding(Z1_mul_natn).We first show thatab_homZA->ab_homZA->Ext(cyclicn)Ais exact. We could inline the proof below, but factoring it out is faster.Local Definitionisexact_ext_cyclic_ab_iii@{uvw|u<v,v<w} `{Univalence}(n:nat) `{IsEmbedding(Z1_mul_natn)} {A:AbGroup@{u}}:IsExact(Tr(-1))(fmap10(A:=Group^op)ab_hom(Z1_mul_natn)A)(abses_pushout_ext(abses_from_inclusion(Z1_mul_natn))):=isexact_ext_contra_sixterm_iii(abses_from_inclusion(Z1_mul_natn)).We show exactness ofA->A->ExtZ/nAwhere the first map is multiplication byn, but considered in universev.Local Definitionext_cyclic_exact@{uvw} `{Univalence}(n:nat) `{IsEmbedding(Z1_mul_natn)} {A:AbGroup@{u}}:IsExact@{vvvvv} (Tr(-1))(ab_mul(A:=A)n)(abses_pushout_ext@{uwv} (abses_from_inclusion(Z1_mul_natn))o* (pequiv_groupisomorphism(equiv_Z1_homA))^-1*).Proof.(* we first moveequiv_Z1_homacross the total space *)applymoveL_isexact_equiv.(* now we change the left map so as to apply exactness at iii from above *)snrapply(isexact_homotopic_i(Tr(-1))).1:exact(fmap10(A:=Group^op)ab_hom(Z1_mul_natn)Ao*(pequiv_inverse(pequiv_groupisomorphism(equiv_Z1_homA)))).-applyphomotopy_homotopy_hset.rapply(equiv_ind(equiv_Z1_homA));introf.refine(_@ap_(eissect__)^).applymoveR_equiv_V;symmetry.refine(apf_@_).1:applyZ1_rec_beta.exact(ab_mul_naturalfnZ1_gen).-(* we get rid ofequiv_Z1_hom*)applyisexact_equiv_fiber.applyisexact_ext_cyclic_ab_iii.Defined.The main result of this section.Theoremext_cyclic_ab@{uvw|u<v,v<w} `{Univalence}(n:nat) `{emb:IsEmbedding(Z1_mul_natn)} {A:AbGroup@{u}}:ab_cokernel@{vw} (ab_mul(A:=A)n)$<~>ab_ext@{uv} (cyclic'@{uv}n)A.(* We take a large cokernel in order to applyabses_cokernel_iso. *)Proof.pose(E:=abses_from_inclusion(Z1_mul_natn)).snrefine(abses_cokernel_iso(ab_muln)_).-exact(grp_homo_compose(abses_pushout_extE)(grp_iso_inverse(equiv_Z1_homA))).-apply(conn_map_compose_(grp_iso_inverse(equiv_Z1_homA))).1:rapplyconn_map_isequiv.(* Coq knows thatExtZ1Ais contractible sinceZ1is projective, so exactness at spot iv gives us this: *)exact(isconnmap_O_isexact_base_contr__(fmap(pTr0)(abses_pullback_pmap(A:=A)(projectionE)))).-(* we changegrp_homo_composetoo**)srapplyisexact_homotopic_f.1:exact(abses_pushout_ext(abses_from_inclusion(Z1_mul_natn))o* (pequiv_groupisomorphism(equiv_Z1_homA))^-1*).1:byapplyphomotopy_homotopy_hset.applyext_cyclic_exact.Defined.

--- Miscellaneous\Smallness.html ---
SmallnessLibrary SmallnessRequireImportBasics.OvertureBasics.EquivalencesBasics.TruncBasics.TacticsBasics.NatTypes.UnitTypes.SigmaTypes.UniverseTypes.EquivHFiber.SetUniverseMinimizationToSet.Facts about "small" typesThis closely follows Section 2 of the paper "Non-accessible localizations", by Dan Christensen, https://arxiv.org/abs/2109.06670Universe variables:  we most often use a subset ofijku.  We think ofType@{i}as containing the "small" types andType@{j}the "large" types.  In some early results, there are no constraints betweeniandj, and in others we require thati<=j, as expected.  While the casei=jisn't particularly interesting, we put some effort into ensuring that it is permitted as well, as there is no semantic reason to exclude it.  The universe variablekshould be thought of as max(i+1,j), and it is generally required to satisfyi<kandj<=k.  If we assume thati<j, then we can takek=j, but we includekso that we also allow the casei=j.  The universe variableuis only present because we occasionally use Univalence inType@{k}, so the equality types need a larger universe to live in.  Because of this, most results requirek<u.Summary of the most common situation:i<k<u,j<=k, whereiis for the small types,jis for the large types,k=max(i+1,j)anduis an ambient universe for Univalence.We include universe annotations when they clarify the meaning (e.g. inIsSmalland when usingPropResizing), and also when it is required in order to keep control of the universe variables.Note thatIsSmallis defined in Overture.v.Global Instanceishprop_issmall@{ijk|i<k,j<=k}`{Univalence} (X:Type@{j}):IsHProp(IsSmall@{ij}X).Proof.applyhprop_inhabited_contr.intros[Ze].(*IsSmallXis equivalent toIsSmallZ, which is contractible since it is a based path space. *)rapply(istrunc_equiv_istrunc{Y:Type@{i} &Y<~>Z}_).equiv_via(sig@{kk} (funY:Type@{i} =>Y<~>X)).2:issig.applyequiv_functor_sigma_id.introY.exact(equiv_functor_postcompose_equivYe).Defined.A type inType@{i}is clearly small.Global Instanceissmall_in@{ij|i<=j} (X:Type@{i}) :IsSmall@{ij}X| 10:=Build_IsSmallXXequiv_idmap.The small types are closed under equivalence.Definitionissmall_equiv_issmall@{i1j1i2j2|i1<=i2} {A:Type@{j1}} {B:Type@{j2}}(e:A<~>B) (sA:IsSmall@{i1j1}A):IsSmall@{i2j2}B.Proof.exists(smalltypeA).exact(eoE(equiv_smalltypeA)).Defined.The small types are closed under dependent sums.Definitionsigma_closed_issmall@{ij| } {A:Type@{j}}(B:A->Type@{j}) (sA:IsSmall@{ij}A)(sB:foralla,IsSmall@{ij} (Ba)):IsSmall@{ij} {a:A&Ba}.Proof.exists{a: (smalltypeA) & (smalltype(B(equiv_smalltypeAa))) }.snrapplyequiv_functor_sigma';intros;applyequiv_smalltype.Defined.If a map has small codomain and fibers, then the domain is small.Definitionissmall_issmall_codomain_fibers@{ij| } {XY:Type@{j}}(f:X->Y)(sY:IsSmall@{ij}Y)(sF:forally:Y,IsSmall@{ij} (hfiberfy)):IsSmall@{ij}X.Proof.nrapplyissmall_equiv_issmall.-exact(equiv_fibration_replacementf)^-1%equiv.-applysigma_closed_issmall;assumption.Defined.Every contractible type is small.Definitionissmall_contr@{ij| } (X:Type@{j}) (T:ContrX):IsSmall@{ij}X:=issmall_equiv_issmall(equiv_contr_unit)^-1_.If we can show thatXis small when it is inhabited, then it is in fact small. This is Remark 2.9 in the paper. It lets us simplify the statement of Proposition 2.8. Note that this implies propositional resizing, so thePropResizingassumption is necessary.Definitionissmall_inhabited_issmall@{ijk|i<k,j<=k} `{PropResizing} `{Univalence}(X:Type@{j})(isX:X->IsSmall@{ij}X):IsSmall@{ij}X.Proof.(* SinceIsSmallis cumulative in the universej, it suffices to proveIsSmall@{ik}Xforkthe universe thatIsSmall@{ij}lives in.  We think ofkas max(i+1,j). *)rapply(issmall_issmall_codomain_fibers@{ik}isX).introsX.rapplysigma_closed_issmall.Defined.If a typeXis truncated, then so issmalltypeX.Global Instanceistrunc_smalltype@{ij| } (X:Type@{j}) (n:trunc_index)`{IsSmall@{ij}X,IsTruncnX}:IsTruncn(smalltypeX):=istrunc_equiv_istruncX(equiv_smalltype@{ij}X)^-1%equiv.Locally small typesWe say that a typeXis 0-locally small if it is small, and (n+1)-locally small if its identity types are n-locally small.(* TODO: Can we make this an inductive type and avoid the extra universe variablek? *)FixpointIsLocallySmall@{ijk|i<k,j<=k} (n:nat) (X:Type@{j}) :Type@{k}:=matchnwith| 0%nat=>IsSmall@{ij}X|Sm=>forallxy:X,IsLocallySmallm(x=y)end.Existing ClassIsLocallySmall.Hint UnfoldIsLocallySmall:typeclass_instances.Global Instanceishprop_islocallysmall@{ijk|i<k,j<=k} `{Univalence}(n:nat) (X:Type@{j}):IsHProp@{k} (IsLocallySmall@{ijk}nX).Proof.(* Here and later we usesimple_inductionto control the universe variable. *)revertX;simple_inductionnnIHn;exact_.Defined.A small type is n-locally small for alln.Global Instanceislocallysmall_in@{ijk|i<=j,j<=k,i<k}(n:nat) (X:Type@{i}):IsLocallySmall@{ijk}nX.Proof.revertX.inductionn;introX.-applyissmall_in.-introsxy.exact(IHn(x=y)).Defined.The n-locally small types are closed under equivalence.Definitionislocallysmall_equiv_islocallysmall@{ij1j2k|i<k,j1<=k,j2<=k}(n:nat) {A:Type@{j1}} {B:Type@{j2}}(e:A<~>B) (lsA:IsLocallySmall@{ij1k}nA):IsLocallySmall@{ij2k}nB.Proof.revertABelsA.simple_inductionnnIHn.-exact@issmall_equiv_issmall.-introsABelsAbb'.nrapplyIHn.*exact(equiv_ap'(e^-1%equiv)bb')^-1%equiv.*applylsA.Defined.A small type is n-locally small for all n.Global Instanceislocallysmall_issmall@{ijk|i<k,j<=k} (n:nat)(X:Type@{j}) (sX:IsSmall@{ij}X):IsLocallySmall@{ijk}nX:=islocallysmall_equiv_islocallysmalln(equiv_smalltypeX)_.If a type is n-locally small, then it is (n+1)-locally small.Global Instanceislocallysmall_succ@{ijk|i<k,j<=k} (n:nat)(X:Type@{j}) (lsX:IsLocallySmall@{ijk}nX):IsLocallySmall@{ijk}n.+1X.Proof.revertXlsX;simple_inductionnnIHn;introsX.-applyislocallysmall_issmall.-introlsX.introsxy.applyIHn,lsX.Defined.The n-locally small types are closed under dependent sums.Global Instancesigma_closed_islocallysmall@{ijk|i<k,j<=k}(n:nat) {A:Type@{j}} (B:A->Type@{j})(lsA:IsLocallySmall@{ijk}nA)(lsB:foralla,IsLocallySmall@{ijk}n(Ba)):IsLocallySmall@{ijk}n{a:A&Ba}.Proof.revertABlsAlsB.simple_inductionnnIHn.-exact@sigma_closed_issmall.-introsABlsAlsBxy.apply(islocallysmall_equiv_islocallysmalln(equiv_path_sigma_xy)).applyIHn.*applylsA.*introp.applylsB.Defined.If a map has n-locally small codomain and fibers, then the domain is n-locally small.Definitionislocallysmall_islocallysmall_codomain_fibers@{ijk|i<k,j<=k}(n:nat) {XY:Type@{j}} (f:X->Y)(sY:IsLocallySmall@{ijk}nY)(sF:forally:Y,IsLocallySmall@{ijk}n(hfiberfy)):IsLocallySmall@{ijk}nX.Proof.nrapplyislocallysmall_equiv_islocallysmall.-exact(equiv_fibration_replacementf)^-1%equiv.-applysigma_closed_islocallysmall;assumption.Defined.Under propositional resizing, every (n+1)-truncated type is (n+2)-locally small. This is Lemma 2.3 in the paper.Global Instanceislocallysmall_trunc@{ijk|i<k,j<=k} `{PropResizing}(n:trunc_index) (X:Type@{j}) (T:IsTruncn.+1X):IsLocallySmall@{ijk} (trunc_index_to_natn)X.Proof.revertnXT.simple_inductionnnIHn;cbn.-nrapplyissmall_hprop@{ij}.-introsXTxy.rapplyIHn.Defined.

--- Miscellaneous\Smash.html ---
SmashLibrary SmashRequireImportBasics.OvertureBasics.PathGroupoidsBasics.TacticsBasics.Equivalences.RequireImportTypes.SumTypes.BoolTypes.PathsTypes.Forall.RequireImportWildCat.CoreWildCat.BifunctorWildCat.Equiv.RequireImportColimits.Pushout.RequireImportCubical.DPath.RequireImportPointed.Core.Local OpenScopepointed_scope.Local OpenScopedpath_scope.Local OpenScopepath_scope.(* Definition of smash product *)Definitionsum_to_prod(XY:pType) :X+Y->X*Y:=sum_ind_(funx=> (x,pointY)) (funy=> (pointX,y)).Definitionsum_to_boolXY:X+Y->Bool:=sum_ind_(fun_=>false) (fun_=>true).DefinitionSmash@{uvw|u<=w,v<=w} (X:pType@{u}) (Y:pType@{v}) :pType@{w}:= [Pushout@{wwww} (sum_to_prod@{www}XY) (sum_to_bool@{uvw}XY),pushl(pointX,pointY)].SectionSmash.Context{XY:pType}.Definitionsm(x:X) (y:Y) :SmashXY:=pushl(x,y).Definitionauxl:SmashXY:=pushrfalse.Definitionauxr:SmashXY:=pushrtrue.Definitiongluel(x:X) :smxpt=auxl:=pglue(f:=sum_to_prodXY) (g:=sum_to_boolXY) (inlx).Definitiongluer(y:Y) :smpty=auxr:=pglue(f:=sum_to_prodXY) (g:=sum_to_boolXY) (inry).Definitiongluel'(xx':X) :smxpt=smx'pt:=gluelx@ (gluelx')^.Definitiongluer'(yy':Y) :smpty=smpty':=gluery@ (gluery')^.Definitionglue(x:X) (y:Y) :smxpt=smpty:=gluel'xpt@gluer'pty.Definitionglue_pt_left(y:Y) :gluepty=gluer'pty.Proof.refine(_@concat_1p_).applywhiskerR,concat_pV.Defined.Definitionglue_pt_right(x:X) :gluexpt=gluel'xpt.Proof.refine(_@concat_p1_).applywhiskerL,concat_pV.Defined.Definitionap_sm_left{xx':X} (p:x=x'):ap(funt=>smtpt)p=gluel'xx'.Proof.destructp.symmetry.applyconcat_pV.Defined.Definitionap_sm_right{yy':Y} (p:y=y'):ap(smpt)p=gluer'yy'.Proof.destructp.symmetry.applyconcat_pV.Defined.DefinitionSmash_ind{P:SmashXY->Type}(Psm:forallab,P(smab)) (Pl:Pauxl) (Pr:Pauxr)(Pgl:foralla,DPathP(gluela) (Psmapt)Pl)(Pgr:forallb,DPathP(gluerb) (Psmptb)Pr):forallx:SmashXY,Px.Proof.srapplyPushout_ind.+intros[ab].applyPsm.+apply(Bool_ind_PrPl).+srapplysum_ind.-applyPgl.-applyPgr.Defined.DefinitionSmash_ind_beta_gluel{P:SmashXY->Type}{Psm:forallab,P(smab)} {Pl:Pauxl} {Pr:Pauxr}(Pgl:foralla,DPathP(gluela) (Psmapt)Pl)(Pgr:forallb,DPathP(gluerb) (Psmptb)Pr) (a:X):apD(Smash_indPsmPlPrPglPgr) (gluela) =Pgla:=Pushout_ind_beta_pglueP___(inla).DefinitionSmash_ind_beta_gluer{P:SmashXY->Type}{Psm:forallab,P(smab)} {Pl:Pauxl} {Pr:Pauxr}(Pgl:foralla,DPathP(gluela) (Psmapt)Pl)(Pgr:forallb,DPathP(gluerb) (Psmptb)Pr) (b:Y):apD(Smash_indPsmPlPrPglPgr) (gluerb) =Pgrb:=Pushout_ind_beta_pglueP___(inrb).DefinitionSmash_ind_beta_gluel'{P:SmashXY->Type}{Psm:forallab,P(smab)} {Pl:Pauxl} {Pr:Pauxr}(Pgl:foralla,DPathP(gluela) (Psmapt)Pl)(Pgr:forallb,DPathP(gluerb) (Psmptb)Pr) (ab:X):apD(Smash_indPsmPlPrPglPgr) (gluel'ab)= (Pgla) @Dp((Pglb)^D).Proof.lhsnrapplydp_apD_pp.applyap011.1:applySmash_ind_beta_gluel.lhsnrapplydp_apD_V.applyap.applySmash_ind_beta_gluel.Defined.DefinitionSmash_ind_beta_gluer'{P:SmashXY->Type}{Psm:forallab,P(smab)} {Pl:Pauxl} {Pr:Pauxr}(Pgl:foralla,DPathP(gluela) (Psmapt)Pl)(Pgr:forallb,DPathP(gluerb) (Psmptb)Pr) (ab:Y):apD(Smash_indPsmPlPrPglPgr) (gluer'ab)= (Pgra) @Dp((Pgrb)^D).Proof.lhsnrapplydp_apD_pp.applyap011.1:applySmash_ind_beta_gluer.lhsnrapplydp_apD_V.applyap.applySmash_ind_beta_gluer.Defined.DefinitionSmash_ind_beta_glue{P:SmashXY->Type}{Psm:forallab,P(smab)} {Pl:Pauxl} {Pr:Pauxr}(Pgl:foralla,DPathP(gluela) (Psmapt)Pl)(Pgr:forallb,DPathP(gluerb) (Psmptb)Pr) (a:X) (b:Y):apD(Smash_indPsmPlPrPglPgr) (glueab)= ((Pgla) @Dp((Pglpt)^D)) @Dp((Pgrpt) @Dp((Pgrb)^D)).Proof.lhsnrapplydp_apD_pp.applyap011.-applySmash_ind_beta_gluel'.-applySmash_ind_beta_gluer'.Defined.DefinitionSmash_rec{P:Type} (Psm:X->Y->P) (PlPr:P)(Pgl:foralla,Psmapt=Pl) (Pgr:forallb,Psmptb=Pr):SmashXY->P:=Smash_indPsmPlPr(funx=>dp_const(Pglx)) (funx=>dp_const(Pgrx)).(* Version of smash_rec that forces (Pgl pt) and (Pgr pt) to be idpath *)DefinitionSmash_rec'{P:Type} {Psm:X->Y->P}(Pgl:foralla,Psmapt=Psmptpt) (Pgr:forallb,Psmptb=Psmptpt)(ql:Pglpt= 1) (qr:Pgrpt= 1):SmashXY->P:=Smash_recPsm(Psmptpt) (Psmptpt)PglPgr.DefinitionSmash_rec_beta_gluel{P:Type} {Psm:X->Y->P} {PlPr:P}(Pgl:foralla,Psmapt=Pl) (Pgr:forallb,Psmptb=Pr) (a:X):ap(Smash_recPsmPlPrPglPgr) (gluela) =Pgla.Proof.rhs_Vnrapply(eissectdp_const).applymoveL_equiv_V.lhs_Vnrapplydp_apD_const.nrapplySmash_ind_beta_gluel.Defined.DefinitionSmash_rec_beta_gluer{P:Type} {Psm:X->Y->P} {PlPr:P}(Pgl:foralla,Psmapt=Pl) (Pgr:forallb,Psmptb=Pr) (b:Y):ap(Smash_recPsmPlPrPglPgr) (gluerb) =Pgrb.Proof.rhs_Vnrapply(eissectdp_const).applymoveL_equiv_V.lhs_Vnrapplydp_apD_const.nrapplySmash_ind_beta_gluer.Defined.DefinitionSmash_rec_beta_gluel'{P:Type} {Psm:X->Y->P} {PlPr:P}(Pgl:foralla,Psmapt=Pl) (Pgr:forallb,Psmptb=Pr) (ab:X):ap(Smash_recPsmPlPrPglPgr) (gluel'ab) =Pgla@ (Pglb)^.Proof.lhsnrapplyap_pp.f_ap.1:applySmash_rec_beta_gluel.lhsnrapplyap_V.applyinverse2.applySmash_rec_beta_gluel.Defined.DefinitionSmash_rec_beta_gluer'{P:Type} {Psm:X->Y->P} {PlPr:P}(Pgl:foralla,Psmapt=Pl) (Pgr:forallb,Psmptb=Pr) (ab:Y):ap(Smash_recPsmPlPrPglPgr) (gluer'ab) =Pgra@ (Pgrb)^.Proof.lhsnrapplyap_pp.f_ap.1:applySmash_rec_beta_gluer.lhsnrapplyap_V.applyinverse2.applySmash_rec_beta_gluer.Defined.DefinitionSmash_rec_beta_glue{P:Type} {Psm:X->Y->P} {PlPr:P}(Pgl:foralla,Psmapt=Pl) (Pgr:forallb,Psmptb=Pr) (a:X)(b:Y) :ap(Smash_recPsmPlPrPglPgr) (glueab)= ((Pgla) @ (Pglpt)^) @ (Pgrpt@ (Pgrb)^).Proof.lhsnrapplyap_pp.f_ap.-applySmash_rec_beta_gluel'.-applySmash_rec_beta_gluer'.Defined.EndSmash.Argumentssm:simplnever.Argumentsauxl:simplnever.Argumentsgluel:simplnever.Argumentsgluer:simplnever.Miscellaneous lemmas about SmashA version ofSmash_indspecifically for proving that two functions from aSmashare homotopic.DefinitionSmash_ind_FlFr{AB:pType} {P:Type} (fg:SmashAB->P)(Hsm:forallab,f(smab) =g(smab))(Hl:fauxl=gauxl) (Hr:fauxr=gauxr)(Hgluel:foralla,apf(gluela) @Hl=Hsmapt@apg(gluela))(Hgluer:forallb,apf(gluerb) @Hr=Hsmptb@apg(gluerb)):f==g.Proof.snrapply(Smash_indHsmHlHr).-introsa.nrapplytransport_paths_FlFr'.exact(Hgluela).-introsb.nrapplytransport_paths_FlFr'.exact(Hgluerb).Defined.A version ofSmash_indj specifically for proving that the composition of two functions is the identity map.DefinitionSmash_ind_FFlr{AB:pType} {P:Type}(f:SmashAB->P) (g:P->SmashAB)(Hsm:forallab,g(f(smab)) =smab)(Hl:g(fauxl) =auxl) (Hr:g(fauxr) =auxr)(Hgluel:foralla,apg(apf(gluela)) @Hl=Hsmapt@gluela)(Hgluer:forallb,apg(apf(gluerb)) @Hr=Hsmptb@gluerb):gof==idmap.Proof.snrapply(Smash_indHsmHlHr).-introsa.nrapply(transport_paths_FFlr'(f:=f) (g:=g)).exact(Hgluela).-introsb.nrapply(transport_paths_FFlr'(f:=f) (g:=g)).exact(Hgluerb).Defined.Functoriality of the smash productDefinitionfunctor_smash{ABXY:pType} (f:A$->X) (g:B$->Y):SmashAB$->SmashXY.Proof.srapplyBuild_pMap.-snrapply(Smash_rec(funab=>sm(fa) (gb))auxlauxr).+introa;cbnbeta.rhs_Vnrapply(gluel(fa)).exact(ap011_1 (point_eqg)).+introb;cbnbeta.rhs_Vnrapply(gluer(gb)).exact(ap011_(point_eqf) 1).-exact(ap011_(point_eqf) (point_eqg)).Defined.Definitionfunctor_smash_idmap(XY:pType):functor_smash(@pmap_idmapX) (@pmap_idmapY) $==pmap_idmap.Proof.snrapplyBuild_pHomotopy.{snrapplySmash_ind_FlFr.1-3:reflexivity.-introsx.applyequiv_p1_1q.rhsnrapplyap_idmap.lhsnrapplySmash_rec_beta_gluel.applyconcat_1p.-introsy.applyequiv_p1_1q.rhsnrapplyap_idmap.lhsnrapplySmash_rec_beta_gluer.applyconcat_1p. }reflexivity.Defined.Definitionfunctor_smash_compose{XYABCD:pType}(f:X$->A) (g:Y$->B) (h:A$->C) (k:B$->D):functor_smash(h$of) (k$og) $==functor_smashhk$ofunctor_smashfg.Proof.pointed_reduce.snrapplyBuild_pHomotopy.{snrapplySmash_ind_FlFr.1-3:reflexivity.-introsx.applyequiv_p1_1q.lhsnrapplySmash_rec_beta_gluel.symmetry.lhsnrapply(ap_compose(functor_smash__)_(gluelx)).lhsnrapplyap.2:nrapplySmash_rec_beta_gluel.lhsnrapplySmash_rec_beta_gluel.applyconcat_1p.-introsy.applyequiv_p1_1q.lhsnrapplySmash_rec_beta_gluer.symmetry.lhsnrapply(ap_compose(functor_smash__)_(gluery)).lhsnrapplyap.2:nrapplySmash_rec_beta_gluer.lhsnrapplySmash_rec_beta_gluer.applyconcat_1p. }reflexivity.Defined.Definitionfunctor_smash_homotopic{XYAB:pType}{fh:X$->A} {gk:Y$->B}(p:f$==h) (q:g$==k):functor_smashfg$==functor_smashhk.Proof.pointed_reduce.snrapplyBuild_pHomotopy.{snrapplySmash_ind_FlFr.1:exact(funxy=>ap011_(px) (qy)).1,2:reflexivity.-introsx.lhsnrapplyconcat_p1.lhsnrapplySmash_rec_beta_gluel.rhsnrapplywhiskerL.2:nrapplySmash_rec_beta_gluel.simpl;induction(px);simpl.rhs_Vnrapplyconcat_pp_p.applywhiskerR.nrapplyap_pp.-introsy.lhsnrapplyconcat_p1.lhsnrapplySmash_rec_beta_gluer.rhsnrapplywhiskerL.2:nrapplySmash_rec_beta_gluer.simpl;induction(qy);simpl.rhs_Vnrapplyconcat_pp_p.applywhiskerR.nrapply(ap011_pp___1 1). }exact(ap022_(concat_p1(ppt))^ (concat_p1(qpt))^ @ (concat_p1_)^).Defined.Global Instanceis0bifunctor_smash:Is0BifunctorSmash.Proof.snrapplyBuild_Is0Bifunctor'.1,2:exact_.nrapplyBuild_Is0Functor.intros[XY] [AB] [fg].exact(functor_smashfg).Defined.Global Instanceis1bifunctor_smash:Is1BifunctorSmash.Proof.snrapplyBuild_Is1Bifunctor'.snrapplyBuild_Is1Functor.-intros[XY] [AB] [fg] [hi] [pq].exact(functor_smash_homotopicpq).-intros[XY].exact(functor_smash_idmapXY).-intros[XY] [AB] [CD] [fg] [hi].exact(functor_smash_composefghi).Defined.Symmetry of the smash productDefinitionpswap(XY:pType) :SmashXY$->SmashYX:=Build_pMap__(Smash_rec(flipsm)auxrauxlgluergluel) 1.Definitionpswap_pswap{XY:pType}:pswapXY$opswapYX$==pmap_idmap.Proof.snrapplyBuild_pHomotopy.-snrapplySmash_ind_FFlr.1-3:reflexivity.+introsy.applyequiv_p1_1q.lhsnrapplyap.1:applySmash_rec_beta_gluel.nrapplySmash_rec_beta_gluer.+introsx.applyequiv_p1_1q.lhsnrapplyap.1:applySmash_rec_beta_gluer.nrapplySmash_rec_beta_gluel.-reflexivity.Defined.Definitionpequiv_pswap{XY:pType} :SmashXY$<~>SmashYX.Proof.snrapplycate_adjointify.1,2:exact(pswap__).1,2:exactpswap_pswap.Defined.Definitionpswap_natural{ABXY:pType} (f:A$->X) (g:B$->Y):pswapXY$ofunctor_smashfg$==functor_smashgf$opswapAB.Proof.pointed_reduce.snrapplyBuild_pHomotopy.-snrapplySmash_ind_FlFr.1-3:reflexivity.+introsa.applyequiv_p1_1q.rhsnrapply(ap_compose(pswap__)_(gluela)).rhsnrapplyap.2:applySmash_rec_beta_gluel.rhsnrapplySmash_rec_beta_gluer.lhsnrapply(ap_compose(functor_smash__) (pswap__) (gluela)).lhsnrapplyap.1:applySmash_rec_beta_gluel.simpl.lhsnrapplyap.1:applyconcat_1p.rhsnrapplyconcat_1p.nrapplySmash_rec_beta_gluel.+introsb.applyequiv_p1_1q.rhsnrapply(ap_compose(pswap__) (functor_smash__) (gluerb)).rhsnrapplyap.2:applySmash_rec_beta_gluer.rhsnrapplySmash_rec_beta_gluel.lhsnrapply(ap_compose(functor_smash__) (pswap__) (gluerb)).lhsnrapplyap.1:applySmash_rec_beta_gluer.lhsnrapplyap.1:applyconcat_1p.rhsnrapplyconcat_1p.nrapplySmash_rec_beta_gluer.-reflexivity.Defined.

--- Miscellaneous\Span.html ---
SpanLibrary SpanRequireImportBasics.RequireImportTypes.RequireImportDiagrams.Graph.RequireImportDiagrams.Diagram.The underlying graph of a span.Definitionspan_graph:Graph.Proof.srapply(Build_Graph(Unit+Bool)).intros[i|i] [j|j].2:exactUnit.all:exactEmpty.Defined.SectionSpan.Context{ABC:Type}.A span is a diagram:
         f     g
      B <-- A --> CDefinitionspan(f:A->B) (g:A->C) :Diagramspan_graph.Proof.srapplyBuild_Diagram.-intros[i|i].+exactA.+exact(ifithenBelseC).-intros[i|i] [j|j]u;cbn;trycontradiction.destructj.+exactf.+exactg.Defined.EndSpan.

--- Miscellaneous\SpanPushout.html ---
SpanPushoutLibrary SpanPushoutRequireImportHoTT.BasicsHoTT.Colimits.Pushout.Pushouts of "dependent spans".SectionSpanPushout.Context{XY:Type} (Q:X->Y->Type).DefinitionSPushout:= @Pushout@{up__up} (sig@{up_} (fun(xy:X*Y) =>Q(fstxy) (sndxy)))XY(fstopr1) (sndopr1).Definitionspushl:X->SPushout:=pushl.Definitionspushr:Y->SPushout:=pushr.Definitionspglue{x:X} {y:Y} :Qxy->spushlx=spushry:=funq=>pglue((x,y) ;q).DefinitionSPushout_rec(R:Type)(spushl':X->R) (spushr':Y->R)(sglue':forallxy(q:Qxy),spushl'x=spushr'y):SPushout->R.Proof.srapply(@Pushout_rec{xy:X*Y&Q(fstxy) (sndxy)}XY(fstopr1) (sndopr1)Rspushl'spushr').intros[[xy]q];cbnin*.applysglue';assumption.Defined.DefinitionSPushout_ind(R:SPushout->Type)(spushl':forallx,R(spushlx))(spushr':forally,R(spushry))(sglue':forallxy(q:Qxy),transportR(spglueq) (spushl'x) = (spushr'y)):forallp,Rp.Proof.srapply(@Pushout_ind{xy:X*Y&Q(fstxy) (sndxy)}XY(fstopr1) (sndopr1)Rspushl'spushr').intros[[xy]q];cbnin*.applysglue';assumption.Defined.Definitionspushout_ind_beta_sglue(R:SPushout->Type)(spushl':forallx,R(spushlx))(spushr':forally,R(spushry))(spglue':forallxy(q:Qxy),transportR(spglueq) (spushl'x) = (spushr'y))(x:X) (y:Y) (q:Qxy):apD(SPushout_indRspushl'spushr'spglue') (spglueq) =spglue'xyq:=Pushout_ind_beta_pglue____((x,y);q).EndSpanPushout.

--- Miscellaneous\Spec.html ---
SpecLibrary SpecRequireImportBasics.OvertureBasics.Tactics.RequireImportPos.Core.LocalSetUniverseMinimizationToSet.Local OpenScopepositive_scope.Specification ofsuccin term ofaddLemmapos_add_1_rp:p+ 1 =pos_succp.Proof.bydestructp.Qed.Lemmapos_add_1_lp: 1 +p=pos_succp.Proof.bydestructp.Qed.Specification ofadd_carryTheorempos_add_carry_specpq:pos_add_carrypq=pos_succ(p+q).Proof.revertq.inductionp;destructq;simpl;byapplyap.Qed.Commutativity ofaddTheorempos_add_commpq:p+q=q+p.Proof.revertq.inductionp;destructq;simpl;applyap;trivial.rewrite2pos_add_carry_spec;byapplyap.Qed.Permutation ofaddandsuccTheorempos_add_succ_rpq:p+pos_succq=pos_succ(p+q).Proof.revertq.inductionp;destructq;simpl;applyap;autousingpos_add_1_r;rewritepos_add_carry_spec;auto.Qed.Theorempos_add_succ_lpq:pos_succp+q=pos_succ(p+q).Proof.rewritepos_add_comm, (pos_add_commp).applypos_add_succ_r.Qed.Definitionpos_add_succpq:p+pos_succq=pos_succp+q.Proof.byrewritepos_add_succ_r,pos_add_succ_l.Defined.Definitionpos_add_carry_spec_lqr:pos_add_carryqr=pos_succq+r.Proof.byrewritepos_add_carry_spec,pos_add_succ_l.Qed.Definitionpos_add_carry_spec_rqr:pos_add_carryqr=q+pos_succr.Proof.byrewritepos_add_carry_spec,pos_add_succ_r.Defined.No neutral elements for additionLemmapos_add_no_neutralpq:q+p<>p.Proof.revertq.inductionpas[ |pIHp|pIHp];intros[ |q|q].1,3:applyx0_neq_xH.1:applyx1_neq_xH.1,3:applyx1_neq_x0.2,4:applyx0_neq_x1.1,2:introH;apply(IHpq).1:applyx0_inj,H.applyx1_inj,H.Qed.Injectivity of pos_succLemmapos_succ_injnm:pos_succn=pos_succm->n=m.Proof.revertm.inductionnas[ |nx|nx];inductionmas[ |my|my].+reflexivity.+introp.destruct(x0_neq_x1p).+introp.simplinp.applyx0_injinp.destructm.1,3:destruct(xH_neq_x0p).destruct(xH_neq_x1p).+introp.destruct(x1_neq_x0p).+simpl.introp.byapplyap,x1_inj.+introp.destruct(x1_neq_x0p).+introp.cbninp.applyx0_injinp.destructn.1,3:destruct(x0_neq_xHp).destruct(x1_neq_xHp).+introp.cbninp.destruct(x0_neq_x1p).+introp.applyap,x,x0_inj,p.Defined.Addition is associativeTheorempos_add_assocpqr:p+ (q+r) =p+q+r.Proof.revertqr.inductionp.+intros[|q|q] [|r|r].all:tryreflexivity.all:simpl.1,2:bydestructr.1,2:applyap;symmetry.1:applypos_add_carry_spec.1:applypos_add_succ_l.applyap.rewritepos_add_succ_l.applypos_add_carry_spec.+intros[|q|q] [|r|r].all:tryreflexivity.all:cbn;applyap.3,4,6:applyIHp.1:applypos_add_1_r.1:symmetry;applypos_add_carry_spec_r.1:applypos_add_succ_r.rewrite2pos_add_carry_spec_l.rewrite<-pos_add_succ_r.applyIHp.+intros[|q|q] [|r|r].all:cbn;applyap.1:applypos_add_1_r.1:applypos_add_carry_spec_l.1:applypos_add_succ.1:applypos_add_carry_spec.1:applyIHp.2:symmetry;applypos_add_carry_spec_r.1,2:rewrite2pos_add_carry_spec, ?pos_add_succ_l.1,2:applyap,IHp.rewrite?pos_add_carry_spec_r.rewritepos_add_succ.applyIHp.Qed.One is neutral for multiplicationLemmapos_mul_1_lp: 1 *p=p.Proof.reflexivity.Qed.Lemmapos_mul_1_rp:p* 1 =p.Proof.inductionp;cbn;trivial;byapplyap.Qed.pos_succ and doubling functionsLemmapos_pred_double_succn:pos_pred_double(pos_succn) =n~1.Proof.inductionnas[|n|nnH].all:trivial.cbn;applyap,nH.Qed.Lemmapos_succ_pred_doublen:pos_succ(pos_pred_doublen) =n~0.Proof.inductionnas[|nnH|n].all:trivial.cbn;applyap,nH.Qed.Iteration and pos_succLemmapos_iter_succ_l{A} (f:A->A)pa:pos_iterf(pos_succp)a=f(pos_iterfpa).Proof.unfoldpos_iter.byrewritepos_peano_rec_beta_pos_succ.Qed.Lemmapos_iter_succ_r{A} (f:A->A)pa:pos_iterf(pos_succp)a=pos_iterfp(fa).Proof.revertpfa.srapplypos_peano_ind.1:hnf;intros;trivial.hnf;introspqfa.refine(_@_@_^).1,3:unfoldpos_iter;byrewritepos_peano_rec_beta_pos_succ.applyap.applyq.Qed.Right reduction properties for multiplicationLemmamul_xO_rpq:p*q~0 = (p*q)~0.Proof.inductionp;simpl;f_ap;f_ap;trivial.Qed.Lemmamul_xI_rpq:p*q~1 =p+ (p*q)~0.Proof.inductionp;simpl;trivial;f_ap.rewriteIHp.rewritepos_add_assoc.rewrite(pos_add_commqp).symmetry.applypos_add_assoc.Qed.Commutativity of multiplicationLemmapos_mul_commpq:p*q=q*p.Proof.inductionq;simpl.1:applypos_mul_1_r.+rewritemul_xO_r.f_ap.+rewritemul_xI_r.f_ap;f_ap.Qed.Distributivity of addition over multiplicationTheorempos_mul_add_distr_lpqr:p* (q+r) =p*q+p*r.Proof.inductionp;cbn; [reflexivity|f_ap| ].rewriteIHp.set(m:=(p*q)~0).set(n:=(p*r)~0).change((p*q+p*r)~0)with(m+n).rewrite2pos_add_assoc;f_ap.rewrite<- 2pos_add_assoc;f_ap.applypos_add_comm.Qed.Theorempos_mul_add_distr_rpqr:(p+q) *r=p*r+q*r.Proof.rewrite3 (pos_mul_comm_r);applypos_mul_add_distr_l.Qed.Associativity of multiplicationTheorempos_mul_assocpqr:p* (q*r) =p*q*r.Proof.inductionp;simpl;rewrite?IHp;trivial.byrewritepos_mul_add_distr_r.Qed.pos_succ and pos_mulLemmapos_mul_succ_lpq: (pos_succp) *q=p*q+q.Proof.byrewrite<-pos_add_1_r,pos_mul_add_distr_r,pos_mul_1_l.Qed.Lemmapos_mul_succ_rpq:p* (pos_succq) =p+p*q.Proof.byrewrite<-pos_add_1_l,pos_mul_add_distr_l,pos_mul_1_r.Qed.

--- Miscellaneous\Spectrum.html ---
SpectrumLibrary SpectrumSpectraRequireImportHoTT.BasicsHoTT.Types.RequireImportPointed.Local OpenScopenat_scope.Local OpenScopepath_scope.Local OpenScopeequiv_scope.Local OpenScopepointed_scope.Basic Definitions of SpectraRecordPrespectrum:={deloop:>nat->pType;glue:foralln,deloopn->*loops(deloop(n.+1)) }.ClassIsSpectrum(E:Prespectrum) :=is_equiv_glue:foralln,IsEquiv(glueEn).Global Existing Instanceis_equiv_glue.Definitionequiv_glue(E:Prespectrum) `{IsSpectrumE}:foralln,En<~>*loops(En.+1):=funn=>Build_pEquiv__(glueEn)_.RecordSpectrum:={to_prespectrum:>Prespectrum;to_is_spectrum:IsSpectrumto_prespectrum}.Global Existing Instanceto_is_spectrum.Truncations of spectraDefinitionstrunc`{Univalence} (k:trunc_index) (E:Spectrum) :Spectrum.Proof.simplerefine(Build_Spectrum(Build_Prespectrum(funn=>pTr(trunc_index_inckn) (En))_)_).-introsn.exact((ptr_loops_(En.+1))o*E(pequiv_ptr_functor_(equiv_glueEn))).-introsn.unfoldglue.srapplyisequiv_compose.Defined.

--- Miscellaneous\Spheres.html ---
SpheresLibrary SpheresRequireImportBasicsTypes.RequireImportWildCat.Equiv.RequireImportNullHomotopy.RequireImportHomotopy.Suspension.RequireImportPointed.RequireImportTruncations.RequireImportSpaces.CircleSpaces.TwoSphere.The spheres, in all dimensions.Local OpenScopepointed_scope.Local OpenScopetrunc_scope.Local OpenScopepath_scope.Generalizable VariablesXABfgn.Definition, by iterated suspension.To match the usual indexing for spheres, we have to pad the sequence with a dummy termSphere-2.FixpointSphere(n:trunc_index):=matchnreturnTypewith| -2 =>Empty| -1 =>Empty|n'.+1 =>Susp(Spheren')end.Pointed sphere for non-negative dimensions.Definitionpsphere(n:nat) :pType:= [Spheren,_].ArgumentsSphere:simplnever.Argumentspsphere:simplnever.Explicit equivalences in low dimensionsSphere0DefinitionS0_to_Bool: (Sphere0) ->Bool.Proof.simpl.apply(Susp_rectruefalse).intros[].Defined.DefinitionBool_to_S0:Bool-> (Sphere0).Proof.exact(funb=>ifbthenNorthelseSouth).Defined.Global Instanceisequiv_S0_to_Bool:IsEquiv(S0_to_Bool) | 0.Proof.applyisequiv_adjointifywithBool_to_S0.-intros[ | ];exact1.-refine(Susp_ind_1 1_).intros[].Defined.Definitionequiv_S0_Bool:Sphere0 <~>Bool:=Build_Equiv___isequiv_S0_to_Bool.Definitionispointed_bool:IsPointedBool:=true.DefinitionpBool:= [Bool,true].Definitionpequiv_S0_Bool:psphere0 <~>*pBool:= @Build_pEquiv'(psphere0)pBoolequiv_S0_Bool1.Inpmap_from_psphere_iterated_loopsbelow, we'll use this universal property ofpBool.Definitionpmap_from_bool`{Funext} (X:pType): (pBool->**X) <~>*X.Proof.snrapplyBuild_pEquiv'.-refine(_oE(issig_pmap__)^-1%equiv).refine(_oE(equiv_functor_sigma_pb(equiv_bool_rec_uncurriedX))^-1%equiv);cbn.make_equiv_contr_basedpaths.-reflexivity.Defined.Sphere1DefinitionS1_to_Circle: (Sphere1) ->Circle.Proof.apply(Susp_recCircle.baseCircle.base).exact(funx=>if(S0_to_Boolx)thenloopelse1).Defined.DefinitionCircle_to_S1:Circle-> (Sphere1).Proof.apply(Circle_rec_North).exact(meridNorth@ (meridSouth)^).Defined.Global Instanceisequiv_S1_to_Circle:IsEquiv(S1_to_Circle) | 0.Proof.applyisequiv_adjointifywithCircle_to_S1.-refine(Circle_ind_1_).nrapplytransport_paths_FFlr';applyequiv_p1_1q.refine(ap_(Circle_rec_beta_loop___) @_).refine(ap_pp__(meridSouth)^ @_).refine((1 @@ap_V__) @_).refine((_@@ (apinverse_)) @_). 1, 2:nrapplySusp_rec_beta_merid.simpl.applyconcat_p1.-refine(Susp_ind(funx=>Circle_to_S1(S1_to_Circlex) =x)1 (meridSouth)_);introsx.nrapplytransport_paths_FFlr';symmetry.unfoldS1_to_Circle;rewrite(Susp_rec_beta_meridx).revertx.change(SuspEmpty)with(Sphere0).apply(equiv_ind(S0_to_Bool^-1));introsx.casex;simpl.2:reflexivity.lhsnrapplyconcat_1p.unfoldCircle_to_S1;rewriteCircle_rec_beta_loop.symmetry;applyconcat_pV_p.Defined.Definitionequiv_S1_Circle:Sphere1 <~>Circle:=Build_Equiv___isequiv_S1_to_Circle.Definitionpequiv_S1_Circle:psphere1 <~>* [Circle,_].Proof.srapplyBuild_pEquiv'.1:applyequiv_S1_Circle.reflexivity.Defined.Sphere2DefinitionS2_to_TwoSphere: (Sphere2) ->TwoSphere.Proof.apply(Susp_recbasebase).apply(Susp_rec(idpathbase) (idpathbase)).apply(Susp_recsurf(idpath(idpathbase))).applyEmpty_rec.Defined.DefinitionTwoSphere_to_S2:TwoSphere-> (Sphere2).Proof.apply(TwoSphere_rec(Sphere2)North).refine(transport(funx=>x=x) (concat_pV(meridNorth))_).refine(((ap(funu=>meridu@ (meridNorth)^)(meridNorth@ (meridSouth)^)))).Defined.Definitionissect_TwoSphere_to_S2:S2_to_TwoSphereoTwoSphere_to_S2==idmap.Proof.refine(TwoSphere_ind_1_).rhs_Vrapplyconcat_p1.rhsrefine(@concat_Ap(base=base)__(funp=> (p^ @apS2_to_TwoSphere(apTwoSphere_to_S2p))^)(funx=>(transport_paths_FFlrx1)@ap(funu=>u@x) (concat_p1_)@ap(funw=>_@w) (inv_Vx)^@ (inv_pp__)^)1 1surf).rhsrapplyconcat_1p.rhsrefine(ap_compose(funp=>p^ @apS2_to_TwoSphere(apTwoSphere_to_S2p))inversesurf).refine(@ap__(apinverse) 1__).rhs_Vrapplyconcat2_ap_ap.rhsrefine(ap(funw=>inverse2surf@@w)(ap_compose(apTwoSphere_to_S2) (apS2_to_TwoSphere)surf)).lhs_Vrefine(concat_Vp_inverse2__surf).lhsrapplyconcat_p1.refine(ap(funp: 1 = 1 =>inverse2surf@@p)_).symmetry.lhsrefine((ap(ap(apS2_to_TwoSphere))(TwoSphere_rec_beta_surf(Sphere2)North_))).lhsrefine(ap_transport(concat_pV(meridNorth))(funz=> @ap___zz)(ap(funu=>meridu@ (meridNorth)^)(meridNorth@ (meridSouth)^))).lhs_Vrefine(ap(transport(funz=>apS2_to_TwoSpherez=apS2_to_TwoSpherez)(concat_pV(meridNorth)))(ap_compose(funu=>meridu@ (meridNorth)^) (apS2_to_TwoSphere)(meridNorth@ (meridSouth)^))).applytransport_paths_FlFr';symmetry.lhs_Vrefine(1 @@ap_pp_concat_pVS2_to_TwoSphere(meridNorth)).lhs_Vrefine(1 @@ (1 @@ (1 @@(concat_pV_inverse2(apS2_to_TwoSphere(meridNorth))_(Susp_rec_beta_meridNorth))))).lhsrefine(@concat_Ap(Sphere1)_(funx=>apS2_to_TwoSphere(meridx@ (meridNorth)^))(funx=>Susp_rec1 1(Susp_recsurf1Empty_rec)x@ 1)(funx=>ap_ppS2_to_TwoSphere(meridx) (meridNorth)^@ ((1 @@ap_VS2_to_TwoSphere(meridNorth))@ ((Susp_rec_beta_meridx@@inverse2(Susp_rec_beta_meridNorth))@ 1)))NorthNorth(meridNorth@ (meridSouth)^)).f_ap.{rhs_Vrefine(ap_pp_concat_pV__).exact(1 @@ (1 @@ (concat_pV_inverse2___))). }lhs_Vrefine(concat2_ap_ap(Susp_rec1 1 (Susp_recsurf1Empty_rec))(fun_=> 1)(meridNorth@ (meridSouth)^)).lhsrefine(ap(funw=>_@@w) (ap_const__)).lhsrapplywhiskerR_p1_1.lhsrefine(ap_pp_(meridNorth) (meridSouth)^).rhs_Vrapplyconcat_p1.f_ap.-exact(Susp_rec_beta_meridNorth).-lhsrapplyap_V.refine(@inverse2____1_).exact(Susp_rec_beta_meridSouth).Defined.Definitionissect_S2_to_TwoSphere:TwoSphere_to_S2oS2_to_TwoSphere==idmap.Proof.introx.refine((Susp_rec_eta_homotopic(TwoSphere_to_S2oS2_to_TwoSphere)x) @_).symmetry.generalizedependentx.refine(Susp_ind_1 (meridNorth)^_).introx.refine((transport_paths_FlFr(f:=funy=>y)__) @_).rewrite_moveR_Vp_p.refine((concat_1p_) @_).refine(_@ (ap(funw=>w@_) (ap_idmap_)^)).refine((Susp_rec_beta_merid_) @_).path_via(apTwoSphere_to_S2(apS2_to_TwoSphere(meridx))).{apply(ap_composeS2_to_TwoSphereTwoSphere_to_S2(meridx)). }path_via(apTwoSphere_to_S2(Susp_rec1 1 (Susp_recsurf1Empty_rec)x)).{repeatf_ap.applySusp_rec_beta_merid. }symmetry.generalizedependentx.simplerefine(Susp_ind_(concat_pV(meridNorth))__).-refine(_@ (concat_pV(meridNorth))).apply(ap(funw=>meridw@ (meridNorth)^) (meridSouth)^).-introx.refine((transport_paths_FlFr(meridx) (concat_pV(meridNorth))) @_).rewrite_moveR_Vp_p.symmetry.refine((dpath_path_lr___)^-1_).refine((ap(transport__) (ap_pp_(meridx) (meridSouth)^)^) @_).refine(_@ (ap_compose(Susp_rec1 1(Susp_recsurf1Empty_rec))(apTwoSphere_to_S2) (meridx))^).refine(_@ (ap(ap02TwoSphere_to_S2) (Susp_rec_beta_merid_)^)).symmetry.generalizedependentx.simplerefine(Susp_ind____).+refine(TwoSphere_rec_beta_surf___).+refine(_@ (ap(funw=>transport__(ap_w))(concat_pV(meridSouth))^)).refine(_@ (transport_paths_lr__)^).refine(_@ (ap(funw=>w@_) (concat_p1_)^)).refine(concat_Vp_)^.+applyEmpty_ind.Defined.Global Instanceisequiv_S2_to_TwoSphere:IsEquiv(S2_to_TwoSphere) | 0.Proof.applyisequiv_adjointifywithTwoSphere_to_S2.-applyissect_TwoSphere_to_S2.-applyissect_S2_to_TwoSphere.Defined.Definitionequiv_S2_TwoSphere:Sphere2 <~>TwoSphere:=Build_Equiv___isequiv_S2_to_TwoSphere.Truncation and connectedness of spheres.S0 is 0-truncated.Global Instanceistrunc_s0:IsHSet(Sphere0).Proof.srapply(istrunc_isequiv_istrunc_S0_to_Bool^-1).Defined.S1 is 1-truncated.Global Instanceistrunc_s1`{Univalence} :IsTrunc1 (Sphere1).Proof.srapply(istrunc_isequiv_istrunc_S1_to_Circle^-1).Defined.Global Instanceisconnected_snn:IsConnectedn.+1 (Spheren.+2).Proof.inductionn.{srapplycontr_inhabited_hprop.applytr,North. }applyisconnected_susp.Defined.Truncatedness via spheresWe show here that a type is n-truncated if and only if every map from the (n+1)-sphere into it is null-homotopic.  (One direction of this is of course the assertion that the (n+1)-sphere is n-connected.)TODO: re-type these lemmas in terms of truncation.Fixpointallnullhomot_trunc{n:trunc_index} {X:Type} `{IsTruncnX}(f:Spheren.+1 ->X) {structn}:NullHomotopyf.Proof.destructnas[ |n'].-exists(centerX).intros[].-applynullhomot_susp_from_paths.rapplyallnullhomot_trunc.Defined.Fixpointistrunc_allnullhomot{n:trunc_index} {X:Type}(HX:forall(f:Spheren.+2 ->X),NullHomotopyf) {structn}:IsTruncn.+1X.Proof.destructnas[ |n'].-(* n = -2 *)applyhprop_allpath.introsx0x1.set(f:= (funb=>if(S0_to_Boolb)thenx0elsex1)).set(n:=HXf).exact(n.2North@ (n.2South)^).-(* n ≥ -1 *)applyistrunc_S;introsx0x1.apply(istrunc_allnullhomotn').introf.applynullhomot_paths_from_susp,HX.Defined.Iterated loop spaces can be described using pointed maps from spheres.  Then=0case of this is stated using Bool inpmap_from_boolabove, and then=1case of this is stated usingCircleinpmap_from_circle_loopsin Circle.v.Definitionpmap_from_psphere_iterated_loops`{Funext} (n:nat) (X:pType): (pspheren->**X) <~>*iterated_loopsnX.Proof.inductionnas[|nIHn];simpl.-exact(pmap_from_boolXo*Epequiv_pequiv_precomposepequiv_S0_Bool^-1* ).-refine(emaploopsIHno*E_).refine(_o*Eloop_susp_adjoint(pspheren)_).symmetry;applyequiv_loops_ppforall.Defined.

--- Miscellaneous\Square.html ---
SquareLibrary SquareRequireImportBasics.Overture.RequireImportWildCat.Core.RequireImportWildCat.Equiv.Squares of morphisms in a Wild Category.These come up a lot as naturality squares. In this file we define basic operations on squares, to conveniently work with them.A Square is a cubical 2-cell in a 1-category. The order of the arguments is left-right-top-bottom:Squarelrtb.  It is defined to ber$ot$==b$ol.DefinitionSquare@{uvw} {A:Type@{u}} `{Is1Cat@{uwv}A} {x00x20x02x22:A}(f01:x00$->x02) (f21:x20$->x22) (f10:x00$->x20) (f12:x02$->x22):Type@{w}:=f21$of10$==f12$of01.SectionSquares.(* We declare a context with a lot of variables: the first component is horizontal, the second vertical.x00 f10 x20 f30 x40f01     f21     f41x02 f12 x22 f32 x42f03     f23     f43x04 f14 x24 f34 x44All morphisms are pointed to the right or down. *)Context{A:Type} `{Is1CatA} {xx'x00x20x40x02x22x42x04x24x44:A}{f10f10':x00$->x20} {f30:x20$->x40}{f12f12':x02$->x22} {f32:x22$->x42}{f14:x04$->x24} {f34:x24$->x44}{f01f01':x00$->x02} {f21f21':x20$->x22} {f41f41':x40$->x42}{f03:x02$->x04} {f23:x22$->x24} {f43:x42$->x44}.We give a "constructor" and "destructor" for squares.DefinitionBuild_Square(p:f21$of10$==f12$of01) :Squaref01f21f10f12:=p.Definitiongpdhom_square(s:Squaref01f21f10f12) :f21$of10$==f12$of01:=s.Squares degenerate in two sides given by a single 2-morphism.Definitionhdeg_square{ff':x$->x'} (p:f$==f') :Squareff'(Idx) (Idx'):=cat_idrf'$@p^$ $@ (cat_idlf)^$.Definitionvdeg_square{ff':x$->x'} (p:f$==f') :Square(Idx) (Idx')ff':=cat_idlf$@p$@ (cat_idrf')^$.Squares degenerate in two sides given by the identity 2-morphism at some morphism.Definitionhrefl(f:x$->x') :Squareff(Idx) (Idx') :=hdeg_square(Idf).Definitionvrefl(f:x$->x') :Square(Idx) (Idx')ff:=vdeg_square(Idf).The transpose of a squareDefinitiontranspose(s:Squaref01f21f10f12) :Squaref10f12f01f21:=s^$.Horizontal and vertical concatenation of squaresDefinitionhconcat(s:Squaref01f21f10f12) (t:Squaref21f41f30f32):Squaref01f41(f30$of10) (f32$of12):= (cat_assoc___)^$ $@ (t$@Rf10) $@cat_assoc___$@ (f32$@Ls) $@ (cat_assoc___)^$.Definitionvconcat(s:Squaref01f21f10f12) (t:Squaref03f23f12f14):Square(f03$of01) (f23$of21)f10f14:=cat_assoc___$@ (f23$@Ls) $@ (cat_assoc___)^$ $@ (t$@Rf01) $@cat_assoc___.If the horiztonal morphisms in a square are equivalences then we can flip the square by inverting them.Definitionhinverse{HE:HasEquivsA} (f10:x00$<~>x20) (f12:x02$<~>x22) (s:Squaref01f21f10f12):Squaref21f01f10^-1$f12^-1$:= (cat_idl_)^$ $@ ((cate_issectf12)^$ $@R_) $@cat_assoc___$@ (_$@L((cat_assoc___)^$ $@ (s^$ $@R_) $@cat_assoc___$@ (_$@Lcate_isretrf10) $@cat_idr_)).The following four declarations modify one side of a Square using a 2-cell. The L or R indicate the side of the 2-cell. This can be thought of as rewriting the sides of a square using a homotopy.Rewriting the left edge.DefinitionhconcatL(p:f01'$==f01) (s:Squaref01f21f10f12):Squaref01'f21f10f12:=s$@ (f12$@Lp^$).Rewriting the right edge.DefinitionhconcatR(s:Squaref01f21f10f12) (p:f21'$==f21):Squaref01f21'f10f12:= (p$@Rf10) $@s.Rewriting the top edge.DefinitionvconcatL(p:f10'$==f10) (s:Squaref01f21f10f12):Squaref01f21f10'f12:= (f21$@Lp) $@s.Rewriting the bottom edge.DefinitionvconcatR(s:Squaref01f21f10f12) (p:f12'$==f12):Squaref01f21f10f12':=s$@ (p^$ $@Rf01).EndSquares.SectionSquares2.We declare the context again, now that we can reuse some declarations where the variables have been inserted. This would not need to be done if coq could generalize variables within sections. Currently this is possible in Lean and Agda.Context{A:Type} `{HasEquivsA}{xx'x00x20x40x02x22x42x04x24x44:A}{f10f10':x00$->x20} {f30:x20$->x40}{f12f12':x02$->x22} {f32:x22$->x42}{f14:x04$->x24} {f34:x24$->x44}{f01f01':x00$->x02} {f21f21':x20$->x22} {f41f41':x40$->x42}{f03:x02$->x04} {f23:x22$->x24} {f43:x42$->x44}.If the vertical morphisms in a square are equivalences then we can flip the square by inverting them.Definitionvinverse(f01:x00$<~>x02) (f21:x20$<~>x22) (s:Squaref01f21f10f12):Square(f01^-1$) (f21^-1$)f12f10:=transpose(hinverse__(transposes)).Whisker a map in one of the corners. For the bottom-left and top-right we have two choices.DefinitionwhiskerTL{f:x$->x00} (s:Squaref01f21f10f12):Square(f01$of)f21(f10$of)f12:= (cat_assoc___)^$ $@ (s$@Rf) $@cat_assoc___.DefinitionwhiskerBR{f:x22$->x} (s:Squaref01f21f10f12):Squaref01(f$of21)f10(f$of12):=cat_assoc___$@ (f$@Ls) $@ (cat_assoc___)^$.DefinitionwhiskerBL{f:x$<~>x02} (s:Squaref01f21f10f12):Square(f^-1$ $of01)f21f10(f12$of):=s$@ ((compose_hh_V__)^$ $@Rf01) $@cat_assoc___.DefinitionwhiskerLB{f:x02$<~>x} (s:Squaref01f21f10f12):Square(f$of01)f21f10(f12$of^-1$):=s$@ ((compose_hV_h__)^$ $@Rf01) $@cat_assoc___.DefinitionwhiskerTR{f:x20$<~>x} (s:Squaref01f21f10f12):Squaref01(f21$of^-1$) (f$of10)f12:=cat_assoc___$@ (f21$@Lcompose_V_hh__) $@s.DefinitionwhiskerRT{f:x$<~>x20} (s:Squaref01f21f10f12):Squaref01(f21$of) (f^-1$ $of10)f12:=cat_assoc___$@ (f21$@Lcompose_h_Vh__) $@s.Moving around maps in a square. Associativity laws.Definitionmove_bottom_left{f01:x00$->x} {f01':x$->x02}(s:Square(f01'$of01)f21f10f12):Squaref01f21f10(f12$of01'):=s$@ (cat_assoc___)^$.Definitionmove_left_bottom{f12:x02$->x} {f12':x$->x22}(s:Squaref01f21f10(f12'$of12)):Square(f12$of01)f21f10f12':=s$@cat_assoc___.Definitionmove_right_top{f10:x00$->x} {f10':x$->x20}(s:Squaref01f21(f10'$of10)f12):Squaref01(f21$of10')f10f12:=cat_assoc___$@s.Definitionmove_top_right{f21:x20$->x} {f21':x$->x22}(s:Squaref01(f21'$of21)f10f12):Squaref01f21'(f21$of10)f12:= (cat_assoc___)^$ $@s.Definitionfmap_square{B:Type} `{Is1CatB} (f:A->B) `{!Is0Functorf} `{!Is1Functorf}(s:Squaref01f21f10f12):Square(fmapff01) (fmapff21) (fmapff10) (fmapff12):= (fmap_compf__)^$ $@fmap2fs$@fmap_compf__.EndSquares2.Notation"s $@h t" := (hconcatst).Notation"s $@v t" := (vconcatst).Notation"s $@hR p" := (hconcatRsp).Notation"s $@hL p" := (hconcatLps).Notation"s $@vR p" := (vconcatRsp).Notation"s $@vL p" := (vconcatLps).Notation"s ^h$" := (hinverse__s).Notation"s ^v$" := (vinverse__s).

--- Miscellaneous\Strict.html ---
StrictLibrary StrictDefinition of a strict categoryRequireExportCategory.Core.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.Quoting the HoTT Book:  Definition. Astrict categoryis a precategory whose type of
    objects is a set.NotationIsStrictCategoryC:= (IsHSet(objectC)).RecordStrictCategory:={precategory_strict:>PreCategory;isstrict_StrictCategory:>IsStrictCategoryprecategory_strict}.Global Existing Instanceisstrict_StrictCategory.

--- Miscellaneous\Structure.html ---
StructureLibrary StructureSince there are only notations inStructure.Notations, we can just export those.RequireExportStructure.Notations.RequireStructure.Core.RequireStructure.IdentityPrinciple.IncludeStructure.Core.IncludeStructure.IdentityPrinciple.We don't want to make utf-8 notations the default, so we don't export them.

--- Miscellaneous\Subcategory.html ---
SubcategoryLibrary SubcategorySubcategoriesFullRequireSubcategory.Full.WideRequireSubcategory.Wide.IncludeSubcategory.Full.IncludeSubcategory.Wide.

--- Miscellaneous\Subgroup.html ---
SubgroupLibrary SubgroupRequireImportBasicsTypesHFiberWildCat.Core.RequireImportTruncations.Core.RequireImportAlgebra.Groups.GroupTruncType.Local OpenScopemc_scope.Local OpenScopemc_mult_scope.Generalizable VariablesGHABCNfg.SubgroupsA subgroup H of a group G is a predicate (i.e. an hProp-valued type family) on G which is closed under the group operations. The group underlying H is given by the total space { g : G & H g }, defined insubgroup_groupbelow.ClassIsSubgroup{G:Group} (H:G->Type) := {issubgroup_predicate:forallx,IsHProp(Hx) ;issubgroup_in_unit:Hmon_unit;issubgroup_in_op:forallxy,Hx->Hy->H(x*y) ;issubgroup_in_inv:forallx,Hx->H(-x) ;}.Global Existing Instanceissubgroup_predicate.Smart constructor for subgroups.DefinitionBuild_IsSubgroup'{G:Group}(H:G->Type) `{forallx,IsHProp(Hx)}(unit:Hmon_unit)(c:forallxy,Hx->Hy->H(x* -y)):IsSubgroupH.Proof.refine(Build_IsSubgroupGH_unit__).-introsxy.introshxhy.pose(c':=cmon_unity).specialize(c'unit).specialize(cx(-y)).rewrite(negate_involutivey)inc.rewriteleft_identityinc'.applyc.1:assumption.exact(c'hy).-introg.specialize(c_gunit).rewriteleft_identityinc.assumption.Defined.Additional lemmas about being elements in a subgroupSectionIsSubgroupElements.Context{G:Group} {H:G->Type} `{IsSubgroupGH}.Definitionissubgroup_in_op_inv(xy:G) :Hx->Hy->H(x* -y).Proof.introspq.applyissubgroup_in_op.1:assumption.byapplyissubgroup_in_inv.Defined.Definitionissubgroup_in_inv'(x:G) :H(-x) ->Hx.Proof.introsp;rewrite<- (negate_involutivex);revertp.applyissubgroup_in_inv.Defined.Definitionissubgroup_in_inv_op(xy:G) :Hx->Hy->H(-x*y).Proof.introspq.rewrite<- (negate_involutivey).applyissubgroup_in_op_inv.1,2:byapplyissubgroup_in_inv.Defined.Definitionissubgroup_in_op_l(xy:G) :H(x*y) ->Hy->Hx.Proof.introspq.rewrite<- (grp_unit_rx).revertpq.rewrite<- (grp_inv_ry).rewritegrp_assoc.applyissubgroup_in_op_inv.Defined.Definitionissubgroup_in_op_r(xy:G) :H(x*y) ->Hx->Hy.Proof.introspq.rewrite<- (grp_unit_ly).revertqp.rewrite<- (grp_inv_lx).rewrite<-grp_assoc.applyissubgroup_in_inv_op.Defined.EndIsSubgroupElements.Definitionissig_issubgroup{G:Group} (H:G->Type) :_<~>IsSubgroupH:=ltac:(issig).Given a predicate H on a group G, being a subgroup is a property.Global Instanceishprop_issubgroup`{F:Funext} {G:Group} {H:G->Type}:IsHProp(IsSubgroupH).Proof.exact(istrunc_equiv_istrunc_(issig_issubgroupH)).Defined.The type (set) of subgroups of a group G.RecordSubgroup(G:Group) := {subgroup_pred:G->Type;subgroup_issubgroup:IsSubgroupsubgroup_pred;}.Coercionsubgroup_pred:Subgroup>->Funclass.Global Existing Instancesubgroup_issubgroup.DefinitionBuild_Subgroup'{G:Group}(H:G->Type) `{forallx,IsHProp(Hx)}(unit:Hmon_unit)(c:forallxy,Hx->Hy->H(x* -y)):SubgroupG.Proof.refine(Build_SubgroupGH_).rapplyBuild_IsSubgroup';assumption.Defined.SectionSubgroupElements.Context{G:Group} (H:SubgroupG) (xy:G).Definitionsubgroup_in_unit:Hmon_unit:=issubgroup_in_unit.Definitionsubgroup_in_inv:Hx->H(-x) :=issubgroup_in_invx.Definitionsubgroup_in_inv':H(-x) ->Hx:=issubgroup_in_inv'x.Definitionsubgroup_in_op:Hx->Hy->H(x*y) :=issubgroup_in_opxy.Definitionsubgroup_in_op_inv:Hx->Hy->H(x* -y) :=issubgroup_in_op_invxy.Definitionsubgroup_in_inv_op:Hx->Hy->H(-x*y) :=issubgroup_in_inv_opxy.Definitionsubgroup_in_op_l:H(x*y) ->Hy->Hx:=issubgroup_in_op_lxy.Definitionsubgroup_in_op_r:H(x*y) ->Hx->Hy:=issubgroup_in_op_rxy.EndSubgroupElements.Global Instanceisequiv_subgroup_in_inv`(H:SubgroupG) (x:G):IsEquiv(subgroup_in_invHx).Proof.srapplyisequiv_iff_hprop.applysubgroup_in_inv'.Defined.Definitionequiv_subgroup_inverse{G:Group} (H:SubgroupG) (x:G):Hx<~>H(-x) :=Build_Equiv__(subgroup_in_invHx)_.The group given by a subgroupDefinitionsubgroup_group{G:Group} (H:SubgroupG) :Group.Proof.apply(Build_GroupThe underlying type is the sigma type of the predicate.(sigH)The operation is the group operation on the first projection with the proof  of being in the subgroup given by the subgroup data.(fun'(x;p) '(y;q) => (x*y;issubgroup_in_opxypq))The unit(mon_unit;issubgroup_in_unit)Inverse(fun'(x;p) => (-x;issubgroup_in_inv_p))).Finally we need to prove our group laws.repeatsplit.1:exact_.all:grp_auto.Defined.Coercionsubgroup_group:Subgroup>->Group.Definitionsubgroup_incl{G:Group} (H:SubgroupG):subgroup_groupH$->G.Proof.snrapplyBuild_GroupHomomorphism.1:exactpr1.hnf;reflexivity.Defined.Global Instanceisembedding_subgroup_incl{G:Group} (H:SubgroupG):IsEmbedding(subgroup_inclH):=fun_=>istrunc_equiv_istrunc_(hfiber_fibration__).Definitionissig_subgroup{G:Group} :_<~>SubgroupG:=ltac:(issig).Trivial subgroupDefinitiontrivial_subgroup{G} :SubgroupG.Proof.rapply(Build_Subgroup'(funx=>x=mon_unit)).1:reflexivity.introsxypq.rewritep,q.rewriteleft_identity.applynegate_mon_unit.Defined.The preimage of a subgroup under a group homomorphism is a subgroup.Definitionsubgroup_preimage{GH:Group} (f:G$->H) (S:SubgroupH):SubgroupG.Proof.snrapplyBuild_Subgroup'.-exact(Sof).-hnf;exact_.-nrefine(transportS(grp_homo_unitf)^_).applysubgroup_in_unit.-hnf;introsxySfxSfy.nrefine(transportS(grp_homo_opf__)^_).nrapplysubgroup_in_op;only1:assumption.nrefine(transportS(grp_homo_invf_)^_).byapplysubgroup_in_inv.Defined.Every group is a (maximal) subgroup of itselfDefinitionmaximal_subgroup{G} :SubgroupG.Proof.rapply(Build_SubgroupG(funx=>Unit)).split;auto;exact_.Defined.Paths between subgroups correspond to homotopies between the underlying predicates.Propositionequiv_path_subgroup`{F:Funext} {G:Group} (HK:SubgroupG): (H==K) <~> (H=K).Proof.refine((equiv_ap'issig_subgroup^-1%equiv__)^-1%equivoE_);cbn.refine(equiv_path_sigma_hprop__oE_);cbn.applyequiv_path_arrow.Defined.Propositionequiv_path_subgroup'`{U:Univalence} {G:Group} (HK:SubgroupG): (forallg:G,Hg<->Kg) <~> (H=K).Proof.refine(equiv_path_subgroup__oE_).applyequiv_functor_forall_id;introg.exactequiv_path_iff_ishprop.Defined.Global Instanceishset_subgroup`{Univalence} {G:Group} :IsHSet(SubgroupG).Proof.nrefine(istrunc_equiv_istrunc_issig_subgroup).nrefine(istrunc_equiv_istrunc_(equiv_functor_sigma_id_)).-introP;applyissig_issubgroup.-nrefine(istrunc_equiv_istrunc_(equiv_sigma_assoc'__)^-1%equiv).nrapplyistrunc_sigma.2:intros[];applyistrunc_hprop.nrefine(istrunc_equiv_istrunc_(equiv_sig_coind(fung:G=>Type) (fungx=>IsHPropx))^-1%equiv).applyistrunc_forall.Defined.SectionCosets.Left and right cosets give equivalence relations.Context{G:Group} (H:SubgroupG).The relation of being in a left coset represented by an element.Definitionin_cosetL:RelationG:=funxy=>H(-x*y).The relation of being in a right coset represented by an element.Definitionin_cosetR:RelationG:=funxy=>H(x* -y).Hint Extern4 =>progressunfoldin_cosetL:typeclass_instances.Hint Extern4 =>progressunfoldin_cosetR:typeclass_instances.Global Argumentsin_cosetL/.Global Argumentsin_cosetR/.These are propsGlobal Instanceishprop_in_cosetL:is_mere_relationGin_cosetL:=_.Global Instanceishprop_in_cosetR:is_mere_relationGin_cosetR:=_.In fact, they are both equivalence relations.Global Instancereflexive_in_cosetL:Reflexivein_cosetL.Proof.introx;hnf.rewriteleft_inverse.applyissubgroup_in_unit.Defined.Global Instancereflexive_in_cosetR:Reflexivein_cosetR.Proof.introx;hnf.rewriteright_inverse.applyissubgroup_in_unit.Defined.Global Instancesymmetric_in_cosetL:Symmetricin_cosetL.Proof.introsxyh;cbn;cbninh.rewrite<- (negate_involutivex).rewrite<-negate_sg_op.applyissubgroup_in_inv;assumption.Defined.Global Instancesymmetric_in_cosetR:Symmetricin_cosetR.Proof.introsxyh;cbn;cbninh.rewrite<- (negate_involutivey).rewrite<-negate_sg_op.applyissubgroup_in_inv;assumption.Defined.Global Instancetransitive_in_cosetL:Transitivein_cosetL.Proof.introsxyzhk;cbn;cbninh;cbnink.rewrite<- (right_identity(-x)).rewrite<- (right_inversey:y* -y=mon_unit).rewrite(associativity(-x)__).rewrite<-simple_associativity.applyissubgroup_in_op;assumption.Defined.Global Instancetransitive_in_cosetR:Transitivein_cosetR.Proof.introsxyzhk;cbn;cbninh;cbnink.rewrite<- (right_identityx).rewrite<- (left_inversey: -y*y=mon_unit).rewrite(simple_associativityx).rewrite<- (associativity__(-z)).applyissubgroup_in_op;assumption.Defined.EndCosets.Identities related to the left and right cosets.Definitionin_cosetL_unit{G:Group} {N:SubgroupG}:forallxy,in_cosetLN(-x*y)mon_unit<~>in_cosetLNxy.Proof.introsxy;cbn.rewrite(right_identity(-_)).rewrite(negate_sg_op_).rewrite(negate_involutive_).applyequiv_iff_hprop;applysymmetric_in_cosetL.Defined.Definitionin_cosetR_unit{G:Group} {N:SubgroupG}:forallxy,in_cosetRN(x* -y)mon_unit<~>in_cosetRNxy.Proof.introsxy;cbn.rewritenegate_mon_unit.rewrite(right_identity(x* -y)).reflexivity.Defined.Symmetry is an equivalence.Definitionequiv_in_cosetL_symm{G:Group} {N:SubgroupG}:forallxy,in_cosetLNxy<~>in_cosetLNyx.Proof.introsxy.srapplyequiv_iff_hprop.all:byintro.Defined.Definitionequiv_in_cosetR_symm{G:Group} {N:SubgroupG}:forallxy,in_cosetRNxy<~>in_cosetRNyx.Proof.introsxy.srapplyequiv_iff_hprop.all:byintro.Defined.A normal subgroup is a subgroup closed under conjugation.ClassIsNormalSubgroup{G:Group} (N:SubgroupG):=isnormal:forall{xy},N(x*y) ->N(y*x).RecordNormalSubgroup(G:Group) := {normalsubgroup_subgroup:SubgroupG;normalsubgroup_isnormal:IsNormalSubgroupnormalsubgroup_subgroup;}.ArgumentsBuild_NormalSubgroupGN_:rename.Coercionnormalsubgroup_subgroup:NormalSubgroup>->Subgroup.Global Existing Instancenormalsubgroup_isnormal.Definitionequiv_symmetric_in_normalsubgroup{G:Group}(N:NormalSubgroupG):forallxy,N(x*y) <~>N(y*x).Proof.introsxy.rapplyequiv_iff_hprop.all:applyisnormal.Defined.Our definiiton of normal subgroup implies the usual definition of invariance under conjugation.Definitionisnormal_conjugate{G:Group} (N:NormalSubgroupG) {xy:G}:Nx->N(y*x* -y).Proof.introsn.applyisnormal.nrefine(transportN(grp_assoc___)^_).nrefine(transport(funy=>N(y*x)) (grp_inv_l_)^_).nrefine(transportN(grp_unit_l_)^_).exactn.Defined.We can show a subgroup is normal if it is invariant under conjugation.DefinitionBuild_IsNormalSubgroup'(G:Group) (N:SubgroupG)(isnormal:forallxy,Nx->N(y*x* -y)):IsNormalSubgroupN.Proof.introsxyn.nrefine(transportN(grp_unit_r_)_).nrefine(transport(funz=>N(_*z)) (grp_inv_ry)_).nrefine(transportN(grp_assoc___)^_).nrefine(transport(funz=>N(z*_)) (grp_assoc___)_).byapplyisnormal.Defined.Under funext, being a normal subgroup is a hprop.Global Instanceishprop_isnormalsubgroup`{Funext} {G:Group} (N:SubgroupG):IsHProp(IsNormalSubgroupN).Proof.unfoldIsNormalSubgroup;exact_.Defined.Our definition of normal subgroup and the usual definition are therefore equivalent.Definitionequiv_isnormal_conjugate`{Funext} {G:Group} (N:SubgroupG):IsNormalSubgroupN<~> (forallxy,Nx->N(y*x* -y)).Proof.rapplyequiv_iff_hprop.-introsis_normalxy.exact(isnormal_conjugate(Build_NormalSubgroupGNis_normal)).-introsis_normal'.bysnrapplyBuild_IsNormalSubgroup'.Defined.Left and right cosets are equivalent in normal subgroups.Definitionequiv_in_cosetL_in_cosetR_normalsubgroup{G:Group}(N:NormalSubgroupG) (xy:G):in_cosetLNxy<~>in_cosetRNxy:=equiv_in_cosetR_symm__oEequiv_symmetric_in_normalsubgroup___.Inverses are then respectedDefinitionin_cosetL_inverse{G:Group} {N:NormalSubgroupG} (xy:G):in_cosetLN(-x) (-y) <~>in_cosetLNxy.Proof.refine(_oEequiv_in_cosetL_in_cosetR_normalsubgroup___);cbn.byrewritenegate_involutive.Defined.Definitionin_cosetR_inverse{G:Group} {N:NormalSubgroupG} (xy:G):in_cosetRN(-x) (-y) <~>in_cosetRNxy.Proof.refine(_oEequiv_in_cosetL_in_cosetR_normalsubgroup___);cbn.byrewritegrp_inv_inv.Defined.This lets us prove that left and right coset relations are congruences.Definitionin_cosetL_cong{G:Group} {N:NormalSubgroupG}(xx'yy':G):in_cosetLNxy->in_cosetLNx'y'->in_cosetLN(x*x') (y*y').Proof.cbn;introspq.rewrite goal before applying subgroup_oprewritenegate_sg_op, <-simple_associativity.applyisnormal.rewritesimple_associativity, <-simple_associativity.applysubgroup_in_op.1:exactp.applyisnormal.exactq.Defined.Definitionin_cosetR_cong{G:Group} {N:NormalSubgroupG}(xx'yy':G):in_cosetRNxy->in_cosetRNx'y'->in_cosetRN(x*x') (y*y').Proof.cbn;introspq.rewrite goal before applying subgroup_oprewritenegate_sg_op,simple_associativity.applyisnormal.rewrite<-simple_associativity,simple_associativity.applysubgroup_in_op.2:exactq.applyisnormal.exactp.Defined.The property of being the trivial subgroup is useful.DefinitionIsTrivialSubgroup{G:Group} (H:SubgroupG) :Type:=forallx,Hx<->trivial_subgroupx.Existing ClassIsTrivialSubgroup.Global Instanceistrivialsubgroup_trivial_subgroup{G:Group}:IsTrivialSubgroup(@trivial_subgroupG):=ltac:(hnf;reflexivity).Intersection of two subgroupsDefinitionsubgroup_intersection{G:Group} (HK:SubgroupG) :SubgroupG.Proof.snrapplyBuild_Subgroup'.1:exact(fung=>Hg/\Kg).1:exact_.1:split;applysubgroup_in_unit.introsxy[] [].split;byapplysubgroup_in_op_inv.Defined.The subgroup generated by a subsetUnderlying type family of a subgroup generated by subsetInductivesubgroup_generated_type{G:Group} (X:G->Type) :G->Type:=The subgroup should contain all elements of the original family.|sgt_in(g:G) :Xg->subgroup_generated_typeXgIt should contain the unit.|sgt_unit:subgroup_generated_typeXmon_unitFinally, it should be closed under inverses and operation.|sgt_op(gh:G):subgroup_generated_typeXg->subgroup_generated_typeXh->subgroup_generated_typeX(g* -h).Argumentssgt_in{GXg}.Argumentssgt_unit{GX}.Argumentssgt_op{GXgh}.Note thatsubgroup_generated_typewill not automatically land inHProp. For example, ifXalready "contains" the unit of the group, then there are at least two different inhabitants of this family at the unit (given bysgt_unitandsgt_ingroup_unit_). Therefore, we propositionally truncate insubgroup_generatedbelow.Subgroups are closed under inverses.Definitionsgt_inv{G:Group} {X} {g:G}:subgroup_generated_typeXg->subgroup_generated_typeX(-g).Proof.introsp.rewrite<-left_identity.exact(sgt_opsgt_unitp).Defined.Definitionsgt_inv'{G:Group} {X} {g:G}:subgroup_generated_typeX(-g) ->subgroup_generated_typeXg.Proof.introsp.rewrite<-grp_inv_inv.byapplysgt_inv.Defined.Definitionsgt_op'{G:Group} {X} {gh:G}:subgroup_generated_typeXg->subgroup_generated_typeXh->subgroup_generated_typeX(g*h).Proof.introspq.rewrite<- (negate_involutiveh).exact(sgt_opp(sgt_invq)).Defined.The subgroup generated by a subsetDefinitionsubgroup_generated{G:Group} (X:G->Type) :SubgroupG.Proof.refine(Build_Subgroup'(merelyosubgroup_generated_typeX)(trsgt_unit)_).introsxypq;strip_truncations.exact(tr(sgt_oppq)).Defined.The inclusion of generators into the generated subgroup.Definitionsubgroup_generated_gen_incl{G:Group} {X:G->Type} (g:G) (H:Xg):subgroup_generatedX:= (g;tr(sgt_inH)).Iff:G$->His a group homomorphism andXandYare subsets ofGandHsuch thatfmapsXintoY, thenfsends the subgroup generated byXinto the subgroup generated byY.Definitionfunctor_subgroup_generated{GH:Group} (X:G->Type) (Y:H->Type)(f:G$->H) (preserves:forallg,Xg->Y(fg)):forallg,subgroup_generatedXg->subgroup_generatedY(fg).Proof.introg.applyTrunc_functor.introp.inductionpas[gi| |ghp1IHp1p2IHp2].-applysgt_in,preserves,i.-rewritegrp_homo_unit.applysgt_unit.-rewritegrp_homo_op,grp_homo_inv.byapplysgt_op.Defined.The product of two subgroups.Definitionsubgroup_product{G:Group} (HK:SubgroupG) :SubgroupG:=subgroup_generated(funx=> ((Hx) + (Kx))%type).The induction principle for the product.Definitionsubgroup_product_ind{G:Group} (HK:SubgroupG)(P:forallx,subgroup_productHKx->Type)(P_H_in:forallxy,Px(tr(sgt_in(inly))))(P_K_in:forallxy,Px(tr(sgt_in(inry))))(P_unit:Pmon_unit(trsgt_unit))(P_op:forallxyhk,Px(trh) ->Py(trk) ->P(x* -y) (tr(sgt_ophk)))`{forallxy,IsHProp(Pxy)}:forallx(p:subgroup_productHKx),Pxp.Proof.introsxp.strip_truncations.inductionpas[xs| |xyhIHhkIHk].+destructs.-applyP_H_in.-applyP_K_in.+exactP_unit.+byapplyP_op.Defined.(* **** Paths between generated subgroups *)(* This gets used twice inpath_subgroup_generated, so we factor it out here. *)Local Lemmapath_subgroup_generated_helper{G:Group}(XY:G->Type) (K:forallg,merely(Xg) ->merely(Yg)):forallg,Trunc(-1) (subgroup_generated_typeXg)->Trunc(-1) (subgroup_generated_typeYg).Proof.introg;applyTrunc_rec;introing.inductioningas[gx| |ghXgIHYgXhIHYh].-exact(Trunc_functor(-1)sgt_in(Kg(trx))).-exact(trsgt_unit).-strip_truncations.byapplytr,sgt_op.Defined.(* If the predicates selecting the generators are merely equivalent, then the generated subgroups are equal. (One could probably prove that the generated subgroup are isomorphic without using univalence.) *)Definitionpath_subgroup_generated`{Univalence} {G:Group}(XY:G->Type) (K:forallg,Trunc(-1) (Xg) <->Trunc(-1) (Yg)):subgroup_generatedX=subgroup_generatedY.Proof.rapplyequiv_path_subgroup'.(* Uses Univalence. *)introg;split.-applypath_subgroup_generated_helper, (funx=>fst(Kx)).-applypath_subgroup_generated_helper, (funx=>snd(Kx)).Defined.(* Equal subgroups have isomorphic underlying groups. *)Definitionequiv_subgroup_group{G:Group} (H1H2:SubgroupG):H1=H2->GroupIsomorphismH1H2:=ltac:(intros[];exactgrp_iso_id).

--- Miscellaneous\SuccessorStructure.html ---
SuccessorStructureLibrary SuccessorStructureRequireImportBasics.RequireImportNat.Core.RequireImportSpaces.Int.RequireImportSpaces.Finite.Fin.RequireImportWildCat.Core.LocalSetUniverseMinimizationToSet.Successor Structures.A successor structure is just a type with a endofunctor on it, called 'successor'. Typical examples include either the integers or natural numbers with the successor (or predecessor) operation.RecordSuccStr:Type:= {ss_carrier:>Type;ss_succ:ss_carrier->ss_carrier;}.Declare Scopesucc_scope.Local OpenScopenat_scope.Local OpenScopetype_scope.Local OpenScopesucc_scope.DelimitScopesucc_scopewithsucc.Argumentsss_succ{_}_.Notation"x .+1" := (ss_succx) :succ_scope.Successor structure of naturalsDefinitionNatSucc:SuccStr:=Build_SuccStrnatnat_succ.Successor structure of integersDefinitionBinIntSucc:SuccStr:=Build_SuccStrIntint_succ.Notation"'+N'" :=NatSucc:succ_scope.Notation"'+Z'" :=BinIntSucc:succ_scope.Stratified successor structuresIfNhas a successor structure, then so does the productN*Finn.  The successor operation increases the second factor, and if it wraps around, it also increases the first factor.DefinitionStratifiedType(N:SuccStr) (n:nat) :=N*Finn.Definitionstratified_succ(N:SuccStr) (n:nat) (x:StratifiedTypeNn):StratifiedTypeNn.Proof.constructor.+destructn.-exact(Empty_rec_(sndx)).-destruct(dec(sndx=inrtt)).*exact(ss_succ(fstx)).*exact(fstx).+exact(fsucc_mod(sndx)).Defined.DefinitionStratified(N:SuccStr) (n:nat) :SuccStr:=Build_SuccStr(StratifiedTypeNn) (stratified_succNn).Addition in successor structuresDefinitionss_add{N:SuccStr} (n:N) (k:nat) :N:=nat_iterkss_succn.Infix"+" :=ss_add:succ_scope.Definitionss_add_succ{N:SuccStr} (n:N) (k:nat):n+k.+1 =n.+1 +k:=nat_iter_succ_rkss_succn.Definitionss_add_sum{N:SuccStr} (n:N) (kl:nat):n+ (k+l) = (n+l) +k:=nat_iter_addklss_succn.Nat and Int segmented by triplesNotation"'N3'" := (Stratified(+N) 3) :succ_scope.Notation"'Z3'" := (Stratified(+Z) 3) :succ_scope.Category of successor structuresInspired by the construction of the wildcat structure on pType, we can give SuccStr a wildcat structure in a similar manner (all the way up).RecordssFam(A:SuccStr) := {ss_fam:>A->Type;dss_succ{x} :ss_famx->ss_fam(x.+1);}.Argumentsss_fam{__}_.Argumentsdss_succ{___}.RecordssForall{A:SuccStr} (B:ssFamA) := {ss_fun:>forallx,Bx;ss_fun_succ:forallx,ss_funx.+1 =dss_succ(ss_funx);}.Argumentsss_fun{__}__.Argumentsss_fun_succ{__}__.Definitionssfam_const{A:SuccStr} (B:SuccStr) :ssFamA:=Build_ssFamA(fun_=>B) (fun_=>ss_succ).Definitionssfam_sshomotopy{A:SuccStr} {P:ssFamA} (fg:ssForallP):ssFamA.Proof.snrapplyBuild_ssFam.1:exact(funx=>fx=gx).cbn;introsxp.refine(ss_fun_succfx@apdss_succp@ (ss_fun_succgx)^).Defined.DefinitionssHomotopy{A:SuccStr} {P:ssFamA} (fg:ssForallP):=ssForall(ssfam_sshomotopyfg).Global Instanceisgraph_ss:IsGraphSuccStr.Proof.snrapplyBuild_IsGraph.introsXY.exact(@ssForallX(ssfam_constY)).Defined.Global Instanceisgraph_ssforall{A:SuccStr} (P:ssFamA):IsGraph(ssForallP).Proof.snrapplyBuild_IsGraph.exactssHomotopy.Defined.Global Instanceis2graph_ssforall{A:SuccStr} (P:ssFamA):Is2Graph(ssForallP):= {}.Global Instanceis2graph_ss:Is2GraphSuccStr:= {}.Global Instanceis3graph_ss:Is3GraphSuccStr:= {}.Ltacsselim_elimeqx:=matchtypeof(eqx)with| ?lhs=_=>generalizedependent(eqx);generalizedependentlhs|_=>fail"sselim: no lhs found"end.Ltacsselimf:=leteq:=fresh"eq"indestructfas[feq];cbnin*;matchtypeofeqwith|forallx: ?X,_=_=>multimatchgoalwith|x:X|-_=>sselim_elimeqx|f: ?Y->X|-_=>matchgoalwith|y:Y|-_=>sselim_elimeq(fy)|g: ?Z->Y|-_=>matchgoalwith|z:Z|-_=>sselim_elimeq(f(gz))endend|_=>fail"sselim: no hyp found"end|_=>fail"sselim: no eq found"end;nrapplypaths_ind_r;trycleareq;tryclearf.Tactic Notation"sselim"constr(x0) :=sselimx0.Tactic Notation"sselim"constr(x0)constr(x1) :=sselimx0;sselimx1.Tactic Notation"sselim"constr(x0)constr(x1)constr(x2) :=sselimx0;sselimx1x2.Tactic Notation"sselim"constr(x0)constr(x1)constr(x2)constr(x3) :=sselimx0;sselimx1x2x3.Tactic Notation"sselim"constr(x0)constr(x1)constr(x2)constr(x3)constr(x4) :=sselimx0;sselimx1x2x3x4.Tactic Notation"sselim"constr(x0)constr(x1)constr(x2)constr(x3)constr(x4)constr(x5) :=sselimx0;sselimx1x2x3x4x5.Tactic Notation"sselim"constr(x0)constr(x1)constr(x2)constr(x3)constr(x4)constr(x5)constr(x6) :=sselimx0;sselimx1x2x3x4x5x6.Global Instanceis01cat_ss:Is01CatSuccStr.Proof.snrapplyBuild_Is01Cat.-introX.snrapplyBuild_ssForall.+exact(funx=>x).+reflexivity.-introsXYZfg.snrapplyBuild_ssForall.+introx.exact(f(gx)).+introx.exact(apf(ss_fun_succgx) @ss_fun_succf(gx)).Defined.Global Instanceis01cat_ssforall{A:SuccStr} (P:ssFamA):Is01Cat(ssForallP).Proof.snrapplyBuild_Is01Cat.-introf.snrapplyBuild_ssForall.+reflexivity.+introx;simpl.bydestruct(ss_fun_succfx).-introsfghpq.snrapplyBuild_ssForall.+introx.exact(qx@px).+introx;cbn.sselimpqfgh.simpl.bydestruct(px), (qx).Defined.Global Instanceis0gpd_ssforall{A:SuccStr} (P:ssFamA):Is0Gpd(ssForallP).Proof.snrapplyBuild_Is0Gpd.introsfgp.snrapplyBuild_ssForall.-introx.exact(px)^.-introx;cbn.sselimpfg.bydestruct(px).Defined.Global Instanceis1cat_ss:Is1CatSuccStr.Proof.snrapplyBuild_Is1Cat'.1,2:exact_.-introsXYZg.snrapplyBuild_Is0Functor.introsfhp.snrapplyBuild_ssForall.+introx.exact(apg(px)).+introx;cbn.sselimpfh.destruct(px);clearp;simpl.sselimg.bydestruct(eq(fx)).-introsXYZg.snrapplyBuild_Is0Functor.introsfhq.snrapplyBuild_ssForall.+introsx.applyq.+introsx;cbn.bysselimgqfh.-introsXYZWfgh.srapplyBuild_ssForall.+introx.reflexivity.+introx;cbn.bysselimfgh.-introsXYf.srapplyBuild_ssForall.1:reflexivity.introsx.bysselimf.-introsXYf.srapplyBuild_ssForall.1:reflexivity.introsx.bysselimf.Defined.

--- Miscellaneous\Sum.html ---
SumLibrary SumRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.Sum categoriesGlobal Instanceisgraph_sumAB`{IsGraphA} `{IsGraphB}:IsGraph(A+B).Proof.econstructor.intros[a1|b1] [a2|b2].+exact(a1$->a2).+exactEmpty.+exactEmpty.+exact(b1$->b2).Defined.Global Instanceis01cat_sumAB`{Is01CatA} `{Is01CatB}:Is01Cat(A+B).Proof.srapplyBuild_Is01Cat.-intros[a|b];cbn;applyId.-intros[a|b] [a1|b1] [a2|b2];trycontradiction;cbn;applycat_comp.Defined.Global Instanceis2graph_sumAB`{Is2GraphA,Is2GraphB}:Is2Graph(A+B).Proof.introsxy;applyBuild_IsGraph.destructxas[a1|b1],yas[a2|b2];trycontradiction;cbn;applyHom.Defined.(* Note:trycontradictiondeals with empty cases. *)Global Instanceis1cat_sumAB`{Is1CatA} `{Is1CatB}:Is1Cat(A+B).Proof.snrapplyBuild_Is1Cat.-introsxy.srapplyBuild_Is01Cat;destructxas[a1|b1],yas[a2|b2].2,3,6,7:contradiction.all:cbn.1,2:exactId.1,2:introsabc;applycat_comp.-introsxy;srapplyBuild_Is0Gpd.destructxas[a1|b1],yas[a2|b2].2,3:contradiction.all:cbn;introsfg;applygpd_rev.-introsxyzh;srapplyBuild_Is0Functor.introsfgp.destructxas[a1|b1],yas[a2|b2].2,3:contradiction.all:destructzas[a3|b3].2,3:contradiction.all:cbnin*;change(f$==g)inp;exact(h$@Lp).-introsxyzh;srapplyBuild_Is0Functor.introsfgp.destructxas[a1|b1],yas[a2|b2].2,3:contradiction.all:destructzas[a3|b3].2,3:contradiction.all:cbnin*;change(f$==g)inp;exact(p$@Rh).-intros[a1|b1] [a2|b2].2,3:contradiction.all:intros[a3|b3].2,3:contradiction.all:intros[a4|b4].2-3:contradiction.all:introsfgh;cbn;applycat_assoc.-intros[a1|b1] [a2|b2].2,3:contradiction.all:intros[a3|b3].2,3:contradiction.all:intros[a4|b4].2-3:contradiction.all:introsfgh;cbn;applycat_assoc_opp.-intros[a1|b1] [a2|b2]f.2, 3:contradiction.all:cbn;applycat_idl.-intros[a1|b1] [a2|b2]f.2, 3:contradiction.all:cbn;applycat_idr.Defined.

--- Miscellaneous\surjective_factor.html ---
surjective_factorLibrary surjective_factorRequireImportHoTT.BasicsHoTT.Truncations.CoreModalities.Modality.Definition by factoring through a surjection.Sectionsurjective_factor.Context`{Funext}.Context{ABC} `{IsHSetC} `(f:A->C) `(g:A->B) {Esurj:IsSurjectiong}.Variable(Eg:forallxy,gx=gy->fx=fy).Lemmaishprop_surjective_factor_aux:forallb,IsHProp(existsc:C,foralla,ga=b->fa=c).Proof.intros.applySigma.ishprop_sigma_disjoint.introsc1c2E1E2.generalize(@center_(Esurjb));apply(Trunc_ind_).intros[ap];destructp.path_via(fa).Qed.Definitionsurjective_factor_aux:=@conn_map_elim____Esurj(funb=>existsc:C,foralla,ga=b->fa=c)ishprop_surjective_factor_aux(funa=>exist(func=>foralla,_->_=c) (fa) (funa'=>Ega'a)).Definitionsurjective_factor:B->C:=funb=> (surjective_factor_auxb).1.Lemmasurjective_factor_pr:f==composesurjective_factorg.Proof.introsa.apply(surjective_factor_aux(ga)).2.trivial.Qed.Endsurjective_factor.

--- Miscellaneous\Syllepsis.html ---
SyllepsisLibrary SyllepsisFromHoTTRequireImportBasicsTypes.(* vertical composition of squares *)Sectionconcat_square_vert.Context{X:Type}.(* 0-paths *)Context{a0b0c0:X}.Context{a1b1c1:X}.(* 1-paths *)Context{a01:a0=a1}.Context{b01:b0=b1}.Context{c01:c0=c1}.Context{ab0:a0=b0}.Context{ab1:a1=b1}.Context{bc0:b0=c0}.Context{bc1:b1=c1}.(* 2-paths *)Context(p:ab0@b01=a01@ab1).Context(q:bc0@c01=b01@bc1).Local Definitionconcat_square_vert:(ab0@bc0) @c01=a01@ (ab1@bc1).Proof.refine(concat_pp_p___@_).refine(whiskerL_q@_).refine(concat_p_pp___@_).refine(whiskerRp_@_).applyconcat_pp_p.Defined.Endconcat_square_vert.Infix"[-]" := (concat_square_vert) (atlevel60).(* horizontal composition of squares *)Sectionconcat_square_hor.Context{X:Type}.(* 0-paths *)Context{a0b0c0:X}.Context{a1b1c1:X}.(* 1-paths *)Context{a01:a0=a1}.Context{b01:b0=b1}.Context{c01:c0=c1}.Context{ab0:a0=b0}.Context{ab1:a1=b1}.Context{bc0:b0=c0}.Context{bc1:b1=c1}.(* 2-paths *)Context(p:a01@ab1=ab0@b01).Context(q:b01@bc1=bc0@c01).Local Definitionconcat_square_hor:a01@ (ab1@bc1) = (ab0@bc0) @c01.Proof.refine(concat_p_pp___@_).refine(whiskerRp_@_).refine(concat_pp_p___@_).refine(whiskerL_q@_).applyconcat_p_pp.Defined.Endconcat_square_hor.Infix"[I]" := (concat_square_hor) (atlevel60).(* We will frequently use the following equivalences. *)Definitionrlucancel{X} {ab:X} {pq:a=b} :(p=q) <~> (p@ 1 = 1 @q).Proof.refine(equiv_compose'__).-exact(equiv_concat_r(concat_1p_)^_).-exact(equiv_concat_l(concat_p1_)_).Defined.Definitionrlucancel_inv{X} {ab:X} {pq:a=b} := (@rlucancelXabpq)^-1.Definitionlrucancel{X} {ab:X} {pq:a=b} :(p=q) <~> (1 @p=q@ 1).Proof.refine(equiv_compose'__).-exact(equiv_concat_r(concat_p1_)^_).-exact(equiv_concat_l(concat_1p_)_).Defined.(* This special case ofequiv_path_indcomes up a lot. *)Definitionequiv_path_ind_rlucancel{X} (ab:X) (p:a=b)(P:forall(q:a=b),p@ 1 = 1 @q->Type)(r:Pp(rlucancel1)):forall(q:a=b) (s:p@ 1 = 1 @q),Pqs.Proof.snrapply(equiv_path_ind(fun_=>rlucancel)).exactr.Defined.(* This special case ofequiv_path_indcomes up a lot. *)Definitionequiv_path_ind_lrucancel{X} (ab:X) (p:a=b)(P:forall(q:a=b), 1 @p=q@ 1 ->Type)(r:Pp(lrucancel1)):forall(q:a=b) (s: 1 @p=q@ 1),Pqs.Proof.snrapply(equiv_path_ind(fun_=>lrucancel)).exactr.Defined.(* Interaction of the above equivalences with square composition. *)Definitionrlucancel_sVs_1_pp{X} {abc:X} {p:a=b} {q:b=c} {r} (theta:p@q=r) :(rlucancel1 [-]rlucancel1) @whiskerL_theta=whiskerRtheta_@ (rlucancel1).Proof.bydestructtheta,p,q.Defined.Definitionlrucancel_sHs_1_pp{X} {abc:X} {p:a=b} {q:b=c} {r} (theta:p@q=r) :(lrucancel1 [I]lrucancel1) @whiskerRtheta_=whiskerL_theta@ (lrucancel1).Proof.bydestructtheta,p,q.Defined.Definitionrlucancel_sHs_1{X} {ab:X} (p:a=b) :(rlucancel1 [I]rlucancel1) =rlucancel(idpathp).Proof.bydestructp.Defined.Definitionlrucancel_sVs_1{X} {ab:X} (p:a=b) :(lrucancel1 [-]lrucancel1) =lrucancel(idpathp).Proof.bydestructp.Defined.(* Naturality of composition with 1. *)Definitionulnat{X} {ab:X} {uv:a=b} (p:u=v) :whiskerL1p@concat_1pv=concat_1pu@p.Proof.destructp.exact(lrucancel1).Defined.Definitionurnat{X} {ab:X} {uv:a=b} (p:u=v) :whiskerRp1 @concat_p1v=concat_p1u@p.Proof.destructp.exact(lrucancel1).Defined.(* Exchange law for whiskering on the left and on the right. *)Definitionwlrnat{X} {abc:X} {uv:a=b} {xy:b=c}pq:whiskerLup@whiskerRqy=whiskerRqx@whiskerLvp.Proof.bydestructp,q.Defined.(* Eckmann-Hilton *)Theoremeh{X} {a:X} (pq:idpatha=idpatha) :p@q=q@p.Proof.refine(_@rlucancel_inv(urnatq[-]ulnatp)).refine((rlucancel_inv(ulnatp[-]urnatq))^ @_).exact(wlrnatpq).Defined.(* Eckmann-Hilton on reflexivity. *)Local Definitioneh_1p_gen{X} {ab:X} {uv:a=b} (p:u=v) {q} (theta:whiskerRp1 @ 1 = 1 @q) :(rlucancel_inv(1 [-]theta))^ @wlrnat1p@rlucancel_inv(theta[-] 1) @concat_p1q=concat_1pq.Proof.revertqtheta.snrapplyequiv_path_ind_rlucancel.bydestructp.Defined.Definitioneh_1p{X} {a:X} (p:idpatha=idpatha) :eh1p@concat_p1p=concat_1pp.Proof.exact(eh_1p_genp(urnatp)).Defined.Local Definitioneh_p1_gen{X} {ab:X} {uv:a=b} (p:u=v) {q} (theta:whiskerL1p@ 1 = 1 @q) :(rlucancel_inv(theta[-] 1))^ @wlrnatp1 @rlucancel_inv(1 [-]theta) @concat_1pq=concat_p1q.Proof.revertqtheta.snrapplyequiv_path_ind_rlucancel.bydestructp.Defined.Definitioneh_p1{X} {a:X} (p:idpatha=idpatha) :ehp1 @concat_1pp=concat_p1p.Proof.exact(eh_p1_genp(ulnatp)).Defined.(* Naturality of Eckmann-Hilton. *)Definitionehlnat{X} {a:X} (u:idpatha=idpatha) {xy} (p:x=y) :whiskerLup@ehuy=ehux@whiskerRpu.Proof.destructp.exact(lrucancel1).Defined.Definitionehrnat{X} {a:X} {uv} (p:u=v) (x:idpatha=idpatha) :whiskerRpx@ehvx=ehux@whiskerLxp.Proof.destructp.exact(lrucancel1).Defined.(* Naturality of Eckmann-Hilton when the fixed path is 1. *)Definitionehlnat_1p{X} {a:X} {uv:idpatha=idpatha} (p:u=v) :(ehlnat1p[I]urnatp) @whiskerR(eh_1pu)_=whiskerL_(eh_1pv) @ulnatp.Proof.destructp.applylrucancel_sHs_1_pp.Defined.Definitionehrnat_p1{X} {a:X} {uv:idpatha=idpatha} (p:u=v) :(ehrnatp1 [I]ulnatp) @whiskerR(eh_p1u)_=whiskerL_(eh_p1v) @urnatp.Proof.destructp.applylrucancel_sHs_1_pp.Defined.(* These lemmas should probably be in the library in some form. *)Local Definitionconcat_p_pp_pp_p{A} {uvxy:A} (p:u=v) (q:v=x) (r:x=y) :concat_p_pppqr@concat_pp_ppqr= 1.Proof.bydestructp,q,r.Defined.Local Definitionconcat_pp_p_p_pp{A} {uvxy:A} (p:u=v) (q:v=x) (r:x=y) :concat_pp_ppqr@concat_p_pppqr= 1.Proof.bydestructp,q,r.Defined.(* These lemmas are in the library but with worse computational behavior. *)Local DefinitionwhiskerL_pp{A} {abc:A} (u:a=b) {vwz:b=c} (p:v=w) (q:w=z) :whiskerLu(p@q) =whiskerLup@whiskerLuq.Proof.bydestructp,q.Defined.Local DefinitionwhiskerR_pp{A} {abc:A} {uvw:a=b} (z:b=c) (p:u=v) (q:v=w) :whiskerR(p@q)z=whiskerRpz@whiskerRqz.Proof.bydestructp,q.Defined.(* We now prove that "ulnat (p @ q)" suitably relates to "ulnat p" and "ulnat q". *)Definitionulnat_pp{X} {ab:X} {uvw:a=b} (p:u=v) (q:v=w) :ulnatp[-]ulnatq=whiskerR(whiskerL_pp_pq)^_@ulnat(p@q).Proof.bydestructp,q,u.Defined.(* We now prove that "urnat (p @ q)" suitably relates to "urnat p" and "urnat q". *)Definitionurnat_pp{X} {ab:X} {uvw:a=b} (p:u=v) (q:v=w) :urnatp[-]urnatq=whiskerR(whiskerR_pp_pq)^_@urnat(p@q).Proof.bydestructp,q,u.Defined.(* We now prove that "ehlnat u (p @ q)" suitably relates to "ehlnat u p" and "ehlnat u q". *)Definitionehlnat_pp{X} {a:X} (u:idpatha=idpatha) {vw:idpatha=idpatha} (p:v= 1) (q: 1 =w) :(ehlnatup[-]ehlnatuq) @whiskerL_(whiskerR_pp_pq)^ =(whiskerR(whiskerL_pp_pq)^_) @ehlnatu(p@q).Proof.revertvp.snrapply(equiv_path_ind(equiv_path_inverse_)).destructq.applyrlucancel,lrucancel_sVs_1.Defined.(* We now prove that "ehrnat (p @ q) w" suitably relates to "ehrnat p w" and "ehrnat q w". *)Definitionehrnat_pp{X} {a:X} {uv:idpatha=idpatha} (p:u= 1) (q: 1 =v) (w:idpatha=idpatha) :(ehrnatpw[-]ehrnatqw) @whiskerL_(whiskerL_pp_pq)^ =(whiskerR(whiskerR_pp_pq)^_) @ehrnat(p@q)w.Proof.revertup.snrapply(equiv_path_ind(equiv_path_inverse_)).destructq.cbn.applyrlucancel,lrucancel_sVs_1.Defined.(* We now prove that "wlrnat p (q @ r)" suitably relates to "wlrnat p q" and "wlrnat q p". *)Definitionwlrnat_p_pp{X} {abc:X} {uvw:a=b} {xy:b=c} (p:x=y) (q:u=v) (r:v=w) :(wlrnatpq[I]wlrnatpr) @whiskerR(whiskerR_pp_qr)^_=whiskerL_(whiskerR_pp_qr)^ @wlrnatp(q@r).Proof.bydestructp,q,r.Defined.(* We now prove that "wlrnat (p @ q) r" suitably relates to "wlrnat p r" and "wlrnat q r". *)Definitionwlrnat_pp_p{X} {abc:X} {uv:a=b} {xyz:b=c} (p:x=y) (q:y=z) (r:u=v) :(wlrnatpr[-]wlrnatqr) @whiskerL_(whiskerL_pp_pq)^ =whiskerR(whiskerL_pp_pq)^_@wlrnat(p@q)r.Proof.bydestructp,q,r.Defined.(* We now prove that "wlrnat p q" suitably relates to "wlrnat q p". *)Definitionwlrnat_V{X} {a:X} {uvxy:idpatha=idpatha}pq:whiskerR(wlrnatpq) (ehvy) @ (ehrnatqx[-]ehlnatvp) =(ehlnatup[-]ehrnatqy) @whiskerL(ehux) (wlrnatqp)^.Proof.destructp,q.exact(lrucancel1).Defined.(* Coherence 1: We now prove that "eh p (q @ r)" suitably relates to "eh p q" and "eh p r". *)Sectioneh_p_pp.Context{X:Type}.(* 0-paths *)Context{abcdef:X}.(* 1-paths *)Context{wlx0x0:a=b}.Context{wlx1x1:c=d}.Context{wlx2x2:e=f}.Context{wry0y0:b=d}.Context{wry1y1:a=c}.Context{wrz0z0:d=f}.Context{wrz1z1:c=e}.Context{wryz0:b=f}.Context{wryz1:a=e}.(* 2-paths *)Context{ulnat_x0:wlx0@ 1 = 1 @x0}.Context{ulnat_x1:wlx1@ 1 = 1 @x1}.Context{ulnat_x2:wlx2@ 1 = 1 @x2}.Context{urnat_y0:wry0@ 1 = 1 @y0}.Context{urnat_y1:wry1@ 1 = 1 @y1}.Context{urnat_z0:wrz0@ 1 = 1 @z0}.Context{urnat_z1:wrz1@ 1 = 1 @z1}.Context{urnat_yz0:wryz0@ 1 = 1 @ (y0@z0)}.Context{urnat_yz1:wryz1@ 1 = 1 @ (y1@z1)}.Context{wlrnat_x_y:wlx0@wry0=wry1@wlx1}.Context{wlrnat_x_z:wlx1@wrz0=wrz1@wlx2}.Context{wlrnat_x_yz:wlx0@wryz0=wryz1@wlx2}.Context{wrpp_yz0:wry0@wrz0=wryz0}.Context{wrpp_yz1:wry1@wrz1=wryz1}.(* 3-paths *)HypothesisH_urnat_yz0:(urnat_y0[-]urnat_z0) =whiskerRwrpp_yz0_@urnat_yz0.HypothesisH_urnat_yz1:(urnat_y1[-]urnat_z1) =whiskerRwrpp_yz1_@urnat_yz1.HypothesisH_wlrnat_x_yz:(wlrnat_x_y[I]wlrnat_x_z) @whiskerRwrpp_yz1_=whiskerL_wrpp_yz0@wlrnat_x_yz.(* the coherence *)Definitioneh_p_pp_gen:letEH_x_y:= (rlucancel_inv(ulnat_x0[-]urnat_y0))^ @wlrnat_x_y@rlucancel_inv(urnat_y1[-]ulnat_x1)inletEH_x_z:= (rlucancel_inv(ulnat_x1[-]urnat_z0))^ @wlrnat_x_z@rlucancel_inv(urnat_z1[-]ulnat_x2)inletEH_x_yz:= (rlucancel_inv(ulnat_x0[-]urnat_yz0))^ @wlrnat_x_yz@rlucancel_inv(urnat_yz1[-]ulnat_x2)inEH_x_yz@ (concat_pp_p___@whiskerL_EH_x_z^) =concat_p_pp___@whiskerREH_x_y_@concat_pp_p___.Proof.applymoveR_VpinH_urnat_yz0,H_urnat_yz1,H_wlrnat_x_yz.destructH_urnat_yz0,H_urnat_yz1,H_wlrnat_x_yz.clearH_urnat_yz0H_urnat_yz1H_wlrnat_x_yz.destructwrpp_yz0,wrpp_yz1.clearwrpp_yz0wrpp_yz1.revertx0ulnat_x0.snrapplyequiv_path_ind_rlucancel.revertx1ulnat_x1.snrapplyequiv_path_ind_rlucancel.revertx2ulnat_x2.snrapplyequiv_path_ind_rlucancel.reverty0urnat_y0.snrapplyequiv_path_ind_rlucancel.reverty1urnat_y1.snrapplyequiv_path_ind_rlucancel.revertz0urnat_z0.snrapplyequiv_path_ind_rlucancel.revertz1urnat_z1.snrapplyequiv_path_ind_rlucancel.destructwry0,wry1,wrz0,wrz1.clearwry0wry1wrz0wrz1.revertwlx2wlrnat_x_z.snrapplyequiv_path_ind_rlucancel.revertwlx1wlrnat_x_y.snrapplyequiv_path_ind_rlucancel.destructwlx0.clearwlx0.reflexivity.Defined.Endeh_p_pp.Theoremeh_p_pp{X} {a:X} (pqr:idpatha=idpatha) :ehp(q@r) @ (concat_pp_p___@whiskerL_(ehpr)^) =concat_p_pp___@whiskerR(ehpq)_@concat_pp_p___.Proof.nrapplyeh_p_pp_gen.-exact(urnat_ppqr).-exact(urnat_ppqr).-exact(wlrnat_p_pppqr).Defined.(* Coherence 1: We now prove that "eh (p @ q) r" suitably relates to "eh p r" and "eh q r". *)Sectioneh_pp_p.Context{X:Type}.(* 0-paths *)Context{abcdef:X}.(* 1-paths *)Context{wlx0x0:a=b}.Context{wlx1x1:d=e}.Context{wly0y0:b=c}.Context{wly1y1:e=f}.Context{wrz0z0:c=f}.Context{wrz1z1:b=e}.Context{wrz2z2:a=d}.Context{wlxy0:a=c}.Context{wlxy1:d=f}.(* 2-paths *)Context{ulnat_x0:wlx0@ 1 = 1 @x0}.Context{ulnat_x1:wlx1@ 1 = 1 @x1}.Context{ulnat_y0:wly0@ 1 = 1 @y0}.Context{ulnat_y1:wly1@ 1 = 1 @y1}.Context{urnat_z0:wrz0@ 1 = 1 @z0}.Context{urnat_z1:wrz1@ 1 = 1 @z1}.Context{urnat_z2:wrz2@ 1 = 1 @z2}.Context{ulnat_xy0:wlxy0@ 1 = 1 @ (x0@y0)}.Context{ulnat_xy1:wlxy1@ 1 = 1 @ (x1@y1)}.Context{wlrnat_x_z:wlx0@wrz1=wrz2@wlx1}.Context{wlrnat_y_z:wly0@wrz0=wrz1@wly1}.Context{wlrnat_xy_z:wlxy0@wrz0=wrz2@wlxy1}.Context{wlpp_xy0:wlx0@wly0=wlxy0}.Context{wlpp_xy1:wlx1@wly1=wlxy1}.(* 3-paths *)HypothesisH_ulnat_xy0:(ulnat_x0[-]ulnat_y0) =whiskerRwlpp_xy0_@ulnat_xy0.HypothesisH_ulnat_xy1:(ulnat_x1[-]ulnat_y1) =whiskerRwlpp_xy1_@ulnat_xy1.HypothesisH_wlrnat_xy_z:(wlrnat_x_z[-]wlrnat_y_z) @whiskerL_wlpp_xy1=whiskerRwlpp_xy0_@wlrnat_xy_z.(* the coherence *)Definitioneh_pp_p_gen:letEH_x_z:= (rlucancel_inv(ulnat_x0[-]urnat_z1))^ @wlrnat_x_z@rlucancel_inv(urnat_z2[-]ulnat_x1)inletEH_y_z:= (rlucancel_inv(ulnat_y0[-]urnat_z0))^ @wlrnat_y_z@rlucancel_inv(urnat_z1[-]ulnat_y1)inletEH_xy_z:= (rlucancel_inv(ulnat_xy0[-]urnat_z0))^ @wlrnat_xy_z@rlucancel_inv(urnat_z2[-]ulnat_xy1)inEH_xy_z@ (concat_p_pp___@whiskerREH_x_z^_) =concat_pp_p___@whiskerL_EH_y_z@concat_p_pp___.Proof.applymoveR_VpinH_ulnat_xy0,H_ulnat_xy1,H_wlrnat_xy_z.destructH_ulnat_xy0,H_ulnat_xy1,H_wlrnat_xy_z.clearH_ulnat_xy0H_ulnat_xy1H_wlrnat_xy_z.destructwlpp_xy0,wlpp_xy1.clearwlpp_xy0wlpp_xy1.revertx0ulnat_x0.snrapplyequiv_path_ind_rlucancel.revertx1ulnat_x1.snrapplyequiv_path_ind_rlucancel.reverty0ulnat_y0.snrapplyequiv_path_ind_rlucancel.reverty1ulnat_y1.snrapplyequiv_path_ind_rlucancel.revertz0urnat_z0.snrapplyequiv_path_ind_rlucancel.revertz1urnat_z1.snrapplyequiv_path_ind_rlucancel.revertz2urnat_z2.snrapplyequiv_path_ind_rlucancel.destructwlx0,wlx1,wly0,wly1.clearwlx0wlx1wly0wly1.revertwrz2wlrnat_x_z.snrapplyequiv_path_ind_lrucancel.revertwrz1wlrnat_y_z.snrapplyequiv_path_ind_lrucancel.destructwrz0.clearwrz0.reflexivity.Defined.Endeh_pp_p.Theoremeh_pp_p{X} {a:X} (pqr:idpatha=idpatha) :eh(p@q)r@ (concat_p_pp___@whiskerR(ehpr)^_) =concat_pp_p___@whiskerL_(ehqr) @concat_p_pp___.Proof.nrapplyeh_pp_p_gen.-exact(ulnat_pppq).-exact(ulnat_pppq).-exact(wlrnat_pp_ppqr).Defined.(* Syllepsis: We now prove that "eh p q" is suitably related to "eh q p". *)Sectioneh_V.Context{X:Type}.(* 0-paths *)Context{abcd:X}.(* 1-paths *)Context{wlx0x0wrx0:a=b}.Context{wlx1x1wrx1:c=d}.Context{wly0y0wry0:b=d}.Context{wly1y1wry1:a=c}.(* 2-paths *)Context{ulnat_x0:wlx0@ 1 = 1 @x0}.Context{urnat_x0:wrx0@ 1 = 1 @x0}.Context{ulnat_x1:wlx1@ 1 = 1 @x1}.Context{urnat_x1:wrx1@ 1 = 1 @x1}.Context{ulnat_y0:wly0@ 1 = 1 @y0}.Context{urnat_y0:wry0@ 1 = 1 @y0}.Context{ulnat_y1:wly1@ 1 = 1 @y1}.Context{urnat_y1:wry1@ 1 = 1 @y1}.Context{ehlnat_x0:wlx0@ 1 = 1 @wrx0}.Context{ehlnat_x1:wlx1@ 1 = 1 @wrx1}.Context{ehrnat_y0:wry0@ 1 = 1 @wly0}.Context{ehrnat_y1:wry1@ 1 = 1 @wly1}.Context{wlrnat_x_y:wlx0@wry0=wry1@wlx1}.Context{wlrnat_y_x:wly1@wrx1=wrx0@wly0}.(* 3-paths *)Hypothesisehlnat_1p_x0:(ehlnat_x0[I]urnat_x0) @ 1  = 1 @ulnat_x0.Hypothesisehlnat_1p_x1:(ehlnat_x1[I]urnat_x1) @ 1 = 1 @ulnat_x1.Hypothesisehrnat_p1_y0:(ehrnat_y0[I]ulnat_y0) @ 1 = 1 @urnat_y0.Hypothesisehrnat_p1_y1:(ehrnat_y1[I]ulnat_y1) @ 1 = 1 @urnat_y1.Hypothesiswlrnat_V_x_y:whiskerRwlrnat_x_y_@ (ehrnat_y1[-]ehlnat_x1) =(ehlnat_x0[-]ehrnat_y0) @whiskerL_wlrnat_y_x^.(* the syllepsis *)Definitioneh_V_gen:letEH_x_y:= (rlucancel_inv(ulnat_x0[-]urnat_y0))^ @wlrnat_x_y@rlucancel_inv(urnat_y1[-]ulnat_x1)inletEH_y_x:= (rlucancel_inv(ulnat_y1[-]urnat_x1))^ @wlrnat_y_x@rlucancel_inv(urnat_x0[-]ulnat_y0)inEH_x_y@EH_y_x= 1.Proof.pose(H_whiskerR_wlrnat_x_y:=moveL_Mp___(moveL_pV___(whiskerR_p1wlrnat_x_y))).applymoveL_pVinwlrnat_V_x_y.apply(concatH_whiskerR_wlrnat_x_y^)inwlrnat_V_x_y.applymoveL_Vp,moveL_pVinwlrnat_V_x_y.applysymmetryinwlrnat_V_x_y.destructwlrnat_V_x_y.clearwlrnat_V_x_y.clearH_whiskerR_wlrnat_x_y.revertulnat_x0ehlnat_1p_x0.snrapplyequiv_path_ind_rlucancel.revertulnat_x1ehlnat_1p_x1.snrapplyequiv_path_ind_rlucancel.reverturnat_y0ehrnat_p1_y0.snrapplyequiv_path_ind_rlucancel.reverturnat_y1ehrnat_p1_y1.snrapplyequiv_path_ind_rlucancel.revertx0urnat_x0.snrapplyequiv_path_ind_rlucancel.revertx1urnat_x1.snrapplyequiv_path_ind_rlucancel.reverty0ulnat_y0.snrapplyequiv_path_ind_rlucancel.reverty1ulnat_y1.snrapplyequiv_path_ind_rlucancel.revertwlrnat_y_x.revertwrx0ehlnat_x0.snrapplyequiv_path_ind_rlucancel.revertwrx1ehlnat_x1.snrapplyequiv_path_ind_rlucancel.revertwly0ehrnat_y0.snrapplyequiv_path_ind_rlucancel.revertwly1ehrnat_y1.snrapplyequiv_path_ind_rlucancel.destructwry0,wry1,wlx1.clearwry0wry1wlx1.revertwlx0.snrapplyequiv_path_ind_lrucancel.reflexivity.Defined.Endeh_V.Theoremeh_V{X} {a:X} (pq:idpath(idpatha) =idpath(idpatha)) :ehpq@ehqp= 1.Proof.nrapplyeh_V_gen.-exact(ehlnat_1pp).-exact(ehlnat_1pp).-exact(ehrnat_p1q).-exact(ehrnat_p1q).-exact(wlrnat_Vpq).Defined.(* Given "ehrnat_p1 y" and "ehrnat_p1 z", we can explicitly construct "ehrnat_p1 (y @ z)". *)SectionEhrnat_p1_pp.Context{X:Type}.(* 0-paths *)Context{a0a1a2:X}.Context{b0b1b2:X}.Context{c0c1c2:X}.(* 1-paths *)Context{wry:a0=b0}.Context{wrz:b0=c0}.Context{wly:a1=b1}.Context{wlz:b1=c1}.Context{y:a2=b2}.Context{z:b2=c2}.Context{wryz:a0=c0}.Context{wlyz:a1=c1}.Context{a01:a0=a1}.Context{a12:a1=a2}.Context{b01:b0=b1}.Context{b12:b1=b2}.Context{c01:c0=c1}.Context{c12:c1=c2}.Context{a02:a0=a2}.Context{c02:c0=c2}.(* 2-paths *)Context{ehrnat_y:wry@b01=a01@wly}.Context{ehrnat_z:wrz@c01=b01@wlz}.Context{ehrnat_yz:wryz@c01=a01@wlyz}.Context{ulnat_y:wly@b12=a12@y}.Context{ulnat_z:wlz@c12=b12@z}.Context{ulnat_yz:wlyz@c12=a12@ (y@z)}.Context{urnat_y:wry@ (b01@b12) =a02@y}.Context{urnat_z:wrz@c02= (b01@b12) @z}.Context{urnat_yz:wryz@c02=a02@ (y@z)}.Context{wrpp_yz:wry@wrz=wryz}.Context{wlpp_yz:wly@wlz=wlyz}.Context(H_a02:a01@a12=a02).Context(H_c02:c01@c12=c02).(* 3-paths *)HypothesisH_ehrnat_yz:(ehrnat_y[-]ehrnat_z) @whiskerL_wlpp_yz=whiskerRwrpp_yz_@ehrnat_yz.HypothesisH_ulnat_yz:(ulnat_y[-]ulnat_z) =whiskerRwlpp_yz_@ulnat_yz.HypothesisH_urnat_yz:(urnat_y[-]urnat_z) =whiskerRwrpp_yz_@urnat_yz.Variableehrnat_p1_y:(ehrnat_y[I]ulnat_y) @whiskerRH_a02_= 1 @urnat_y.Variableehrnat_p1_z:(ehrnat_z[I]ulnat_z) @ 1 =whiskerL_H_c02@urnat_z.(* the composite iso *)DefinitionEhrnat_p1_pp:(ehrnat_yz[I]ulnat_yz) @whiskerRH_a02_=whiskerL_H_c02@urnat_yz.Proof.applymoveR_VpinH_urnat_yz,H_ulnat_yz,H_ehrnat_yz.destructH_urnat_yz,H_ulnat_yz,H_ehrnat_yz.clearH_urnat_yzH_ulnat_yzH_ehrnat_yz.applymoveR_Vpinehrnat_p1_y,ehrnat_p1_z.destructehrnat_p1_y,ehrnat_p1_z.clearehrnat_p1_yehrnat_p1_z.destructH_a02,H_c02.clearH_a02H_c02.destructwrpp_yz,wlpp_yz.clearwrpp_yzwlpp_yz.destructa01,a12,b01,b12,c01,c12.cleara01a12b01b12c01c12.revertyulnat_y.snrapplyequiv_path_ind_rlucancel.revertzulnat_z.snrapplyequiv_path_ind_rlucancel.revertwlyehrnat_y.snrapplyequiv_path_ind_rlucancel.revertwlzehrnat_z.snrapplyequiv_path_ind_rlucancel.destructwry,wrz.clearwrywrz.reflexivity.Defined.EndEhrnat_p1_pp.Definitionehrnat_p1_pp{X} {a:X} {uv:idpatha=idpatha} (q:u= 1) (r: 1 =v) :Ehrnat_p1_pp(eh_p1u) (eh_p1v) (ehrnat_ppqr1) (ulnat_ppqr) (urnat_ppqr)(ehrnat_p1q) (ehrnat_p1r) =ehrnat_p1(q@r).Proof.revertuq.snrapply(equiv_path_ind(equiv_path_inverse_)).bydestructr.Defined.(* Given "wlrnat_V x y" and "wlrnat_V x z", we can explicitly construct "wlrnat_V x (y @ z)". *)Sectionwlrnat_V_p_pp.Context{X:Type}.(* 0-paths *)Context{a0b0c0d0e0f0:X}.Context{a1b1c1d1e1f1:X}.(* 1-paths *)Context{wlx0:a0=b0}.Context{wlx1:c0=d0}.Context{wlx2:e0=f0}.Context{wrx0:a1=b1}.Context{wrx1:c1=d1}.Context{wrx2:e1=f1}.Context{wry0:b0=d0}.Context{wly0:b1=d1}.Context{wry1:a0=c0}.Context{wly1:a1=c1}.Context{wrz0:d0=f0}.Context{wlz0:d1=f1}.Context{wrz1:c0=e0}.Context{wlz1:c1=e1}.Context{a01:a0=a1}.Context{b01:b0=b1}.Context{c01:c0=c1}.Context{d01:d0=d1}.Context{e01:e0=e1}.Context{f01:f0=f1}.Context{wryz0:b0=f0}.Context{wlyz0:b1=f1}.Context{wryz1:a0=e0}.Context{wlyz1:a1=e1}.(* 2-paths *)Context{ehlnat_x0:wlx0@b01=a01@wrx0}.Context{ehlnat_x1:wlx1@d01=c01@wrx1}.Context{ehlnat_x2:wlx2@f01=e01@wrx2}.Context{ehrnat_y0:wry0@d01=b01@wly0}.Context{ehrnat_y1:wry1@c01=a01@wly1}.Context{ehrnat_z0:wrz0@f01=d01@wlz0}.Context{ehrnat_z1:wrz1@e01=c01@wlz1}.Context{ehrnat_yz0:wryz0@f01=b01@wlyz0}.Context{ehrnat_yz1:wryz1@e01=a01@wlyz1}.Context{wlrnat_x_y:wlx0@wry0=wry1@wlx1}.Context{wlrnat_y_x:wly1@wrx1=wrx0@wly0}.Context{wlrnat_x_z:wlx1@wrz0=wrz1@wlx2}.Context{wlrnat_z_x:wlz1@wrx2=wrx1@wlz0}.Context{wlrnat_x_yz:wlx0@wryz0=wryz1@wlx2}.Context{wlrnat_yz_x:wlyz1@wrx2=wrx0@wlyz0}.Context{wrpp_yz0:wry0@wrz0=wryz0}.Context{wlpp_yz0:wly0@wlz0=wlyz0}.Context{wrpp_yz1:wry1@wrz1=wryz1}.Context{wlpp_yz1:wly1@wlz1=wlyz1}.(* 3-paths *)HypothesisH_ehrnat_yz0:(ehrnat_y0[-]ehrnat_z0) @whiskerL_wlpp_yz0=whiskerRwrpp_yz0_@ehrnat_yz0.HypothesisH_ehrnat_yz1:(ehrnat_y1[-]ehrnat_z1) @whiskerL_wlpp_yz1=whiskerRwrpp_yz1_@ehrnat_yz1.HypothesisH_wlrnat_x_yz:(wlrnat_x_y[I]wlrnat_x_z) @whiskerRwrpp_yz1_=whiskerL_wrpp_yz0@wlrnat_x_yz.HypothesisH_wlrnat_yz_x:(wlrnat_y_x[-]wlrnat_z_x) @whiskerL_wlpp_yz0=whiskerRwlpp_yz1_@wlrnat_yz_x.Variablewlrnat_V_x_y:whiskerRwlrnat_x_y_@ (ehrnat_y1[-]ehlnat_x1) =(ehlnat_x0[-]ehrnat_y0) @whiskerL_wlrnat_y_x^.Variablewlrnat_V_x_z:whiskerRwlrnat_x_z_@ (ehrnat_z1[-]ehlnat_x2) =(ehlnat_x1[-]ehrnat_z0) @whiskerL_wlrnat_z_x^.(* the composite square *)DefinitionWlrnat_V_p_pp:whiskerRwlrnat_x_yz_@ (ehrnat_yz1[-]ehlnat_x2) =(ehlnat_x0[-]ehrnat_yz0) @whiskerL_wlrnat_yz_x^.Proof.applymoveR_VpinH_ehrnat_yz0,H_ehrnat_yz1.destructH_ehrnat_yz0,H_ehrnat_yz1.clearH_ehrnat_yz0H_ehrnat_yz1.applymoveR_VpinH_wlrnat_x_yz,H_wlrnat_yz_x.destructH_wlrnat_x_yz,H_wlrnat_yz_x.clearH_wlrnat_x_yzH_wlrnat_yz_x.destructa01,b01,c01,d01,e01,f01.cleara01b01c01d01e01f01.pose(H_whiskerR_wlrnat_x_y:=moveL_Mp___(moveL_pV___(whiskerR_p1wlrnat_x_y))).pose(H_whiskerR_wlrnat_x_z:=moveL_Mp___(moveL_pV___(whiskerR_p1wlrnat_x_z))).applymoveL_pVinwlrnat_V_x_y.apply(concatH_whiskerR_wlrnat_x_y^)inwlrnat_V_x_y.applymoveL_Vp,moveL_pVinwlrnat_V_x_y.applysymmetryinwlrnat_V_x_y.destructwlrnat_V_x_y.clearwlrnat_V_x_y.applymoveL_pVinwlrnat_V_x_z.apply(concatH_whiskerR_wlrnat_x_z^)inwlrnat_V_x_z.applymoveL_Vp,moveL_pVinwlrnat_V_x_z.applysymmetryinwlrnat_V_x_z.destructwlrnat_V_x_z.clearwlrnat_V_x_z.clearH_whiskerR_wlrnat_x_yH_whiskerR_wlrnat_x_z.destructwrpp_yz0,wlpp_yz0,wrpp_yz1,wlpp_yz1.clearwrpp_yz0wlpp_yz0wrpp_yz1wlpp_yz1.revertwlrnat_y_xwlrnat_z_x.revertwrx0ehlnat_x0.snrapplyequiv_path_ind_rlucancel.revertwrx1ehlnat_x1.snrapplyequiv_path_ind_rlucancel.revertwrx2ehlnat_x2.snrapplyequiv_path_ind_rlucancel.revertwly0ehrnat_y0.snrapplyequiv_path_ind_rlucancel.revertwly1ehrnat_y1.snrapplyequiv_path_ind_rlucancel.revertwlz0ehrnat_z0.snrapplyequiv_path_ind_rlucancel.revertwlz1ehrnat_z1.snrapplyequiv_path_ind_rlucancel.destructwry0,wry1,wrz0,wrz1.clearwry0wry1wrz0wrz1.revertwlx0.snrapplyequiv_path_ind_lrucancel.revertwlx1.snrapplyequiv_path_ind_lrucancel.destructwlx2.clearwlx2.reflexivity.Defined.Endwlrnat_V_p_pp.Definitionwlrnat_V_p_pp{X} {a:X} {uvw:idpatha=idpatha} (p: 1 =w) (q:u= 1) (r: 1 =v) :Wlrnat_V_p_pp(ehrnat_ppqr_) (ehrnat_ppqr_) (wlrnat_p_pppqr) (wlrnat_pp_pqrp)(wlrnat_Vpq) (wlrnat_Vpr) =wlrnat_Vp(q@r).Proof.revertuq.snrapply(equiv_path_ind(equiv_path_inverse_)).bydestructp,r.Defined.(* Next we prove a coherence law relatingeh_Vp(q@r)toeh_Vpqandeh_Vpq. *)(* The following tactics will be used to make the proof faster, but with only minor modifications, the proof goes through without these tactics. The final tacticgeneralize_goaltakes a goal of the formforallabc...,expressionand asserts a new goalforallP,_->forallabc...,Pabc...which can be used to prove the original goal. Becauseexpressionhas been replaced with a generic function, the proof of the new goal can be more efficient than the proof of the special case, especially when there are around 84 variables. *)Ltacapply_PtyP:=lazymatchtywith|foralla: ?A, ?ty=>letty':=freshinletP':=freshinconstr:(foralla:A,(* Bindtyinmatchso that we avoid issues such as https://github.com/coq/coq/issues/7299 and similar ones.  Withoutreturn_,matchtries two ways to elaborate the branches, which results in exponential blowup on failure. *)matchty,Pareturn_with|ty',P'=>ltac:(letty:= (evalcbvdelta[ty']inty')inletP:= (evalcbvdelta[P']inP')inclearty'P';letres:=apply_PtyPinexactres)end)|_=>Pend.Ltacmake_P_and_evarty:=letP:=fresh"P"inopen_constr:(forallP:_,_->ltac:(letres:=apply_PtyPinexactres)).Ltacgeneralize_goalX:=matchgoalwith|- ?G=>letT:=make_P_and_evarGinassert(X:T)end.(* We need this equivalence twice below. *)Local Lemmaequiv_helper{X} {ab:X} {pqr:a=b} (t:q@ 1 =r) (u:p@ 1 =r) (s:p=q): ((concat_p1p)^ @ (u@t^)) @ (concat_p1q) =s<~>whiskerRs1 @t=u.Proof.snrapply(_oEequiv_path_inverse__).snrapply(_oEequiv_moveR_pV___).snrapply(_oEequiv_moveR_Mp___).snrapply(_oEequiv_concat_l__).3:exact(moveL_Mp___(moveL_pV___(whiskerR_p1s))).snrapply(equiv_moveR_pM___).Defined.(* This special case ofequiv_path_indcomes up a lot. *)Definitionequiv_path_ind_moveL_Mp{X} (abc:X) (p:a=c) (r:a=b)(P:forall(q:b=c),p=r@q->Type)(i:P(r^ @p) (equiv_moveL_Mp___1)):forall(q:b=c) (s:p=r@q),Pqs.Proof.exact(equiv_path_ind(funq=> (equiv_moveL_Mpq__))Pi).Defined.(* A form of the coherence we can prove by path induction. *)Definitioneh_V_p_pp_gen{X:Type}(* 0-paths *){abcdef:X}(* 1-paths *){wlx0x0wrx0:a=b}{wlx1x1wrx1:c=d}{wlx2x2wrx2:e=f}{wly0y0wry0:b=d}{wly1y1wry1:a=c}{wlz0z0wrz0:d=f}{wlz1z1wrz1:c=e}{wlyz0wryz0:b=f}{wlyz1wryz1:a=e}(* 2-paths *){ulnat_x0:wlx0@ 1 = 1 @x0}{urnat_x0:wrx0@ 1 = 1 @x0}{ulnat_x1:wlx1@ 1 = 1 @x1}{urnat_x1:wrx1@ 1 = 1 @x1}{ulnat_x2:wlx2@ 1 = 1 @x2}{urnat_x2:wrx2@ 1 = 1 @x2}{ulnat_y0:wly0@ 1 = 1 @y0}{urnat_y0:wry0@ 1 = 1 @y0}{ulnat_y1:wly1@ 1 = 1 @y1}{urnat_y1:wry1@ 1 = 1 @y1}{ulnat_z0:wlz0@ 1 = 1 @z0}{urnat_z0:wrz0@ 1 = 1 @z0}{ulnat_z1:wlz1@ 1 = 1 @z1}{urnat_z1:wrz1@ 1 = 1 @z1}{ulnat_yz0:wlyz0@ 1 = 1 @ (y0@z0)}{urnat_yz0:wryz0@ 1 = 1 @ (y0@z0)}{ulnat_yz1:wlyz1@ 1 = 1 @ (y1@z1)}{urnat_yz1:wryz1@ 1 = 1 @ (y1@z1)}{ehlnat_x0:wlx0@ 1 = 1 @wrx0}{ehlnat_x1:wlx1@ 1 = 1 @wrx1}{ehlnat_x2:wlx2@ 1 = 1 @wrx2}{ehrnat_y0:wry0@ 1 = 1 @wly0}{ehrnat_y1:wry1@ 1 = 1 @wly1}{ehrnat_z0:wrz0@ 1 = 1 @wlz0}{ehrnat_z1:wrz1@ 1 = 1 @wlz1}{ehrnat_yz0:wryz0@ 1 = 1 @wlyz0}{ehrnat_yz1:wryz1@ 1 = 1 @wlyz1}{wlrnat_x_y:wlx0@wry0=wry1@wlx1}{wlrnat_y_x:wly1@wrx1=wrx0@wly0}{wlrnat_x_z:wlx1@wrz0=wrz1@wlx2}{wlrnat_z_x:wlz1@wrx2=wrx1@wlz0}{wlrnat_x_yz:wlx0@wryz0=wryz1@wlx2}{wlrnat_yz_x:wlyz1@wrx2=wrx0@wlyz0}{wrpp_yz0:wry0@wrz0=wryz0}{wlpp_yz0:wly0@wlz0=wlyz0}{wrpp_yz1:wry1@wrz1=wryz1}{wlpp_yz1:wly1@wlz1=wlyz1}(* 3-paths *){H_ulnat_yz0: (ulnat_y0[-]ulnat_z0) =whiskerRwlpp_yz0_@ulnat_yz0}{H_urnat_yz0: (urnat_y0[-]urnat_z0) =whiskerRwrpp_yz0_@urnat_yz0}{H_ulnat_yz1: (ulnat_y1[-]ulnat_z1) =whiskerRwlpp_yz1_@ulnat_yz1}{H_urnat_yz1: (urnat_y1[-]urnat_z1) =whiskerRwrpp_yz1_@urnat_yz1}{H_ehrnat_yz0: (ehrnat_y0[-]ehrnat_z0) @whiskerL_wlpp_yz0=whiskerRwrpp_yz0_@ehrnat_yz0}{H_ehrnat_yz1: (ehrnat_y1[-]ehrnat_z1) @whiskerL_wlpp_yz1=whiskerRwrpp_yz1_@ehrnat_yz1}{H_wlrnat_x_yz: (wlrnat_x_y[I]wlrnat_x_z) @whiskerRwrpp_yz1_=whiskerL_wrpp_yz0@wlrnat_x_yz}{H_wlrnat_yz_x: (wlrnat_y_x[-]wlrnat_z_x) @whiskerL_wlpp_yz0=whiskerRwlpp_yz1_@wlrnat_yz_x}(ehlnat_1p_x0: (ehlnat_x0[I]urnat_x0) @ 1 = 1 @ulnat_x0)(ehlnat_1p_x1: (ehlnat_x1[I]urnat_x1) @ 1 = 1 @ulnat_x1)(ehlnat_1p_x2: (ehlnat_x2[I]urnat_x2) @ 1 = 1 @ulnat_x2){ehrnat_p1_y0: (ehrnat_y0[I]ulnat_y0) @ 1 = 1 @urnat_y0}{ehrnat_p1_y1: (ehrnat_y1[I]ulnat_y1) @ 1 = 1 @urnat_y1}{ehrnat_p1_z0: (ehrnat_z0[I]ulnat_z0) @ 1 = 1 @urnat_z0}{ehrnat_p1_z1: (ehrnat_z1[I]ulnat_z1) @ 1 = 1 @urnat_z1}{ehrnat_p1_yz0: (ehrnat_yz0[I]ulnat_yz0) @ 1 = 1 @urnat_yz0}{ehrnat_p1_yz1: (ehrnat_yz1[I]ulnat_yz1) @ 1 = 1 @urnat_yz1}{wlrnat_V_x_y:whiskerRwlrnat_x_y_@ (ehrnat_y1[-]ehlnat_x1) =(ehlnat_x0[-]ehrnat_y0) @whiskerL_wlrnat_y_x^}{wlrnat_V_x_z:whiskerRwlrnat_x_z_@ (ehrnat_z1[-]ehlnat_x2) =(ehlnat_x1[-]ehrnat_z0) @whiskerL_wlrnat_z_x^}{wlrnat_V_x_yz:whiskerRwlrnat_x_yz_@ (ehrnat_yz1[-]ehlnat_x2) =(ehlnat_x0[-]ehrnat_yz0) @whiskerL_wlrnat_yz_x^}(* 4-paths *)(H_ehrnat_p1_yz0:Ehrnat_p1_pp1 1H_ehrnat_yz0H_ulnat_yz0H_urnat_yz0ehrnat_p1_y0ehrnat_p1_z0=ehrnat_p1_yz0)(H_ehrnat_p1_yz1:Ehrnat_p1_pp1 1H_ehrnat_yz1H_ulnat_yz1H_urnat_yz1ehrnat_p1_y1ehrnat_p1_z1=ehrnat_p1_yz1)(H_wlrnat_V_x_yz:Wlrnat_V_p_ppH_ehrnat_yz0H_ehrnat_yz1H_wlrnat_x_yzH_wlrnat_yz_xwlrnat_V_x_ywlrnat_V_x_z=wlrnat_V_x_yz):leteh_x_y:=concat_p_ppx0y0z0@whiskerR(((rlucancel_inv(ulnat_x0[-]urnat_y0))^ @wlrnat_x_y) @rlucancel_inv(urnat_y1[-]ulnat_x1))z0inwhiskerR(concat_p1_@@concat_p1_)eh_x_y@whiskerR(eh_V_gen(ehlnat_1p_x0) (ehlnat_1p_x2) (ehrnat_p1_yz0) (ehrnat_p1_yz1)wlrnat_V_x_yz)eh_x_y@lrucancel1 @whiskerLeh_x_y(Syllepsis.concat_pp_p_p_pp___)^ @whiskerLeh_x_y(concat_p1_@@concat_p1_)^ =(eh_p_pp_genH_urnat_yz0H_urnat_yz1H_wlrnat_x_yz[-]lrucancel(whiskerL_(ap(funp=>whiskerLy1p)(moveL_V1__(eh_V_genehlnat_1p_x1ehlnat_1p_x2ehrnat_p1_z0ehrnat_p1_z1wlrnat_V_x_z))))) [-](eh_pp_p_genH_ulnat_yz1H_ulnat_yz0H_wlrnat_yz_x[-]lrucancel(whiskerL_(ap(funp=>whiskerRpz0)(moveL_1V__(eh_V_genehlnat_1p_x0ehlnat_1p_x1ehrnat_p1_y0ehrnat_p1_y1wlrnat_V_x_y))))).Proof.(* For some reason, it's most efficient to destruct a few things here but the rest within the subgoal. *)destructH_ehrnat_p1_yz0,H_ehrnat_p1_yz1,H_wlrnat_V_x_yz.(* For efficiency purposes, we generalize the goal to an arbitrary functionPof the context (except forXanda), and do all of the induction steps in this generality.  This reduces the size of the term that Coq needs to manipulate, speeding up the proof.  The same proof works with the next three lines removed and with the second and third last lines removed. *)revert_untila.generalize_goallem.{introsPH;intros.destructwry0,wry1,wrz0,wrz1.destructwrpp_yz0,wlpp_yz0,wrpp_yz1,wlpp_yz1.revertwlrnat_x_yzH_wlrnat_x_yz.snrapplyequiv_path_ind_moveL_Mp.revertwlrnat_x_ywlrnat_V_x_y.snrapply(equiv_path_ind(equiv_helper__)).revertwlrnat_x_zwlrnat_V_x_z.snrapply(equiv_path_ind(equiv_helper__)).revertulnat_x0ehlnat_1p_x0.snrapplyequiv_path_ind_rlucancel.revertulnat_x1ehlnat_1p_x1.snrapplyequiv_path_ind_rlucancel.revertulnat_x2ehlnat_1p_x2.snrapplyequiv_path_ind_rlucancel.reverturnat_yz0H_urnat_yz0.snrapplyequiv_path_ind_moveL_Mp.reverturnat_yz1H_urnat_yz1.snrapplyequiv_path_ind_moveL_Mp.revertwlrnat_yz_xH_wlrnat_yz_x.snrapplyequiv_path_ind_moveL_Mp.revertehrnat_yz0H_ehrnat_yz0.snrapplyequiv_path_ind_moveL_Mp.revertehrnat_yz1H_ehrnat_yz1.snrapplyequiv_path_ind_moveL_Mp.revertulnat_yz1H_ulnat_yz1.snrapplyequiv_path_ind_moveL_Mp.revertulnat_yz0H_ulnat_yz0.snrapplyequiv_path_ind_moveL_Mp.reverturnat_y0ehrnat_p1_y0.snrapplyequiv_path_ind_rlucancel.reverturnat_y1ehrnat_p1_y1.snrapplyequiv_path_ind_rlucancel.reverturnat_z0ehrnat_p1_z0.snrapplyequiv_path_ind_rlucancel.reverturnat_z1ehrnat_p1_z1.snrapplyequiv_path_ind_rlucancel.revertx0urnat_x0.snrapplyequiv_path_ind_rlucancel.revertx1urnat_x1.snrapplyequiv_path_ind_rlucancel.revertx2urnat_x2.snrapplyequiv_path_ind_rlucancel.reverty0ulnat_y0.snrapplyequiv_path_ind_rlucancel.reverty1ulnat_y1.snrapplyequiv_path_ind_rlucancel.revertz0ulnat_z0.snrapplyequiv_path_ind_rlucancel.revertz1ulnat_z1.snrapplyequiv_path_ind_rlucancel.revertwlrnat_y_x.(* Paired with wlx0 below. *)revertwrx0ehlnat_x0.snrapplyequiv_path_ind_rlucancel.revertwlrnat_z_x.(* Paired with wlx1 below. *)revertwrx1ehlnat_x1.snrapplyequiv_path_ind_rlucancel.revertwrx2ehlnat_x2.snrapplyequiv_path_ind_rlucancel.revertwly0ehrnat_y0.snrapplyequiv_path_ind_rlucancel.revertwly1ehrnat_y1.snrapplyequiv_path_ind_rlucancel.revertwlz0ehrnat_z0.snrapplyequiv_path_ind_rlucancel.revertwlz1ehrnat_z1.snrapplyequiv_path_ind_rlucancel.revertwlx1.snrapplyequiv_path_ind_lrucancel.revertwlx0.snrapplyequiv_path_ind_lrucancel.destructwlx2.(* Remove the next two lines if not using thegeneralize_goaltactic. *)exactH. }applylem.reflexivity.Qed.Definitioneh_V_p_pp{X} {a:X} (pqr:idpath(idpatha) =idpath(idpatha)) :whiskerR(concat_p1_@@concat_p1_)_@whiskerR(eh_Vp(q@r))_@lrucancel1 @whiskerL_(Syllepsis.concat_pp_p_p_pp___)^ @whiskerL_(concat_p1_@@concat_p1_)^ =(eh_p_pp_gen(urnat_ppqr) (urnat_ppqr) (wlrnat_p_pppqr) [-]lrucancel(whiskerL_(ap(funp=>whiskerLqp) (moveL_V1__(eh_Vpr))))) [-](eh_pp_p_gen(ulnat_ppqr) (ulnat_ppqr) (wlrnat_pp_pqrp) [-]lrucancel(whiskerL_(ap(funp=>whiskerRpr) (moveL_1V__(eh_Vpq))))).Proof.exact(eh_V_p_pp_gen___(ehrnat_p1_ppqr) (ehrnat_p1_ppqr) (wlrnat_V_p_pppqr)).Defined.

--- Miscellaneous\TensorProduct.html ---
TensorProductLibrary TensorProductRequireImportBasics.OvertureBasics.Tactics.RequireImportTypes.ForallTypes.SigmaTypes.Prod.RequireImportWildCat.CoreWildCat.EquivWildCat.MonoidalWildCat.Bifunctor.RequireImportWildCat.NatTransWildCat.MonoidalTwistConstruction.RequireImportAlgebra.Groups.GroupAlgebra.Groups.QuotientGroup.RequireImportAlgebra.AbGroups.AbelianGroupAlgebra.AbGroups.Biproduct.RequireImportAlgebra.AbGroups.AbHomAlgebra.AbGroups.FreeAbelianGroup.RequireImportAlgebra.AbGroups.AbelianizationAlgebraAlgebra.Groups.FreeGroup.RequireImportColimits.Quotient.RequireImportSpaces.List.CoreSpaces.Int.RequireImportAbGroups.Z.RequireImportTruncations.Local OpenScopemc_scope.Local OpenScopemc_add_scope.The Tensor Product of Abelian GroupsVarious mapsA*B→Cfrom the cartesian product of two abelian groups to another abelian group are "biadditive" (also called "bilinear"), meaning that they are group homomorphisms when we fix the left or right argument.The tensor product of abelian groups is a construction that produces an abelian groupA⊗Balong with a biadditive mapA*B->A⊗Bwhich is initial among biadditive maps fromA*B.  This means that any biadditive mapA*B→Cfactors uniquely through the tensor product via a group homomorphismA⊗B->C.Biadditive functions appear in all sorts of contexts ranging from linear algebra to analysis. Therefore having a way to systematically study them is very useful.ConstructionWe define the tensor product of abelian groups as a quotient of the free abelian group on pairs of elements of the two groups by the subgroup generated by the biadditive pairs.Here we define the subgroup of biadditive pairs in two steps.Definitionfamily_biadditive_pairs{AB:AbGroup}:FreeAbGroup(A*B) ->Type.Proof.introsx.refine((exists(a1a2:A) (b:B),_) +exists(a:A) (b1b2:B),_)%type.-refine(-_+ (_+_) =x).1-3:applyfreeabgroup_in.+exact(a1+a2,b).+exact(a1,b).+exact(a2,b).-refine(-_+ (_+_) =x).1-3:applyfreeabgroup_in.+exact(a,b1+b2).+exact(a,b1).+exact(a,b2).Defined.Definitionsubgroup_biadditive_pairs{AB:AbGroup}:Subgroup(FreeAbGroup(A*B)):=subgroup_generatedfamily_biadditive_pairs.The tensor productab_tensor_prodABof two abelian groupsAandBis defined to be a quotient of the free abelian group on pairs of elementsA*Bby the subgroup of biadditive pairs.Definitionab_tensor_prod(AB:AbGroup) :AbGroup:=QuotientAbGroup(FreeAbGroup(A*B))subgroup_biadditive_pairs.Argumentsab_tensor_prodAB:simplnever.The tensor product ofAandBcontains formal sums and differences of pairs of elements fromAandB. We denote these pairs as "simple tensors" and name themtensor.Definitiontensor{AB:AbGroup} :A->B->ab_tensor_prodAB:=funab=>grp_quotient_map(freeabgroup_in(a,b)).Properties of tensorsThe characterizing property of simple tensors are that they are biadditive in their arguments.Atensorof a sum distributes over the sum on the left.Definitiontensor_dist_l{AB:AbGroup} (a:A) (bb':B):tensora(b+b') =tensorab+tensorab'.Proof.applyqglue,tr.applysgt_in.right.byexistsa,b,b'.Defined.Atensorof a sum distributes over the sum on the right.Definitiontensor_dist_r{AB:AbGroup} (aa':A) (b:B):tensor(a+a')b=tensorab+tensora'b.Proof.applyqglue,tr.applysgt_in.left.byexistsa,a',b.Defined.Tensoring on the left is a group homomorphism.Definitiongrp_homo_tensor_l{AB:AbGroup} (a:A):B$->ab_tensor_prodAB.Proof.snrapplyBuild_GroupHomomorphism.-exact(funb=>tensorab).-introsbb'.nrapplytensor_dist_l.Defined.Tensoring on the right is a group homomorphism.Definitiongrp_homo_tensor_r{AB:AbGroup} (b:B):A$->ab_tensor_prodAB.Proof.snrapplyBuild_GroupHomomorphism.-exact(funa=>tensorab).-introsaa'.nrapplytensor_dist_r.Defined.Tensors preserve negation in the left argument.Definitiontensor_neg_l{AB:AbGroup} (a:A) (b:B):tensor(-a)b= -tensorab:=grp_homo_inv(grp_homo_tensor_rb)a.Tensors preserve negation in the right argument.Definitiontensor_neg_r{AB:AbGroup} (a:A) (b:B):tensora(-b) = -tensorab:=grp_homo_inv(grp_homo_tensor_la)b.Tensoring by zero on the left is zero.Definitiontensor_zero_l{AB:AbGroup} (b:B):tensor(A:=A) 0b= 0:=grp_homo_unit(grp_homo_tensor_rb).Tensoring by zero on the right is zero.Definitiontensor_zero_r{AB:AbGroup} (a:A):tensor(B:=B)a0 = 0:=grp_homo_unit(grp_homo_tensor_la).Thetensormap is biadditive and therefore can be written in a curried form using the internal abelian group hom.Definitiongrp_homo_tensor`{Funext} {AB:AbGroup}:A$->ab_homB(ab_tensor_prodAB).Proof.snrapplyBuild_GroupHomomorphism.-introsa.snrapplyBuild_GroupHomomorphism.+exact(tensora).+nrapplytensor_dist_l.-introsaa'.applyequiv_path_grouphomomorphism.introsb.nrapplytensor_dist_r.Defined.Induction principlesHere we write down some induction principles to help us prove lemmas about the tensor product. Some of these are quite specialised but are patterns that appear often in practice.Our main recursion principle states that in order to build a homomorphism out of the tensor product, it is sufficient to provide a map out of the direct product which is biadditive, that is, a map that preserves addition in each argument of the product.We separate out the proof of this part, so we can make it opaque.Definitionab_tensor_prod_rec_helper{ABC:AbGroup}(f:A->B->C)(l:forallabb',fa(b+b') =fab+fab')(r:forallaa'b,f(a+a')b=fab+fa'b)(x:FreeAbGroup(A*B)) (insg:subgroup_biadditive_pairsx):grp_homo_abel_rec(FreeGroup_rec(A*B)C(uncurryf))x=mon_unit.Proof.set(abel_rec:=grp_homo_abel_rec(FreeGroup_rec(A*B)C(uncurryf))).strip_truncations.inductioninsgas[xbiad| |ghinsg_gIHginsg_hIHh].-destructbiadas[ [a[a'[bp] ] ] | [a[b[b'p] ] ] ].all:destructp;simpl.all:applygrp_moveL_M1^-1%equiv;symmetry.1:applyr.applyl.-nrapplygrp_homo_unit.-rewritegrp_homo_op,grp_homo_inv.applygrp_moveL_1M^-1.exact(IHg@IHh^).Defined.Opaqueab_tensor_prod_rec_helper.Definitionab_tensor_prod_rec{ABC:AbGroup}(f:A->B->C)(l:forallabb',fa(b+b') =fab+fab')(r:forallaa'b,f(a+a')b=fab+fa'b):ab_tensor_prodAB$->C.Proof.unfoldab_tensor_prod.snrapplygrp_quotient_rec.-snrapplyFreeAbGroup_rec.exact(uncurryf).-unfoldnormalsubgroup_subgroup.applyab_tensor_prod_rec_helper;assumption.Defined.A special case that arises.Definitionab_tensor_prod_rec'{ABC:AbGroup}(f:A-> (B$->C))(l:forallaa'b,f(a+a')b=fab+fa'b):ab_tensor_prodAB$->C.Proof.refine(ab_tensor_prod_recf_l).introa;applygrp_homo_op.Defined.We give an induction principle for an hprop-valued type familyP.  It may be surprising at first that we only requirePto hold for the simple tensorstensoraband be closed under addition.  It automatically follows thatP0holds (sincetensor00=0) and thatPis closed under negation (sincetensor-ab=-tensorab). This induction principle says that the simple tensors generate the tensor product as a semigroup.Definitionab_tensor_prod_ind_hprop{AB:AbGroup}(P:ab_tensor_prodAB->Type){H:forallx,IsHProp(Px)}(Hin:forallab,P(tensorab))(Hop:forallxy,Px->Py->P(x+y)):forallx,Px.Proof.unfoldab_tensor_prod.srapplygrp_quotient_ind_hprop.srapplyAbel_ind_hprop;cbnbeta.set(tensor_in:=grp_quotient_map$oabel_unit:FreeGroup(A*B) $->ab_tensor_prodAB).change(forallx,P(tensor_inx)).srapplyFreeGroup_ind_hprop';introsw;cbnbeta.inductionw.-(* The goal here isP0, so we useHin00:P(tensor00). *)exact(transportP(tensor_zero_l0) (Hin0 0)).-change(P(tensor_in(freegroup_eta[a]%list+freegroup_etaw))).(* Thisrewriteisreflexivity, but theDefinedis slow ifchangeis used instead. *)rewritegrp_homo_op.destructaas[[ab]|[ab]].+change(P(tensor_in(freegroup_in(a,b)) +tensor_in(freegroup_etaw))).applyHop;trivial.applyHin.+change(P(tensor_in(-freegroup_in(a,b)) +tensor_in(freegroup_etaw))).(* Thisrewriteis also reflexivity. *)rewritegrp_homo_inv.applyHop;trivial.rewrite<-tensor_neg_l.applyHin.Defined.As a commonly occuring special case of the above induction principle, we have the case when the predicate in question is showing that two group homomorphisms out of the tensor product are homotopic. In order to do this, it suffices to show it only for simple tensors. The homotopy is closed under addition, so we don't need to hypothesise anything else.Definitionab_tensor_prod_ind_homotopy{ABG:AbGroup}{ff':ab_tensor_prodAB$->G}(H:forallab,f(tensorab) =f'(tensorab)):f$==f'.Proof.nrapplyab_tensor_prod_ind_hprop.-exact_.-exactH.-introsxy;applygrp_homo_op_agree.Defined.As an even more specialised case, we occasionally have the second homomorphism being a sum of abelian group homomorphisms. In those cases, it is easier to use this specialised lemma.Definitionab_tensor_prod_ind_homotopy_plus{ABG:AbGroup}{ff'f'':ab_tensor_prodAB$->G}(H:forallab,f(tensorab) =f'(tensorab) +f''(tensorab)):forallx,fx=f'x+f''x:=ab_tensor_prod_ind_homotopy(f':=ab_homo_addf'f'')H.Here we give an induction principle for a triple tensor, a.k.a a dependent trilinear function.Definitionab_tensor_prod_ind_hprop_triple{ABC:AbGroup}(P:ab_tensor_prodA(ab_tensor_prodBC) ->Type)(H:forallx,IsHProp(Px))(Hin:forallabc,P(tensora(tensorbc)))(Hop:forallxy,Px->Py->P(x+y)):forallx,Px.Proof.rapply(ab_tensor_prod_ind_hpropP).-introsa.rapply(ab_tensor_prod_ind_hprop(funx=>P(tensor_x))).+nrapplyHin.+introsxyHxHy.rewritetensor_dist_l.byapplyHop.-exactHop.Defined.Similar to before, we specialise the triple tensor induction principle for proving homotopies of trilinear/triadditive functions.Definitionab_tensor_prod_ind_homotopy_triple{ABCG:AbGroup}{ff':ab_tensor_prodA(ab_tensor_prodBC) $->G}(H:forallabc,f(tensora(tensorbc)) =f'(tensora(tensorbc))):f$==f'.Proof.nrapplyab_tensor_prod_ind_hprop_triple.-exact_.-exactH.-introsxy;applygrp_homo_op_agree.Defined.As explained for the biadditive and triadditive cases, we also derive an induction principle for quadruple tensors giving us dependent quadrilinear maps.Definitionab_tensor_prod_ind_hprop_quad{ABCD:AbGroup}(P:ab_tensor_prodA(ab_tensor_prodB(ab_tensor_prodCD)) ->Type)(H:forallx,IsHProp(Px))(Hin:forallabcd,P(tensora(tensorb(tensorcd))))(Hop:forallxy,Px->Py->P(x+y)):forallx,Px.Proof.rapply(ab_tensor_prod_ind_hpropP).-introsa.nrapply(ab_tensor_prod_ind_hprop_triple(funx=>P(tensor_x))).+introx;applyH.+nrapplyHin.+introsxyHxHy.rewritetensor_dist_l.byapplyHop.-exactHop.Defined.To construct a homotopy between quadrilinear maps we need only check equality for the quadruple simple tensors.Definitionab_tensor_prod_ind_homotopy_quad{ABCDG:AbGroup}{ff':ab_tensor_prodA(ab_tensor_prodB(ab_tensor_prodCD)) $->G}(H:forallabcd,f(tensora(tensorb(tensorcd)))=f'(tensora(tensorb(tensorcd)))):f$==f'.Proof.nrapply(ab_tensor_prod_ind_hprop_quad(fun_=>_)).-exact_.-exactH.-introsxy;applygrp_homo_op_agree.Defined.Universal Property of the Tensor ProductA function of two variables is biadditive if it preserves the operation in each variable.ClassIsBiadditive{ABC:Type} `{SgOpA,SgOpB,SgOpC} (f:A->B->C) := {isbiadditive_l::forallb,IsSemiGroupPreserving(flipfb);isbiadditive_r::foralla,IsSemiGroupPreserving(fa);}.Definitionissig_IsBiadditive{ABC:Type} `{SgOpA,SgOpB,SgOpC}(f:A->B->C):_<~>IsBiadditivef:=ltac:(issig).The truncation level of theIsBiadditivefpredicate is determined by the truncation level of the codomain. This will almost always be a hset.Global Instanceistrunc_isbiadditive`{Funext}{ABC:Type} `{SgOpA,SgOpB,SgOpC}(f:A->B->C)n`{IsTruncn.+1C}:IsTruncn(IsBiadditivef).Proof.nrapplyistrunc_equiv_istrunc.1:rapplyissig_IsBiadditive.unfoldIsSemiGroupPreserving.exact_.Defined.The simple tensor map is biadditive.Global Instanceisbiadditive_tensor(AB:AbGroup):IsBiadditive(@tensorAB) := {|isbiadditive_l:=funbaa'=>tensor_dist_raa'b;isbiadditive_r:=tensor_dist_l;|}.The type of biadditive maps.RecordBiadditive(ABC:Type) `{SgOpA,SgOpB,SgOpC} := {biadditive_fun:>A->B->C;biadditive_isbiadditive::IsBiadditivebiadditive_fun;}.Definitionissig_Biadditive{ABC:Type} `{SgOpA,SgOpB,SgOpC}:_<~>BiadditiveABC:=ltac:(issig).Definitionbiadditive_ab_tensor_prod{ABC:AbGroup}: (ab_tensor_prodAB$->C) ->BiadditiveABC.Proof.introsf.exists(funxy=>f(tensorxy)).snrapplyBuild_IsBiadditive.-introsbaa';simpl.lhsnrapply(apf).1:nrapplytensor_dist_r.nrapplygrp_homo_op.-introsaa'b;simpl.lhsnrapply(apf).1:nrapplytensor_dist_l.nrapplygrp_homo_op.Defined.The universal property of the tensor product is that biadditive maps between abelian groups are in one-to-one corresondance with maps out of the tensor product. In this sense, the tensor product is the most perfect object describing biadditive maps between two abelian groups.Definitionequiv_ab_tensor_prod_rec`{Funext} (ABC:AbGroup):BiadditiveABC<~> (ab_tensor_prodAB$->C).Proof.snrapplyequiv_adjointify.-intros[f[lr]].exact(ab_tensor_prod_recfr(funaa'b=>lbaa')).-snrapplybiadditive_ab_tensor_prod.-introsf.snrapplyequiv_path_grouphomomorphism.snrapplyab_tensor_prod_ind_homotopy.introsab;simpl.reflexivity.-intros[f[lr]].snrapply(equiv_ap_inv'issig_Biadditive).rapplypath_sigma_hprop;simpl.reflexivity.Defined.Functoriality of the Tensor ProductThe tensor product produces a bifunctor and we will later show that it gives a symmetric monoidal structure on the category of abelian groups.Given a pair of maps, we can produce a homomorphism between the pairwise tensor products of the domains and codomains.Definitionfunctor_ab_tensor_prod{ABA'B':AbGroup}(f:A$->A') (g:B$->B'):ab_tensor_prodAB$->ab_tensor_prodA'B'.Proof.snrapplyab_tensor_prod_rec'.-introa.exact(grp_homo_tensor_l(fa) $og).-introsaa'b;hnf.rewritegrp_homo_op.nrapplytensor_dist_r.Defined.2-functoriality of the tensor product.Definitionfunctor2_ab_tensor_prod{ABA'B':AbGroup}{ff':A$->A'} (p:f$==f') {gg':B$->B'} (q:g$==g'):functor_ab_tensor_prodfg$==functor_ab_tensor_prodf'g'.Proof.snrapplyab_tensor_prod_ind_homotopy.introsab;simpl.exact(ap011tensor(p_) (q_)).Defined.The tensor product functor preserves identity morphisms.Definitionfunctor_ab_tensor_prod_id(AB:AbGroup):functor_ab_tensor_prod(IdA) (IdB) $==Id(ab_tensor_prodAB).Proof.snrapplyab_tensor_prod_ind_homotopy.introsab;simpl.reflexivity.Defined.The tensor product functor preserves composition.Definitionfunctor_ab_tensor_prod_compose{ABCA'B'C':AbGroup}(f:A$->B) (g:B$->C) (f':A'$->B') (g':B'$->C'):functor_ab_tensor_prod(g$of) (g'$of')$==functor_ab_tensor_prodgg'$ofunctor_ab_tensor_prodff'.Proof.snrapplyab_tensor_prod_ind_homotopy.introsab;simpl.reflexivity.Defined.The tensor product functor is a 0-bifunctor.Global Instanceis0bifunctor_ab_tensor_prod:Is0Bifunctorab_tensor_prod.Proof.rapplyBuild_Is0Bifunctor'.snrapplyBuild_Is0Functor.intros[AB] [A'B'] [fg].exact(functor_ab_tensor_prodfg).Defined.The tensor product functor is a bifunctor.Global Instanceis1bifunctor_ab_tensor_prod:Is1Bifunctorab_tensor_prod.Proof.rapplyBuild_Is1Bifunctor'.snrapplyBuild_Is1Functor.-introsABA'B'fgf'g'[pq].exact(functor2_ab_tensor_prodpq).-intros[AB].exact(functor_ab_tensor_prod_idAB).-introsAA'BB'CC'[fg] [f'g'].exact(functor_ab_tensor_prod_composeff'gg').Defined.Symmetry of the Tensor ProductThe tensor product is symmetric in that the order in which we take the tensor shouldn't matter upto isomorphism.We can define a swap map which swaps the order of simple tensors.Definitionab_tensor_swap{AB} :ab_tensor_prodAB$->ab_tensor_prodBA.Proof.snrapplyab_tensor_prod_rec.-exact(fliptensor).-introsabb'.applytensor_dist_r.-introsaa'b.applytensor_dist_l.Defined.ab_tensor_swapis involutive.Definitionab_tensor_swap_swap{AB}:ab_tensor_swap$o@ab_tensor_swapAB$==Id_.Proof.snrapplyab_tensor_prod_ind_homotopy.reflexivity.Defined.ab_tensor_swapis natural in both arguments. This means that it also acts on tensor functors.Definitionab_tensor_swap_natural{ABA'B'} (f:A$->A') (g:B$->B'):ab_tensor_swap$ofunctor_ab_tensor_prodfg$==functor_ab_tensor_prodgf$oab_tensor_swap.Proof.snrapplyab_tensor_prod_ind_homotopy.simpl.(* This speeds up thereflexivityand theDefined. *)reflexivity.Defined.The swap map gives us a symmetric braiding on the category of abelian groups. We will later show it is a full symmetric monoidal category.Global Instancesymmetricbraiding_ab_tensor_prod:SymmetricBraidingab_tensor_prod.Proof.snrapplyBuild_SymmetricBraiding.-snrapplyBuild_NatTrans.+intro;exactab_tensor_swap.+snrapplyBuild_Is1Natural.intros;nrapplyab_tensor_swap_natural.-intros;nrapplyab_tensor_swap_swap.Defined.Twisting Triple TensorsIn order to construct the symmetric monoidal category, we will use what is termed the "Twist construction" in Monoidal.v. This simplifies the data of a symmetric monoidal category by constructing it from simpler parts. For instance, instead of having to prove full associativity(A⊗B)⊗C$->A⊗(B⊗C), we can provide a twist mapA⊗(B⊗C)$->B⊗(A⊗C)and use the symmetric braiding we have so far to prove associativity.In order to be more efficient whilst unfolding definitions, we break up the definition of a twist map into its components.Local Definitionab_tensor_prod_twist_map{ABC:AbGroup}:A-> (ab_tensor_prodBC$->ab_tensor_prodB(ab_tensor_prodAC)).Proof.introsa.snrapplyab_tensor_prod_rec'.-introsb.exact(grp_homo_tensor_lb$ogrp_homo_tensor_la).-introsbb'c;hnf.nrapplytensor_dist_r.Defined.Local Definitionab_tensor_prod_twist_map_additive_l{ABC:AbGroup}(aa':A) (b:ab_tensor_prodBC):ab_tensor_prod_twist_map(a+a')b=ab_tensor_prod_twist_mapab+ab_tensor_prod_twist_mapa'b.Proof.revertb.nrapplyab_tensor_prod_ind_homotopy_plus.introsbc.change(tensorb(tensor(a+a')c)=tensorb(tensorac) +tensorb(tensora'c)).rhs_Vnrapplytensor_dist_l.nrapply(ap(tensorb)).nrapplytensor_dist_r.Defined.Given a triple tensor product, we have a twist map which permutes the first two components.Definitionab_tensor_prod_twist{ABC}:ab_tensor_prodA(ab_tensor_prodBC) $->ab_tensor_prodB(ab_tensor_prodAC).Proof.snrapplyab_tensor_prod_rec'.-exactab_tensor_prod_twist_map.-exactab_tensor_prod_twist_map_additive_l.Defined.The twist map is involutive.Definitionab_tensor_prod_twist_twist{ABC}:ab_tensor_prod_twist$o@ab_tensor_prod_twistABC$==Id_.Proof.snrapplyab_tensor_prod_ind_homotopy_triple.reflexivity.Defined.The twist map is natural in all 3 arguments. This means that the twist map acts on the triple tensor functor in the same way.Definitionab_tensor_prod_twist_natural{ABCA'B'C'}(f:A$->A') (g:B$->B') (h:C$->C'):ab_tensor_prod_twist$ofmap11ab_tensor_prodf(fmap11ab_tensor_prodgh)$==fmap11ab_tensor_prodg(fmap11ab_tensor_prodfh) $oab_tensor_prod_twist.Proof.snrapplyab_tensor_prod_ind_homotopy_triple.introsabc.(* Thischangespeeds up thereflexivity.simplproduces a goal that looks the same, but is still slow. *)change(tensor(gb) (tensor(fa) (hc)) =tensor(gb) (tensor(fa) (hc))).reflexivity.Defined.Unitality ofabgroup_ZIn the symmetric monoidal structure on abelian groups,abgroup_Zis the unit. We show that tensoring withabgroup_Zon the right is isomorphic to the original group.First we characterise the action of integers viagrp_powand their interaction on tensors. This is just a generalisation of the distributivity laws for tensors.Multiplication in the first factor can be factored out.Definitiontensor_ab_mul_l{AB:AbGroup} (z:Int) (a:A) (b:B):tensor(ab_mulza)b=ab_mulz(tensorab):=ab_mul_natural(grp_homo_tensor_rb)za.Multiplication in the second factor can be factored out.Definitiontensor_ab_mul_r{AB:AbGroup} (z:Int) (a:A) (b:B):tensora(ab_mulzb) =ab_mulz(tensorab):=ab_mul_natural(grp_homo_tensor_la)zb.Multiplication can be transferred from one factor to the other. The tensor product ofR-modules will include this as an extra axiom, but here we haveZ-modules and we can prove it.Definitiontensor_ab_mul{AB:AbGroup} (z:Int) (a:A) (b:B):tensor(ab_mulza)b=tensora(ab_mulzb).Proof.rhsnrapplytensor_ab_mul_r.nrapplytensor_ab_mul_l.Defined.abgroup_Zis a right identity for the tensor product.Definitionab_tensor_prod_Z_r{A}:ab_tensor_prodAabgroup_Z$<~>A.Proof.Checking that the inverse map is a homomorphism is easier.symmetry.snrapplyBuild_GroupIsomorphism.-nrapplygrp_homo_tensor_r.exact1%int.-snrapplyisequiv_adjointify.+snrapplyab_tensor_prod_rec'.*exactgrp_pow_homo.*introsaa'z;cbnbeta.nrapply(grp_homo_op(ab_mulz)).+hnf.change(forallx: ?A, (grp_homo_map?f) ((grp_homo_map?g)x) =x)with(f$og$==Id_).snrapplyab_tensor_prod_ind_homotopy.introsaz.change(tensor(B:=abgroup_Z) (grp_powaz) 1%int=tensoraz).lhsnrapplytensor_ab_mul.nrapplyap.lhsnrapplyabgroup_Z_ab_mul.applyint_mul_1_r.+exactgrp_unit_r.Defined.We have a right unitor for the tensor product given by unitabgroup_Z. Naturality ofab_tensor_prod_Z_ris straightforward to prove.Global Instancerightunitor_ab_tensor_prod:RightUnitorab_tensor_prodabgroup_Z.Proof.snrapplyBuild_NatEquiv.-introsA.applyab_tensor_prod_Z_r.-snrapplyBuild_Is1Natural.introsAA'f.snrapplyab_tensor_prod_ind_homotopy.introsaz.change(grp_pow(fa)z=f(grp_powaz)).exact(grp_pow_natural___)^.Defined.Since we have symmetry of the tensor product, we get left unitality for free.Global Instanceleft_unitor_ab_tensor_prod:LeftUnitorab_tensor_prodabgroup_Z.Proof.rapplyleft_unitor_twist.Defined.Symmetric Monoidal Structure of Tensor ProductUsing the twist construction we can derive an associator for the tensor product. In other words, we have associativity of the tensor product of abelian groups natural in each factor.Global Instanceassociator_ab_tensor_prod:Associatorab_tensor_prod.Proof.srapplyassociator_twist.-exact@ab_tensor_prod_twist.-intros;nrapplyab_tensor_prod_twist_twist.-intros;nrapplyab_tensor_prod_twist_natural.Defined.The triangle identity is straightforward to prove using the custom induction principles we proved earlier.Global Instancetriangle_ab_tensor_prod:TriangleIdentityab_tensor_prodabgroup_Z.Proof.snrapplytriangle_twist.introsAB.snrapplyab_tensor_prod_ind_homotopy_triple.introsabz.exact(tensor_ab_mulzab)^.Defined.The hexagon identity is also straighforward to prove. We simply have to reduce all the involved functions on the simple tensors using our custom triple tensor induction principle.Global Instancehexagon_ab_tensor_prod:HexagonIdentityab_tensor_prod.Proof.snrapplyhexagon_twist.introsABC.snrapplyab_tensor_prod_ind_homotopy_triple.introsbac.change(tensorc(tensorab) =tensorc(tensorab)).reflexivity.Defined.Finally, we can prove the pentagon identity using the quadruple tensor induction principle. As we did before, the work only involves reducing the involved functions on the simple tensor redexes.Global Instancepentagon_ab_tensor_prod:PentagonIdentityab_tensor_prod.Proof.snrapplypentagon_twist.introsABCD.snrapplyab_tensor_prod_ind_homotopy_quad.introsabcd.change(tensorc(tensord(tensorab)) =tensorc(tensord(tensorab))).reflexivity.Defined.We therefore have all the data of a monoidal category.Global Instanceismonoidal_ab_tensor_prod:IsMonoidalAbGroupab_tensor_prodabgroup_Z:= {}.And furthermore, all the data of a symmetric monoidal category.Global Instanceissymmmetricmonoidal_ab_tensor_prod:IsSymmetricMonoidalAbGroupab_tensor_prodabgroup_Z:= {}.Preservation of CoequalizersThe tensor product of abelian groups preserves coequalizers, meaning that the coequalizer of two tensored groups is the tensor of the coequalizer. We show this is the case on the left and the right.Tensor products preserve coequalizers on the right.Definitiongrp_iso_ab_tensor_prod_coeq_lA{BC} (fg:B$->C):ab_coeq(fmap01ab_tensor_prodAf) (fmap01ab_tensor_prodAg)$<~>ab_tensor_prodA(ab_coeqfg).Proof.snrapplycate_adjointify.-snrapplyab_coeq_rec.+rapply(fmap01ab_tensor_prodA).nrapplyab_coeq_in.+refine(_^$ $@fmap02ab_tensor_prod__$@_).1,3:rapplyfmap01_comp.nrapplyab_coeq_glue.-snrapplyab_tensor_prod_rec'.+introsa.snrapplyfunctor_ab_coeq.1,2:snrapply(grp_homo_tensor_la).1,2:hnf;reflexivity.+introsaa';cbnbeta.srapplyab_coeq_ind_hprop.introsx.exact(ap(ab_coeq_in(f:=fmap01ab_tensor_prodAf)(g:=fmap01ab_tensor_prodAg))(tensor_dist_raa'x)).-snrapplyab_tensor_prod_ind_homotopy.introsa.srapplyab_coeq_ind_hprop.introsc.reflexivity.-snrapplyab_coeq_ind_homotopy.snrapplyab_tensor_prod_ind_homotopy.reflexivity.Defined.The equivalence respects the natural maps fromab_tensor_prodAC.Definitionab_tensor_prod_coeq_l_triangleA{BC} (fg:B$->C):grp_iso_ab_tensor_prod_coeq_lAfg$oab_coeq_in$==fmap01ab_tensor_prodAab_coeq_in.Proof.snrapplyab_tensor_prod_ind_homotopy.reflexivity.Defined.Tensor products preserve coequalizers on the left.Definitiongrp_iso_ab_tensor_prod_coeq_r{AB} (fg:A$->B)C:ab_coeq(fmap10ab_tensor_prodfC) (fmap10ab_tensor_prodgC)$<~>ab_tensor_prod(ab_coeqfg)C.Proof.refine(braide__$oE_).nrefine(grp_iso_ab_tensor_prod_coeq_l_fg$oE_).snrapplygrp_iso_ab_coeq.1,2:rapplybraide.1,2:symmetry;nrapplyab_tensor_swap_natural.Defined.The equivalence respects the natural maps fromab_tensor_prodBC.Definitionab_tensor_prod_coeq_r_triangle{AB} (fg:A$->B)C:grp_iso_ab_tensor_prod_coeq_rfgC$oab_coeq_in$==fmap10ab_tensor_prodab_coeq_inC.Proof.snrapplyab_tensor_prod_ind_homotopy.reflexivity.Defined.Tensor Product of Free Abelian GroupsDefinitionequiv_ab_tensor_prod_freeabgroupXY:FreeAbGroup(X*Y) $<~>ab_tensor_prod(FreeAbGroupX) (FreeAbGroupY).Proof.srefine(letf:=_inletg:=_incate_adjointifyfg__).-snrapplyFreeAbGroup_rec.intros[xy].exact(tensor(freeabgroup_inx) (freeabgroup_iny)).-snrapplyab_tensor_prod_rec.+introsx.snrapplyFreeAbGroup_rec.introsy;revertx.unfoldFreeAbGroup.snrapplyFreeAbGroup_rec.introsx.applyabel_unit.applyfreegroup_in.exact(x,y).+introsxyy'.snrapplygrp_homo_op.+introsxx'.rapplyAbel_ind_hprop.snrapply(FreeGroup_ind_homotopy_(f':=ab_homo_add__)).introsy.lhsnrapplyFreeGroup_rec_beta.lhsnrapplygrp_homo_op.snrapply(ap011(+)_^_^).1,2:nrapplyFreeGroup_rec_beta.-snrapplyab_tensor_prod_ind_homotopy.introsx.change(f$og$ogrp_homo_tensor_lx$==grp_homo_tensor_lx).rapplyAbel_ind_hprop.change(@abel_in?G)with(grp_homo_map(@abel_unitG)).repeatchange(cat_comp(A:=AbGroup) ?f?g)with(cat_comp(A:=Group)fg).change(forally,grp_homo_map?f(abel_unity) =grp_homo_map?g(abel_unity))with(cat_comp(A:=Group)fabel_unit$==cat_comp(A:=Group)gabel_unit).rapplyFreeGroup_ind_homotopy.introsy;revertx.change(f$og$ogrp_homo_tensor_r(freeabgroup_iny) $==grp_homo_tensor_r(freeabgroup_iny)).rapplyAbel_ind_hprop.change(@abel_in?G)with(grp_homo_map(@abel_unitG)).repeatchange(cat_comp(A:=AbGroup) ?f?g)with(cat_comp(A:=Group)fg).change(forally,grp_homo_map?f(abel_unity) =grp_homo_map?g(abel_unity))with(cat_comp(A:=Group)fabel_unit$==cat_comp(A:=Group)gabel_unit).rapplyFreeGroup_ind_homotopy.introsx.reflexivity.-rapplyAbel_ind_hprop.change(GpdHom(A:=Hom(A:=Group) (FreeGroup(X*Y))_)(cat_comp(A:=Group) (g$of) (@abel_unit(FreeGroup(X*Y))))(@abel_unit(FreeGroup(X*Y)))).snrapplyFreeGroup_ind_homotopy.reflexivity.Defined.Tensor products distribute over direct sumsDefinitionab_tensor_prod_dist_l{ABC:AbGroup}:ab_tensor_prodA(ab_biprodBC)$<~>ab_biprod(ab_tensor_prodAB) (ab_tensor_prodAC).Proof.srapply(letf:=_inletg:=_incate_adjointifyfg__).-snrapplyab_tensor_prod_rec.+introsabc.exact(tensora(fstbc),tensora(sndbc)).+introsabcbc';cbnbeta.snrapplypath_prod';snrapplytensor_dist_l.+introsaa'bc;cbnbeta.snrapplypath_prod;snrapplytensor_dist_r.-snrapplyab_biprod_rec.+exact(fmap01ab_tensor_prodAab_biprod_inl).+exact(fmap01ab_tensor_prodAab_biprod_inr).-snrapplyab_biprod_ind_homotopy.+refine(cat_assoc___$@ (_$@L_) $@_).1:snrapplyab_biprod_rec_beta_inl.snrapplyab_tensor_prod_ind_homotopy.introsab.snrapplypath_prod;simpl.*reflexivity.*snrapplytensor_zero_r.+refine(cat_assoc___$@ (_$@L_) $@_).1:snrapplyab_biprod_rec_beta_inr.snrapplyab_tensor_prod_ind_homotopy.introsab.snrapplypath_prod;simpl.*snrapplytensor_zero_r.*reflexivity.-snrapplyab_tensor_prod_ind_homotopy.introsa[bc].lhs_Vnrapplytensor_dist_l;simpl.snrapplyap.symmetry;applygrp_prod_decompose.Defined.Definitionab_tensor_prod_dist_r{ABC:AbGroup}:ab_tensor_prod(ab_biprodAB)C$<~>ab_biprod(ab_tensor_prodAC) (ab_tensor_prodBC).Proof.refine(emap11ab_biprod(braide__) (braide__)$oE_$oEbraide__).snrapplyab_tensor_prod_dist_l.Defined.TODO: Show that the category of abelian groups is symmetric closed and therefore we have adjoint pair with the tensor and internal hom. This should allow us to prove lemmas such as tensors distributing over coproducts.

--- Miscellaneous\TermAlgebra.html ---
TermAlgebraLibrary TermAlgebraThis file defines the term algebraTermAlgebra, also referred to as the absolutely free algebra.We show that term algebra forms an adjoint functor from the category of hset carriers{C : Carrier σ | forall s, IsHSet (C s)}to the category of algebras (without equations)Algebraσ, whereCarriersσis notation forSortσ->Type.  Seeump_term_algebra.There is a similar construction for algebras with equations, the free algebraFreeAlgebra. The free algebra is defined in another file.RequireExportHoTT.Algebra.Universal.Algebra.RequireImportHoTT.Universes.HSetHoTT.Classes.interfaces.canonical_namesHoTT.Algebra.Universal.HomomorphismHoTT.Algebra.Universal.Congruence.UnsetEliminationSchemes.Local OpenScopeAlgebra_scope.The term algebra carriers are generated byC:Carriersσ, with an element for each element ofCs, and an operation for each operation symbolu:Symbolσ.InductiveCarriersTermAlgebra{σ} (C:Carriersσ) :Carriersσ :=|var_term_algebra:foralls,Cs->CarriersTermAlgebraCs|ops_term_algebra:forall(u:Symbolσ),DomOperation(CarriersTermAlgebraC) (σu) ->CarriersTermAlgebraC(sort_cod(σu)).SchemeCarriersTermAlgebra_ind:=InductionforCarriersTermAlgebraSortType.ArgumentsCarriersTermAlgebra_ind{σ}.DefinitionCarriersTermAlgebra_rect{σ} := @CarriersTermAlgebra_indσ.DefinitionCarriersTermAlgebra_rec{σ :Signature} (C:Carriersσ)(P:Sortσ ->Type) (vs:forall(s:Sortσ),Cs->Ps)(os:forall(u:Symbolσ) (c:DomOperation(CarriersTermAlgebraC) (σu)),(foralli:Arity(σu),P(sorts_dom(σu)i)) ->P(sort_cod(σu)))(s:Sortσ) (T:CarriersTermAlgebraCs):Ps:=CarriersTermAlgebra_indC(funs_=>Ps)vsossT.A family of relationsR:foralls,Relation(Cs)can be extended to a family of relations on the term algebra carriers,forall s, Relation (CarriersTermAlgebra C s)SeeExtendDRelTermAlgebraandExtendRelTermAlgebrabelow.FixpointExtendDRelTermAlgebra{σ :Signature} {C:Carriersσ}(R:foralls,Relation(Cs)) {s1s2:Sortσ}(S:CarriersTermAlgebraCs1) (T:CarriersTermAlgebraCs2):Type:=matchS,Twith|var_term_algebras1x,var_term_algebras2y=>{p:s1=s2|Rs2(p#x)y}|ops_term_algebrau1a,ops_term_algebrau2b=>{p:u1=u2|foralli:Arity(σu1),ExtendDRelTermAlgebraR(ai) (b(transport(funv=>Arity(σv))pi))}|_,_=>Emptyend.DefinitionExtendRelTermAlgebra{σ :Signature} {C:Carriersσ}(R:foralls,Relation(Cs)) {s:Sortσ}:CarriersTermAlgebraCs->CarriersTermAlgebraCs->Type:=ExtendDRelTermAlgebraR.The next section shows, in particular, the following: IfR:foralls,Relation(Cs)is a family of mere equivalence relations, then@ExtendRelTermAlgebraσCRis a family of mere equivalence eqlations.Sectionextend_rel_term_algebra.Context`{Funext} {σ :Signature} {C:Carriersσ}(R:foralls,Relation(Cs))`{!foralls,is_mere_relation(Cs) (Rs)}.Global Instancehprop_extend_drel_term_algebra{s1s2:Sortσ}(S:CarriersTermAlgebraCs1) (T:CarriersTermAlgebraCs2):IsHProp(ExtendDRelTermAlgebraRST).Proof.generalizedependents2.inductionS;intross2T;destructT;exact_.Qed.Global Instancereflexive_extend_rel_term_algebra`{!foralls,Reflexive(Rs)} {s:Sortσ}:Reflexive(@ExtendRelTermAlgebraσCRs).Proof.introS.inductionSas[|uch].-byexistsidpath.-existsidpath.introi.applyh.Qed.Lemmasymmetric_extend_drel_term_algebra`{!foralls,Symmetric(Rs)} {s1s2:Sortσ}(S:CarriersTermAlgebraCs1) (T:CarriersTermAlgebraCs2)(h:ExtendDRelTermAlgebraRST):ExtendDRelTermAlgebraRTS.Proof.generalizedependents2.inductionSas[|uch];intross2[]p.-destructpas[p1p2].inductionp1.existsidpath.bysymmetry.-elimp.-elimp.-destructpas[pf].inductionp.existsidpath.introi.applyh.applyf.Qed.Global Instancesymmetric_extend_rel_term_algebra`{!foralls,Symmetric(Rs)} {s:Sortσ}:Symmetric(@ExtendRelTermAlgebraσCRs).Proof.introsST.applysymmetric_extend_drel_term_algebra.Defined.Lemmatransitive_extend_drel_term_algebra`{!foralls,Transitive(Rs)} {s1s2s3:Sortσ}(S:CarriersTermAlgebraCs1)(T:CarriersTermAlgebraCs2)(U:CarriersTermAlgebraCs3)(h1:ExtendDRelTermAlgebraRST)(h2:ExtendDRelTermAlgebraRTU):ExtendDRelTermAlgebraRSU.Proof.generalizedependents3.generalizedependents2.inductionSas[|uch];intross2[?d| ?d]h2s3[]h3;destructh2as[p2P2],h3as[p3P3] ||by(elimh2||elimh3).-exists(p2@p3).rewritetransport_pp.inductionp2,p3.bytransitivityd.-exists(p2@p3).introi.inductionp2.apply(hi_(di)).+applyP2.+rewriteconcat_1p.applyP3.Qed.Global Instancetransitive_extend_rel_term_algebra`{!foralls,Transitive(Rs)} {s:Sortσ}:Transitive(@ExtendRelTermAlgebraσCRs).Proof.introsSTU.applytransitive_extend_drel_term_algebra.Defined.Global Instanceequivrel_extend_rel_term_algebra`{!foralls,EquivRel(Rs)} (s:Sortσ):EquivRel(@ExtendRelTermAlgebraσCRs).Proof.constructor;exact_.Qed.Endextend_rel_term_algebra.By using path (propositional equality) as equivalence relation forExtendRelTermAlgebra, we obtain an equivalent notion of equality of term algebra carriers,equiv_path_extend_path_term_algebra. The reason for introducingExtendRelTermAlgebrais to have a notion of equality which works well together with induction on term algebras.Sectionextend_path_term_algebra.Context`{Funext} {σ} {C:Carriersσ} `{!foralls,IsHSet(Cs)}.DefinitionExtendPathTermAlgebra{s:Sortσ}(S:CarriersTermAlgebraCs) (T:CarriersTermAlgebraCs):Type:=ExtendRelTermAlgebra(funs=>paths)ST.Global Instancereflexive_extend_path_term_algebra:foralls:Sortσ,Reflexive(@ExtendPathTermAlgebras).Proof.byapplyreflexive_extend_rel_term_algebra.Defined.Lemmareflexive_extend_path_term_algebra_path{s:Sortσ}{ST:CarriersTermAlgebraCs} (p:S=T):ExtendPathTermAlgebraST.Proof.inductionp.applyreflexive_extend_path_term_algebra.Defined.Global Instancesymmetric_extend_path_term_algebra:foralls:Sortσ,Symmetric(@ExtendPathTermAlgebras).Proof.applysymmetric_extend_rel_term_algebra.introssxy.applyinverse.Defined.Global Instancetransitive_extend_path_term_algebra:foralls:Sortσ,Transitive(@ExtendPathTermAlgebras).Proof.applytransitive_extend_rel_term_algebra.introssxyz.applyconcat.Defined.Global Instanceequivrel_extend_path_term_algebra:foralls:Sortσ,EquivRel(@ExtendPathTermAlgebras).Proof.constructor;exact_.Qed.Global Instancehprop_extend_path_term_algebra(s:Sortσ):is_mere_relation(CarriersTermAlgebraCs)ExtendPathTermAlgebra.Proof.introsST.exact_.Defined.Lemmadependent_path_extend_path_term_algebra{s1s2:Sortσ}(S:CarriersTermAlgebraCs1) (T:CarriersTermAlgebraCs2)(e:ExtendDRelTermAlgebra(funs=>paths)ST): {p:s1=s2|p#S=T}.Proof.generalizedependents2.inductionSas[|uch];intross2[?d| ?d]e;solve[elime] ||destructeas[pe].-existsp.byinductionp,e.-inductionp.existsidpath.cbn.f_ap.funexta.destruct(ha_(da) (ea))as[pq].byinduction(hset_path2idpathp).Defined.Lemmapath_extend_path_term_algebra{s:Sortσ}(ST:CarriersTermAlgebraCs) (e:ExtendPathTermAlgebraST):S=T.Proof.destruct(dependent_path_extend_path_term_algebraSTe)as[pq].byinduction(hset_path2idpathp).Defined.Global Instancehset_carriers_term_algebra(s:Sortσ):IsHSet(CarriersTermAlgebraCs).Proof.apply(@ishset_hrel_subpaths_ExtendPathTermAlgebra).-applyreflexive_extend_path_term_algebra.-applyhprop_extend_path_term_algebra;exact_.-applypath_extend_path_term_algebra.Defined.Definitionequiv_path_extend_path_term_algebra{s:Sortσ}(ST:CarriersTermAlgebraCs):ExtendPathTermAlgebraST<~> (S=T):=equiv_iff_hprop(path_extend_path_term_algebraST)reflexive_extend_path_term_algebra_path.Endextend_path_term_algebra.At this point we can define the term algebra.DefinitionTermAlgebra`{Funext} {σ :Signature}(C:Carriersσ) `{!foralls,IsHSet(Cs)}:Algebraσ:=Build_Algebra(CarriersTermAlgebraC) (@ops_term_algebra_C).Lemmaisinj_var_term_algebra{σ} (C:Carriersσ) (s:Sortσ) (xy:Cs):var_term_algebraCsx=var_term_algebraCsy->x=y.Proof.introp.applyreflexive_extend_path_term_algebra_pathinp.destructpas[p1p2].bydestruct(hset_path2p1idpath)^.Qed.Lemmaisinj_ops_term_algebra`{Funext} {σ} (C:Carriersσ)(u:Symbolσ) (ab:DomOperation(CarriersTermAlgebraC) (σu)):ops_term_algebraCua=ops_term_algebraCub->a=b.Proof.introp.applyreflexive_extend_path_term_algebra_pathinp.destructpas[p1p2].destruct(hset_path2p1idpath)^.funexti.applypath_extend_path_term_algebra.applyp2.Qed.The extensionExtendRelTermAlgebraR, of a family of mere
    equivalence relationsR, is a congruence.Global Instanceis_congruence_extend_rel_term_algebra`{Funext} {σ} (C:Carriersσ) `{!foralls,IsHSet(Cs)}(R:foralls,Relation(Cs)) `{!foralls,EquivRel(Rs)}`{!foralls,is_mere_relation(Cs) (Rs)}:IsCongruence(TermAlgebraC) (@ExtendRelTermAlgebraσCR).Proof.constructor.-intros.exact_.-intros.exact_.-introsuabc.existsidpath.introi.applyc.Defined.Given and family of functionsf:foralls,Cs->As, we can extend it to aTermAlgebraC$->A, as shown in the next section.Sectionhom_term_algebra.Context`{Funext} {σ} {C:Carriersσ} `{!foralls,IsHSet(Cs)}(A:Algebraσ) (f:foralls,Cs->As).Definitionmap_term_algebra{σ} {C:Carriersσ} (A:Algebraσ)(f:foralls,Cs->As) (s:Sortσ) (T:CarriersTermAlgebraCs):As:=CarriersTermAlgebra_recCAf(funu_r=>u.#Ar)sT.Global Instanceis_homomorphism_map_term_algebra: @IsHomomorphismσ (TermAlgebraC)A(map_term_algebraAf).Proof.introsua.byrefine(apu.#A_).Qed.Definitionhom_term_algebra:TermAlgebraC$->A:= @Build_Homomorphismσ (TermAlgebraC)A(map_term_algebraAf)_.Endhom_term_algebra.The next section proves the universal property of the term algebra,
    thatTermAlgebrais a left adjoint functor{C : Carriers σ | forall s, IsHSet (C s)} -> Algebra σ,with right adjoint the forgetful functor. This is stated below as
    an equivalenceHomomorphism (TermAlgebra C) A <~> (forall s, C s -> A s),given by precomposition withvar_term_algebra C s : C s -> TermAlgebra C s.Sectionump_term_algebra.Context`{Funext} {σ} (C:Carriersσ) `{foralls,IsHSet(Cs)} (A:Algebraσ).By precomposingHomomorphism(TermAlgebraC)Awithvar_term_algebra, we obtain a familyforalls,Cs->As.Definitionprecomp_var_term_algebra(f:TermAlgebraC$->A):foralls,Cs->As:=funsx=>fs(var_term_algebraCsx).Lemmapath_precomp_var_term_algebra_to_hom_term_algebra:forall(f:TermAlgebraC$->A),hom_term_algebraA(precomp_var_term_algebraf) =f.Proof.introf.applypath_homomorphism.funextsT.inductionTas[|uch].-reflexivity.-refine(_@ (is_homomorphismfuc)^).refine(apu.#A_).funexti.applyh.Defined.Lemmapath_hom_term_algebra_to_precomp_var_term_algebra:forall(f:foralls,Cs->As),precomp_var_term_algebra(hom_term_algebraAf) =f.Proof.introf.byfunextsa.Defined.Precomposition withvar_term_algebrais an equivalenceGlobal Instanceisequiv_precomp_var_term_algebra:IsEquivprecomp_var_term_algebra.Proof.srapplyisequiv_adjointify.-applyhom_term_algebra.-intro.applypath_hom_term_algebra_to_precomp_var_term_algebra.-intro.applypath_precomp_var_term_algebra_to_hom_term_algebra.Defined.The universal property of the term algebra: TheTermAlgebrais a left adjoint functor.
      Noticeisequiv_precomp_var_term_algebraabove.Theoremump_term_algebra: (TermAlgebraC$->A) <~> (foralls,Cs->As).Proof.exact(Build_Equiv__precomp_var_term_algebra_).Defined.Endump_term_algebra.

--- Miscellaneous\Theory.html ---
TheoryLibrary TheoryRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoidsBasics.TruncBasics.EquivalencesBasics.DecidableBasics.Iff.RequireImportTypes.PathsTypes.UnitTypes.ProdTypes.SigmaTypes.SumTypes.EmptyTypes.Option.RequireExportSpaces.List.CoreSpaces.Nat.Core.LocalSetUniverseMinimizationToSet.LocalSetPolymorphicInductiveCumulativity.Theory of Lists and List OperationsIn this file we collect lemmas about lists and their operations. We don't include those inList.Coreso that file can stay lightweight on dependencies.We generally try to keep the order the same as the concepts appeared inList.Core.Local OpenScopelist_scope.LengthA list of length zero must be the empty list.Definitionlength_0{A:Type} (l:listA) (H:lengthl= 0%nat):l=nil.Proof.destructl.-reflexivity.-discriminate.Defined.ConcatenationConcatenating the empty list on the right is the identity.Definitionapp_nil{A:Type} (l:listA):l++nil=l.Proof.inductionlas[|alIHl].1:reflexivity.simpl;f_ap.Defined.Associativity of list concatenation.Definitionapp_assoc{A:Type} (xyz:listA):appx(appyz) =app(appxy)z.Proof.inductionxas[|axIHx]in|- *.-reflexivity.-exact(ap(consa)IHx).Defined.The type of lists has a monoidal structure given by concatenation.Definitionlist_pentagon{A:Type} (wxyz:listA):app_assocwx(y++z) @app_assoc(w++x)yz=ap(funl=>w++l) (app_assocxyz)@app_assocw(x++y)z@ap(funl=>l++z) (app_assocwxy).Proof.symmetry.inductionwas[|?wIHw]inx,y,z|- *.-simpl.applyequiv_p1_1q.lhsnrapplyconcat_p1.applyap_idmap.-simpl.rhs_Vnrapplyap_pp.rhs_Vnrapply(ap(ap(consa)) (IHwxyz)).rhsnrapplyap_pp.f_ap.{rhsnrapplyap_pp.f_ap.applyap_compose. }lhs_Vnrapplyap_compose.nrapply(ap_compose(funl=>l++z)).Defined.The length of a concatenated list is the sum of the lengths of the two lists.Definitionlength_app{A:Type} (ll':listA):length(l++l') = (lengthl+lengthl')%nat.Proof.inductionlas[|alIHl]usinglist_ind.1:reflexivity.simpl.exact(apSIHl).Defined.An element of a concatenated list is equivalently either in the first list or in the second list.Definitionequiv_inlist_app{A:Type} (ll':listA) (x:A):InListxl+InListxl'<~>InListx(l++l').Proof.inductionlas[|alIHl].-applysum_empty_l.-cbn;nrefine(_oEequiv_sum_assoc___).byapplyequiv_functor_sum_l.Defined.FoldingA left fold over a concatenated list is equivalent to folding over the first followed by folding over the second.Lemmafold_left_app{AB:Type} (f:A->B->A) (ll':listB) (i:A):fold_leftf(l++l')i=fold_leftfl'(fold_leftfli).Proof.inductionlini|- *.1:reflexivity.applyIHl.Defined.A right fold over a concatenated list is equivalent to folding over the second followed by folding over the first.Lemmafold_right_app{AB:Type} (f:B->A->A) (i:A) (ll':listB):fold_rightfi(l++l') =fold_rightf(fold_rightfil')l.Proof.inductionlini|- *.1:reflexivity.exact(ap(fa) (IHl_)).Defined.MapsThe length of a mapped list is the same as the length of the original list.Definitionlength_list_map{AB:Type} (f:A->B) (l:listA):length(list_mapfl) =lengthl.Proof.inductionlas[|xlIHl]usinglist_ind.-reflexivity.-simpl.exact(apSIHl).Defined.A function applied to an element of a list is an element of the mapped list.Definitioninlist_map{AB:Type} (f:A->B) (l:listA) (x:A):InListxl->InList(fx) (list_mapfl).Proof.simple_list_inductionlylIHl.1:contradiction.intros[p|i].-left.exact(apfp).-right.exact(IHli).Defined.An element of a mapped list is equal to the function applied to some element of the original list.Definitioninlist_map'{AB:Type} (f:A->B) (l:listA) (x:B):InListx(list_mapfl) -> {y:A& (fy=x) *InListyl}.Proof.inductionlas[|ylIHl].1:contradiction.intros[p|i].-exact(y; (p,inlidpath)).-destruct(IHli)as[y'[pi']].exact(y'; (p,inri')).Defined.Mapping a function over a concatenated list is the concatenation of the mapped lists.Definitionlist_map_app{AB:Type} (f:A->B) (ll':listA):list_mapf(l++l') =list_mapfl++list_mapfl'.Proof.inductionlas[|alIHl].1:reflexivity.simpl;f_ap.Defined.A function that acts as the identity on the elements of a list is the identity on the mapped list.Lemmalist_map_id{A:Type} (f:A->A) (l:listA)(Hf:forallx,InListxl->fx=x):list_mapfl=l.Proof.inductionlas[|xlIHl].-reflexivity.-simpl.nrapplyap011.+exact(Hf_(inlidpath)).+applyIHl.introsyHy.applyHf.byright.Defined.Alist_mapof a composition is the composition of the maps.Definitionlist_map_compose{ABC} (f:A->B) (g:B->C) (l:listA):list_map(funx=>g(fx))l=list_mapg(list_mapfl).Proof.inductionlas[|alIHl].1:reflexivity.simpl;f_ap.Defined.TODO: generalize as max  The length of alist_map2is the same as the length of the original lists.Definitionlength_list_map2@{ijk|} {A:Type@{i}} {B:Type@{j}} {C:Type@{k}}(f:A->B->C)defldefrl1l2:lengthl1=lengthl2->length(list_map2fdefldefrl1l2) =lengthl1.Proof.introsp.inductionl1as[|xl1IHl1]inl2,p|- *usinglist_ind@{ij}.-destructl2.+reflexivity.+inversionp.-destructl2.+inversionp.+cbn;f_ap.byapplyIHl1,path_nat_succ.Defined.An element of alist_map2is the result of applying the function to some elements of the original lists.Definitioninlist_map2@{ijku|i<=u,j<=u,k<=u}{A:Type@{i}} {B:Type@{j}} {C:Type@{k}}(f:A->B->C)defldefrl1l2x:InListx(list_map2fdefldefrl1l2) ->lengthl1=lengthl2-> {y:A& {z:B&prod@{ku} ((fyz) =x) (InListyl1*InListzl2) } }.Proof.introsHp.inductionl1as[|yl1IHl1]inl2,x,H,p|- *usinglist_ind@{iu}.-destructl2.1:contradiction.inversionp.-destructl2as[|z].1:inversionp.destructHas[q|i].1:exact(y;z; (q, (inlidpath,inlidpath))).destruct(IHl1l2xi)as[y'[z'[q[rs]]]].1:applypath_nat_succ,p.exact(y';z'; (q, (inrr,inrs))).Defined.list_map2is alist_mapif the first list is a repeated value.Definitionlist_map2_repeat_l{ABC} (f:A->B->C) (x:A)l{defldefr}:list_map2fdefldefr(repeatx(lengthl))l=list_map(fx)l.Proof.inductionlas[|ylIHl].-reflexivity.-cbn;f_ap.Defined.list_map2is alist_mapif the second list is a repeated value.Definitionlist_map2_repeat_r{ABC} (f:A->B->C) (y:B)l{defldefr}:list_map2fdefldefrl(repeaty(lengthl)) =list_map(funx=>fxy)l.Proof.inductionlas[|xlIHl].-reflexivity.-cbn;f_ap.Defined.ReversalThe length ofreverse_accis the sum of the lengths of the two lists.Definitionlength_reverse_acc@{i|} {A:Type@{i}} (accl:listA):length(reverse_accaccl) = (lengthacc+lengthl)%nat.Proof.symmetry.inductionlas[|xlIHl]inacc|- *usinglist_ind@{ii}.-applynat_add_zero_r.-rhs_VnrapplyIHl.applynat_add_succ_r.Defined.The length ofreverseis the same as the length of the original list.Definitionlength_reverse{A:Type} (l:listA):length(reversel) =lengthl.Proof.rapplylength_reverse_acc.Defined.Thelist_mapof areverse_accis thereverse_accof thelist_mapof the two lists.Definitionlist_map_reverse_acc{AB:Type}(f:A->B) (ll':listA):list_mapf(reverse_accl'l) =reverse_acc(list_mapfl') (list_mapfl).Proof.revertl';simple_list_inductionlalIHl;introl'.1:reflexivity.applyIHl.Defined.Thelist_mapof a reversed list is the reversedlist_map.Definitionlist_map_reverse{AB} (f:A->B) (l:listA):list_mapf(reversel) =reverse(list_mapfl).Proof.nrapplylist_map_reverse_acc.Defined.reverse_accis the same as concatenating the reversed list with the accumulator.Definitionreverse_acc_cons{A:Type} (ll':listA):reverse_accl'l=reversel++l'.Proof.inductionlas[|alIHl]inl'|- *.1:reflexivity.lhsnrapplyIHl.lhsnrapply(app_assoc_[a]).f_ap;symmetry.applyIHl.Defined.Thereverseof aconsis the concatenation of thereversewith the head.Definitionreverse_cons{A:Type} (a:A) (l:listA):reverse(a::l) =reversel++ [a].Proof.inductionlas[|blIHl]ina|- *.1:reflexivity.rewriteIHl.rewrite<-app_assoc.cbn;applyreverse_acc_cons.Defined.Thereverseof a concatenated list is the concatenation of the reversed lists in reverse order.Definitionreverse_app{A:Type} (ll':listA):reverse(l++l') =reversel'++reversel.Proof.inductionlas[|alIHl]inl'|- *.1:symmetry;applyapp_nil.simpl.lhsnrapplyreverse_cons.rhsnrapplyap.2:nrapplyreverse_cons.rhsnrapplyapp_assoc.nrapply(ap(funl=>l++ [a])).exact(IHll').Defined.reverseis involutive.Definitionreverse_reverse{A:Type} (l:listA):reverse(reversel) =l.Proof.inductionl.1:reflexivity.lhsnrapplyap.1:nrapplyreverse_cons.lhsnrapplyreverse_app.exact(ap_IHl).Defined.Getting elementsA variant ofnththat returns an element of the list and a proof that it is then-th element.Definitionnth_lt@{i|} {A:Type@{i}} (l:listA) (n:nat)(H: (n<lengthl)%nat): {x:A&nthln=Somex}.Proof.inductionlas[|alIHa]inn,H|- *usinglist_ind@{ii}.1:destruct(not_lt_zero_r_H).destructn.1:byexistsa.applyIHa.applyleq_pred'.exactH.Defined.A variant ofnththat always returns an element when we know that the index is in the list.Definitionnth'{A:Type} (l:listA) (n:nat) (H: (n<lengthl)%nat) :A:=pr1(nth_ltlnH).Thenth'element doesn't depend on the proof thatn<lengthl.Definitionnth'_nth'{A} (l:listA) (n:nat) (HH': (n<lengthl)%nat):nth'lnH=nth'lnH'.Proof.applyap,path_ishprop.Defined.Thenth'element of a list is in the list.Definitioninlist_nth'@{i|} {A:Type@{i}} (l:listA) (n:nat)(H: (n<lengthl)%nat):InList(nth'lnH)l.Proof.inductionlas[|alIHa]inn,H|- *usinglist_ind@{ii}.1:destruct(not_lt_zero_r_H).destructn.1:byleft.right.applyIHa.Defined.Thenth'element of a list is the same as the one given bynth.Definitionnth_nth'{A} (l:listA) (n:nat) (H: (n<lengthl)%nat):nthln=Some(nth'lnH).Proof.exact(nth_ltlnH).2.Defined.Thenth'element of aconsindexed atn.+1is the same as thenth'element of the tail indexed atn.Definitionnth'_cons{A:Type} (l:listA) (n:nat) (x:A)(H: (n<lengthl)%nat) (H': (n.+1 <length(x::l))%nat):nth'(x::l)n.+1H'=nth'lnH.Proof.applyisinj_some.nrefine(_^ @_@_).1,3:rapplynth_nth'.reflexivity.Defined.The index of an element in a list is thensuch that thenth'element is the element.Definitionindex_of@{i|} {A:Type@{i}} (l:listA) (x:A):InListxl->sig@{Seti} (funn:nat=> {H: (n<lengthl)%nat&nth'lnH=x}).Proof.inductionlas[|alIHl]usinglist_ind@{ii}.1:introsx';destructx'.intros[|i].-revertap.snrapplypaths_ind_r@{ii}.snrefine(exist@{ii}_0%nat_).snrefine(exist__idpath).applyleq_succ.exact_.-destruct(IHli)as[n[HH']].snrefine(exist@{ii}_n.+1%nat_).snrefine(_;_);cbn.1:applyleq_succ,H.refine(_@H').applynth'_cons.Defined.Thenthelement of a map is the function applied optionally to thenthelement of the original list.Definitionnth_list_map@{ij|} {A:Type@{i}} {B:Type@{j}}(f:A->B) (l:listA) (n:nat):nth(list_mapfl)n=functor_optionf(nthln).Proof.inductionlas[|alIHl]inn|- *usinglist_ind@{ij}.1:bydestructn.destructn.1:reflexivity.applyIHl.Defined.Thenth'element of alist_mapis the function applied to thenth'element of the original list.Definitionnth'_list_map@{ij|} {A:Type@{i}} {B:Type@{j}}(f:A->B) (l:listA) (n:nat) (H: (n<lengthl)%nat)(H': (n<length(list_mapfl))%nat):nth'(list_mapfl)nH'=f(nth'lnH).Proof.inductionlas[|alIHl]inn,H,H'|- *usinglist_ind@{ij}.1:destruct(not_lt_zero_r_H).destructn.1:reflexivity.applyIHl.Defined.Thenth'element of alist_map2is the function applied to thenth'elements of the original lists. The length of the two lists is required to be the same.Definitionnth'_list_map2{ABC:Type}(f:A->B->C) (l1:listA) (l2:listB)(n:nat)defldefr(H: (n<lengthl1)%nat) (H': (n<lengthl2)%nat)(H'': (n<length(list_map2fdefldefrl1l2))%nat)(p:lengthl1=lengthl2):f(nth'l1nH) (nth'l2nH') =nth'(list_map2fdefldefrl1l2)nH''.Proof.revertl2ndefldefrHH'H''p;simple_list_inductionl1al1IHl1;introsl2ndefldefrHH'H''p.-destructl2as[|bl2].+destruct(not_lt_zero_r_H).+inversionp.-destructl2as[|bl2].+inversionp.+destructn.*reflexivity.*erewrite3nth'_cons.applyIHl1.byapplypath_nat_succ.Defined.Thenth'element of arepeatis the repeated value.Definitionnth'_repeat@{i|} {A:Type@{i}} (x:A) (in:nat)(H: (i<length(repeatxn))%nat):nth'(repeatxn)iH=x.Proof.inductionnas[|nIHn]ini,H|- *usingnat_ind@{i}.1:destruct(not_lt_zero_r_H).destructi.1:reflexivity.applyIHn.Defined.Two lists are equal if theirnth'elements are equal.Definitionpath_list_nth'@{i|} {A:Type@{i}} (ll':listA)(p:lengthl=lengthl'): (foralln(H: (n<lengthl)%nat),nth'lnH=nth'l'n(p#H))->l=l'.Proof.introsH.inductionlas[|alIHl]inl',p,H|- *usinglist_ind@{ii}.{destructl'.-reflexivity.-discriminate. }destructl'as[|a'l'].1:discriminate.f_ap.-exact(H0%nat_).-snrapplyIHl.1:byapplypath_nat_succ.introsnHn.snrefine((nth'_conslnaHn_)^ @_).1:applyleq_succ,Hn.lhsnrapplyH.nrapplynth'_cons.Defined.Thenthnelement of a concatenated listl++l'wheren<lengthlis thenthelement ofl.Definitionnth_app@{i|} {A:Type@{i}} (ll':listA) (n:nat)(H: (n<lengthl)%nat):nth(l++l')n=nthln.Proof.inductionlas[|alIHl]inl',n,H|- *usinglist_ind@{ii}.1:destruct(not_lt_zero_r_H).destructn.1:reflexivity.byapplyIHl,leq_pred'.Defined.Thenthielement wherepred(lengthl)=iis the last element of the list.Definitionnth_last{A:Type} (l:listA) (i:nat) (p:nat_pred(lengthl) =i):nthli=lastl.Proof.destructp.inductionlas[|alIHl].1:reflexivity.destructlas[|bl].1:reflexivity.cbn;applyIHl.Defined.The last element of a list with an element appended is the appended element.Definitionlast_app{A:Type} (l:listA) (x:A):last(l++ [x]) =Somex.Proof.inductionlas[|alIHl]inx|- *.1:reflexivity.destructl.1:reflexivity.cbn;applyIHl.Defined.Removing elementsThese functions allow surgery to be perfomed on a given list.Dropdropnlremoves the firstnelements ofl.Fixpointdrop{A:Type} (n:nat) (l:listA) :listA:=matchl,nwith|_::l,n.+1%nat=>dropnl|_,_=>lend.Adropof zero elements is the identity.Definitiondrop_0{A:Type} (l:listA):drop0l=l.Proof.bydestructl.Defined.Adropof one element is the tail of the list.Definitiondrop_1{A:Type} (l:listA):drop1l=taill.Proof.inductionl.1:reflexivity.bydestructl.Defined.Adropof the empty list is the empty list.Definitiondrop_nil{A:Type} (n:nat):dropn(@nilA) =nil.Proof.bydestructn.Defined.Adropofnelements withlengthl<=nis the empty list.Definitiondrop_length_leq@{i|} {A:Type@{i}} (n:nat) (l:listA)(H: (lengthl<=n)%nat):dropnl=nil.Proof.inductionlas[|alIHl]inH,n|- *usinglist_ind@{ii}.1:applydrop_nil.destructn.1:destruct(not_lt_zero_r_H).cbn;applyIHl.applyleq_pred'.exactH.Defined.The length of adropnis the length of the original list minusn.Definitionlength_drop@{i|} {A:Type@{i}} (n:nat) (l:listA):length(dropnl) = (lengthl-n)%nat.Proof.inductionlas[|alIHl]inn|- *usinglist_ind@{ii}.1:byrewritedrop_nil.destructn.1:reflexivity.exact(IHln).Defined.An element of adropis an element of the original list.Definitiondrop_inlist@{i|} {A:Type@{i}} (n:nat) (l:listA) (x:A):InListx(dropnl) ->InListxl.Proof.introsH.inductionlas[|alIHl]inn,H,x|- *usinglist_ind@{ii}.1:rewritedrop_nilinH;contradiction.destructn.1:rewritedrop_0inH;assumption.right;nrapply(IHl__H).Defined.Taketakenlkeeps the firstnelements ofland returnslifn>=lengthl.Fixpointtake{A:Type} (n:nat) (l:listA) :listA:=matchl,nwith|x::l,n.+1%nat=>x::takenl|_,_=>nilend.Atakeof zero elements is the empty list.Definitiontake_0{A:Type} (l:listA) :take0l=nil.Proof.bydestructl.Defined.Atakeof the empty list is the empty list.Definitiontake_nil{A:Type} (n:nat) :taken(@nilA) =nil.Proof.bydestructn.Defined.Atakeofnelements withlengthl<=nis the original list.Definitiontake_length_leq@{i|} {A:Type@{i}} (n:nat) (l:listA)(H: (lengthl<=n)%nat):takenl=l.Proof.inductionlas[|alIHl]inH,n|- *usinglist_ind@{ii}.1:applytake_nil.destructn.1:destruct(not_lt_zero_r_H).cbn;f_ap.byapplyIHl,leq_pred'.Defined.The length of atakenis the minimum ofnand the length of the original list.Definitionlength_take@{i|} {A:Type@{i}} (n:nat) (l:listA):length(takenl) =nat_minn(lengthl).Proof.inductionlas[|alIHl]inn|- *usinglist_ind@{ii}.{rewritetake_nil.rewritenat_min_r.1:reflexivity.cbn;exact_. }destructn.1:reflexivity.cbn;f_ap.Defined.An element of atakeis an element of the original list.Definitiontake_inlist@{i|} {A:Type@{i}} (n:nat) (l:listA) (x:A):InListx(takenl) ->InListxl.Proof.introsH.inductionlas[|alIHl]inn,H,x|- *usinglist_ind@{ii}.1:rewritetake_nilinH;contradiction.destructn.1:rewritetake_0inH;contradiction.destructHas[-> |H].-left;reflexivity.-right;exact(IHl__H).Defined.Removeremovenlremoves then-th element ofl.Definitionremove{A:Type} (n:nat) (l:listA) :listA:=takenl++dropn.+1l.Removing the first element of a list is the tail of the list.Definitionremove_0{A:Type} (l:listA) :remove0l=taill.Proof.unfoldremove.byrewritetake_0,drop_1.Defined.Removing then-th element of a list withlengthl<=nis the original list.Definitionremove_length_leq{A:Type} (n:nat) (l:listA)(H: (lengthl<=n)%nat):removenl=l.Proof.unfoldremove.rewritetake_length_leq.2:exact_.rewritedrop_length_leq.2:exact_.applyapp_nil.Defined.The length of aremovenis the length of the original list minus one.Definitionlength_remove@{i|} {A:Type@{i}} (n:nat) (l:listA)(H: (n<lengthl)%nat):length(removenl) =nat_pred(lengthl)%nat.Proof.unfoldremove.rewritelength_app@{i}.rewritelength_take.rewritelength_drop.rewritenat_min_l.2:exact(leq_trans_H).rewrite<-nat_sub_l_add_r.2:exact_.lhsnrapplynat_sub_succ_r.applyap.applynat_add_sub_cancel_l.Defined.An element of aremoveis an element of the original list.Definitionremove_inlist{A:Type} (n:nat) (l:listA) (x:A):InListx(removenl) ->InListxl.Proof.unfoldremove.introsp.applyequiv_inlist_appinp.revertp.snrapplysum_rec.-applytake_inlist.-applydrop_inlist.Defined.FilterProduce the list of elements of a list that satisfy a decidable predicate.Fixpointlist_filter@{uv|} {A:Type@{u}} (l:listA) (P:A->Type@{v})(dec:forallx,Decidable(Px)):listA:=matchlwith|nil=>nil|x::l=>ifdecxthenx::list_filterlPdecelselist_filterlPdecend.Definitioninlist_filter@{uvk|u<=k,v<=k} {A:Type@{u}} (l:listA)(P:A->Type@{v}) (dec:forallx,Decidable(Px)) (x:A):iff@{ukk} (InListx(list_filterlPdec)) (InListxl/\Px).Proof.simple_list_inductionlalIHl.-simpl.applyiff_inverse.applyiff_equiv.snrapplyprod_empty_l@{v}.-simpl.nrapplyiff_compose.2: {applyiff_inverse.applyiff_equiv.exact(sum_distrib_r@{kkk___kk}___). }destruct(deca)as[p|p].+simpl.snrapplyiff_compose.1:exact(sum(a=x) (prod(InList@{u}xl) (Px))).1:split;applyfunctor_sum;only1,3:exactidmap;applyIHl.split;applyfunctor_sum@{kkkk};only2,4:applyidmap.*intros[].exact(idpath,p).*exactfst.+nrapplyiff_compose.1:applyIHl.applyiff_inverse.applyiff_equiv.nrefine(equiv_compose'@{kkk} (sum_empty_l@{k}_)_).snrapplyequiv_functor_sum'@{kkkkkk}.2:exactequiv_idmap.applyequiv_to_empty.byintros[[]r].Defined.Definitionlist_filter_app{A:Type} (ll':listA) (P:A->Type)(dec:forallx,Decidable(Px)):list_filter(l++l')Pdec=list_filterlPdec++list_filterl'Pdec.Proof.simple_list_inductionlalIHl.-reflexivity.-simpl;destruct(deca);trivial.simpl;f_ap.Defined.SequencesThe length of a reverse sequence ofnnumbers isn.Definitionlength_seq_rev@{} (n:nat):length(seq_revn) =n.Proof.inductionnas[|nIHn].1:reflexivity.cbn;f_ap.Defined.The length of a sequence ofnnumbers isn.Definitionlength_seq@{} (n:nat):length(seqn) =n.Proof.lhsnrapplylength_reverse.applylength_seq_rev.Defined.The reversed sequence ofn.+1numbers is thenfollowed by the rest of the reversed sequence.Definitionseq_rev_cons@{} (n:nat):seq_revn.+1 =n::seq_revn.Proof.inductionnas[|nIHn].1:reflexivity.cbn;f_ap.Defined.The sequence ofn.+1numbers is the sequence ofnnumbers concatenated with[n].Definitionseq_succ@{} (n:nat):seqn.+1 =seqn++ [n].Proof.applyreverse_cons.Defined.Alternate definition ofseq_revthat keeps the proofs of the entries being<n.Definitionseq_rev'@{} (n:nat) :list{k:nat& (k<n)%nat}.Proof.transparentassert(f: (foralln, {k:nat& (k<n)%nat}-> {k:nat& (k<n.+1)%nat})).{introsm.snrapply(functor_sigmaidmap).introskH.exact(leq_succ_rH). }inductionnas[|nIHn].1:exactnil.nrefine((n;_) ::list_map(fn)IHn).exact_.Defined.Alternate definition ofseqthat keeps the proofs of the entries being<n.Definitionseq'@{} (n:nat) :list{k:nat& (k<n)%nat}:=reverse(seq_rev'n).The length ofseq_rev'nisn.Definitionlength_seq_rev'@{} (n:nat):length(seq_rev'n) =n.Proof.inductionnas[|nIHn].1:reflexivity.cbn;f_ap.lhsnrapplylength_list_map.exactIHn.Defined.The length ofseq'nisn.Definitionlength_seq'@{} (n:nat):length(seq'n) =n.Proof.lhsnrapplylength_reverse.applylength_seq_rev'.Defined.Thelist_mapof first projections onseq_rev'nisseq_revn.Definitionseq_rev_seq_rev'@{} (n:nat):list_mappr1(seq_rev'n) =seq_revn.Proof.inductionnas[|nIHn].1:reflexivity.simpl;f_ap.lhs_Vnrapplylist_map_compose.applyIHn.Defined.Thelist_mapof first projections onseq'nisseqn.Definitionseq_seq'@{} (n:nat):list_mappr1(seq'n) =seqn.Proof.lhsnrapplylist_map_reverse_acc.apply(apreverse).applyseq_rev_seq_rev'.Defined.Thenthelement of aseq_revisn-i.+1.Definitionnth_seq_rev@{} {ni} (H: (i<n)%nat):nth(seq_revn)i=Some(n-i.+1)%nat.Proof.inductionias[|iIHi]inn,H|- *.-inductionn.1:destruct(not_lt_zero_r_H).cbn;byrewritenat_sub_zero_r.-inductionnas[|nIHn].1:destruct(not_lt_zero_r_H).byapplyIHi,leq_pred'.Defined.Thenthelement of aseqisi.Definitionnth_seq@{} {ni} (H: (i<n)%nat):nth(seqn)i=Somei.Proof.inductionn.1:destruct(not_lt_zero_r_H).rewriteseq_succ.destruct(dec(i<n)%nat)as[H'|H'].-lhsnrapplynth_app.1:byrewritelength_seq.byapplyIHn.-applygeq_iff_not_ltinH'.applyleq_pred'inH.destruct(leq_antisymHH').lhsnrapplynth_last.{rewritelength_app.rewritenat_add_comm.applylength_seq. }nrapplylast_app.Defined.Thenth'element of aseq'isi.Definitionnth'_seq'@{} (ni:nat) (H: (i<length(seq'n))%nat): (nth'(seq'n)iH).1 =i.Proof.unshelvelhs_Vnrapplynth'_list_map.1:byrewritelength_list_map.unshelvelhsnrapply(ap011D(funxy=>nth'x_y)_idpath).2:applyseq_seq'.applyisinj_some.lhs_Vnrapplynth_nth'.applynth_seq.byrewritelength_seq'inH.Defined.Definitioninlist_seq@{} (n:nat)x:InListx(seqn) <~> (x<n)%nat.Proof.simple_inductionnnIHn.{symmetry;applyequiv_to_empty.applynot_lt_zero_r. }refine(_oEequiv_transport_(seq_succ_)).nrefine(_oE(equiv_inlist_app___)^-1).nrefine(_oEequiv_functor_sum'(B':=x=n)IHn_).2: {simpl.exact(equiv_path_inverse__oEsum_empty_r@{Set}_). }nrefine(_oEequiv_leq_lt_or_eq^-1).rapplyequiv_iff_hprop.Defined.RepeatThe length of a repeated list is the number of repetitions.Definitionlength_repeat@{i|} {A:Type@{i}} (n:nat) (x:A):length(repeatxn) =n.Proof.inductionnusingnat_ind@{i}.-reflexivity.-exact(apSIHn).Defined.An element of a repeated list is equal to the repeated element.Definitioninlist_repeat@{i|} {A:Type@{i}} (n:nat) (xy:A):InListy(repeatxn) ->y=x.Proof.inductionnas[|nIHn].1:contradiction.intros[p|i].-bysymmetry.-byapplyIHn.Defined.ForallIf a predicate holds for all elements of a list, the thefor_allpredicate holds for the list.Definitionfor_all_inlist{A:Type} (P:A->Type)l: (forallx,InListxl->Px) ->for_allPl.Proof.simple_list_inductionlhtIHl;introsH;cbn;trivial;split.-applyH.byleft.-applyIHl.introsyi.applyH.byright.Defined.Conversely, iffor_allPlthen each element of the list satisfiesP.Definitioninlist_for_all{A:Type} {P:A->Type}(l:listA):for_allPl->forallx,InListxl->Px.Proof.simple_list_inductionlxlIHl.-contradiction.-intros[HxHl]y[-> |i].+exactHx.+applyIHl.1:exactHl.exacti.Defined.If a predicatePimplies a predicateQcomposed with a functionf, thenfor_allPlimpliesfor_allQ(list_mapfl).Definitionfor_all_list_map{AB:Type} (P:A->Type) (Q:B->Type)(f:A->B) (Hf:forallx,Px->Q(fx)):foralll,for_allPl->for_allQ(list_mapfl).Proof.simple_list_inductionlxlIHl;simpl;trivial.intros[HxHl].split;auto.Defined.A variant offor_all_mapPQfwhereQisPof.Definitionfor_all_list_map'{AB:Type} (P:B->Type) (f:A->B):foralll,for_all(Pof)l->for_allP(list_mapfl).Proof.byapplyfor_all_list_map.Defined.If a predicatePand a predicateQtogether imply a predicateR, thenfor_allPlandfor_allQltogether implyfor_allRl. There are also some side conditions for the default elements.Lemmafor_all_list_map2{ABC:Type}(P:A->Type) (Q:B->Type) (R:C->Type)(f:A->B->C) (Hf:forallxy,Px->Qy->R(fxy))def_l(Hdefl:foralll1,for_allPl1->for_allR(def_ll1))def_r(Hdefr:foralll2,for_allQl2->for_allR(def_rl2))(l1:listA) (l2:listB):for_allPl1->for_allQl2->for_allR(list_map2fdef_ldef_rl1l2).Proof.revertl2;simple_list_inductionl1xl1IHl1;introl2.-destructl2as[|yl2];cbn;auto.-simpl.destructl2as[|yl2];intros[HxHl1];[intros_|intros[HyHl2] ];simpl;auto.applyHdefl.simpl;auto.Defined.A simpler variant offor_all_map2where both lists have the same length and the side conditions on the default elements can be avoided.Definitionfor_all_list_map2'{ABC:Type}(P:A->Type) (Q:B->Type) (R:C->Type)(f:A->B->C) (Hf:forallxy,Px->Qy->R(fxy)){def_ldef_r} {l1:listA} {l2:listB}(p:lengthl1=lengthl2):for_allPl1->for_allQl2->for_allR(list_map2fdef_ldef_rl1l2).Proof.revertl2p;simple_list_inductionl1xl1IHl1;introsl2p.-destructl2.+reflexivity.+discriminate.-destructl2as[|yl2].+discriminate.+intros[HxHl1] [HyHl2].split.*byapplyHf.*applyIHl1;trivial.applypath_nat_succ.exactp.Defined.The left fold offon a listlfor whichfor_allQlsatisfiesPifPandQimplyPcomposed withf.Lemmafold_left_preserves{AB:Type}(P:A->Type) (Q:B->Type) (f:A->B->A)(Hf:forallxy,Px->Qy->P(fxy))(acc:A) (Ha:Pacc) (l:listB) (Hl:for_allQl):P(fold_leftflacc).Proof.revertaccHaHl;simple_list_inductionlxlIHl;introsaccHaHl.-exactHa.-simpl.destructHlas[QxHl].applyIHl;auto.Defined.for_allpreserves the truncation predicate.Definitionistrunc_for_all{A:Type}{n:trunc_index} (P:A->Type) (l:listA):for_all(funx=>IsTruncn(Px))l->IsTruncn(for_allPl).Proof.inductionlas[|xlIHl];simpl.-destructn;exact_.-intros[HxHl].applyIHlinHl.exact_.Defined.Global Instanceistrunc_for_all'{A:Type} {n:trunc_index}(P:A->Type) (l:listA)`{forallx,IsTruncn(Px)}:IsTruncn(for_allPl).Proof.byapplyistrunc_for_all,for_all_inlist.Defined.If a predicate holds for an element, then it holdsfor_allthe elements of the repeated list.Definitionfor_all_repeat{A:Type} {n:nat}(P:A->Type) (x:A):Px->for_allP(repeatxn).Proof.introsH.inductionnas[|nIHn].1:exacttt.exact(H,IHn).Defined.We can form a list of pairs of a sigma type given a list and a for_all predicate over it.Definitionlist_sigma{A:Type} (P:A->Type) (l:listA) (p:for_allPl):list{x:A&Px}.Proof.inductionlas[|xlIHl]inp|- *.1:exactnil.destructpas[HxHl].exact((x;Hx) ::IHlHl).Defined.The length of a list of sigma types is the same as the original list.Definitionlength_list_sigma{A:Type} {P:A->Type} {l:listA} {p:for_allPl}:length(list_sigmaPlp) =lengthl.Proof.revertp;simple_list_inductionlxlIHl;introp.1:reflexivity.destructpas[HxHl].cbn;f_ap.applyIHl.Defined.If a predicatePis decidable then so isfor_allP.Global Instancedecidable_for_all{A:Type} (P:A->Type)`{forallx,Decidable(Px)} (l:listA):Decidable(for_allPl).Proof.simple_list_inductionlxlIHl;exact_.Defined.If a predicatePis decidable then so islist_existsP.Global Instancedecidable_list_exists{A:Type} (P:A->Type)`{forallx,Decidable(Px)} (l:listA):Decidable(list_existsPl).Proof.simple_list_inductionlxlIHl;exact_.Defined.Definitioninlist_list_exists{A:Type} (P:A->Type) (l:listA):list_existsPl->exists(x:A),InListxl/\Px.Proof.simple_list_inductionlxlIHl.1:done.simpl.intros[Px|ex].-existsx.bysplit; [left|].-destruct(IHlex)as[x'[HPx']].existsx'.bysplit; [right|].Defined.Definitionlist_exists_inlist{A:Type} (P:A->Type) (l:listA):forall(x:A),InListxl->Px->list_existsPl.Proof.simple_list_inductionlxlIHl.1:trivial.simpl;introsyHp;revertH.applyfunctor_sum.-exact(funr=>r^ #p).-introsH.byapply(IHly).Defined.Definitionlist_exists_seq{n:nat} (P:nat->Type)(H:forallk,Pk-> (k<n)%nat): (existsk,Pk) <->list_existsP(seqn).Proof.split.-intros[kp].snrapply(list_exists_inlistP_k_p).applyinlist_seq,H.exactp.-introsH1.applyinlist_list_existsinH1.destructH1as[k[Hkp]].existsk.exactp.Defined.An upper bound on witnesses of a decidable predicate makes the sigma type decidable.Definitiondecidable_exists_nat(n:nat) (P:nat->Type)(H1:forallk,Pk-> (k<n)%nat)(H2:forallk,Decidable(Pk)):Decidable(existsk,Pk).Proof.nrapplydecidable_iff.1:applyiff_inverse;nrapplylist_exists_seq.1:exactH1.exact_.Defined.

--- Miscellaneous\ToCat.html ---
ToCatLibrary ToCatGrothendieck Construction of a functor to CatRequireImportCategory.CoreFunctor.Core.RequireImportPseudofunctor.FromFunctor.RequireImportCat.Core.RequireImportGrothendieck.PseudofunctorToCat.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.SectionGrothendieck.Context`{Funext}.VariableP:PreCategory->Type.(*Context `{forall C, IsHProp (P C)}.*)Context`{HF:forallCD,PC->PD->IsHSet(FunctorCD)}.Local Notationcat:= (@sub_pre_cat_PHF).VariableC:PreCategory.VariableF:FunctorCcat.Category of elementsDefinitioncategory:PreCategory:=category(pseudofunctor_of_functor_to_catF).First projection functorDefinitionpr1:FunctorcategoryC:=pr1(pseudofunctor_of_functor_to_catF).EndGrothendieck.

--- Miscellaneous\Topological.html ---
TopologicalLibrary TopologicalRequireImportHoTT.BasicsHoTT.Types.RequireImportExtensionsHoTT.Truncations.RequireImportAccessibleLexNullification.Local OpenScopepath_scope.Topological localizationsA topological localization -- or, as we will say, a topological nullification -- is a nullification at a family of hprops, or more generally an accessible modality whose generators of accessibility are all hprops.  This is not quite the same as Lurie's definition: in Higher Topos Theory, a topological localization is an accessible *left exact* localization at a pullback-stable class generated by a set of monomorphisms.  "Pullback-stable class generated by" is roughly incorporated into our internal notion of accessibility, so the main new difference here is that when the generation is internal in this way, the localization at a family of hprops is *automatically* left exact.NotationTopologicalO:= (foralli,IsHProp(acc_ngenOi)).Topological modalities are lexWe prove left-exactness by proving that the universe of modal types is modal, using univalence.  It's unclear whether univalence is necessary or not in general; in one special case (open modalities) funext suffices.  But it's plausible that it would be necessary in general, because lex-ness of nullification is a statement about the path-spaces of a HIT, and characterizing those in any way usually requires some amount of univalence.Global Instancelex_topological`{Univalence}(O:Modality) `{IsAccModalityO} `{TopologicalO}:LexO.Proof.snrapplylex_from_inO_typeO; [exact_|introsi].apply((equiv_ooextendable_isequiv__)^-1%equiv).srapplyisequiv_adjointify;cbn.-introsB_.refine((foralla,Ba) ;_).exact_.-introsB.applypath_arrow;introsa.applypath_TypeO,path_universe_uncurried.unfoldcomposeD;simpl.simplerefine(equiv_adjointify____).+introsf.exact(fa).+introsba'.exact(transportB(path_ishpropaa')b).+introsb.refine(transport2B(path_contr_1)b).+introsf.applypath_forall;introsa'.exact(apDf_).-introsB.applypath_arrow;intros[].applypath_TypeO,path_universe_uncurried.unfoldcomposeD;simpl.pose(e:=isequiv_ooextendable__(fst(inO_iff_isnullO(Btt)) (inO_TypeO(Btt))i)).unfoldcomposeDine;simpline.refine(_oE(Build_Equiv___e)^-1).exact(equiv_contr_forall_).Defined.Global Instancelex_nullification`{Univalence}(S:NullGenerators) `{foralli,IsHProp(Si)}:Lex(NulS).Proof.rapplylex_topological.Defined.Lex modalities generated by n-types are topologicalForn>=0, nullification at a family ofn-types need not be lex.  For instance, the (-1)-truncation is nullification atBool.  However, if the nullification at a family ofn-types *is* lex, then it is topological.This is kind of annoying to prove, not just because the proof is fiddly, but because we have to pass back and forth between different generating families for the "same" modality.  It's a bit easier to prove it about nullifications than about arbitrary accessible lex modalities.Definitiontopological_lex_trunc_acc`{Funext}(B:NullGenerators) {Olex:Lex(NulB)}(n:trunc_index) (gtr:foralla,IsTruncn(ngen_typeBa)): {D:NullGenerators&(forallc,IsHProp(ngen_typeDc)) *(NulD<=>NulB) }.Proof.destructn.{exists(Build_NullGeneratorsEmpty(fun_=>Unit)).split; [exact_|split;introsX_; [ |intros[] ] ].introsi.applyooextendable_equiv,isequiv_contr_contr. }pose(O:=NulB).pose(OeqB:=reflexive_O_eqO:O<=> (NulB)).change(NulB)withOinOlex.clearbodyOOeqB.revertBOeqBgtr.inductionn;introsBOeqBgtr.{existsB;split; [assumption|reflexivity]. }pose(A:=ngen_indicesB).pose(C:=A+ {a:A&B(a) *B(a) }).pose(D:=Build_NullGeneratorsC(func:C=>matchcwith|inla=>merely(Ba)|inr(a; (b1,b2)) => (b1=b2)end:Type)).assert(Dtrunc:forallc:C,IsTruncn.+1 (Dc)).{intros[a| [a[b1b2]]]; [cbn|exact_].(* Becausetrunc_hpropcan't be used as an idmap... *)destructn;exact_. }assert(OeqD:O<=> (NulD)).{split;introsX.-introsX_inOc.assert(Bc:foralla:A,IsConnectedO(Ba)).{introsa.rapply(@isconnected_O_leqO(NulB)).exact(isconnected_acc_ngen(NulB)a). }apply(ooextendable_const_isconnected_inOO);[destructcas[a| [a[b1b2]]] |exactX_inO].+applyisconnected_from_elim_to_O.destruct(isconnected_elimO(O(merely(Ba)))(funb=>toO_(trb)))as[xh].existsx;introsy;cbniny.strip_truncations.exact(hy).+cbn.rapplyisconnected_paths.-introsDnull;rapply(@inO_leq(NulB)O).introsa;cbnina;cbn.apply((equiv_ooextendable_isequiv(unit_nameX) (fun_:Ba=>tt))^-1).applyisequiv_contr_map;introsf;cbninf.refine(contr_equiv'{x:X&forallu:Ba,x=fu}_).{refine(equiv_functor_sigma'(equiv_unit_recX)_).introsx;unfoldcomposeD;cbn.applyequiv_path_arrow. }refine((isconnected_elim(NulD) (A:=D(inla))__).1).{rapplyisconnected_acc_ngen. }introsb;cbninb.strip_truncations.assert(bc:IsConnMap(NulD) (unit_nameb)).{introsx;unfoldhfiber.apply(isconnected_equiv(NulD) (b=x)(equiv_contr_sigma_)^-1).rapply(isconnected_acc_ngen(NulD) (inr(a;(b,x)))). }pose(p:=conn_map_elim(NulD) (unit_nameb)(funu=>fb=fu) (fun_=> 1)).apply(Build_Contr_(fb;p));intros[xq].refine(path_sigma'_(qb)^_);applypath_forall.refine(conn_map_elim(NulD) (unit_nameb)__);intros[].rewritetransport_forall_constant,transport_paths_l,inv_V.rewrite(conn_map_comp(NulD) (unit_nameb)(funu:Ba=>fb=fu)(fun_=> 1)tt:pb= 1).applyconcat_p1. }destruct(IHnDOeqD_)as[E[HEEeqD]].existsE;split; [exactHE| ].refine(transitivityEeqD_).refine(transitivity_OeqB).symmetry;assumption.Defined.

--- Miscellaneous\Torus.html ---
TorusLibrary TorusRequireImportBasics.OvertureBasics.EquivalencesCubical.DPathCubical.PathSquareCubical.DPathSquareCubical.PathCubeCubical.DPathCube.In this file we define the Torus as a HIT generated by two loops and a square between them.Notationhr:= (sq_refl_h_).Notationvr:= (sq_refl_v_).ModuleExportTorus.Private InductiveTorus:=|tbase.Axiomloop_a:tbase=tbase.Axiomloop_b:tbase=tbase.Axiomsurf:PathSquareloop_aloop_aloop_bloop_b.We define the induction principle for TorusDefinitionTorus_ind(P:Torus->Type) (pb:Ptbase)(pla:DPathPloop_apbpb) (plb:DPathPloop_bpbpb)(ps:DPathSquarePsurfplaplaplbplb) (x:Torus) :Px:= (matchxwithtbase=>fun___=>pbend)plaplbps.We declare propositional computational rules for loop_a and loop_bAxiomTorus_ind_beta_loop_a:forall(P:Torus->Type) (pb:Ptbase)(pla:DPathPloop_apbpb) (plb:DPathPloop_bpbpb)(ps:DPathSquarePsurfplaplaplbplb),DPathSquarePhr(apD(Torus_indPpbplaplbps) (loop_a))pla1%dpath1%dpath.AxiomTorus_ind_beta_loop_b:forall(P:Torus->Type) (pb:Ptbase)(pla:DPathPloop_apbpb) (plb:DPathPloop_bpbpb)(ps:DPathSquarePsurfplaplaplbplb),DPathSquarePhr(apD(Torus_indPpbplaplbps) (loop_b))plb1%dpath1%dpath.We write out the computation rule for surf even though we will not use it. Instead we currently have an unfinished recursion computation principle, but we don't currently know how to derive it from thisAxiomTorus_ind_beta_surf:forall(P:Torus->Type) (pb:Ptbase)(pla:DPathPloop_apbpb) (plb:DPathPloop_bpbpb)(ps:DPathSquarePsurfplaplaplbplb),DPathCubeP(cu_refl_lr_) (ds_apD(Torus_indPpbplaplbps)surf)ps(Torus_ind_beta_loop_a_____) (Torus_ind_beta_loop_a_____)(Torus_ind_beta_loop_b_____) (Torus_ind_beta_loop_b_____).EndTorus.We can now define Torus recursion as a special case of Torus inductionDefinitionTorus_rec(P:Type) (pb:P) (plaplb:pb=pb)(ps:PathSquareplaplaplbplb) :Torus->P:=Torus_ind_pb(dp_constpla) (dp_constplb) (ds_constps).We can derive the recursion computation rules for Torus_recLemmaTorus_rec_beta_loop_a(P:Type) (pb:P) (plaplb:pb=pb)(ps:PathSquareplaplaplbplb):PathSquare(ap(Torus_recPpbplaplbps)loop_a)pla1 1.Proof.refine(sq_GGcc_(eissect__)(ds_const'^-1 (Torus_ind_beta_loop_a_____))).applymoveR_equiv_V,dp_apD_const.Defined.LemmaTorus_rec_beta_loop_b(P:Type) (pb:P) (plaplb:pb=pb)(ps:PathSquareplaplaplbplb):PathSquare(ap(Torus_recPpbplaplbps)loop_b)plb1 1.Proof.refine(sq_GGcc_(eissect__)(ds_const'^-1 (Torus_ind_beta_loop_b_____))).applymoveR_equiv_V,dp_apD_const.Defined.We ought to be able to prove this from Torus_ind_beta_surf but it is currently too difficult. Therefore we will leave it as admitted where it will simply look like an axiom.DefinitionTorus_rec_beta_surf(P:Type) (pb:P) (plaplb:pb=pb)(ps:PathSquareplaplaplbplb):PathCube(sq_ap(Torus_recPpbplaplbps)surf)ps(Torus_rec_beta_loop_aPpbplaplbps)(Torus_rec_beta_loop_aPpbplaplbps)(Torus_rec_beta_loop_bPpbplaplbps)(Torus_rec_beta_loop_bPpbplaplbps).Proof.Admitted.The torus is pointed.Global Instanceispointed_torus:IsPointedTorus:=tbase.The loops commute.Definitionloops_commute_torus:loop_a@loop_b=loop_b@loop_a:=equiv_sq_path^-1surf.(* TODO:(* We ought to be able to prove the computation rules all at the same time *)(* This gives me the idea of writing all our computation rules as a"dependent filler" *)Definition Torus_rec_beta_cube (P : Type) (pb : P) (pla plb : pb = pb)(ps : PathSquare pla pla plb plb): { ba : PathSquare (ap (Torus_rec P pb pla plb ps) loop_a) pla 1 1 &{ bb : PathSquare (ap (Torus_rec P pb pla plb ps) loop_b) plb 1 1 &PathCube (sq_ap (Torus_rec P pb pla plb ps) surf) ps ba ba bb bb}}.Proof.refine (_;_;_).set(cu_cGcccc (eissect ds_const' _)(dc_const'^-1 (Torus_ind_beta_surf (fun _ => P) pb(dp_const pla) (dp_const plb) (ds_const' (sq_GGGG (eissect _ _)^ (eissect _ _)^ (eissect _ _)^ (eissect _ _)^ ps))))).Admitted.*)

--- Miscellaneous\TorusEquivCircles.html ---
TorusEquivCirclesLibrary TorusEquivCirclesRequireImportBasicsTypes.RequireImportCubical.DPathCubical.PathSquareCubical.DPathSquareCubical.PathCubeCubical.DPathCube.RequireImportSpaces.CircleSpaces.Torus.Torus.In this file we prove that the torus is equivalent to the product of two circles.Here is a cube filler for help with circle recursion into the torusDefinitionc2t_square_and_cube: {s:PathSquareloop_aloop_a(ap(Circle_rec_tbaseloop_b)loop)(ap(Circle_rec_tbaseloop_b)loop)&PathCubessurfhrhr(sq_G1(Circle_rec_beta_loop___))(sq_G1(Circle_rec_beta_loop___))}.Proof.applycu_fill_left.Defined.We define the map from the Torus to the CirclesDefinitiont2c:Torus->Circle*Circle.Proof.snrapplyTorus_rec.+exact(base,base).(* The point of the torus is taken to (base, base *)+exact(path_prod'loop1).(* loop_a is taken to loop in the first *)+exact(path_prod'1loop).(* loop_b is taken to loop in the second *)+exact(sq_prod(hr,vr)).(* The square is the obvious product of squares *)Defined.We now define the curried function from the circles to the torus.  TODO: It's easy to removeFunextfrom this definition by usingintroandrevertappropriately, but then the cube algebra in the proof ofc2t'_betawould need to be updated. See https://github.com/HoTT/Coq-HoTT/pull/1824.Definitionc2t'`{Funext} :Circle->Circle->Torus.Proof.snrapplyCircle_rec.+snrapplyCircle_rec.(* Double circle recursion *)-exacttbase.(* The basepoint is sent to the point of the torus *)-exactloop_b.(* The second loop is sent to loop_b *)+applypath_forall.(* We use function extensionality here to induct *)snrapplyCircle_ind.(* Circle induction as a DPath *)-exactloop_a.(* The first loop is sent to loop_a *)-srapplysq_dp^-1.(* This DPath is actually a square *)apply(pr1c2t_square_and_cube).(* We apply the cap we found above *)Defined.Here is the uncurried versionDefinitionc2t`{Funext} :Circle*Circle->Torus.Proof.applyuncurry,c2t'.Defined.Computation rules for c2t' as a cube fillerDefinitionc2t'_beta`{Funext} :{bl1:PathSquare(ap(funy=>c2t'basey)loop)loop_b1 1 &{bl2:PathSquare(ap(funx=>c2t'xbase)loop)loop_a1 1 &PathCube(sq_ap011c2t'looploop)surfbl2bl2bl1bl1}}.Proof.nrefine(_;_;_).unfoldsq_ap011.(* 1. Unfusing ap *)nrefine(cu_concat_lr(cu_ds(dp_apD_nat(funy=>ap_compose_(funf=>fy)_)_))_(sji0:=?[X1]) (sji1:=?X1) (sj0i:=?[Y1]) (sj1i:=?Y1) (pj11:=1)).(* 2. Reducing c2t' on loop *)nrefine(cu_concat_lr(cu_ds(dp_apD_nat(funx=>ap_apply_l__@apD10(ap_(Circle_rec_beta_loop___))x)_))_(sji0:=?[X2]) (sji1:=?X2) (sj0i:=?[Y2]) (sj1i:=?Y2) (pj11:=1)).(* 3. Reducing ap10 on function extensionality *)nrefine(cu_concat_lr(cu_ds(dp_apD_nat(ap10_path_forall___)_))_(sji0:=?[X3]) (sji1:=?X3) (sj0i:=?[Y3]) (sj1i:=?Y3) (pj11:=1)).(* 4. Reducing Circle_ind on loop *)nrefine(cu_concat_lr(cu_G11(ap_(Circle_ind_beta_loop___)))_(sji0:=?[X4]) (sji1:=?X4) (sj0i:=?[Y4]) (sj1i:=?Y4) (pj11:=1)).(* 5. collapsing equivalence *)nrefine(cu_concat_lr(cu_G11(eisretr__))_(sji0:=?[X5]) (sji1:=?X5) (sj0i:=?[Y5]) (sj1i:=?Y5) (pj11:=1)).(* 6. filling the cube *)applyc2t_square_and_cube.2.Defined.Local OpenScopepath_scope.Local OpenScopecube_scope.We now prove that t2c is a section of c2tDefinitiont2c2t`{Funext} :c2tot2c==idmap.Proof.(* We start with Torus induction *)nrefine(Torus_ind_1___).(* Our DPathSquare is really just a cube *)applycu_ds^-1.(* We pretend that our sides have sq_dpath o sq_dpath^-1and get rid of them *)refine(cu_GGGGcc(eisretr__)^ (eisretr__)^(eisretr__)^ (eisretr__)^_).(* Apply a symmetry to get the faces on the right side *)applycu_rot_tb_fb.(* Clean up other faces *)refine(cu_ccGGGG(eisretr__)^ (eisretr__)^(eisretr__)^ (eisretr__)^_).(* Now we finish the proof with the following composition of cubes *)nrefine((sq_ap_composet2cc2tsurf)@lr(cu_apc2t(Torus_rec_beta_surf_____))@lr(sq_ap_uncurry___)@lr(pr2(pr2c2t'_beta))@lr(cu_flip_lr(sq_ap_idmap_))).Defined.(* NOTE: The last step in the previous proof can be done as a sequence ofrefines however coq really struggles to unify this. Below is the originalway we proved the last statement before making it short and sweet. As canbe seen, we need to give refine hints using existential variables which istedious to write out, and perhaps motivates why we wrote it as one bigconcatenation. Ideally the way below should be as smooth as the way above,since above is difficult to write directly without having tried below.(* Now we decompose the cube with middle sq_ap_compose *)(* Note: coq sucks at unifying this so we have to explicitly give paths *)refine (cu_concat_lr (sq_ap_compose t2c c2t surf) _(sji0:=?X1) (sji1:=?X1) (sj0i:=?Y1) (sj1i:=?Y1) (pj11:=1)).(* Now we reduce (sq_ap t2c surf) *)refine (cu_concat_lr (cu_ap c2t (Torus_rec_beta_surf _ _ _ _ _ )) _(sji0:=?X2) (sji1:=?X2) (sj0i:=?Y2) (sj1i:=?Y2) (pj11:=1)).(* We now uncurry c2t inside sq_ap *)refine (cu_concat_lr (sq_ap_uncurry _ _ _) _(sji0:=?X3) (sji1:=?X3) (sj0i:=?Y3) (sj1i:=?Y3) (pj11:=1)).(* Reduce sq_ap2 c2t' loop loop *)refine (cu_concat_lr (pr2 (pr2 c2t'_beta)) _(sji0:=?X4) (sji1:=?X4) (sj0i:=?Y4) (sj1i:=?Y4) (pj11:=1)).(* Finally flip and sq_ap idmap *)refine (cu_flip_lr (sq_ap_idmap _)).*)Local Notationapcs:= (ap_compose_sq___).Definitionsq_ap011_compose{ABCD:Type} (f:A->B->C) (g:C->D){aa':A} (p:a=a') {bb':B} (q:b=b'):PathCube(sq_ap011(funxy=>g(fxy))pq) (sq_apg(sq_ap011fpq))apcsapcsapcsapcs.Proof.bydestructp,q.Defined.We now prove t2c is a retraction of c2tDefinitionc2t2c`{Funext} :t2coc2t==idmap.Proof.nrapplyprod_ind.(* Start with double circle induction *)snrefine(Circle_ind_(Circle_ind_1_)_).(* Change the second loop case into a square and shelve *)1:applysq_dp^-1,sq_tr^-1;shelve.(* Take the forall out of the DPath *)applydp_forall_domain.introx;applysq_dp^-1;revertx.snrefine(Circle_ind___).1:applysq_tr^-1;shelve.applydp_cu.nrefine(cu_ccGGcc___).1,2:nrefine(apsq_dp(Circle_ind_beta_loop___)@eisretr__)^.applycu_rot_tb_fb.nrefine(cu_ccGGGG_____).1,2,3,4:exact(eisretr__)^.nrefine((sq_ap011_composec2t't2clooploop)@lr(cu_apt2c(c2t'_beta.2.2))@lr(Torus_rec_beta_surf_____)@lr(cu_flip_lr(sq_ap_idmap_))@lr(sq_ap_uncurry___)).Defined.(* refine (cu_concat_lr (sq_ap2_compose c2t' t2c loop loop) _(sji0:=?X1) (sji1:=?X1) (sj0i:=?Y1) (sj1i:=?Y1) (pj11:=1)).refine (cu_concat_lr (cu_ap t2c (c2t'_beta.2.2)) _(sji0:=?X2) (sji1:=?X2) (sj0i:=?Y2) (sj1i:=?Y2) (pj11:=1)).refine (cu_concat_lr (Torus_rec_beta_surf _ _ _ _ _) _(sji0:=?X3) (sji1:=?X3) (sj0i:=?Y3) (sj1i:=?Y3) (pj11:=1)).refine (cu_concat_lr (cu_flip_lr (sq_ap_idmap _)) _(sji0:=?X4) (sji1:=?X4) (sj0i:=?Y4) (sj1i:=?Y4) (pj11:=1)).apply sq_ap_uncurry. *)Definitionequiv_torus_prod_Circle`{Funext} :Torus<~>Circle*Circle:=equiv_adjointifyt2cc2tc2t2ct2c2t.

--- Miscellaneous\TorusHomotopy.html ---
TorusHomotopyLibrary TorusHomotopyRequireImportBasicsTypes.RequireImportPointedWildCat.RequireImportModalities.ReflectiveSubuniverseTruncations.Core.RequireImportAlgebra.AbGroups.RequireImportHomotopy.HomotopyGroup.RequireImportHomotopy.PinSn.RequireImportSpaces.IntSpaces.Circle.RequireImportSpaces.Torus.Torus.RequireImportSpaces.Torus.TorusEquivCircles.Local OpenScopetrunc_scope.Local OpenScopepointed_scope.Fundamental group of the torus .The torus is 1-truncatedGlobal Instanceis1type_torus`{Univalence} :IsTrunc1Torus.Proof.refine(istrunc_equiv_istrunc_equiv_torus_prod_Circle^-1).Qed.The torus is 0-connectedGlobal Instanceisconnected_torus`{Univalence} :IsConnected0Torus.Proof.srapply(isconnected_equiv'__equiv_torus_prod_Circle^-1).srapply(isconnected_equiv'__(equiv_sigma_prod0__)).Qed.We give these notations for the pointed versions.Local NotationT:= ([Torus,_]).Local NotationS1:= ([Circle,_]).A pointed version of the equivalence from TorusEquivCircles.v.  TODO: IfFunextis removed from there, remove it from here as well.Lemmapequiv_torus_prod_circles`{Funext} :T<~>*S1*S1.Proof.srapplyBuild_pEquiv'.1:applyequiv_torus_prod_Circle.reflexivity.Defined.Fundamental group of torusTheorempi1_torus`{Univalence}:GroupIsomorphism(Pi1T) (grp_prodabgroup_Zabgroup_Z).Proof.etransitivity.1:exact(emap(Pi1)pequiv_torus_prod_circles).etransitivity.1:applygrp_iso_pi_prod.applygrp_iso_prod.1,2:applypi1_circle.Defined.Loop space of torusTheoremloops_torus`{Univalence} :loopsT<~>*Int*Int.Proof.(* SinceTis 1-truncated,loopsTis 0-truncated, and is therefore equivalent to its 0-truncation. *)refine(_o*Epequiv_ptr(n:=0)).nrapplypi1_torus.Defined.

--- Miscellaneous\ToSet.html ---
ToSetLibrary ToSetGrothendieck Construction of a functor to SetWe want to have the following as subdirectories/modules, not at top level.  Unfortunately, namespacing in Coq is kind-of broken (see, e.g., https://coq.inria.fr/bugs/show_bug.cgi?id=3676), so we don't get the ability to rename subfolders byIncludinginto other modules.constructionRequireGrothendieck.ToSet.Core.classification of morphismsRequireGrothendieck.ToSet.Morphisms.preservation of saturationRequireGrothendieck.ToSet.Univalent.IncludeGrothendieck.ToSet.Core.

--- Miscellaneous\TriJoin.html ---
TriJoinLibrary TriJoinRequireImportBasicsTypes.PathsWildCatJoin.CoreHoTT.Tactics.Induction and recursion principles for the triple joinWe show that the triple join satisfies symmetrical induction and recursion principles and prove that the recursion principle gives an equivalence of 0-groupoids.  We use this in JoinAssoc.v to prove that the join is associative.  Our approach parallels what is done in the two-variable case in Join/Core.v, especially starting withTriJoinRecDatahere andJoinRecDatathere.  That case is much simpler, so should be read first.SectionTriJoinStructure.Context{ABC:Type}.DefinitionTriJoin:=JoinA(JoinBC).Definitionjoin1:A->TriJoin:=joinl.Definitionjoin2:B->TriJoin:=funb=> (joinr(joinlb)).Definitionjoin3:C->TriJoin:=func=> (joinr(joinrc)).Definitionjoin12:forallab,join1a=join2b:=funab=>jgluea(joinlb).Definitionjoin13:forallac,join1a=join3c:=funac=>jgluea(joinrc).Definitionjoin23:forallbc,join2b=join3c:=funbc=>apjoinr(jgluebc).Definitionjoin123:forallabc,join12ab@join23bc=join13ac:=funabc=>triangle_va(jgluebc).EndTriJoinStructure.ArgumentsTriJoinABC:clearimplicits.ap_trijoinandap_trijoin_transportFunctions send triangles to triangles.Definitionap_triangle{XY} (f:X->Y){abc:X} {ab:a=b} {bc:b=c} {ac:a=c} (abc:ab@bc=ac):apfab@apfbc=apfac:= (ap_ppfabbc)^ @ap(apf)abc.This general result abstracts away the situation whereJisTriJoinABC,aisjoinla'for somea',jrisjoinr:JoinBC->J,jgisfunw=>jgluea'w, andpisjgluebc.  By working in this generality, we can do induction onp.  This also allows us to inline the proof oftriangle_v.Definitionap_trijoin_general{JWP:Type} (f:J->P)(a:J) (jr:W->J) (jg:forallw,a=jrw){bc:W} (p:b=c):apf(jgb) @apf(apjrp) =apf(jgc).Proof.applyap_triangle.inductionp.applyconcat_p1.Defined.Functions send the canonical triangles in triple joins to triangles.Definitionap_trijoin{ABCP:Type} (f:TriJoinABC->P)(a:A) (b:B) (c:C):apf(join12ab) @apf(join23bc) =apf(join13ac).Proof.nrapplyap_trijoin_general.Defined.Definitionap_trijoin_general_transport{JWP:Type} (f:J->P)(a:J) (jr:W->J) (jg:forallw,a=jrw){bc:W} (p:b=c):ap_trijoin_generalfajrjgp= (1 @@ap_compose_f_)^ @ (transport_paths_Fr__)^ @apD(funx=>apf(jgx))p.Proof.inductionp.unfoldap_trijoin_general;simpl.induction(jgb).reflexivity.Defined.Definitionap_trijoin_transport{ABCP:Type} (f:TriJoinABC->P)(a:A) (b:B) (c:C):ap_trijoinfabc= (1 @@ap_compose_f_)^ @ (transport_paths_Fr__)^ @apD(funx=>apf(jglueax)) (jgluebc).Proof.nrapplyap_trijoin_general_transport.Defined.Definitionap_trijoin_general_V{JWP:Type} (f:J->P)(a:J) (jr:W->J) (jg:forallw,a=jrw){bc:W} (p:b=c):ap_trijoin_generalfajrjgp^= (1 @@ (ap(apf) (ap_Vjrp) @ap_Vf_)) @moveR_pV___(ap_trijoin_generalfajrjgp)^.Proof.inductionp.unfoldap_trijoin_general;cbn.byinduction(jgb).Defined.Definitionap_trijoin_V{ABCP:Type} (f:TriJoinABC->P)(a:A) (b:B) (c:C):ap_trianglef(triangle_va(jgluebc)^)= (1 @@ (ap(apf) (ap_Vjoinr_) @ap_Vf_)) @moveR_pV___(ap_trijoinfabc)^.Proof.nrapplyap_trijoin_general_V.Defined.The induction principle for the triple joinA lemma that handles the path algebra in the final step.Local Definitiontrijoin_ind_helper{ABC:Type} (P:JoinABC->Type)(a:A) (bc:BC) (bc:b=c)(j1':P(joinla)) (j2':P(joinrb)) (j3':P(joinrc))(j12':jglueab#j1'=j2') (j13':jglueac#j1'=j3') (j23': (apjoinrbc) #j2'=j3')(j123':transport_pp_(jglueab) (apjoinrbc)j1'@ap(transport_(apjoinrbc))j12'@j23'=transport2_(triangle_vabc)_@j13'): ((apD(funx:BC=>transportP(jglueax)j1')bc)^@ap(transport(funx:BC=>P(joinrx))bc)j12')@ ((transport_composePjoinrbcj2') @j23') =j13'.Proof.inductionbc;simpl.rewritetransport_pp_1inj123'.cbnin*.unfoldtransport;unfoldtransportinj123'.rewriteap_idmap;rewriteap_idmapinj123'.rewriteconcat_pp_pinj123'.applycancelLinj123'.rewrite2concat_1p.exactj123'.Qed.An induction principle for the triple join. Note that the hypotheses are phrased completely in terms of the "constructors" ofTriJoinABC.Definitiontrijoin_ind(ABC:Type) (P:TriJoinABC->Type)(join1':foralla,P(join1a))(join2':forallb,P(join2b))(join3':forallc,P(join3c))(join12':forallab,join12ab#join1'a=join2'b)(join13':forallac,join13ac#join1'a=join3'c)(join23':forallbc,join23bc#join2'b=join3'c)(join123':forallabc,transport_pp_(join12ab) (join23bc) (join1'a)@ap(transport_(join23bc)) (join12'ab) @join23'bc=transport2_(join123abc)_@join13'ac):forallx,Px.Proof.snrapplyJoin_ind.-exactjoin1'.-snrapplyJoin_ind.+exactjoin2'.+exactjoin3'.+introsbc.lhsrapply(transport_composeP).applyjoin23'.-introa.snrapplyJoin_ind.+simpl.exact(join12'a).+simpl.exact(join13'a).+introsbc;cbnbetazeta.lhsnrapply(transport_paths_FlFr_D(jgluebc)).lhsnrapply(1 @@_).1:nrapplyJoin_ind_beta_jglue.applytrijoin_ind_helper,join123'.Defined.The recursion principle for the triple join, and many results about itWe'll bundle up the arguments into a record.RecordTriJoinRecData{ABCP:Type} := {j1:A->P;j2:B->P;j3:C->P;j12:forallab,j1a=j2b;j13:forallac,j1a=j3c;j23:forallbc,j2b=j3c;j123:forallabc,j12ab@j23bc=j13ac;}.ArgumentsTriJoinRecData:clearimplicits.ArgumentsBuild_TriJoinRecData{ABCP}%_type_scope(j1j2j3j12j13j23j123)%_function_scope.Definitiontrijoin_rec{ABCP:Type} (f:TriJoinRecDataABCP):TriJoinABC$->P.Proof.snrapplyJoin_rec.-exact(j1f).-snrapplyJoin_rec.+exact(j2f).+exact(j3f).+exact(j23f).-introa.snrapplyJoin_ind;cbnbeta.+exact(j12fa).+exact(j13fa).+introsbc.lhsnrapplytransport_paths_Fr.exact(1 @@Join_rec_beta_jglue_____@j123fabc).Defined.Beta rules for the recursion principle.Definitiontrijoin_rec_beta_join12{ABCP:Type} (f:TriJoinRecDataABCP) (a:A) (b:B):ap(trijoin_recf) (join12ab) =j12fab:=Join_rec_beta_jglue_____.Definitiontrijoin_rec_beta_join13{ABCP:Type} (f:TriJoinRecDataABCP) (a:A) (c:C):ap(trijoin_recf) (join13ac) =j13fac:=Join_rec_beta_jglue_____.Definitiontrijoin_rec_beta_join23{ABCP:Type} (f:TriJoinRecDataABCP) (b:B) (c:C):ap(trijoin_recf) (join23bc) =j23fbc.Proof.unfoldtrijoin_rec,join23.lhs_Vnrapply(ap_composejoinr);simpl.applyJoin_rec_beta_jglue.Defined.Local Lemmatrijoin_rec_beta_join123_helper{A:Type} {xyz:A}{u0u1:x=y} {p0p1r1:y=z} {q0s1t1:x=z}(p:p0=p1) (q:q0=u0@p0) (r:p0=r1)(s:u1@r1=s1) (t:s1=t1) (u:u0=u1): ((1 @@p)^ @q^) @ (((q@ (u@@ 1)) @ ((1 @@r) @s)) @t)= ((u@@ (p^ @r)) @s) @t.Proof.inductionu,t,s,r,p.revertq0q;byapplypaths_ind_r.Defined.Definitiontrijoin_rec_beta_join123{ABCP:Type} (f:TriJoinRecDataABCP)(a:A) (b:B) (c:C):ap_trijoin(trijoin_recf)abc= (trijoin_rec_beta_join12fab@@trijoin_rec_beta_join23fbc)@j123fabc@ (trijoin_rec_beta_join13fac)^.Proof.(* Expand the LHS: *)lhsnrapplyap_trijoin_transport.rewrite(apD_homotopic(Join_rec_beta_jglue____) (jgluebc)).rewriteJoin_ind_beta_jglue.(* Changeap(transport__)_on LHS. *)rewrite(concat_p_pp_(transport_paths_Fr(jgluebc) (j12fab))_).rewrite(concat_Ap(transport_paths_Fr(jgluebc))).(* Everything that remains is pure path algebra. *)(*trijoin_rec_beta_join23expands to something of the formp^@r, so that's what is in the lemma.  One can unfold it to see this, but theQedis a bit faster without this: *)(* unfold trijoin_rec_beta_join23. *)(* Note that one of theaps on the LHS computes tou@@1, so that's what is in the lemma: *)(* change (ap (fun q => q @ ?x) ?u) with (u @@ @idpath _ x). *)nrapplytrijoin_rec_beta_join123_helper.Qed.We're next going to define a map in the other direction.  We do it via showing thatTriJoinRecDatais a 0-coherent 1-functor toType. We'll later show that it is a 1-functor to 0-groupoids.Definitiontrijoinrecdata_fun{ABCPQ:Type} (g:P->Q) (f:TriJoinRecDataABCP):TriJoinRecDataABCQ.Proof.snrapplyBuild_TriJoinRecData.-exact(goj1f).-exact(goj2f).-exact(goj3f).-exact(funab=>apg(j12fab)).-exact(funac=>apg(j13fac)).-exact(funbc=>apg(j23fbc)).-introsabc;cbnbeta.exact(ap_triangleg(j123fabc)).(* The last four goals above can also be handled by the induction tactics below, but it's useful to be concrete. *)Defined.The triple join itself has canonicalTriJoinRecData.Definitiontrijoinrecdata_trijoin(ABC:Type):TriJoinRecDataABC(JoinA(JoinBC)):=Build_TriJoinRecDatajoin1join2join3join12join13join23join123.Combining these gives a function going in the opposite direction totrijoin_rec.Definitiontrijoin_rec_inv{ABCP:Type} (f:TriJoinABC->P):TriJoinRecDataABCP:=trijoinrecdata_funf(trijoinrecdata_trijoinABC).UnderFunext,trijoin_recandtrijoin_rec_invshould be inverse equivalences.  We'll avoidFunextand show that they are equivalences of 0-groupoids, where we choose the path structures carefully.The graph structure onTriJoinRecDataABCPThe type of fillers for a triangular prism with five 2d facesabc,abc',k12,k13,k23.Definitionprism{P:Type}{abc:P} {ab:a=b} {ac:a=c} {bc:b=c} (abc:ab@bc=ac){a'b'c':P} {ab':a'=b'} {ac':a'=c'} {bc':b'=c'} (abc':ab'@bc'=ac'){k1:a=a'} {k2:b=b'} {k3:c=c'}(k12:ab@k2=k1@ab') (k13:ac@k3=k1@ac') (k23:bc@k3=k2@bc'):=concat_p_pp___@whiskerRabck3@k13=whiskerLabk23@concat_p_pp___@whiskerRk12bc'@concat_pp_p___@whiskerLk1abc'.The "identity" filler is slightly non-trivial, because the fillers for the squares, e.g.ab@1=1@ab, must be non-trivial.Definitionprism_id{P:Type}{abc:P} {ab:a=b} {ac:a=c} {bc:b=c} (abc:ab@bc=ac):prismabcabc(equiv_p1_1qidpath) (equiv_p1_1qidpath) (equiv_p1_1qidpath).Proof.inductionab,bc,abc;simpl.reflexivity.Defined.The paths between elements ofTriJoinRecDataABCP.  UnderFunext, this type will be equivalent to the identity type.  But withoutFunext, this definition will be more useful.RecordTriJoinRecPath{ABCP:Type} {fg:TriJoinRecDataABCP} := {h1:foralla,j1fa=j1ga;h2:forallb,j2fb=j2gb;h3:forallc,j3fc=j3gc;h12:forallab,j12fab@h2b=h1a@j12gab;h13:forallac,j13fac@h3c=h1a@j13gac;h23:forallbc,j23fbc@h3c=h2b@j23gbc;h123:forallabc,prism(j123fabc) (j123gabc) (h12ab) (h13ac) (h23bc);}.ArgumentsTriJoinRecPath{ABCP}fg.We also define data fortrijoin_recthat unbundles the first three components.  This lets us talk about paths between two such when the first three components are definitionally equal. This is a common special case, and this set-up greatly simplifies a lot of path algebra in later proofs.RecordTriJoinRecData'{ABCP:Type} {j1':A->P} {j2':B->P} {j3':C->P} := {j12':forallab,j1'a=j2'b;j13':forallac,j1'a=j3'c;j23':forallbc,j2'b=j3'c;j123':forallabc,j12'ab@j23'bc=j13'ac;}.ArgumentsTriJoinRecData'{ABCP}j1'j2'j3'.ArgumentsBuild_TriJoinRecData'{ABCP}%_type_scope(j1'j2'j3'j12'j13'j23'j123')%_function_scope.Definitionprism'{P:Type} {abc:P}{ab:a=b} {ac:a=c} {bc:b=c} (abc:ab@bc=ac){ab':a=b} {ac':a=c} {bc':b=c} (abc':ab'@bc'=ac')(k12:ab=ab') (k13:ac=ac') (k23:bc=bc'):=abc@k13= (k12@@k23) @abc'.RecordTriJoinRecPath'{ABCP:Type} {j1':A->P} {j2':B->P} {j3':C->P}{fg:TriJoinRecData'j1'j2'j3'} := {h12':forallab,j12'fab=j12'gab;h13':forallac,j13'fac=j13'gac;h23':forallbc,j23'fbc=j23'gbc;h123':forallabc,prism'(j123'fabc) (j123'gabc) (h12'ab) (h13'ac) (h23'bc);}.ArgumentsTriJoinRecPath'{ABCP} {j1'j2'j3'}fg.We can bundle and unbundle these types of data.  For unbundling, we just handleTriJoinRecDatafor now.Definitionbundle_trijoinrecdata{ABCP:Type} {j1':A->P} {j2':B->P} {j3':C->P}(f:TriJoinRecData'j1'j2'j3'):TriJoinRecDataABCP:=Build_TriJoinRecDataj1'j2'j3'(j12'f) (j13'f) (j23'f) (j123'f).Definitionunbundle_trijoinrecdata{ABCP:Type} (f:TriJoinRecDataABCP):TriJoinRecData'(j1f) (j2f) (j3f):=Build_TriJoinRecData'(j1f) (j2f) (j3f) (j12f) (j13f) (j23f) (j123f).The proof by induction that is easily available to us here is what saves work in more complicated contexts.Definitionbundle_prism{P:Type} {abc:P}{ab:a=b} {ac:a=c} {bc:b=c} (abc:ab@bc=ac){ab':a=b} {ac':a=c} {bc':b=c} (abc':ab'@bc'=ac')(k12:ab=ab') (k13:ac=ac') (k23:bc=bc')(k123:prism'abcabc'k12k13k23):prismabcabc'(equiv_p1_1qk12) (equiv_p1_1qk13) (equiv_p1_1qk23).Proof.inductionab.inductionbc.inductionabc.inductionk12.inductionk23.inductionk13.unfoldprism'ink123.induction(moveR_Vp___k123);cleark123.simpl.reflexivity.Defined.Definitionbundle_trijoinrecpath{ABCP:Type} {j1':A->P} {j2':B->P} {j3':C->P}{fg:TriJoinRecData'j1'j2'j3'} (h:TriJoinRecPath'fg):TriJoinRecPath(bundle_trijoinrecdataf) (bundle_trijoinrecdatag).Proof.snrapplyBuild_TriJoinRecPath.1, 2, 3:reflexivity.1, 2, 3:intros;applyequiv_p1_1q.-apply(h12'h).-apply(h13'h).-apply(h23'h).-cbnbetazeta.introsabc.applybundle_prism, (h123'h).Defined.A tactic that helps us apply the previous result.Ltacbundle_trijoinrecpath:=hnf;matchgoalwith|-TriJoinRecPath?F?G=>refine(bundle_trijoinrecpath(f:=unbundle_trijoinrecdataF)(g:=unbundle_trijoinrecdataG)_)end;snrapplyBuild_TriJoinRecPath'.Using these paths, we can restate the beta rule fortrijoin_rec.  The statement usingTriJoinRecPath'typechecks only becausetrijoin_reccomputes definitionally on the path constructors.Definitiontrijoin_rec_beta'{ABCP:Type} (f:TriJoinRecDataABCP):TriJoinRecPath'(unbundle_trijoinrecdata(trijoin_rec_inv(trijoin_recf)))(unbundle_trijoinrecdataf).Proof.snrapplyBuild_TriJoinRecPath';cbn.-applytrijoin_rec_beta_join12.-applytrijoin_rec_beta_join13.-applytrijoin_rec_beta_join23.-introsabc.unfoldprism'.applymoveR_pM.nrapplytrijoin_rec_beta_join123.Defined.We can upgrade this to an unprimed path. This says thattrijoin_rec_invis split surjective.Definitiontrijoin_rec_beta{ABCP:Type} (f:TriJoinRecDataABCP):TriJoinRecPath(trijoin_rec_inv(trijoin_recf))f:=bundle_trijoinrecpath(trijoin_rec_beta'f).trijoin_rec_invis an injective map between 0-groupoidsWe begin with a general purpose lemma.Definitiontriangle_ind{P:Type} (a:P)(Q:forall(bc:P) (ab:a=b) (ac:a=c) (bc:b=c) (abc:ab@bc=ac),Type)(s:Qaaidpathidpathidpathidpath):forallbcabacbcabc,Qbcabacbcabc.Proof.intros.inductionab.inductionbc.inductionabc.applys.Defined.This lemma handles the path algebra in the last goal of the next result.Local Definitionisinj_trijoin_rec_inv_helper{JP:Type} {fg:J->P}{abc:J} {ab:a=b} {ac:a=c} {bc:b=c} {abc:ab@bc=ac}{H1:fa=ga} {H2:fb=gb} {H3:fc=gc}{H12:apfab@H2=H1@apgab}{H13:apfac@H3=H1@apgac}{H23:apfbc@H3=H2@apgbc}(H123:prism(ap_trianglefabc) (ap_trianglegabc)H12H13H23): (transport_pp(funx=>fx=gx)abbcH1@ap(transport(funx=>fx=gx)bc)(transport_paths_FlFr'abH1H2H12)) @transport_paths_FlFr'bcH2H3H23=transport2(funx=>fx=gx)abcH1@transport_paths_FlFr'acH1H3H13.Proof.revertbcabacbcabcH2H3H12H13H23H123.nrapplytriangle_ind;cbn.unfoldap_triangle,transport_paths_FlFr',transport;cbn-[concat_pp_p].generalizedependent(fa);introfa;clearf.generalizedependent(ga);introga;clearga.introsH1H2H3H12H13H23.rewriteap_idmap.revertH12;equiv_intro(equiv_1p_q1(p:=H2) (q:=H1))H12';inductionH12'.revertH13;equiv_intro(equiv_1p_q1(p:=H3) (q:=H2))H13';inductionH13'.inductionH3.introH123.unfoldprisminH123.rewritewhiskerL_1p_1inH123.cbnin*.rewrite!concat_p1inH123.inductionH123.reflexivity.Qed.trijoin_rec_invis essentially injective, as a map between 0-groupoids.Definitionisinj_trijoin_rec_inv{ABCP:Type} {fg:TriJoinABC->P}(h:TriJoinRecPath(trijoin_rec_invf) (trijoin_rec_invg)):f==g.Proof.snrapplytrijoin_ind.1:apply(h1h).1:apply(h2h).1:apply(h3h).1, 2, 3:intros;nrapplytransport_paths_FlFr'.1:apply(h12h).1:apply(h13h).1:apply(h23h).introsabc;cbnbeta.applyisinj_trijoin_rec_inv_helper.exact(h123habc).Defined.Lemmas and tactics about triangles and prismsWe now introduce several lemmas and tactics that will dispense with some routine goals. The idea is that a generic triangle can be assumed to be trivial on the first vertex, and a generic prism can be assumed to be the identity on the domain. In order to apply thetriangle_indandprism_indlemmas that make this precise, we need to generalize various terms in the goal.This destructs a seven component termf, tries to generalize each piece evaluated appropriately, and clears all pieces.  If called witha,bandcall valid terms, we expect all seven components to be generalized.  But one can also call it with one ofa,bandca dummy value (e.g._X_) that causes four of thegeneralizetactics to fail.  In this case, four components will be simply cleared, and three will be generalized and cleared, so this applies when the goal only depends on three of the seven components.Ltacgeneralize_somefabc:=letf1:=freshinletf2:=freshinletf3:=freshinletf12:=freshinletf13:=freshinletf23:=freshinletf123:=freshindestructfas[f1f2f3f12f13f23f123];cbn;trygeneralize(f123abc);clearf123;trygeneralize(f23bc);clearf23;trygeneralize(f13ac);clearf13;trygeneralize(f12ab);clearf12;trygeneralize(f3c);clearf3;trygeneralize(f2b);clearf2;trygeneralize(f1a);clearf1.(* No easy way to skip the "last" one, since we don't know which will be the last to be generalized. *)Use this withf:TriJoinRecDataABCP,a:A,b:B,c:C.Ltactriangle_indfabc:=generalize_somefabc;introf;(*generalize_somegoes one step too far, so intro the last variable. *)applytriangle_ind.Use this withf:TriJoinRecDataABCP. Two of the argumentsa,bandcshould be elements ofA,BandC, respectively, and the third should be a dummy value (e.g._X_) that causes the generalize tactic to fail.  It applies to goals that only depend on the components offinvolving just two ofA,BandC.Ltactriangle_ind_twofabc:=generalize_somefabc;introf;(*generalize_somegoes one step too far, so intro the last variable. *)applypaths_ind.The prism analog of the functiontriangle_indfrom earlier in the file. To prove something about all prisms, it's enough to prove it for the "identity" prism.  Note that we don't specialize to a prism concentrated on a single vertex, since sometimes we have to deal with a composite of two prisms.Definitionprism_ind{P:Type} (abc:P) (ab:a=b) (ac:a=c) (bc:b=c) (abc:ab@bc=ac)(Q:forall(a'b'c':P) (ab':a'=b') (ac':a'=c') (bc':b'=c') (abc':ab'@bc'=ac')(k1:a=a') (k2:b=b') (k3:c=c')(k12:ab@k2=k1@ab') (k13:ac@k3=k1@ac') (k23:bc@k3=k2@bc')(k123:prismabcabc'k12k13k23),Type)(s:Qabcabacbcabcidpathidpathidpath(equiv_p1_1qidpath) (equiv_p1_1qidpath) (equiv_p1_1qidpath) (prism_idabc)):foralla'b'c'ab'ac'bc'abc'k1k2k3k12k13k23k123,Qa'b'c'ab'ac'bc'abc'k1k2k3k12k13k23k123.Proof.intros.inductionk1,k2,k3.revertk123.revertk12;equiv_intro(equiv_p1_1q(p:=ab) (q:=ab'))k12';inductionk12'.revertk13;equiv_intro(equiv_p1_1q(p:=ac) (q:=ac'))k13';inductionk13'.revertk23;equiv_intro(equiv_p1_1q(p:=bc) (q:=bc'))k23';inductionk23'.inductionab,bc,abc;simplin*.unfoldprism;simpl.equiv_intro(equiv_concat_r(concat_1p(whiskerL1abc') @whiskerL_1p_1abc')^idpath)k123'.inductionk123'.simpl.exacts.Defined.Use this withfg:TriJoinRecDataABCP,h:TriJoinRecPathfg(sogis the *co*domain ofh),a:A,b:B,c:C.Ltacprism_indghabc:=generalize_somehabc;generalize_somegabc;applyprism_ind.Use this withfg:TriJoinRecDataABCP,h:TriJoinRecPathfg(sogis the *co*domain ofh).  Two of the argumentsa,bandcshould be elements ofA,BandC, respectively, and the third should be a dummy value (e.g._X_) that causes the generalize tactic to fail.  It applies to goals that only depend on the components ofgandhinvolving just two ofA,BandC. So it is dealing with one square face of the prism.Ltacprism_ind_twoghabc:=generalize_somehabc;generalize_somegabc;applysquare_ind.(* From Join/Core.v *)Use the WildCat library to organize thingsWe begin by showing thatTriJoinRecDataABCPis a 0-groupoid, one piece at a time.Global Instanceisgraph_trijoinrecdata(ABCP:Type) :IsGraph(TriJoinRecDataABCP):= {|Hom:=TriJoinRecPath|}.Global Instanceis01cat_trijoinrecdata(ABCP:Type) :Is01Cat(TriJoinRecDataABCP).Proof.applyBuild_Is01Cat.-introf.bundle_trijoinrecpath.1, 2, 3:reflexivity.introsabc;cbnbeta.(* Can finish with:bytriangle_indfabc.*)unfoldprism'.cbn.applyconcat_p1_1p.-introsf1f2f3k2k1.snrapplyBuild_TriJoinRecPath;intros;cbnbeta.+exact(h1k1a@h1k2a).+exact(h2k1b@h2k2b).+exact(h3k1c@h3k2c).+(* Some simple path algebra works as well. *)prism_ind_twof3k2ab_X_.prism_ind_twof2k1ab_X_.bytriangle_ind_twof1ab_X_.+prism_ind_twof3k2a_X_c.prism_ind_twof2k1a_X_c.bytriangle_ind_twof1a_X_c.+prism_ind_twof3k2_X_bc.prism_ind_twof2k1_X_bc.bytriangle_ind_twof1_X_bc.+cbnbeta.prism_indf3k2abc.prism_indf2k1abc.bytriangle_indf1abc.Defined.Global Instanceis0gpd_trijoinrecdata(ABCP:Type) :Is0Gpd(TriJoinRecDataABCP).Proof.applyBuild_Is0Gpd.introsfgh.snrapplyBuild_TriJoinRecPath;intros;cbnbeta.+exact(h1ha)^.+exact(h2hb)^.+exact(h3hc)^.+(* Some simple path algebra works as well. *)prism_ind_twoghab_X_.bytriangle_ind_twofab_X_.+prism_ind_twogha_X_c.bytriangle_ind_twofa_X_c.+prism_ind_twogh_X_bc.bytriangle_ind_twof_X_bc.+prism_indghabc.bytriangle_indfabc.Defined.Definitiontrijoinrecdata_0gpd(ABCP:Type) :ZeroGpd:=Build_ZeroGpd(TriJoinRecDataABCP)___.trijoinrecdata_0gpdABCis a 1-functor fromTypetoZeroGpdIt's a 1-functor that lands inZeroGpd, and the morphisms ofZeroGpdare 0-functors, so it's easy to get confused about the levels.First we need to show that the induced map is a morphism inZeroGpd, i.e. that it is a 0-functor.Global Instanceis0functor_trijoinrecdata_fun{ABCPQ:Type} (g:P->Q):Is0Functor(@trijoinrecdata_funABCPQg).Proof.applyBuild_Is0Functor.introsf1f2h.snrapplyBuild_TriJoinRecPath;intros;cbn.1, 2, 3:apply(apg).1:apply(h1h).1:apply(h2h).1:apply(h3h).1, 2, 3:refine((ap_ppg__)^ @_@ap_ppg__);apply(ap(apg)).1:apply(h12h).(* Or: prism_ind_12 f2 h a b. triangle_ind_12 f1 a b. reflexivity. *)1:apply(h13h).1:apply(h23h).prism_indf2habc.triangle_indf1abc;cbn.reflexivity.Defined.trijoinrecdata_0gpdABCis a 0-functor fromTypetoZeroGpd(one level up).Global Instanceis0functor_trijoinrecdata_0gpd(ABC:Type) :Is0Functor(trijoinrecdata_0gpdABC).Proof.applyBuild_Is0Functor.introsPQg.snrapplyBuild_Morphism_0Gpd.-exact(trijoinrecdata_fung).-applyis0functor_trijoinrecdata_fun.Defined.trijoinrecdata_0gpdABCis a 1-functor fromTypetoZeroGpd.Global Instanceis1functor_trijoinrecdata_0gpd(ABC:Type) :Is1Functor(trijoinrecdata_0gpdABC).Proof.applyBuild_Is1Functor.(* Ifg1g2:P->Qare homotopic, then the induced maps are homotopic: *)-introsPQg1g2hf;cbnin*.snrapplyBuild_TriJoinRecPath;intros;cbn.1, 2, 3:applyh.1, 2, 3:applyconcat_Ap.triangle_indfabc;cbn.byinduction(hf).(* The identity mapP->Pis sent to a map homotopic to the identity. *)-introsPf;cbn.bundle_trijoinrecpath;intros;cbn.1, 2, 3:applyap_idmap.bytriangle_indfabc.(* It respects composition. *)-introsPQRg1g2f;cbn.bundle_trijoinrecpath;intros;cbn.1, 2, 3:applyap_compose.bytriangle_indfabc.Defined.Definitiontrijoinrecdata_0gpd_fun(ABC:Type) :Fun11TypeZeroGpd:=Build_Fun11__(trijoinrecdata_0gpdABC).By the Yoneda lemma, it follows fromTriJoinRecDatabeing a 1-functor that givenTriJoinRecDatainJ, we get a map(J->P)$->(TriJoinRecDataABCP)of 0-groupoids which is natural inP. Below we will specialize to the case whereJisTriJoinABCwith the canonicalTriJoinRecData.Definitiontrijoin_nattrans_recdata{ABCJ:Type} (f:TriJoinRecDataABCJ):NatTrans(opyon_0gpdJ) (trijoinrecdata_0gpd_funABC).Proof.snrapplyBuild_NatTrans.-rapplyopyoneda_0gpd;exactf.-exact_.Defined.Thus we get a map(TriJoinABC->P)$->(TriJoinRecDataABCP)of 0-groupoids, natural inP. The underlying map istrijoin_rec_invABCP.Definitiontrijoin_rec_inv_nattrans(ABC:Type):NatTrans(opyon_0gpd(TriJoinABC)) (trijoinrecdata_0gpd_funABC):=trijoin_nattrans_recdata(trijoinrecdata_trijoinABC).This natural transformation is in fact a natural equivalence of 0-groupoids.Definitiontrijoin_rec_inv_natequiv(ABC:Type):NatEquiv(opyon_0gpd(TriJoinABC)) (trijoinrecdata_0gpd_funABC).Proof.snrapplyBuild_NatEquiv'.1:applytrijoin_rec_inv_nattrans.introP.applyisequiv_0gpd_issurjinj.applyBuild_IsSurjInj.-introsf;cbninf.exists(trijoin_recf).applytrijoin_rec_beta.-exact(@isinj_trijoin_rec_invABCP).Defined.It will be handy to name the inverse natural equivalence.Definitiontrijoin_rec_natequiv(ABC:Type):=natequiv_inverse(trijoin_rec_inv_natequivABC).trijoin_rec_natequivABCPis an equivalence of 0-groupoids whose underlying function is definitionallytrijoin_rec.Local Definitiontrijoin_rec_natequiv_check(ABCP:Type):equiv_fun_0gpd(trijoin_rec_natequivABCP) = @trijoin_recABCP:=idpath.It follows thattrijoin_recABCPis a 0-functor.Global Instanceis0functor_trijoin_rec(ABCP:Type) :Is0Functor(@trijoin_recABCP).Proof.change(Is0Functor(equiv_fun_0gpd(trijoin_rec_natequivABCP))).exact_.Defined.And thattrijoin_recABCis natural.   The$==in the statement is just==, but we use WildCat notation so that we can invert and compose these with WildCat notation.Definitiontrijoin_rec_nat(ABC:Type) {PQ:Type} (g:P->Q)(f:TriJoinRecDataABCP):trijoin_rec(trijoinrecdata_fungf) $==gotrijoin_recf.Proof.exact(isnat(trijoin_rec_natequivABC)gf).Defined.It is also useful to record this.Definitionissect_trijoin_rec_inv{ABCP:Type} (f:TriJoinABC->P):trijoin_rec(trijoin_rec_invf) $==f:=cate_issect(trijoin_rec_inv_natequivABCP)f.This comes up a lot as well, and if you inline the proof, you get an ugly goal.DefinitionmoveR_trijoin_rec{ABCP:Type} {f:TriJoinRecDataABCP} {g:TriJoinABC->P}(p:f$==trijoin_rec_invg):trijoin_recf==g.Proof.exact(moveR_equiv_V_0gpd(trijoin_rec_inv_natequivABCP)__p).Defined.Functoriality of the triple joinPrecomposition ofTriJoinRecDataFirst observe that we can precomposek:TriJoinRecDatawith a triple of maps.Definitiontrijoinrecdata_tricomp{ABCA'B'C'P} (k:TriJoinRecDataABCP)(f:A'->A) (g:B'->B) (h:C'->C):TriJoinRecDataA'B'C'P:= {|j1:=j1kof;j2:=j2kog;j3:=j3koh;j12:=funab=>j12k(fa) (gb);j13:=funac=>j13k(fa) (hc);j23:=funbc=>j23k(gb) (hc);j123:=funabc=>j123k(fa) (gb) (hc); |}.Precomposition with a triple respects paths.Definitiontrijoinrecdata_tricomp_0fun{ABCA'B'C'P}{kl:TriJoinRecDataABCP} (p:k$==l)(f:A'->A) (g:B'->B) (h:C'->C):trijoinrecdata_tricompkfgh$==trijoinrecdata_tricomplfgh.Proof.(* This line is not needed, but clarifies the proof. *)unfoldtrijoinrecdata_tricomp;destructp.snrapplyBuild_TriJoinRecPath;intros;cbn;apply_hyp.(* E.g., the first goal isj1k(fa)=j1l(fa), and this is solved byh1p(fa). We just precompose all fields ofpwithf,gandh. *)Defined.Homotopies between the triple are also respected.Definitiontrijoinrecdata_tricomp2{ABCA'B'C'P} (k:TriJoinRecDataABCP){ff':A'->A} {gg':B'->B} {hh':C'->C}(p:f==f') (q:g==g') (r:h==h'):trijoinrecdata_tricompkfgh$==trijoinrecdata_tricompkf'g'h'.Proof.snrapplyBuild_TriJoinRecPath;intros;cbn.-applyap,p.-applyap,q.-applyap,r.-induction(pa), (qb);byapplyequiv_p1_1q.-induction(pa), (rc);byapplyequiv_p1_1q.-induction(qb), (rc);byapplyequiv_p1_1q.-induction(pa), (qb), (rc);applyprism_id.Defined.Functoriality ofTriJoinviafunctor_trijoinTo definefunctor_trijoin, we simply precompose the canonicalTriJoinRecDatawithf,gandh. For example, this hasj1:=join1ofandj12:=funab=>join12(fa)(gb).Definitionfunctor_trijoin{ABCA'B'C'} (f:A->A') (g:B->B') (h:C->C'):TriJoinABC->TriJoinA'B'C':=trijoin_rec(trijoinrecdata_tricomp(trijoinrecdata_trijoinA'B'C')fgh).We usefunctor_trijointo express a partial functoriality oftrijoin_recinA,BandC.Definitiontrijoin_rec_functor_trijoin{ABCA'B'C'P} (k:TriJoinRecDataA'B'C'P)(f:A->A') (g:B->B') (h:C->C'):trijoin_reckofunctor_trijoinfgh==trijoin_rec(trijoinrecdata_tricompkfgh).Proof.(* On the LHS, we use naturality of thetrijoin_recinsidefunctor_trijoin: *)refine((trijoin_rec_nat_____)^$ $@_).refine(fmaptrijoin_rec_).(* Just to clarify to the reader what is going on: *)change(?L$-> ?R)with(trijoinrecdata_tricomp(trijoin_rec_inv(trijoin_reck))fgh$->R).exact(trijoinrecdata_tricomp_0fun(trijoin_rec_betak)fgh).Defined.Now we have all of the tools to efficiently prove functoriality.Definitionfunctor_trijoin_compose{ABCA'B'C'A''B''C''}(f:A->A') (g:B->B') (h:C->C')(f':A'->A'') (g':B'->B'') (h':C'->C''):functor_trijoin(f'of) (g'og) (h'oh) ==functor_trijoinf'g'h'ofunctor_trijoinfgh.Proof.symmetry.nrapplytrijoin_rec_functor_trijoin.Defined.Definitionfunctor_trijoin_idmap{ABC}:functor_trijoinidmapidmapidmap== (idmap:TriJoinABC->TriJoinABC).Proof.applymoveR_trijoin_rec.change(trijoinrecdata_trijoinABC$==trijoinrecdata_funidmap(trijoinrecdata_trijoinABC)).symmetry.exact(fmap_id(trijoinrecdata_0gpdABC)_(trijoinrecdata_trijoinABC)).Defined.Definitionfunctor2_trijoin{ABCA'B'C'}{ff':A->A'} {gg':B->B'} {hh':C->C'}(p:f==f') (q:g==g') (r:h==h'):functor_trijoinfgh==functor_trijoinf'g'h'.Proof.unfoldfunctor_trijoin.rapply(fmaptrijoin_rec).apply(trijoinrecdata_tricomp2_pqr).Defined.Global Instanceisequiv_functor_trijoin{ABCA'B'C'}(f:A->A') `{!IsEquivf}(g:B->B') `{!IsEquivg}(h:C->C') `{!IsEquivh}:IsEquiv(functor_trijoinfgh).Proof.(* This proof is almost identical to the proof ofisequiv_functor_join. *)snrapplyisequiv_adjointify.-apply(functor_trijoinf^-1g^-1h^-1).-etransitivity.1:symmetry;applyfunctor_trijoin_compose.etransitivity.1:exact(functor2_trijoin(eisretrf) (eisretrg) (eisretrh)).applyfunctor_trijoin_idmap.-etransitivity.1:symmetry;applyfunctor_trijoin_compose.etransitivity.1:exact(functor2_trijoin(eissectf) (eissectg) (eissecth)).applyfunctor_trijoin_idmap.Defined.Definitionequiv_functor_trijoin{ABCA'B'C'}(f:A<~>A') (g:B<~>B') (h:C<~>C'):TriJoinABC<~>TriJoinA'B'C':=Build_Equiv__(functor_trijoinfgh)_.The relationship betweenfunctor_trijoinandfunctor_join.Whilefunctor_trijoinis convenient to work with, we want to know thatfunctor_trijoinfghis homotopic tofunctor_joinf(functor_joingh).  This is worked out using the next three results.A lemma that handles the path algebra in the next result.BChere isJoinBCthere,bchere isjgluebcthere,bc'here isjggbcthere, andbeta_jghere isJoin_rec_beta_jglue___bcthere.Local Lemmaap_triangle_functor_join{ABCA'P} (f:A->A') (g:BC->P)(a:A) {bc:BC} (bc:b=c) (bc':gb=gc) (beta_jg:apgbc=bc'):ap_triangle(functor_joinfg) (triangle_vabc) @functor_join_beta_jgluefgac= (functor_join_beta_jgluefgab@@ ((ap_composejoinr(functor_joinfg)bc)^@ (ap_composegjoinrbc@ap(apjoinr)beta_jg)))@triangle_v(fa)bc'.Proof.inductionbc,beta_jg;simpl.transitivity(concat_p1_@functor_join_beta_jgluefgab).-refine(_@@ 1).unfoldap_triangle.applymoveR_Vp;symmetry.exact(ap_pp_concat_p1(functor_joinfg) (jglueab)).-applymoveR_Mp;symmetry.exact(concat_p_pp___@whiskerR_p1_).Defined.We'll generalize the situation a bit to keep things less verbose.join_recghere will befunctor_joinghin the next result.  Maybe this extra generality will also be useful sometime?Definitionfunctor_join_join_rec{ABCA'P} (f:A->A') (g:JoinRecDataBCP):functor_joinf(join_recg)==trijoin_rec{|j1:=joinlof;j2:=joinrojlg;j3:=joinrojrg;j12:=funab=>jglue(fa) (jlgb);j13:=funac=>jglue(fa) (jrgc);j23:=funbc=>apjoinr(jggbc);j123:=funabc=>triangle_v(fa) (jggbc); |}.Proof.(* Recall thattrijoin_recis defined to be the inverse oftrijoin_rec_inv_natequiv.... *)refine(moveL_equiv_V_0gpd(trijoin_rec_inv_natequivABC_)___).(* The next two lines aren't needed, but clarify the goal. *)unfoldtrijoin_rec_inv_natequiv,equiv_fun_0gpd;simpl.unfoldtrijoinrecdata_fun,trijoinrecdata_trijoin;simpl.bundle_trijoinrecpath;intros;cbn.-exact(functor_join_beta_jgluef_a(joinlb)).-exact(functor_join_beta_jgluef_a(joinrc)).-unfoldjoin23.refine((ap_composejoinr__)^ @_).simpl.refine(ap_compose_joinr(jgluebc) @_).refine(ap(apjoinr)_).applyjoin_rec_beta_jg.-unfoldprism'.change(join123abc)with(triangle_va(jgluebc)).exact(ap_triangle_functor_joinf(join_recg)a(jgluebc) (jggbc) (Join_rec_beta_jglue___bc)).Defined.Definitionfunctor_trijoin_as_functor_join{ABCA'B'C'}(f:A->A') (g:B->B') (h:C->C'):functor_joinf(functor_joingh) ==functor_trijoinfgh:=functor_join_join_recf(functor_join_recdatagh).

--- Miscellaneous\TruncImpliesFunext.html ---
TruncImpliesFunextLibrary TruncImpliesFunextPropositional truncation implies function extensionalityRequireImportHoTT.BasicsHoTT.TruncationsHoTT.Types.Bool.RequireImportMetatheory.CoreMetatheory.FunextVarietiesMetatheory.ImpredicativeTruncation.An approach using the truncations defined as HITsWe can construct an interval type asTrunc-1Bool.Local Definitioninterval:=Trunc(-1)Bool.Local Definitioninterval_rec(P:Type) (ab:P) (p:a=b):interval->P.Proof.We define this map by factoring it through the type{x:P&x=b}, which is a proposition since it is contractible.refine((pr1: {x:P&x=b} ->P)o_).applyTrunc_rec.intros[].-exact(a;p).-exact(b;idpath).Defined.Local Definitionseg:trtrue=trfalse:>interval:=path_ishprop__.From an interval type, and thus from truncations, we can prove function extensionality.Definitionfunext_type_from_trunc:Funext_type:=WeakFunext_implies_Funext(NaiveFunext_implies_WeakFunext(funAPfgp=>leth:=fun(x:interval) (a:A) =>interval_rec_(fa) (ga) (pa)xinaphseg)).An approach without using HITsAssumingFunext(and not propositional resizing), the constructionTrmin ImpredicativeTruncation.v applied toBoolgives an interval type with definitional computation on the end points.  So we see that function extensionality is equivalent to the existence of an interval type.SectionAssumeFunext.Context`{Funext}.Definitionfinterval:=TrmBool.Definitionfinterval_rec(P:Type) (ab:P) (p:a=b):finterval->P.Proof.refine((pr1: {x:P&x=b} ->P)o_).applyTrm_rec.intros[].-exact(a;p).-exact(b;idpath).Defined.As an example, we check that it computes ontrue.Definitionfinterval_rec_beta(P:Type) (ab:P) (p:a=b):finterval_recPabp(trmtrue) =a:=idpath.Definitionfseg:trmtrue=trmfalse:>finterval:=path_ishprop__.To verify that our interval type is good enough, we use it to prove function extensionality.Definitionfunext_type_from_finterval:Funext_type:=WeakFunext_implies_Funext(NaiveFunext_implies_WeakFunext(funAPfgp=>leth:=fun(x:finterval) (a:A) =>finterval_rec_(fa) (ga) (pa)xinaphfseg)).EndAssumeFunext.

--- Miscellaneous\TwoOneCat.html ---
TwoOneCatLibrary TwoOneCatRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.RequireImportWildCat.NatTrans.Wild (2,1)-categoriesClassIs21Cat(A:Type) `{Is1CatA, !Is3GraphA} :={is1cat_hom:forall(ab:A),Is1Cat(a$->b) ;is1gpd_hom:forall(ab:A),Is1Gpd(a$->b) ;is1functor_postcomp:forall(abc:A) (g:b$->c),Is1Functor(cat_postcompag) ;is1functor_precomp:forall(abc:A) (f:a$->b),Is1Functor(cat_precompcf) ;bifunctor_coh_comp:forall{abc:A} {ff':a$->b}  {gg':b$->c}(p:f$==f') (p':g$==g'),(p'$@Rf) $@ (g'$@Lp) $== (g$@Lp) $@ (p'$@Rf') ;Naturality of the associator in each variable separatelyis1natural_cat_assoc_l:forall(abcd:A) (f:a$->b) (g:b$->c),Is1Natural(cat_precompdfocat_precompdg) (cat_precompd(g$of))(cat_assocfg);is1natural_cat_assoc_m:forall(abcd:A) (f:a$->b) (h:c$->d),Is1Natural(cat_precompdfocat_postcompbh) (cat_postcompahocat_precompcf)(fung=>cat_assocfgh);is1natural_cat_assoc_r:forall(abcd:A) (g:b$->c) (h:c$->d),Is1Natural(cat_postcompa(h$og)) (cat_postcompahocat_postcompag)(funf=>cat_assocfgh);Naturality of the unitorsis1natural_cat_idl:forall(ab:A),Is1Natural(cat_postcompa(Idb))idmapcat_idl;is1natural_cat_idr:forall(ab:A),Is1Natural(cat_precompb(Ida))idmapcat_idr;Coherencecat_pentagon:forall(abcde:A)(f:a$->b) (g:b$->c) (h:c$->d) (k:d$->e),(k$@Lcat_assocfgh) $o(cat_assocf(h$og)k) $o(cat_assocghk$@Rf)$== (cat_assoc(g$of)hk) $o(cat_assocfg(k$oh)) ;cat_tril:forall(abc:A) (f:a$->b) (g:b$->c),(g$@Lcat_idlf) $o(cat_assocf(Idb)g) $== (cat_idrg$@Rf)}.Global Existing Instanceis1cat_hom.Global Existing Instanceis1gpd_hom.Global Existing Instanceis1functor_precomp.Global Existing Instanceis1functor_postcomp.Global Existing Instanceis1natural_cat_assoc_l.Global Existing Instanceis1natural_cat_assoc_m.Global Existing Instanceis1natural_cat_assoc_r.Global Existing Instanceis1natural_cat_idl.Global Existing Instanceis1natural_cat_idr.Whiskering functorialityDefinitioncat_postwhisker_pp{A} `{Is21CatA} {abc:A}{fgh:a$->b} (k:b$->c) (p:f$==g) (q:g$==h):k$@L(p$@q) $== (k$@Lp) $@ (k$@Lq).Proof.rapplyfmap_comp.Defined.Definitioncat_prewhisker_pp{A} `{Is21CatA} {abc:A}{fgh:b$->c} (k:a$->b) (p:f$==g) (q:g$==h): (p$@q) $@Rk$== (p$@Rk) $@ (q$@Rk).Proof.rapplyfmap_comp.Defined.Exchange lawDefinitioncat_exchange{A:Type} `{Is21CatA} {abc:A}{ff'f'':a$->b} {gg'g'':b$->c}(p:f$==f') (q:f'$==f'') (r:g$==g') (s:g'$==g''): (p$@q) $@@ (r$@s) $== (p$@@r) $@ (q$@@s).Proof.unfold"$@@".We use the distributivity of$@Rand$@Lin a (2,1)-category (since they are functors) to see that we have the same dadta on both sides of the 3-morphism.nrefine((_$@Lcat_prewhisker_pp___) $@_).nrefine((cat_postwhisker_pp___$@R_) $@_).Now we reassociate and whisker on the left and right.nrefine(cat_assoc___$@_).refine(_$@ (cat_assoc___)^$).nrefine(_$@L_).refine(_$@cat_assoc___).refine((cat_assoc___)^$ $@_).nrefine(_$@R_).Finally we are left with the bifunctoriality condition for left and right whiskering which is part of the data of the (2,1)-cat.applybifunctor_coh_comp.Defined.

--- Miscellaneous\TwoSphere.html ---
TwoSphereLibrary TwoSphereRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoids.Local OpenScopepath_scope.Theorems about the 2-sphereS^2.(* ** Definition of the 2-sphere. *)ModuleExportTwoSphere.Private InductiveTwoSphere:Type0:=|base:TwoSphere.Axiomsurf:idpathbase=idpathbase.DefinitionTwoSphere_ind(P:TwoSphere->Type)(b:Pbase) (s:idpathb=transport2Psurfb):forall(x:TwoSphere),Px:=funx=>matchxwithbase=>fun_=>bends.AxiomTwoSphere_ind_beta_surf:forall(P:TwoSphere->Type)(b:Pbase) (s:idpathb=transport2Psurfb),apD02(TwoSphere_indPbs)surf=s@ (concat_p1_)^.EndTwoSphere.(* ** The non-dependent eliminator *)DefinitionTwoSphere_rec(P:Type) (b:P) (s:idpathb=idpathb):TwoSphere->P:=TwoSphere_ind(fun_=>P)b(s@ (transport2_constsurfb) @ (concat_p1_)).DefinitionTwoSphere_rec_beta_surf(P:Type) (b:P) (s:idpathb=idpathb):ap02(TwoSphere_recPbs)surf=s.Proof.apply(cancel2L(transport2_constsurfb)).apply(cancelL(apD_const(TwoSphere_recPbs) (idpathbase))).apply(cancelR__(concat_p_pp_(transport_const_b)_)^).apply(cancelR__(whiskerL(transport2_surfb) (apD_const__)^)).refine((apD02_const(TwoSphere_recPbs)surf)^ @_).refine((TwoSphere_ind_beta_surf___) @_).refine(_@ (ap(funw=>_@w)(triangulator(transport2(fun_:TwoSphere=>P)surfb)_))).cbn.refine(_@ (ap(funw=> (w@_) @_) (concat_1p_)^)).refine(_@ (concat_p_pp___)).refine(_@ (ap(funw=>_@w) (concat_pp_p___))).refine(_@ (ap(funw=>_@ (w@_)) (concat_Vp_)^)).refine(_@ (ap(funw=>_@ (w@_))(concat_pV(concat_p1(transport2(fun_:TwoSphere=>P)surfb@ 1))))).refine(_@ (ap(funw=>_@w) (concat_p_pp___))).refine(_@ (concat_pp_p___)).applymoveR_pV.refine(_@ (concat_p_pp___)).refine(_@ (ap(funw=>_@w) (whiskerR_p1_)^)).f_ap.refine((ap(funw=>w@_) (whiskerL_1p_1_)^) @_).refine((ap(funw=>_@w) (whiskerR_p1_)^) @_).cbn.refine((concat_p_pp___) @_).f_ap.refine((ap(funw=>_@w) (concat_1p_)) @_).refine((concat_whisker1__1 (transport2_constsurfb)s)^ @_).symmetry.refine((ap(funw=>w@@_) (concat_p1_)^) @_).refine((ap(funw=>_@@w) (concat_1p_)^) @_).refine((concat_concat2____)^ @_).f_ap.Defined.

--- Miscellaneous\Types.html ---
TypesLibrary TypesRequireExportTypes.Unit.RequireExportTypes.Empty.RequireExportTypes.Paths.RequireExportTypes.Prod.RequireExportTypes.Forall.RequireExportTypes.Arrow.RequireExportTypes.Sigma.RequireExportTypes.Equiv.RequireExportTypes.Universe.RequireExportTypes.Bool.RequireExportTypes.Sum.RequireExportTypes.WType.RequireExportTypes.IWType.

--- Miscellaneous\ua_algebra.html ---
ua_algebraLibrary ua_algebraThis file definesAlgebra.RequireExportHoTT.Utf8MinimalHoTT.BasicsHoTT.Classes.implementations.ne_listHoTT.Classes.implementations.family_prod.RequireImportHoTT.TypesHoTT.Universes.HSetHoTT.Spaces.List.Core.Importne_list.notations.Declare ScopeAlgebra_scope.DelimitScopeAlgebra_scopewithAlgebra.OpenScopeAlgebra_scope.DefinitionSymbolType_internal:Type→Type:=ne_list.ASignatureis used to characteriseAlgebras. In particular
    a signature specifies which operations (functions) an algebra for
    the signature is expected to provide. A signature consists ofA type ofSorts. An algebra for the signature must provide
      a type for eachs:Sort.A type of function symbolsSymbol. For each function symbolu:Symbol, an algebra for the signature must provide a
      corresponding operation.The fieldsymbol_typesσuindicates which type the operation
      corresponding toushould have.RecordSignature:Type:=BuildSignature{Sort:Type;Symbol:Type;symbol_types:Symbol→SymbolType_internalSort}.We have this implicit coercion allowing us to use a signatureσ:Signatureas a mapSymbolσ→SymbolTypeσ(seeSymbolTypebelow).Global Coercionsymbol_types:Signature>->Funclass.A single sortedSignatureis a signature withSort=Unit.DefinitionBuildSingleSortedSignature(sym:Type) (arities:sym→nat):Signature:=BuildSignatureUnitsym(ne_list.replicate_Snttoarities).Letσ:Signature. For each symbolu:Symbolσ,σuassociatesuto aSymbolTypeσ. This represents the required
    type of the algebra operation corresponding tou.DefinitionSymbolType(σ :Signature) :Type:=ne_list(Sortσ).Fors:SymbolTypeσ,cod_symboltypeσis the codomain of the
    symbol types.Definitioncod_symboltype{σ} :SymbolTypeσ →Sortσ:=ne_list.last.Fors:SymbolTypeσ,cod_symboltypeσis the domain of the
    symbol types.Definitiondom_symboltype{σ} :SymbolTypeσ →list(Sortσ):=ne_list.front.Fors:SymbolTypeσ,cod_symboltypeσis the arity of the
    symbol types. That is the numbern:natof arguments of theSymbolTypeσ.Definitionarity_symboltype{σ} :SymbolTypeσ →nat:=lengthodom_symboltype.AnAlgebramust provide a family ofCarriersσindexed bySortσ. These carriers are the "objects" (types) of the algebra.(*Carriersis a notation because it will be used for an implicitcoercionAlgebra>->Funclassbelow. *)NotationCarriersσ := (Sortσ →Type).The functionOperationmaps a family of carriersA:Carriersσandw:SymbolTypeσto the corresponding function type.Operation A [:s1; s2; ...; sn; t:] = A s1 → A s2 → ... → A sn → A twhere[:s1;s2;...;sn;t:]:SymbolTypeσis a symbol type
    with domain[s1;s2;...;sn]and codomaint.FixpointOperation{σ} (A:Carriersσ) (w:SymbolTypeσ) :Type:=matchwwith| [:s:] =>As|s:::w'=>As→OperationAw'end.Global Instancetrunc_operation`{Funext} {σ :Signature}(A:Carriersσ) {n} `{!∀s,IsTruncn(As)} (w:SymbolTypeσ):IsTruncn(OperationAw).Proof.inductionw;exact_.Defined.Uncurry of anf:OperationAw, such thatap_operation f (x1,x2,...,xn) = f x1 x2 ... xnFixpointap_operation{σ} {A:Carriersσ} {w:SymbolTypeσ}:OperationAw→FamilyProdA(dom_symboltypew) →A(cod_symboltypew):=matchwwith| [:s:] =>λf_,f|s:::w'=>λf'(x,l),ap_operation(fx)lend.Funext for uncurriedOperationAw. Ifap_operation f (x1,x2,...,xn) = ap_operation g (x1,x2,...,xn)for all(x1,x2,...,xn):As1*As2*...*Asn, thenf=g.Fixpointpath_forall_ap_operation`{Funext} {σ :Signature}{A:Carriersσ} {w:SymbolTypeσ}: ∀ (fg:OperationAw),(∀a:FamilyProdA(dom_symboltypew),ap_operationfa=ap_operationga)->f=g:=matchwwith| [:s:] =>λ(fg:As)p,ptt|s:::w'=>λ(fg:As→OperationAw')p,path_forallfg(λx,path_forall_ap_operation(fx) (gx) (λa,p(x,a)))end.AnAlgebraσfor a signatureσconsists of a familycarriers:Carriersσindexed by the sortss:Sortσ, and for each symbolu:Symbolσ, an operation of typeOperationcarriers(σu),
    whereσu:SymbolTypeσis the symbol type ofu.RecordAlgebra{σ :Signature} :Type:=BuildAlgebra{carriers:Carriersσ;operations: ∀ (u:Symbolσ),Operationcarriers(σu) }.ArgumentsAlgebra:clearimplicits.ArgumentsBuildAlgebra{σ}carriersoperations.We have a convenient implicit coercion from an algebra to the
    family of carriers.Global Coercioncarriers:Algebra>->Funclass.Bind ScopeAlgebra_scopewithAlgebra.DefinitionSigAlgebra(σ :Signature) :Type:= {c:Carriersσ | ∀ (u:Symbolσ),Operationc(σu) }.Lemmaissig_algebra(σ :Signature) :SigAlgebraσ <~>Algebraσ.Proof.issig.Defined.ClassIsTruncAlgebra(n:trunc_index) {σ :Signature} (A:Algebraσ):=trunc_carriers_algebra: ∀ (s:Sortσ),IsTruncn(As).Global Existing Instancetrunc_carriers_algebra.NotationIsHSetAlgebra:= (IsTruncAlgebra0).Global Instancehprop_is_trunc_algebra`{Funext} (n:trunc_index){σ :Signature} (A:Algebraσ):IsHProp(IsTruncAlgebranA).Proof.applyistrunc_forall.Qed.Global Instancetrunc_algebra_succ{σ :Signature} (A:Algebraσ){n} `{!IsTruncAlgebranA}:IsTruncAlgebran.+1A| 1000.Proof.intro;exact_.Qed.To find a path between two algebrasAB:Algebraσit suffices
    to find paths between the carriers and the operations.Lemmapath_algebra{σ :Signature} (AB:Algebraσ)(p:carriersA=carriersB)(q:transport(λX, ∀u,OperationX(σu))p(operationsA)=operationsB):A=B.Proof.destructA,B.cbnin*.bypath_induction.Defined.Lemmapath_ap_carriers_path_algebra{σ} (AB:Algebraσ)(p:carriersA=carriersB)(q:transport(λX, ∀u,OperationX(σu))p(operationsA)=operationsB):apcarriers(path_algebraABpq) =p.Proof.destructAas[Aa],Bas[Bb].cbnin*.bydestructp,q.Defined.Supposep,qare paths inAlgebraσ. To show thatp=qit
    suffices to find a pathrbetween the paths corresponding topandqinSigAlgebraσ.Lemmapath_path_algebra{σ :Signature} {AB:Algebraσ} (pq:A=B)(r:ap(issig_algebraσ)^-1p=ap(issig_algebraσ)^-1q):p=q.Proof.set(e:= (equiv_ap(issig_algebraσ)^-1AB)).byapply(@equiv_inv__(ape) (Equivalences.isequiv_ap__)).Defined.Ifpq:A=BandIsHSetAlgebraB.
    Thenapcarriersp=apcarriersqimpliesp=q.Lemmapath_path_hset_algebra`{Funext} {σ :Signature}{AB:Algebraσ} `{IsHSetAlgebraB}(pq:A=B) (r:apcarriersp=apcarriersq):p=q.Proof.applypath_path_algebra.unshelveeapplypath_path_sigma.-transitivity(apcarriersp); [bydestructp|].transitivity(apcarriersq); [exactr|bydestructq].-applypath_ishprop.Defined.Modulealgebra_notations.GivenA:Algebraσand function symbolu:Symbolσ, we use
    the notationu.#Ato refer to the corresponding algebra
    operation of typeOperationA(σu).Global Notation"u .# A" := (operationsAu) :Algebra_scope.Endalgebra_notations.

--- Miscellaneous\ua_category.html ---
ua_categoryLibrary ua_categoryRequireImportHoTT.TypesHoTT.Categories.Category.CoreHoTT.Categories.Category.UnivalentHoTT.Classes.theory.ua_isomorphic.ImportMorphisms.CategoryMorphismsNotationsisomorphic_notations.Local OpenScopecategory.Given any signatureσ, there is a precategory of set algebras
    and homomorphisms for that signature.Lemmaprecategory_algebra`{Funext} (σ :Signature) :PreCategory.Proof.apply(@Build_PreCategory(SetAlgebraσ)Homomorphismhom_id(@hom_composeσ));[intros;byapplypath_hset_homomorphism.. |exact_].Defined.Category isomorphic implies algebra isomorphic.Lemmacatiso_to_uaiso`{Funext} {σ} {AB:object(precategory_algebraσ)}:A<~=~>B→A≅B.Proof.intros[f[abc]].unshelveeapply(@BuildIsomorphic___f).intross.refine(isequiv_adjointify(fs) (as)__).-exact(apD10_homomorphismcs).-exact(apD10_homomorphismbs).Defined.Algebra isomorphic implies category isomorphic.Lemmauaiso_to_catiso`{Funext} {σ} {AB:object(precategory_algebraσ)}:A≅B→A<~=~>B.Proof.intros[fFG].set(h:=BuildHomomorphismf).apply(@Morphisms.Build_Isomorphic_ABh).apply(@Morphisms.Build_IsIsomorphism_ABh(hom_invh)).-applypath_hset_homomorphism.funextsx.applyeissect.-applypath_hset_homomorphism.funextsx.applyeisretr.Defined.Category isomorphic and algebra isomorphic is equivalent.Global Instanceisequiv_catiso_to_uaiso`{Funext} {σ :Signature}(AB:object(precategory_algebraσ)):IsEquiv(@catiso_to_uaiso_σAB).Proof.refine(isequiv_adjointifycatiso_to_uaisouaiso_to_catiso__).-intros[fFG].byapplypath_hset_isomorphic.-intros[fF].byapplyMorphisms.path_isomorphic.Defined.Morphisms.idtoisofactorizes as the composition of equivalences.Lemmapath_idtoiso_isomorphic_id`{Funext} {σ :Signature}(AB:object(precategory_algebraσ)): @Morphisms.idtoiso(precategory_algebraσ)AB=catiso_to_uaiso^-1oisomorphic_ido(path_setalgebraAB)^-1.Proof.funextp.destructp.byapplyMorphisms.path_isomorphic.Defined.The precategory of set algebras and homomorphisms for a signature
    is a (univalent) category.Lemmaiscategory_algebra`{Univalence} (σ :Signature):IsCategory(precategory_algebraσ).Proof.introsAB.rewritepath_idtoiso_isomorphic_id.apply@isequiv_compose.-applyisequiv_compose.-applyisequiv_inverse.Qed.Definitioncategory_algebra`{Univalence} (σ :Signature) :Category:=Build_Category(iscategory_algebraσ).

--- Miscellaneous\ua_congruence.html ---
ua_congruenceLibrary ua_congruenceRequireImportHoTT.Universes.HPropHoTT.Classes.interfaces.canonical_namesHoTT.Classes.interfaces.ua_algebra.Importalgebra_notationsne_list.notations.Sectioncongruence.Context{σ :Signature} (A:Algebraσ) (Φ: ∀s,Relation(As)).An operationf:As1→As2→...→Asn→AtsatisfiesOpCompatiblefiffΦ s1 x1 y1 ∧ Φ s2 x2 y2 ∧ ... ∧ Φ sn xn ynimpliesΦ t (f x1 x2 ... xn) (f y1 y2 ... yn).DefinitionOpCompatible{w:SymbolTypeσ} (f:OperationAw):Type:= ∀ (ab:FamilyProdA(dom_symboltypew)),for_all_2_family_prodAAΦab->Φ(cod_symboltypew) (ap_operationfa) (ap_operationfb).ClassOpsCompatible:Type:=ops_compatible: ∀ (u:Symbolσ),OpCompatibleu.#A.Global Instancetrunc_ops_compatible`{Funext} {n:trunc_index}`{!∀sxy,IsTruncn(Φsxy)}:IsTruncnOpsCompatible.Proof.applyistrunc_forall.Qed.A family of relationsΦis a congruence iff it is a family of
      mere equivalence relations andOpsCompatibleAΦholds.ClassIsCongruence:Type:=BuildIsCongruence{is_mere_relation_cong: ∀ (s:Sortσ),is_mere_relation(As) (Φs);equiv_rel_cong: ∀ (s:Sortσ),EquivRel(Φs);ops_compatible_cong:OpsCompatible}.Global ArgumentsBuildIsCongruence{is_mere_relation_cong}{equiv_rel_cong}{ops_compatible_cong}.Global Existing Instanceis_mere_relation_cong.Global Existing Instanceequiv_rel_cong.Global Existing Instanceops_compatible_cong.Global Instancehprop_is_congruence`{Funext} :IsHPropIsCongruence.Proof.apply(equiv_hprop_allpath_)^-1.intros[C1C2C3] [D1D2D3].bydestruct(path_ishpropC1D1),(path_ishpropC2D2),(path_ishpropC3D3).Defined.Endcongruence.IfΦis a congruence andf:As1→As2→...→Asnan
    operation such thatOpCompatibleAΦfholds.
    ThenOpCompatible(fx)holds for allx:As1.Lemmaop_compatible_cons{σ :Signature} {A:Algebraσ}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}(s:Sortσ) (w:SymbolTypeσ) (f:OperationA(s:::w))(x:As) (P:OpCompatibleAΦf):OpCompatibleAΦ(fx).Proof.introsabR.exact(P(x,a) (x,b) (EquivRel_Reflexivex,R)).Defined.

--- Miscellaneous\ua_first_isomorphism.html ---
ua_first_isomorphismLibrary ua_first_isomorphismThis file defines the kernel of a homomorphismcong_ker, the
    image of a homomorphismin_image_hom, and it proves the first
    isomorphism theoremisomorphic_first_isomorphism. The first
    identification theoremid_first_isomorphismfollows.RequireImportBasics.NotationsHSetColimits.QuotientClasses.interfaces.canonical_namesClasses.theory.ua_isomorphicClasses.theory.ua_subalgebraClasses.theory.ua_quotient_algebra.Importalgebra_notationsquotient_algebra_notationssubalgebra_notationsisomorphic_notations.The following section defines the kernel of a homomorphismcong_ker, and shows that it is a congruence.Sectioncong_ker.Context{σ :Signature} {AB:Algebraσ} `{IsHSetAlgebraB}(f: ∀s,As→Bs) `{!IsHomomorphismf}.Definitioncong_ker(s:Sortσ) :Relation(As):=λ(xy:As),fsx=fsy.(* Leave the following results aboutcong_keropaque because theyare h-props. *)Global Instanceequiv_rel_ker(s:Sortσ):EquivRel(cong_kers).Proof.repeatconstructor.-introsxy.exactinverse.-introsxyz.exactconcat.Qed.Lemmapath_ap_operation_ker_related{w:SymbolTypeσ}(β:OperationBw) (ab:FamilyProdA(dom_symboltypew))(R:for_all_2_family_prodAAcong_kerab):ap_operationβ(map_family_prodfa)=ap_operationβ(map_family_prodfb).Proof.inductionw.-reflexivity.-destructaas[xa],bas[yb],Ras[rR].cbn.destructr.byapplyIHw.Qed.Global Instanceops_compatible_ker:OpsCompatibleAcong_ker.Proof.introsuabR.unfoldcong_ker.destruct(path_homomorphism_ap_operationfua)^.destruct(path_homomorphism_ap_operationfub)^.byapplypath_ap_operation_ker_related.Qed.Global Instanceis_congruence_ker:IsCongruenceAcong_ker:=BuildIsCongruenceAcong_ker.Endcong_ker.The next section defines an "in image predicate",in_image_hom.
    It gives rise to the homomorphic image of a homomorphism.Sectionin_image_hom.Context`{Funext} {σ :Signature} {AB:Algebraσ}(f: ∀s,As→Bs) {hom:IsHomomorphismf}.Definitionin_image_hom(s:Sortσ) (y:Bs) :HProp:=merely(hfiber(fs)y).Lemmaclosed_under_op_in_image_hom{w:SymbolTypeσ}(α:OperationAw) (β:OperationBw) (P:OpPreservingfαβ):ClosedUnderOpBin_image_homβ.Proof.inductionw.-exact(tr(α;P)).-introy.refine(Trunc_rec_).intros[xp].apply(IHw(αx)).bydestructp.Qed.Lemmais_closed_under_ops_in_image_hom:IsClosedUnderOpsBin_image_hom.Proof.introu.eapplyclosed_under_op_in_image_hom,hom.Qed.Global Instanceis_subalgebra_predicate_in_image_hom:IsSubalgebraPredicateBin_image_hom:=BuildIsSubalgebraPredicateis_closed_under_ops_in_image_hom.Endin_image_hom.The folowing section proves the first isomorphism theorem,isomorphic_first_isomorphismand the first identification
    theoremid_first_isomorphism.Sectionfirst_isomorphism.Context`{Univalence} {σ} {AB:Algebraσ} `{IsHSetAlgebraB}(f: ∀s,As→Bs) {hom:IsHomomorphismf}.The homomorphismdef_first_isomorphismis informally given bydef_first_isomorphism s (class_of _ x) := f s x.Definitiondef_first_isomorphism(s:Sortσ): (A/cong_kerf)s→ (B&&in_image_homf)s.Proof.refine(Quotient_rec(cong_kerfs)_(λx, (fsx;tr(x;idpath)))_).introsxyp.byapplypath_sigma_hprop.Defined.Lemmaoppreserving_first_isomorphism{w:SymbolTypeσ}(α:OperationAw)(β:OperationBw)(γ:Operation(A/cong_kerf)w)(C:ClosedUnderOpB(in_image_homf)β)(P:OpPreservingfαβ)(G:ComputeOpQuotientA(cong_kerf)αγ):OpPreservingdef_first_isomorphismγ(op_subalgebraB(in_image_homf)βC).Proof.inductionw.-applypath_sigma_hprop.generalizedependentγ.refine(Quotient_ind_hprop(cong_kerft)__).introsxG.destructP.apply(related_quotient_paths(cong_kerft)__(Gtt)).-refine(Quotient_ind_hprop(cong_kerft)__).introx.apply(IHw(αx) (β(ftx)) (γ(class_of_x))).+exact(Px).+introa.exact(G(x,a)).Qed.(* Leaveis_homomorphism_first_isomorphismopaque becauseIsHomomorphismis an hprop whenBis a set algebra. *)Global Instanceis_homomorphism_first_isomorphism:IsHomomorphismdef_first_isomorphism.Proof.introu.apply(oppreserving_first_isomorphismu.#A).-applyhom.-applycompute_op_quotient.Qed.Definitionhom_first_isomorphism:Homomorphism(A/cong_kerf) (B&&in_image_homf):=BuildHomomorphismdef_first_isomorphism.Global Instanceembedding_first_isomorphism(s:Sortσ):IsEmbedding(hom_first_isomorphisms).Proof.applyisembedding_isinj_hset.refine(Quotient_ind_hprop(cong_kerfs)__).introx.refine(Quotient_ind_hprop(cong_kerfs)__).introsyp.applyqglue.exact(p..1).Qed.Global Instancesurjection_first_isomorphism(s:Sortσ):IsSurjection(hom_first_isomorphisms).Proof.applyBuildIsSurjection.intros[xM].refine(Trunc_rec_M).intros[yY].applytr.exists(class_of_y).byapplypath_sigma_hprop.Qed.Global Instanceis_isomorphism_first_isomorphism:IsIsomorphismhom_first_isomorphism.Proof.intros.applyisequiv_surj_emb;exact_.Qed.Theoremisomorphic_first_isomorphism:A/cong_kerf≅B&&in_image_homf.Proof.exact(BuildIsomorphicdef_first_isomorphism).Defined.(* The first identification theoremid_first_isomorphismis anh-prop, so we can leave it opaque. *)Corollaryid_first_isomorphism:A/cong_kerf=B&&in_image_homf.Proof.exact(id_isomorphicisomorphic_first_isomorphism).Qed.Endfirst_isomorphism.The next section gives a specialization of the first isomorphism
    theorem, where the homomorphism is surjective.Sectionfirst_isomorphism_surjection.Context`{Univalence} {σ} {AB:Algebraσ} `{IsHSetAlgebraB}(f: ∀s,As→Bs) `{!IsHomomorphismf} {S: ∀s,IsSurjection(fs)}.Global Instanceis_isomorphism_inc_first_isomorphism_surjection:IsIsomorphism(hom_inc_subalgebraB(in_image_homf)).Proof.applyis_isomorphism_inc_improper_subalgebra.introssx;cbn.applycenter,S.Qed.The homomorphismhom_first_isomorphism_surjectionis the
    composition of two isomorphisms, so it is an isomorphism.Definitionhom_first_isomorphism_surjection:Homomorphism(A/cong_kerf)B:=hom_compose(hom_inc_subalgebraB(in_image_homf))(hom_first_isomorphismf).Theoremisomorphic_first_isomorphism_surjection:A/cong_kerf≅B.Proof.exact(BuildIsomorphichom_first_isomorphism_surjection).Defined.Corollaryid_first_isomorphism_surjection: (A/cong_kerf) =B.Proof.exact(id_isomorphicisomorphic_first_isomorphism_surjection).Qed.Endfirst_isomorphism_surjection.The next section specializes the first isomorphism theorem to the
    case where the homomorphism is injective. It proves that an
    injective homomorphism is an isomorphism between its domain
    and its image.Sectionfirst_isomorphism_inj.Context`{Univalence} {σ} {AB:Algebraσ} `{IsHSetAlgebraB}(f: ∀s,As→Bs) `{!IsHomomorphismf} (inj: ∀s,IsInjective(fs)).Global Instanceis_isomorphism_quotient_first_isomorphism_inj:IsIsomorphism(hom_quotient(cong_kerf)).Proof.applyis_isomorphism_quotient.introssxyp.applyinj,p.Qed.The homomorphismhom_first_isomorphism_injis the
    composition of two isomorphisms, so it is an isomorphism.Definitionhom_first_isomorphism_inj:HomomorphismA(B&&in_image_homf):=hom_compose(hom_first_isomorphismf)(hom_quotient(cong_kerf)).Definitionisomorphic_first_isomorphism_inj:A≅B&&in_image_homf:=BuildIsomorphichom_first_isomorphism_inj.Definitionid_first_isomorphism_inj:A=B&&in_image_homf:=id_isomorphicisomorphic_first_isomorphism_inj.Endfirst_isomorphism_inj.

--- Miscellaneous\ua_homomorphism.html ---
ua_homomorphismLibrary ua_homomorphismThis file implementsIsHomomorphismandIsIsomorphism.
    It developes basic algebra homomorphisms and isomorphims. The main
    theorem in this file is thepath_isomorphismtheorem, which
    states that there is a path between isomorphic algebras.RequireExportHoTT.Classes.interfaces.ua_setalgebra.RequireImportHoTT.TypesHoTT.Tactics.Importalgebra_notationsne_list.notations.Sectionis_homomorphism.Context{σ} {AB:Algebraσ} (f: ∀ (s:Sortσ),As→Bs).The family of functionsfabove isOpPreservingαβwith
    respect to operationsα:As1→As2→...→Asn→Atandβ:Bs1→Bs2→...→Bsn→Btiff t (α x1 x2 ... xn) = β (f s1 x1) (f s2 x2) ... (f sn xn)FixpointOpPreserving{w:SymbolTypeσ}:OperationAw→OperationBw→Type:=matchwwith| [:s:] =>λαβ,fsα=β|s:::y=>λαβ, ∀ (x:As),OpPreserving(αx) (β(fsx))end.Global Instancetrunc_oppreserving`{Funext} {n:trunc_index}`{!IsTruncAlgebran.+1B} {w:SymbolTypeσ}(α:OperationAw) (β:OperationBw):IsTruncn(OpPreservingαβ).Proof.inductionw;exact_.Qed.The family of functionsf:∀(s:Sortσ),As→Bsabove is
    a homomorphism if for each function symbolu:Symbolσ, it isOpPreservingu.#Au.#Bwith respect to the algebra
    operationsu.#Aandu.#Bcorresponding tou.ClassIsHomomorphism:Type:=oppreserving_hom: ∀ (u:Symbolσ),OpPreservingu.#Au.#B.Global Instancetrunc_is_homomorphism`{Funext} {n:trunc_index}`{!IsTruncAlgebran.+1B}:IsTruncnIsHomomorphism.Proof.applyistrunc_forall.Qed.Endis_homomorphism.RecordHomomorphism{σ} {AB:Algebraσ} :Type:=BuildHomomorphism{def_hom: ∀ (s:Sortσ),As→Bs;is_homomorphism_hom:IsHomomorphismdef_hom}.ArgumentsHomomorphism{σ}.ArgumentsBuildHomomorphism{σAB}def_hom{is_homomorphism_hom}.We the implicit coercion fromHomomorphismABto the family
    of functions∀s,As→Bs.Global Coerciondef_hom:Homomorphism>->Funclass.Global Existing Instanceis_homomorphism_hom.LemmaapD10_homomorphism{σ} {AB:Algebraσ} {fg:HomomorphismAB}:f=g→ ∀s,fs==gs.Proof.introp.bydestructp.Defined.DefinitionSigHomomorphism{σ} (AB:Algebraσ) :Type:={def_hom: ∀s,As→Bs|IsHomomorphismdef_hom}.Lemmaissig_homomorphism{σ} (AB:Algebraσ):SigHomomorphismAB<~>HomomorphismAB.Proof.issig.Defined.Global Instancetrunc_homomorphism`{Funext} {σ} {AB:Algebraσ}{n:trunc_index} `{!IsTruncAlgebranB}:IsTruncn(HomomorphismAB).Proof.apply(istrunc_equiv_istrunc_(issig_homomorphismAB)).Qed.To find a path between two homomorphismsfg:HomomorphismABit suffices to find a path between the defining families of
    functions and theis_homomorphism_homwitnesses.Lemmapath_homomorphism{σ} {AB:Algebraσ} (fg:HomomorphismAB)(p:def_homf=def_homg)(q:p#(is_homomorphism_homf) =is_homomorphism_homg):f=g.Proof.destructf,g.simplin*.bypath_induction.Defined.To find a path between two homomorphismsfg:HomomorphismABit suffices to find a path between the defining families of
    functions ifIsHSetAlgebraB.Lemmapath_hset_homomorphism`{Funext} {σ} {AB:Algebraσ}`{!IsHSetAlgebraB} (fg:HomomorphismAB)(p:def_homf=def_homg):f=g.Proof.apply(path_homomorphismfgp).applypath_ishprop.Defined.A family of functionsf:∀s,As→Bsis an isomorphism if it is
    a homomorphism, and for eachs:Sortσ,fsis an equivalence.(* We makeIsHomomorphisman argument here, rather than a field, sohaving bothf:HomomorphismABandX:IsIsomorphismfincontext does not result in having two proofs ofIsHomomorphismfin context. *)ClassIsIsomorphism{σ :Signature} {AB:Algebraσ}(f: ∀s,As→Bs) `{!IsHomomorphismf}:=isequiv_isomorphism: ∀ (s:Sortσ),IsEquiv(fs).Global Existing Instanceisequiv_isomorphism.Definitionequiv_isomorphism{σ :Signature} {AB:Algebraσ}(f: ∀s,As→Bs) `{IsIsomorphismσABf}: ∀ (s:Sortσ),As<~>Bs.Proof.intros.rapply(Build_Equiv__(fs)).Defined.Global Instancehprop_is_isomorphism`{Funext} {σ :Signature}{AB:Algebraσ} (f: ∀s,As→Bs) `{!IsHomomorphismf}:IsHProp(IsIsomorphismf).Proof.applyistrunc_forall.Qed.Letf:∀s,As→Bsbe a homomorphism. The following
    section proves thatfis "OpPreserving" with respect to
    uncurried algebra operations in the sense thatf t (α (x1,x2,...,xn,tt)) = β (f s1 x1,f s2 x1,...,f sn xn,tt)for all(x1,x2,...,xn,tt):FamilyProdA[s1;s2;...;sn], whereαandβare uncurried algebra operations inAandBrespectively.Sectionhomomorphism_ap_operation.Context{σ :Signature} {AB:Algebraσ}.Lemmapath_oppreserving_ap_operation(f: ∀s,As→Bs){w:SymbolTypeσ} (a:FamilyProdA(dom_symboltypew))(α:OperationAw) (β:OperationBw) (P:OpPreservingfαβ):f(cod_symboltypew) (ap_operationαa)=ap_operationβ(map_family_prodfa).Proof.inductionw.-assumption.-destructaas[xa].applyIHw.applyP.Defined.A homomorphismf:∀s,As→Bssatisfiesf t (α (a1, a2, ..., an, tt))
      = β (f s1 a1, f s2 a2, ..., f sn an, tt)where(a1,a2,...,an,tt):FamilyProdA[s1;s2;...;sn]andα,βuncurried versions ofu.#A,u.#Brespectively.Lemmapath_homomorphism_ap_operation(f: ∀s,As→Bs)`{!IsHomomorphismf}: ∀ (u:Symbolσ) (a:FamilyProdA(dom_symboltype(σu))),f(cod_symboltype(σu)) (ap_operationu.#Aa)=ap_operationu.#B(map_family_prodfa).Proof.introsua.byapplypath_oppreserving_ap_operation.Defined.Endhomomorphism_ap_operation.The next section shows that the family of identity functions,λsx,xis an isomorphism.Sectionhom_id.Context{σ} (A:Algebraσ).Global Instanceis_homomorphism_id:IsHomomorphism(λs(x:As),x).Proof.introu.generalizeu.#A.introw.induction(σu).-reflexivity.-byintrox.Defined.Global Instanceis_isomorphism_id:IsIsomorphism(λs(x:As),x).Proof.intros.exact_.Qed.Definitionhom_id:HomomorphismAA:=BuildHomomorphism(λsx,x).Endhom_id.Supposef:∀s,As→Bsis an isomorphism. The following
    section shows that the family of inverse functions,λs,(fs)^-1is an isomorphism.Sectionhom_inv.Context{σ} {AB:Algebraσ}(f: ∀s,As→Bs) `{IsIsomorphismσABf}.Global Instanceis_homomorphism_inv:IsHomomorphism(λs, (fs)^-1).Proof.introu.generalizeu.#Au.#B(oppreserving_homfu).introsabP.induction(σu).-destructP.apply(eissect(ft)).-intro.applyIHs.exact(transport(λy,OpPreservingf_(by))(eisretr(ft)x) (P(_^-1x))).Defined.Global Instanceis_isomorphism_inv:IsIsomorphism(λs, (fs)^-1).Proof.intros.exact_.Qed.Definitionhom_inv:HomomorphismBA:=BuildHomomorphism(λs, (fs)^-1).Endhom_inv.Letf:∀s,As→Bsandg:∀s,Bs→Cs. The
    next section shows that composition given byλ(s:Sortσ),gsofsis again a homomorphism. If bothfandgare
    isomorphisms, then the composition is an isomorphism.Sectionhom_compose.Context{σ} {ABC:Algebraσ}.Lemmaoppreserving_compose(g: ∀s,Bs→Cs) `{!IsHomomorphismg}(f: ∀s,As→Bs) `{!IsHomomorphismf} {w:SymbolTypeσ}(α:OperationAw) (β:OperationBw) (γ:OperationCw)(G:OpPreservinggβγ) (F:OpPreservingfαβ):OpPreserving(λs,gsofs)αγ.Proof.inductionw;simplin*.-bypath_induction.-introx.byapply(IHw_(β(f_x))).Defined.Global Instanceis_homomorphism_compose(g: ∀s,Bs→Cs) `{!IsHomomorphismg}(f: ∀s,As→Bs) `{!IsHomomorphismf}:IsHomomorphism(λs,gsofs).Proof.introu.byapply(oppreserving_composegfu.#Au.#Bu.#C).Defined.Global Instanceis_isomorphism_compose(g: ∀s,Bs→Cs) `{IsIsomorphismσBCg}(f: ∀s,As→Bs) `{IsIsomorphismσABf}:IsIsomorphism(λs,gsofs).Proof.intros.applyisequiv_compose.Qed.Definitionhom_compose(g:HomomorphismBC) (f:HomomorphismAB):HomomorphismAC:=BuildHomomorphism(λs,gsofs).Endhom_compose.The following section shows that there is a path between
    isomorphic algebras.Sectionpath_isomorphism.Context`{Univalence} {σ :Signature} {AB:Algebraσ}.LetFG:I→Type. Iff:∀(i:I),Fi<~>Giis a family of
    equivalences, then by function extensionality composed with
    univalence there is a pathF=G.Local Notationpath_equiv_familyf:= (path_forall__(λi,path_universe(fi))).Given a family of equivalencesf:∀(s:Sortσ),As<~>Bswhich isOpPreservingfαβwith respect to algebra operationsα : A s1 → A s2 → ... → A sn → A t
      β : B s1 → B s2 → ... → B sn → B tBy transportingαalong the pathpath_equiv_familyfwe
    find a path from the transported operationαtoβ.Lemmapath_operations_equiv{w:SymbolTypeσ}(α:OperationAw) (β:OperationBw)(f: ∀ (s:Sortσ),As<~>Bs) (P:OpPreservingfαβ):transport(λC:Carriersσ,OperationCw)(path_equiv_familyf)α=β.Proof.inductionw;simplin*.-transport_path_forall_hammer.exact(ap10(transport_idmap_path_universe(ft))α@P).-funexty.transport_path_forall_hammer.rewritetransport_forall_constant.rewritetransport_arrow_toconst.rewrite(transport_path_universe_V(ft)).applyIHw.specialize(P((ft)^-1y)).byrewrite(eisretr(ft)y)inP.Qed.Supposeu:Symbolσis a function symbol. Recall thatu.#Ais notation foroperationsAu:OperationA(σu). This
    is the algebra operation corresponding to function symbolu.An isomorphismf:∀s,As→Bsinduces a family of
    equivalencese:∀(s:Sortσ),As<~>Bs. Letu:Symbolσbe a function symbol. Sincefis a homomorphism, the induced
    family of equivalencesesatisfiesOpPreservinge(u.#A)(u.#B).
    Bypath_operations_equivabove, we can then transportu.#Aalong
    the pathpath_equiv_familyeand obtain a path tou.#B.Lemmapath_operations_isomorphism(f: ∀s,As→Bs)`{IsIsomorphismσABf} (u:Symbolσ):transport(λC:Carriersσ,OperationC(σu))(path_equiv_family(equiv_isomorphismf))u.#A=u.#B.Proof.byapplypath_operations_equiv.Defined.If there is an isomorphismf:∀s,As→BsthenA=B.Theorempath_isomorphism(f: ∀s,As→Bs) `{IsIsomorphismσABf}:A=B.Proof.apply(path_algebra__(path_equiv_family(equiv_isomorphismf))).(* Make the last part abstract because it relies onpath_operations_equiv,which is opaque. In cases where the involved algebras are set algebras,then this part is a mere proposition. *)abstract(funextu;exact(transport_forall_constant__u@path_operations_isomorphismfu)).Defined.Endpath_isomorphism.

--- Miscellaneous\ua_isomorphic.html ---
ua_isomorphicLibrary ua_isomorphicThis file developsIsomorphic,≅. See ua_homomorphism.v forIsHomomorphismandIsIsomorphism.RequireExportHoTT.Classes.theory.ua_homomorphism.RequireImportHoTT.TypesHoTT.Tactics.Two algebrasAB:Algebraσare isomorphic if there is an
    isomorphism∀s,As→Bs.RecordIsomorphic{σ :Signature} (AB:Algebraσ) :=BuildIsomorphic{def_isomorphic: ∀s,As→Bs;is_homomorphism_isomorphic:IsHomomorphismdef_isomorphic;is_isomorphism_isomorphic:IsIsomorphismdef_isomorphic}.ArgumentsBuildIsomorphic{σAB}def_isomorphic{is_homomorphism_isomorphic} {is_isomorphism_isomorphic}.Argumentsdef_isomorphic{σAB}.Argumentsis_homomorphism_isomorphic{σAB}.Argumentsis_isomorphism_isomorphic{σAB}.Global Existing Instanceis_homomorphism_isomorphic.Global Existing Instanceis_isomorphism_isomorphic.Moduleisomorphic_notations.Global Notation"A ≅ B" := (IsomorphicAB) :Algebra_scope.Endisomorphic_notations.Importisomorphic_notations.DefinitionSigIsomorphic{σ :Signature} (AB:Algebraσ) :={def_iso: ∀s,As→Bs| {_:IsHomomorphismdef_iso|IsIsomorphismdef_iso}}.Lemmaissig_isomorphic{σ :Signature} (AB:Algebraσ):SigIsomorphicAB<~>A≅B.Proof.issig.Defined.Isomorphic algebras can be identifiedA≅B→A=B.Corollaryid_isomorphic`{Univalence} {σ} {AB:Algebraσ} (e:A≅B):A=B.Proof.exact(path_isomorphism(def_isomorphice)).Defined.Identified algebras are isomorophicA=B→A≅BLemmaisomorphic_id{σ} {AB:Algebraσ} (p:A=B) :A≅B.Proof.destructp.exact(BuildIsomorphic(hom_idA)).Defined.To find a path between two witnessesFG:A≅B, it suffices
    to find a path between the defining families of functions and
    theis_homomorphism_homwitnesses.Lemmapath_isomorphic`{Funext} {σ :Signature} {AB:Algebraσ}(FG:A≅B) (a:def_isomorphicF=def_isomorphicG)(b:a#(is_homomorphism_isomorphicF) =is_homomorphism_isomorphicG):F=G.Proof.apply(ap(issig_isomorphicAB)^-1)^-1.srapplypath_sigma.-exacta.-applypath_sigma_hprop.refine(ap_(transport_sigma__) @_).applyb.Defined.SupposeIsHSetAlgebraB. To find a path between two isomorphic
    witnessesFG:A≅B, it suffices to find a path between the
    defining families of functions.Lemmapath_hset_isomorphic`{Funext} {σ :Signature} {AB:Algebraσ}`{IsHSetAlgebraB} (FG:A≅B)(a:def_isomorphicF=def_isomorphicG):F=G.Proof.apply(path_isomorphicFGa).applypath_ishprop.Defined.Sectionpath_def_isomorphic_id_transport.Context{σ :Signature} {AB:Algebraσ}.Lemmapath_def_isomorphic_id_transport_dom(p:A=B):def_isomorphic(isomorphic_idp)=transport(λC, ∀s,Cs→Bs) (apcarriersp)^ (hom_idB).Proof.bypath_induction.Defined.Lemmapath_def_isomorphic_id_transport_cod(p:A=B):def_isomorphic(isomorphic_idp)=transport(λC, ∀s,As→Cs) (apcarriersp) (hom_idA).Proof.bypath_induction.Defined.Endpath_def_isomorphic_id_transport.IfIsHSetAlgebraA, thenpath_isomorphismmaps the identity
    homomorphism ofAto the identity path.(* I suspect that the following lemma holds even whenAis not a setalgebra. To show this,path_isomorphismandpath_operations_equivshould be made transparent, which they are not at the moment. *)Lemmapath_path_isomorphism_hom_id_hset`{Univalence} {σ :Signature}(A:Algebraσ) `{IsHSetAlgebraA}:path_isomorphism(hom_idA) =idpath.Proof.applypath_path_hset_algebra.rewritepath_ap_carriers_path_algebra.apply(paths_ind(λs,idpath) (λf_,path_forallAAf=idpath)).-applypath_forall_1.-intros.funexts.symmetry.rewrite(path_ishprop_(isequiv_idmap(As))).applypath_universe_1.Qed.The following section shows thatisomorphic_idis an equivalence
    with inverseid_isomorphic.Sectionisequiv_isomorphic_id.Context`{Univalence} {σ} (AB:Algebraσ) `{IsHSetAlgebraB}.Lemmasect_id_isomorphic: (@isomorphic_idσAB)oid_isomorphic==idmap.Proof.introF.applypath_hset_isomorphic.rewritepath_def_isomorphic_id_transport_cod.funextsx.rewrite!transport_forall_constant.rewritepath_ap_carriers_path_algebra.transport_path_forall_hammer.applytransport_path_universe.Qed.Lemmasect_isomorphic_id:id_isomorphico(@isomorphic_idσAB) ==idmap.Proof.introp.destructp.applypath_path_isomorphism_hom_id_hset.exact_.Qed.Global Instanceisequiv_isomorphic_id:IsEquiv(@isomorphic_idσAB):=isequiv_adjointifyisomorphic_idid_isomorphicsect_id_isomorphicsect_isomorphic_id.Endisequiv_isomorphic_id.

--- Miscellaneous\ua_prod_algebra.html ---
ua_prod_algebraLibrary ua_prod_algebraRequireImportHoTT.Types.BoolHoTT.Classes.theory.ua_homomorphism.Importalgebra_notationsne_list.notations.The following section defines product algebraProdAlgebra.
    Sectionbin_prod_algebraspecialises the definition to
    binary product algebra.Sectionprod_algebra.Context`{Funext} {σ :Signature} (I:Type) (A:I→Algebraσ).Definitioncarriers_prod_algebra:Carriersσ:=λ(s:Sortσ), ∀ (i:I),Ais.Fixpointop_prod_algebra(w:SymbolTypeσ): (∀i,Operation(Ai)w) →Operationcarriers_prod_algebraw:=matchwreturn(∀i,Operation(Ai)w) →Operationcarriers_prod_algebrawwith| [:_:] =>idmap|_:::g=>λfp,op_prod_algebrag(λi,fi(pi))end.Definitionops_prod_algebra(u:Symbolσ):Operationcarriers_prod_algebra(σu):=op_prod_algebra(σu) (λ(i:I),u.#(Ai)).DefinitionProdAlgebra:Algebraσ:=BuildAlgebracarriers_prod_algebraops_prod_algebra.Global Instancetrunc_prod_algebra{n:trunc_index}`{!∀i,IsTruncAlgebran(Ai)}:IsTruncAlgebranProdAlgebra.Proof.intros.exact_.Qed.Endprod_algebra.The next section defines the product projection homomorphisms.Sectionhom_proj_prod_algebra.Context`{Funext} {σ :Signature} (I:Type) (A:I→Algebraσ).Definitiondef_proj_prod_algebra(i:I) (s:Sortσ) (c:ProdAlgebraIAs):Ais:=ci.Lemmaoppreserving_proj_prod_algebra{w:SymbolTypeσ}(i:I) (v: ∀i:I,Operation(Ai)w) (α:Operation(Ai)w)(P:vi=α):OpPreserving(def_proj_prod_algebrai)(op_prod_algebraIAwv)α.Proof.inductionw.-exactP.-introp.apply(IHw(λi,vi(pi)) (α(pi))).f_ap.Defined.Global Instanceis_homomorphism_proj_prod_algebra(i:I):IsHomomorphism(def_proj_prod_algebrai).Proof.introu.byapplyoppreserving_proj_prod_algebra.Defined.Definitionhom_proj_prod_algebra(i:I):Homomorphism(ProdAlgebraIA) (Ai):=BuildHomomorphism(def_proj_prod_algebrai).Endhom_proj_prod_algebra.The product algebra univarsal mapping propertyump_prod_algebra.Sectionump_prod_algebra.Context`{Funext}{σ :Signature}(I:Type)(A:I→Algebraσ)(C:Algebraσ).Definitionhom_prod_algebra_mapout(f:HomomorphismC(ProdAlgebraIA)) (i:I):HomomorphismC(Ai):=hom_compose(hom_proj_prod_algebraIAi)f.Definitiondef_prod_algebra_mapin(f: ∀ (i:I)s,Cs→Ais): ∀ (s:Sortσ) ,Cs→ProdAlgebraIAs:=λ(s:Sortσ) (x:Cs) (i:I),fisx.Lemmaoppreserving_prod_algebra_mapin{w:SymbolTypeσ}(f: ∀ (i:I)s,Cs→Ais)(α: ∀ (i:I),Operation(Ai)w) (β:OperationCw)(P: ∀ (i:I),OpPreserving(fi)β(αi)):OpPreserving(def_prod_algebra_mapinf)β(op_prod_algebraIAw(λi,αi)).Proof.inductionw.-funexti.applyP.-introx.applyIHw.introi.applyP.Defined.Global Instanceis_homomorphism_prod_algebra_mapin(f: ∀ (i:I),HomomorphismC(Ai)):IsHomomorphism(def_prod_algebra_mapinf).Proof.introu.applyoppreserving_prod_algebra_mapin.introi.applyf.Defined.Definitionhom_prod_algebra_mapin(f: ∀i,HomomorphismC(Ai)):HomomorphismC(ProdAlgebraIA):=BuildHomomorphism(def_prod_algebra_mapinf).Given a family of homomorphismsh:∀(i:I),HomomorphismC(Ai)there is a unique homomorphismf:HomomorphismC(ProdAlgebraIA)such thathi=hom_compose(pri)f, wherepr i = hom_proj_prod_algebra I A iis the ith projection homomorphism.Lemmaump_prod_algebra`{!∀i,IsHSetAlgebra(Ai)}: (∀ (i:I),HomomorphismC(Ai)) <~>HomomorphismC(ProdAlgebraIA).Proof.apply(equiv_adjointifyhom_prod_algebra_mapinhom_prod_algebra_mapout).-introf.byapplypath_hset_homomorphism.-introf.funexti.byapplypath_hset_homomorphism.Defined.Endump_prod_algebra.Binary product algebra.Sectionbin_prod_algebra.Context`{Funext} {σ :Signature} (AB:Algebraσ).Definitionbin_prod_algebras(b:Bool) :Algebraσ:=ifbthenBelseA.Global Instancetrunc_bin_prod_algebras{n:trunc_index}`{!IsTruncAlgebranA} `{!IsTruncAlgebranB}: ∀ (b:Bool),IsTruncAlgebran(bin_prod_algebrasb).Proof.intros[];exact_.Qed.DefinitionBinProdAlgebra:Algebraσ :=ProdAlgebraBoolbin_prod_algebras.Definitionfst_prod_algebra:HomomorphismBinProdAlgebraA:=hom_proj_prod_algebraBoolbin_prod_algebrasfalse.Definitionsnd_prod_algebra:HomomorphismBinProdAlgebraB:=hom_proj_prod_algebraBoolbin_prod_algebrastrue.Endbin_prod_algebra.Moduleprod_algebra_notations.Global Notation"A × B" := (BinProdAlgebraAB) :Algebra_scope.Endprod_algebra_notations.Importprod_algebra_notations.Specialisation of the product algebra univarsal mapping property
    to binary product.Sectionump_bin_prod_algebra.Context`{Funext}{σ :Signature}(ABC:Algebraσ)`{!IsHSetAlgebraA} `{!IsHSetAlgebraB}.Lemmaump_bin_prod_algebra:HomomorphismCA*HomomorphismCB<~>HomomorphismC(A×B).Proof.set(k:=λ(b:Bool),HomomorphismC(bin_prod_algebrasABb)).exact(equiv_compose(ump_prod_algebraBool(bin_prod_algebrasAB)C)(equiv_bool_forall_prodk)^-1).Defined.Endump_bin_prod_algebra.

--- Miscellaneous\ua_quotient_algebra.html ---
ua_quotient_algebraLibrary ua_quotient_algebraRequireImportBasics.Notations.RequireExportHoTT.Classes.interfaces.ua_congruence.RequireImportHSetColimits.QuotientSpaces.List.CoreClasses.interfaces.canonical_namesClasses.theory.ua_homomorphism.Local OpenScopelist_scope.Importalgebra_notationsne_list.notations.Sectionquotient_algebra.Context`{Funext} {σ :Signature} (A:Algebraσ)(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}.The quotient algebra carriers is the family of set-quotients
    induced byΦ.Definitioncarriers_quotient_algebra:Carriersσ:=λs,Quotient(Φs).Specialization ofquotient_ind_prop. SupposeP:FamilyProdcarriers_quotient_algebraw→Typeand∀a,IsHProp(Pa). To show thatPaholds for alla:FamilyProdcarriers_quotient_algebraw, it is sufficient to show
    thatP(class_of_x1,...,class_of_xn,tt)holds for all(x1,...,xn,tt):FamilyProdAw.Fixpointquotient_ind_prop_family_prod{w:list(Sortσ)}: ∀ (P:FamilyProdcarriers_quotient_algebraw→Type)`{!∀a,IsHProp(Pa)}(dclass: ∀x,P(map_family_prod(λs,class_of(Φs))x))(a:FamilyProdcarriers_quotient_algebraw),Pa:=matchwwith|nil=>λP_dclass'tt,dclasstt|s::w'=>λP_dclassa,Quotient_ind_hprop(Φs) (λa, ∀b,P(a,b))(λa,quotient_ind_prop_family_prod(λc,P(class_of(Φs)a,c)) (λc,dclass(a,c)))(fsta) (snda)end.Letf:OperationAw,g:Operationcarriers_quotient_algebraw.
    Ifgis the quotient algebra operation induced byf, then we wantComputeOpQuotientfgto hold, since thenβ (class_of _ a1, class_of _ a2, ..., class_of _ an)
      = class_of _ (α (a1, a2, ..., an)),whereαis the uncurriedfoperation andβis the uncurriedgoperation.DefinitionComputeOpQuotient{w:SymbolTypeσ}(f:OperationAw) (g:Operationcarriers_quotient_algebraw):= ∀ (a:FamilyProdA(dom_symboltypew)),ap_operationg(map_family_prod(λs,class_of(Φs))a)=class_of(Φ(cod_symboltypew)) (ap_operationfa).Local NotationQuotOpw:=(∀ (f:OperationAw),OpCompatibleAΦf→∃g:Operationcarriers_quotient_algebraw,ComputeOpQuotientfg) (onlyparsing).Local Notationop_qalg_consqfPx:=(q_(fx) (op_compatible_consΦ__fxP)).1 (onlyparsing).Lemmaop_quotient_algebra_well_def(q: ∀ (w:SymbolTypeσ),QuotOpw)(s:Sortσ) (w:SymbolTypeσ) (f:OperationA(s:::w))(P:OpCompatibleAΦf) (xy:As) (C:Φsxy):op_qalg_consqfPx=op_qalg_consqfPy.Proof.apply(@path_forall_ap_operation_σ).applyquotient_ind_prop_family_prod;tryexact_.introa.destruct(q__(op_compatible_consΦswfxP))as[g1P1].destruct(q__(op_compatible_consΦswfyP))as[g2P2].refine((P1a) @_@ (P2a)^).applyqglue.exact(P(x,a) (y,a) (C,reflexive_for_all_2_family_prodAΦa)).Defined.(* Given an operationf:As1→As2→...Asn→Atand a witnessC:OpCompatibleAΦf, thenop_quotient_algebrafCis adependent pair with first component an operationg:Qs1→Qs2→...Qsn→Qt, whereQ:=carriers_quotient_algebra, andsecond component a proof ofComputeOpQuotientfg. The firstcomponentgis the quotient algebra operation corresponding tof.The second component proof ofComputeOpQuotientfgis passed totheop_quotient_algebra_well_deflemma, which is used to show thatthe quotient algebra operationgis well defined, i.e. that<<Φ s1 x1 y1 ∧ Φ s2 x2 y2 ∧ ... ∧ Φ sn xn yn>>implies<<g (class_of _ x1) (class_of _ x2) ... (class_of _ xn)= g (class_of _ y1) (class_of _ y2) ... (class_of _ yn).>>*)Fixpointop_quotient_algebra{w:SymbolTypeσ} :QuotOpw.Proof.refine(matchwreturnQuotOpwwith| [:s:] =>λ(f:As)P, (class_of(Φs)f;λa,idpath)|s:::w'=>λ(f:As→OperationAw')P,(Quotient_rec(Φs)_(λ(x:As),op_qalg_consop_quotient_algebrafPx)(op_quotient_algebra_well_defop_quotient_algebrasw'fP);_)end).intros[xa].apply(op_quotient_algebraw'(fx) (op_compatible_consΦsw'fxP)).Defined.Definitionops_quotient_algebra(u:Symbolσ):Operationcarriers_quotient_algebra(σu):= (op_quotient_algebrau.#A(ops_compatible_congAΦu)).1.Definition of quotient algebra. See Lemmacompute_op_quotientbelow for the computation rule of quotient algebra operations.DefinitionQuotientAlgebra:Algebraσ:=BuildAlgebracarriers_quotient_algebraops_quotient_algebra.The quotient algebra carriers are always sets.Global Instancehset_quotient_algebra:IsHSetAlgebraQuotientAlgebra.Proof.intros.exact_.Qed.The following lemma gives the computation rule for the quotient
    algebra operations. It says that for(a1,a2,...,an):As1*As2*...*Asn,β (class_of _ a1, class_of _ a2, ..., class_of _ an)
      = class_of _ (α (a1, a2, ..., an))whereαis the uncurriedu.#Aoperation andβis the
    uncurriedu.#QuotientAlgebraoperation.Lemmacompute_op_quotient(u:Symbolσ):ComputeOpQuotientu.#Au.#QuotientAlgebra.Proof.applyop_quotient_algebra.Defined.Endquotient_algebra.Modulequotient_algebra_notations.Global Notation"A / Φ" := (QuotientAlgebraAΦ) :Algebra_scope.Endquotient_algebra_notations.Importquotient_algebra_notations.The next section shows that A/Φ = A/Ψ wheneverΦsxy<->Ψsxyfor alls,x,y.Sectionpath_quotient_algebra.Context{σ :Signature} (A:Algebraσ)(Φ: ∀s,Relation(As)) {CΦ:IsCongruenceAΦ}(Ψ: ∀s,Relation(As)) {CΨ:IsCongruenceAΨ}.Lemmapath_quotient_algebra`{Funext} (p:Φ=Ψ) :A/Φ=A/Ψ.Proof.bydestructp, (path_ishpropCΦCΨ).Defined.Lemmapath_quotient_algebra_iff`{Univalence}(R: ∀sxy,Φsxy<->Ψsxy):A/Φ=A/Ψ.Proof.applypath_quotient_algebra.funextsxy.refine(path_universe_uncurried_).applyequiv_iff_hprop;applyR.Defined.Endpath_quotient_algebra.The following section defines the quotient homomorphismhom_quotient:HomomorphismA(A/Φ).Sectionhom_quotient.Context`{Funext} {σ} {A:Algebraσ}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}.Definitiondef_hom_quotient: ∀ (s:Sortσ),As→ (A/Φ)s:=λsx,class_of(Φs)x.Lemmaoppreserving_quotient`{Funext} (w:SymbolTypeσ)(g:Operation(A/Φ)w) (α:OperationAw)(G:ComputeOpQuotientAΦαg):OpPreservingdef_hom_quotientαg.Proof.unfoldComputeOpQuotientinG.inductionw;cbnin*.-bydestruct(Gtt)^.-introx.applyIHw.introa.apply(G(x,a)).Defined.Global Instanceis_homomorphism_quotient`{Funext}:IsHomomorphismdef_hom_quotient.Proof.introu.applyoppreserving_quotient,compute_op_quotient.Defined.Definitionhom_quotient:HomomorphismA(A/Φ):=BuildHomomorphismdef_hom_quotient.Global Instancesurjection_quotient: ∀s,IsSurjection(hom_quotients).Proof.intros.applyissurj_class_of.Qed.Endhom_quotient.IfΦsxyimpliesx=y, then homomorphismhom_quotientΦis an isomorphism.Global Instanceis_isomorphism_quotient`{Univalence}{σ :Signature} {A:Algebraσ} (Φ: ∀s,Relation(As))`{!IsCongruenceAΦ} (P: ∀sxy,Φsxy→x=y):IsIsomorphism(hom_quotientΦ).Proof.intros.applyisequiv_surj_emb; [exact_|].applyisembedding_isinj_hset.introsxyp.byapplyP, (related_quotient_paths(Φs)).Qed.This section develops the universal mapping propertyump_quotient_algebraof the quotient algebra.Sectionump_quotient_algebra.Context`{Univalence} {σ} {AB:Algebraσ} `{!IsHSetAlgebraB}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}.In the nested section below we show that iff:HomomorphismABmaps elements related byΦto equal elements, there is aHomomorphism(A/Φ)Bout of the quotient algebra satisfyingcompute_quotient_algebra_mapoutbelow.Sectionquotient_algebra_mapout.Context(f:HomomorphismAB)(R: ∀s(xy:As),Φsxy→fsx=fsy).Definitiondef_hom_quotient_algebra_mapout: ∀ (s:Sortσ), (A/Φ)s→Bs:=λs, (equiv_quotient_ump(Φs) (Build_HSet(Bs)))^-1 (fs;Rs).Lemmaoppreserving_quotient_algebra_mapout{w:SymbolTypeσ}(g:Operation(A/Φ)w) (α:OperationAw) (β:OperationBw)(G:ComputeOpQuotientAΦαg) (P:OpPreservingfαβ):OpPreservingdef_hom_quotient_algebra_mapoutgβ.Proof.unfoldComputeOpQuotientinG.inductionw;cbnin*.-destruct(Gtt)^.applyP.-refine(Quotient_ind_hprop(Φt)__).introx.apply(IHw(g(class_of(Φt)x)) (αx) (β(ftx))).+introa.apply(G(x,a)).+applyP.Defined.Global Instanceis_homomorphism_quotient_algebra_mapout:IsHomomorphismdef_hom_quotient_algebra_mapout.Proof.introu.eapplyoppreserving_quotient_algebra_mapout.-applycompute_op_quotient.-applyf.Defined.Definitionhom_quotient_algebra_mapout:Homomorphism(A/Φ)B:=BuildHomomorphismdef_hom_quotient_algebra_mapout.The computation rule forhom_quotient_algebra_mapoutishom_quotient_algebra_mapout s (class_of (Φ s) x) = f s x.Lemmacompute_quotient_algebra_mapout: ∀ (s:Sortσ) (x:As),hom_quotient_algebra_mapouts(class_of(Φs)x) =fsx.Proof.reflexivity.Defined.Endquotient_algebra_mapout.Definitionhom_quotient_algebra_mapin(g:Homomorphism(A/Φ)B):HomomorphismAB:=hom_composeg(hom_quotientΦ).Lemmaump_quotient_algebra_lr:{f:HomomorphismAB| ∀s(xy:As),Φsxy→fsx=fsy}→Homomorphism(A/Φ)B.Proof.intros[fP].exists(hom_quotient_algebra_mapoutfP).exact_.Defined.Lemmaump_quotient_algebra_rl:Homomorphism(A/Φ)B→{f:HomomorphismAB| ∀s(xy:As),Φsxy→fsx=fsy}.Proof.introg.exists(hom_quotient_algebra_maping).introssxyE.exact(transport(λz,gs(class_of(Φs)x) =gsz)(qglueE)idpath).Defined.The universal mapping property of the quotient algebra. For each
    homomorphismf:HomomorphismAB, mapping elements related byΦto equal elements, there is a unique homomorphismg:Homomorphism(A/Φ)Bsatisfyingf = hom_compose g (hom_quotient Φ).Lemmaump_quotient_algebra: {f:HomomorphismAB| ∀s(xy:As),Φsxy→fsx=fsy}<~>Homomorphism(A/Φ)B.Proof.apply(equiv_adjointifyump_quotient_algebra_lrump_quotient_algebra_rl).-introG.applypath_hset_homomorphism.funexts.exact(eissect(equiv_quotient_ump(Φs)_) (Gs)).-introF.applypath_sigma_hprop.byapplypath_hset_homomorphism.Defined.Endump_quotient_algebra.

--- Miscellaneous\ua_second_isomorphism.html ---
ua_second_isomorphismLibrary ua_second_isomorphismThe second isomorphism theoremisomorphic_second_isomorphism.RequireImportBasics.NotationsHSetColimits.QuotientClasses.interfaces.canonical_namesClasses.theory.ua_isomorphicClasses.theory.ua_subalgebraClasses.theory.ua_quotient_algebra.Importalgebra_notationsquotient_algebra_notationssubalgebra_notationsisomorphic_notations.Local Notationi:= (hom_inc_subalgebra__).This section definescong_traceand proves that it is a
    congruence, the restriction of a congruence to a subalgebra.Sectioncong_trace.Context{σ :Signature} {A:Algebraσ}(P: ∀s,As→Type) `{!IsSubalgebraPredicateAP}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}.Definitioncong_trace(s:Sortσ) (x: (A&&P)s) (y: (A&&P)s):=Φs(isx) (isy).Global Instanceequiv_rel_trace_congruence(s:Sortσ):EquivRel(cong_traces).Proof.unfoldcong_trace.constructor.-intros[yY].reflexivity.-intros[y1Y1] [y2Y2]S.bysymmetry.-intros[y1Y1] [y2Y2] [y3Y3]ST.bytransitivityy2.Qed.Lemmafor_all_2_family_prod_trace_congruence{w:SymbolTypeσ}(ab:FamilyProd(A&&P) (dom_symboltypew))(R:for_all_2_family_prod(A&&P) (A&&P)cong_traceab):for_all_2_family_prodAAΦ(map_family_prodia) (map_family_prodib).Proofwithtryassumption.inductionw...destructaas[xa],bas[yb],Ras[CR].split...applyIHw...Qed.Global Instanceops_compatible_trace_trace:OpsCompatible(A&&P)cong_trace.Proof.introsuabR.refine(transport(λX,Φ_X_)(path_homomorphism_ap_operationiua)^_).refine(transport(λX,Φ__X)(path_homomorphism_ap_operationiub)^_).apply(ops_compatible_congAΦ).exact(for_all_2_family_prod_trace_congruenceabR).Qed.Global Instanceis_congruence_trace:IsCongruence(A&&P)cong_trace.Proof.apply(@BuildIsCongruence_(A&&P)cong_trace);[intros;apply(is_mere_relation_congAΦ) |exact_..].Qed.Endcong_trace.The following section defines theis_subalgebra_classsubalgebra
    predicate, which induces a subalgebra ofA/Φ.Sectionis_subalgebra_class.Context`{Univalence}{σ :Signature} {A:Algebraσ}(P: ∀s,As→Type) `{!IsSubalgebraPredicateAP}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}.Definitionis_subalgebra_class(s:Sortσ) (x: (A/Φ)s) :HProp:=hexists(λ(y: (A&&P)s),in_class(Φs)x(isy)).Lemmaop_closed_subalgebra_is_subalgebra_class{w:SymbolTypeσ}(γ:Operation(A/Φ)w)(α:OperationAw)(Q:ComputeOpQuotientAΦαγ)(C:ClosedUnderOpAPα):ClosedUnderOp(A/Φ)is_subalgebra_classγ.Proof.inductionw.-specialize(Qtt).applytr.exists(α;C).cbninQ.destructQ^.exact(EquivRel_Reflexiveα).-refine(Quotient_ind_hprop(Φt)__).introx.refine(Trunc_rec_).intros[yR].apply(IHw(γ(class_of(Φt)x)) (α(ity))).+introa.destruct(qglueR)^.apply(Q(ity,a)).+applyC.exacty.2.Qed.Definitionis_closed_under_ops_is_subalgebra_class:IsClosedUnderOps(A/Φ)is_subalgebra_class.Proof.introu.eapplyop_closed_subalgebra_is_subalgebra_class.-applycompute_op_quotient.-applyis_closed_under_ops_subalgebra_predicate.exact_.Qed.Global Instanceis_subalgebra_predicate_is_subalgebra_class:IsSubalgebraPredicate(A/Φ)is_subalgebra_class.Proof.applyBuildIsSubalgebraPredicate.applyis_closed_under_ops_is_subalgebra_class.Qed.Endis_subalgebra_class.The next section proves the second isomorphism theorem,(A&&P) / (cong_trace P Φ) ≅ (A/Φ) && (is_subalgebra_class P Φ).(* There is an alternative proof using the first isomorphism theorem,but the direct proof below seems simpler in HoTT. *)Sectionsecond_isomorphism.Context`{Univalence}{σ :Signature} (A:Algebraσ)(P: ∀s,As→Type) `{!IsSubalgebraPredicateAP}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}.Local NotationΨ:= (cong_tracePΦ).Local NotationQ:= (is_subalgebra_classPΦ).Definitiondef_second_isomorphism(s:Sortσ): ((A&&P) /Ψ)s→ ((A/Φ) &&Q)s:=Quotient_rec(Ψs)_(λ(x: (A&&P)s),(class_of(Φs) (isx);tr(x;EquivRel_Reflexivex)))(λ(xy: (A&&P)s) (T:Ψsxy),path_sigma_hprop(class_of(Φs) (isx);_)(class_of(Φs) (isy);_) (@qglue_(Φs)__T)).Lemmaoppreserving_second_isomorphism{w:SymbolTypeσ}(α:OperationAw) (γ:Operation(A/Φ)w)(ζ:Operation((A&&P) /Ψ)w) (CA:ClosedUnderOp(A/Φ)Qγ)(CB:ClosedUnderOpAPα) (QA:ComputeOpQuotientAΦαγ)(QB:ComputeOpQuotient(A&&P)Ψ(op_subalgebraAPαCB)ζ):OpPreservingdef_second_isomorphismζ(op_subalgebra(A/Φ)QγCA).Proof.unfoldComputeOpQuotientin*.inductionw;cbnin*.-applypath_sigma_hprop.cbn.destruct(QBtt)^, (QAtt)^.byapplyqglue.-refine(Quotient_ind_hprop(Ψt)__).introx.apply(IHw(α(itx)) (γ(class_of(Φt) (itx)))(ζ(class_of(Ψt)x))(CA(class_of(Φt) (itx)) (tr(x;_)))(CB(itx)x.2)).+introa.exact(QA(itx,a)).+introa.exact(QB(x,a)).Defined.Global Instanceis_homomorphism_second_isomorphism:IsHomomorphismdef_second_isomorphism.Proof.introu.eapplyoppreserving_second_isomorphism.-apply(compute_op_quotientA).-apply(compute_op_quotient(A&&P)).Defined.Definitionhom_second_isomorphism:Homomorphism((A&&P) /Ψ) ((A/Φ) &&Q):=BuildHomomorphismdef_second_isomorphism.Global Instanceembedding_second_isomorphism(s:Sortσ):IsEmbedding(hom_second_isomorphisms).Proof.applyisembedding_isinj_hset.refine(Quotient_ind_hprop(Ψs)__).introx.refine(Quotient_ind_hprop(Ψs)__).introsyp.applyqglue.exact(related_quotient_paths(Φs) (isx) (isy) (p..1)).Qed.Global Instancesurjection_second_isomorphism(s:Sortσ):IsSurjection(hom_second_isomorphisms).Proof.applyBuildIsSurjection.intros[yS].generalizedependentS.generalizedependenty.refine(Quotient_ind_hprop(Φs)__).introsyS.refine(Trunc_rec_S).intros[y'S'].applytr.exists(class_of_y').applypath_sigma_hprop.byapplyqglue.Qed.Theoremis_isomorphism_second_isomorphism:IsIsomorphismhom_second_isomorphism.Proof.intros.applyisequiv_surj_emb;exact_.Qed.Global Existing Instanceis_isomorphism_second_isomorphism.Theoremisomorphic_second_isomorphism: (A&&P) /Ψ≅ (A/Φ) &&Q.Proof.exact(BuildIsomorphicdef_second_isomorphism).Defined.Corollaryid_second_isomorphism: (A&&P) /Ψ= (A/Φ) &&Q.Proof.exact(id_isomorphicisomorphic_second_isomorphism).Defined.Endsecond_isomorphism.

--- Miscellaneous\ua_setalgebra.html ---
ua_setalgebraLibrary ua_setalgebraThis file definesSetAlgebra, a specializedAlgebrawhere
    the carriers are always sets.RequireExportHoTT.Classes.interfaces.ua_algebra.RecordSetAlgebra{σ :Signature} :Type:=BuildSetAlgebra{algebra_setalgebra:Algebraσ;is_hset_algebra_setalgebra:IsHSetAlgebraalgebra_setalgebra}.ArgumentsSetAlgebra:clearimplicits.Global Existing Instanceis_hset_algebra_setalgebra.Global Coercionalgebra_setalgebra:SetAlgebra>->Algebra.To find a pathA=Bbetween set algebrasAB:SetAlgebraσ,
    it is enough to find a path between the defining algebras,algebra_setalgebraA=algebra_setalgebraB.Lemmapath_setalgebra`{Funext} {σ} (AB:SetAlgebraσ)(p:algebra_setalgebraA=algebra_setalgebraB):A=B.Proof.destructAas[AAH],Bas[BBH].cbnin*.transparentassert(a: (p#AH=BH))byapplypath_ishprop.bypath_induction.Defined.The id path is mapped to the id path bypath_setalgebra.Lemmapath_setalgebra_1`{Funext} {σ} (A:SetAlgebraσ):path_setalgebraAAidpath=idpath.Proof.transparentassert(p:(∀I:IsHSetAlgebraA,path_ishpropII=idpath)).-intros.applypath_ishprop.-unfoldpath_setalgebra.byrewritep.Qed.The functionpath_setalgebraABis an equivalence with inverseapalgebra_setalgebra.Global Instanceisequiv_path_setalgebra`{Funext} {σ :Signature}(AB:SetAlgebraσ):IsEquiv(path_setalgebraAB).Proof.refine(isequiv_adjointify(path_setalgebraAB) (apalgebra_setalgebra)__).-abstract(introp;inductionp;byrewritepath_setalgebra_1).-abstract(introe;destructAas[AAH],Bas[BBH];cbnine;destructe;unfoldpath_setalgebra;bydestructpath_ishprop).Defined.

--- Miscellaneous\ua_subalgebra.html ---
ua_subalgebraLibrary ua_subalgebraRequireImportHoTT.Universes.HPropHoTT.TypesHoTT.Classes.theory.ua_homomorphism.Importalgebra_notationsne_list.notations.Sectionclosed_under_op.Context`{Funext} {σ} (A:Algebraσ) (P: ∀s,As→Type).Letα:As1→As2→...→Asn→Atbe an algebra
      operation. ThenPsatisfiesClosedUnderOpαiff
      forx1:As1,x2:As2, ...,xn:Asn,P s1 x1 ∧ P s2 x2 ∧ ... ∧ P sn xnimpliesP t (α x1 x2 ... xn)FixpointClosedUnderOp{w:SymbolTypeσ} :OperationAw→Type:=matchwwith| [:s:] =>Ps|s:::w'=>λ(α:As→OperationAw'),∀ (x:As),Psx→ClosedUnderOp(αx)end.Global Instancetrunc_closed_under_op{n} `{∀sx,IsTruncn(Psx)}{w:SymbolTypeσ} (α:OperationAw):IsTruncn(ClosedUnderOpα).Proof.inductionw;cbn;exact_.Qed.DefinitionIsClosedUnderOps:Type:= ∀ (u:Symbolσ),ClosedUnderOpu.#A.Global Instancetrunc_is_closed_under_ops{n} `{∀sx,IsTruncn(Psx)}:IsTruncnIsClosedUnderOps.Proof.applyistrunc_forall.Qed.Endclosed_under_op.P:∀s,As→Typeis a subalgebra predicate if it is closed
    under operationsIsClosedUnderOpsAPandPsxis an h-prop.Sectionsubalgebra_predicate.Context{σ} (A:Algebraσ) (P: ∀s,As→Type).ClassIsSubalgebraPredicate:=BuildIsSubalgebraPredicate{hprop_subalgebra_predicate: ∀sx,IsHProp(Psx);is_closed_under_ops_subalgebra_predicate:IsClosedUnderOpsAP}.Global Instancehprop_is_subalgebra_predicate`{Funext}:IsHPropIsSubalgebraPredicate.Proof.applyhprop_allpath.intros[x1x2] [y1y2].bydestruct(path_ishpropx1y1), (path_ishpropx2y2).Defined.Endsubalgebra_predicate.Global ArgumentsBuildIsSubalgebraPredicate{σAPhprop_subalgebra_predicate}.Global Existing Instancehprop_subalgebra_predicate.The next section defines subalgebra.Sectionsubalgebra.Context{σ :Signature} (A:Algebraσ)(P: ∀s,As→Type) `{!IsSubalgebraPredicateAP}.The subalgebra carriers is the family of subtypes defined byP.Definitioncarriers_subalgebra:Carriersσ:=λ(s:Sortσ), {x|Psx}.Letα:As1→...→Asn→Atbe an operation and letC:ClosedUnderOpAPα. The corresponding subalgebra operationop_subalgebraαC:(A&P)s1→...→(A&P)sn→(A&P)tis
    given byop_subalgebra α C (x1; p1) ... (xn; pn) =
        (α x1 ... xn; C x1 p1 x2 p2 ... xn pn).Fixpointop_subalgebra{w:SymbolTypeσ}: ∀ (α:OperationAw),ClosedUnderOpAPα→Operationcarriers_subalgebraw:=matchwwith| [:t:] =>λαc, (α;c)|s:::w'=>λαcx,op_subalgebra(αx.1) (cx.1x.2)end.The subalgebra operationsops_subalgebraare defined in terms ofop_subalgebra.Definitionops_subalgebra(u:Symbolσ):Operationcarriers_subalgebra(σu):=op_subalgebrau.#A(is_closed_under_ops_subalgebra_predicateAPu).DefinitionSubalgebra:Algebraσ:=BuildAlgebracarriers_subalgebraops_subalgebra.Global Instancetrunc_subalgebra{n:trunc_index}`{!IsTruncAlgebran.+1A}:IsTruncAlgebran.+1Subalgebra.Proof.poseproof(hprop_subalgebra_predicateAP).intros.apply@istrunc_sigma.-exact_.-intro.inductionn;exact_.Qed.Endsubalgebra.Modulesubalgebra_notations.Notation"A && P" := (SubalgebraAP) :Algebra_scope.Endsubalgebra_notations.Importsubalgebra_notations.The following section defines the inclusion homomorphismHomomorphism(A&P)A, and some related results.Sectionhom_inc_subalgebra.Context{σ :Signature} (A:Algebraσ)(P: ∀s,As→Type) `{!IsSubalgebraPredicateAP}.Definitiondef_inc_subalgebra(s:Sortσ) : (A&&P)s→As:=pr1.Lemmaoppreserving_inc_subalgebra{w:SymbolTypeσ}(α:OperationAw) (C:ClosedUnderOpAPα):OpPreservingdef_inc_subalgebra(op_subalgebraAPαC)α.Proof.inductionw.-reflexivity.-introsx.applyIHw.Defined.Global Instanceis_homomorphism_inc_subalgebra:IsHomomorphismdef_inc_subalgebra.Proof.introu.applyoppreserving_inc_subalgebra.Defined.Definitionhom_inc_subalgebra:Homomorphism(A&&P)A:=BuildHomomorphismdef_inc_subalgebra.Lemmais_isomorphism_inc_improper_subalgebra(improper: ∀s(x:As),Psx):IsIsomorphismhom_inc_subalgebra.Proof.intros.refine(isequiv_adjointify_(λx, (x;impropersx))__).-introx.reflexivity.-introx.byapplypath_sigma_hprop.Qed.Endhom_inc_subalgebra.The next section provides paths between subalgebras. These paths
    are convenient to have because the implicit type-class argumentIsClosedUnderOpsofSubalgebrais complicating things.Sectionpath_subalgebra.Context{σ :Signature} (A:Algebraσ)(P: ∀s,As→Type) {CP:IsSubalgebraPredicateAP}(Q: ∀s,As→Type) {CQ:IsSubalgebraPredicateAQ}.Lemmapath_subalgebra`{Funext} (p:P=Q) :A&&P=A&&Q.Proof.bydestructp, (path_ishpropCPCQ).Defined.Lemmapath_subalgebra_iff`{Univalence} (R: ∀sx,Psx<->Qsx):A&&P=A&&Q.Proof.applypath_subalgebra.funextsx.apply(@path_universe___(fst(Rsx))).apply(equiv_equiv_iff_hprop__(Rsx)).Defined.Endpath_subalgebra.

--- Miscellaneous\ua_third_isomorphism.html ---
ua_third_isomorphismLibrary ua_third_isomorphismThis file proves the third isomorphism theorem,isomorphic_third_isomorphism.RequireImportBasics.NotationsColimits.QuotientClasses.interfaces.canonical_namesClasses.theory.ua_quotient_algebraClasses.theory.ua_isomorphicClasses.theory.ua_first_isomorphismSpaces.List.Core.Importalgebra_notationsquotient_algebra_notationsisomorphic_notations.This section defines the quotientcong_quotientof two
    congruencesΦandΨ, whereΨis a subcongruence ofΦ.
    It is shown thatcong_quotientis a congruence.Sectioncong_quotient.Context`{Univalence}{σ :Signature} {A:Algebraσ}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}(Ψ: ∀s,Relation(As)) `{!IsCongruenceAΨ}(subrel: ∀ (s:Sortσ) (xy:As),Ψsxy→Φsxy).Definitioncong_quotient(_: ∀sxy,Ψsxy→Φsxy)(s:Sortσ) (ab: (A/Ψ)s):= ∀ (xy:As),in_class(Ψs)ax→in_class(Ψs)by→Φsxy.Global Instanceequivalence_relation_quotient(s:Sortσ):EquivRel(cong_quotientsubrels).Proof.constructor.-refine(Quotient_ind_hprop(Ψs)__).introsxyzPQ.applysubrel.bytransitivityx.-refine(Quotient_ind_hprop(Ψs)__).introx1.refine(Quotient_ind_hprop(Ψs)__).introsx2Cy1y2PQ.symmetry.byapplyC.-refine(Quotient_ind_hprop(Ψs)__).introx1.refine(Quotient_ind_hprop(Ψs)__).introx2.refine(Quotient_ind_hprop(Ψs)__).introsx3CDy1y2PQ.transitivityx2.+exact(Cy1x2P(EquivRel_Reflexivex2)).+exact(Dx2y2(EquivRel_Reflexivex2)Q).Defined.Lemmafor_all_relation_quotient{w:list(Sortσ)} (ab:FamilyProdAw):for_all_2_family_prod(A/Ψ) (A/Ψ) (cong_quotientsubrel)(map_family_prod(λs,class_of(Ψs))a)(map_family_prod(λs,class_of(Ψs))b) →for_all_2_family_prodAAΦab.Proof.introF.inductionw;cbnin*.-constructor.-destructaas[xa],bas[yb],Fas[QF].split.+applyQ;simpl;reflexivity.+byapplyIHw.Qed.Global Instanceops_compatible_quotient:OpsCompatible(A/Ψ) (cong_quotientsubrel).Proof.introsu.refine(quotient_ind_prop_family_prodAΨ__).introa.refine(quotient_ind_prop_family_prodAΨ__).introb.(* It should not be necessary to provide the explicit types: *)destruct(compute_op_quotientAΨua:ap_operation(u.#(A/Ψ))(map_family_prod(λs,class_of(Ψs))_) =_)^.destruct(compute_op_quotientAΨub:ap_operation(u.#(A/Ψ))(map_family_prod(λs,class_of(Ψs))_) =_)^.introsRxyPQ.applysubrelinP.applysubrelinQ.transitivity(ap_operationu.#Aa).-bysymmetry.-transitivity(ap_operationu.#Ab);tryassumption.apply(ops_compatibleAΦu).byapplyfor_all_relation_quotient.Defined.Global Instanceis_congruence_quotient:IsCongruence(A/Ψ) (cong_quotientsubrel):=BuildIsCongruence(A/Ψ) (cong_quotientsubrel).Endcong_quotient.Sectionthird_isomorphism.Context`{Univalence}{σ :Signature} {A:Algebraσ}(Φ: ∀s,Relation(As)) `{!IsCongruenceAΦ}(Ψ: ∀s,Relation(As)) `{!IsCongruenceAΨ}(subrel: ∀ (s:Sortσ) (xy:As),Ψsxy→Φsxy).Lemmathird_surjecton_well_def(s:Sortσ)(xy:As) (P:Ψsxy):class_of(Φs)x=class_of(Φs)y.Proof.applyqglue.exact(subrelsxyP).Defined.Definitiondef_third_surjection(s:Sortσ) : (A/Ψ)s→ (A/Φ)s:=Quotient_rec(Ψs)_(class_of(Φs)) (third_surjecton_well_defs).Lemmaoppreserving_third_surjection{w:SymbolTypeσ} (f:OperationAw): ∀ (α:Operation(A/Φ)w) (Qα:ComputeOpQuotientAΦfα)(β:Operation(A/Ψ)w) (Qβ:ComputeOpQuotientAΨfβ),OpPreservingdef_third_surjectionβα.Proof.inductionw.-refine(Quotient_ind_hprop(Φt)__).introsαQα.refine(Quotient_ind_hprop(Ψt)__).introsβQβ.applyqglue.transitivityf.+applysubrel.apply(related_quotient_paths(Ψt)).exact(Qβtt).+apply(related_quotient_paths(Φt)).symmetry.exact(Qαtt).-introsαQαβQβ.refine(Quotient_ind_hprop(Ψt)__).introx.exact(IHw(fx) (α(class_of(Φt)x)) (λa,Qα(x,a))(β(class_of(Ψt)x)) (λa,Qβ(x,a))).Defined.Global Instanceis_homomorphism_third_surjection:IsHomomorphismdef_third_surjection.Proof.introu.eapplyoppreserving_third_surjection;applycompute_op_quotient.Defined.Definitionhom_third_surjection:Homomorphism(A/Ψ) (A/Φ):=BuildHomomorphismdef_third_surjection.Global Instancesurjection_third_surjection(s:Sortσ):IsSurjection(hom_third_surjections).Proof.applyBuildIsSurjection.refine(Quotient_ind_hprop(Φs)__).introx.applytr.byexists(class_of(Ψs)x).Qed.Local NotationΘ:= (cong_quotientΦΨsubrel).Lemmapath_quotient_algebras_third_surjection:A/Ψ/cong_kerhom_third_surjection=A/Ψ/Θ.Proof.applypath_quotient_algebra_iff.introssxy.split;generalizedependenty;generalizedependentx;refine(Quotient_ind_hprop(Ψs)__);introx;refine(Quotient_ind_hprop(Ψs)__);introy.-introsKx'y'CxCy.applysubrelinCx.applysubrelinCy.apply(related_quotient_paths(Φs))inK.transitivityx.+bysymmetry.+bytransitivityy.-introT.applyqglue.exact(Txy(EquivRel_Reflexivex) (EquivRel_Reflexivey)).Defined.Definitionhom_third_isomorphism:Homomorphism(A/Ψ/Θ) (A/Φ):=transport(λX,HomomorphismX(A/Φ))path_quotient_algebras_third_surjection(hom_first_isomorphism_surjectionhom_third_surjection).Theoremis_isomorphism_third_isomorphism:IsIsomorphismhom_third_isomorphism.Proof.unfoldhom_third_isomorphism.destructpath_quotient_algebras_third_surjection.exact_.Qed.Global Existing Instanceis_isomorphism_third_isomorphism.The third isomorphism theorem.Corollaryisomorphic_third_isomorphism:A/Ψ/Θ≅A/Φ.Proof.exact(BuildIsomorphichom_third_isomorphism).Defined.Corollaryid_third_isomorphism:A/Ψ/Θ=A/Φ.Proof.exact(id_isomorphicisomorphic_third_isomorphism).Defined.Endthird_isomorphism.

--- Miscellaneous\unique_choice.html ---
unique_choiceLibrary unique_choiceRequireImportHoTT.BasicsHoTT.Truncations.Core.Definitionatmost1X:=(forallx1x2:X, (x1=x2)).Definitionatmost1P{X} (P:X->Type):=(forallx1x2:X,Px1->Px2-> (x1=x2)).Definitionhunique{X} (P:X->Type):=(hexistsP) * (atmost1PP).Lemmaatmost{X} {P:X->Type}:(forallx,IsHProp(Px)) -> (atmost1PP) ->atmost1(sigP).introsHH0[xp] [yq].specialize(H0xypq).inductionH0.assert(H0: (p=q))byapplypath_ishprop.byinductionH0.Qed.Lemmaiota{X} (P:X->Type):(forallx,IsHProp(Px)) -> (huniqueP) ->sigP.Proof.introsH1[HH0].apply(@Trunc_rec(-1) (sigP) );auto.byapplyhprop_allpath,atmost.Qed.Lemmaunique_choice{XY} (R:X->Y->Type) :(forallxy,IsHProp(Rxy)) -> (forallx, (hunique(Rx)))-> {f:X->Y&forallx, (Rx(fx))}.introsX0X1.exists(funx:X=> (pr1(iota_(X0x) (X1x)))).introx.apply(pr2(iota_(X0x) (X1x))).Qed.

--- Miscellaneous\Unit.html ---
UnitLibrary UnitTheorems about the unit typeRequireImportBasics.OvertureBasics.Equivalences.Local OpenScopepath_scope.LocalSetUniverseMinimizationToSet.Generalizable VariablesA.Eta conversionDefinitioneta_unit(z:Unit) :tt=z:=matchzwithtt=> 1end.Paths(* This is all kind of ridiculous, but it fits the pattern. *)Definitionpath_unit_uncurried(zz':Unit) :Unit->z=z':=fun_=>matchz,z'withtt,tt=> 1end.Definitionpath_unit(zz':Unit) :z=z':=path_unit_uncurriedzz'tt.Definitioneta_path_unit{zz':Unit} (p:z=z') :path_unitzz'=p.Proof.destructp.destructz.reflexivity.Defined.Global Instanceisequiv_path_unit(zz':Unit) :IsEquiv(path_unit_uncurriedzz') | 0.Proof.refine(Build_IsEquiv__(path_unit_uncurriedzz') (fun_=>tt)(funp:z=z'=>matchpin(_=z')return(path_unit_uncurriedzz'tt=p)with|idpath=>matchzaszreturn(path_unit_uncurriedzztt= 1)with|tt=> 1endend)(funx=>matchxwithtt=> 1end)_).intros[];destructz,z';reflexivity.Defined.Definitionequiv_path_unit(zz':Unit) :Unit<~> (z=z'):=Build_Equiv__(path_unit_uncurriedzz')_.TransportIs a special case of transporting in a constant fibration.Universal mapping properties(* The positive universal property *)ArgumentsUnit_ind[A]au:rename.Global Instanceisequiv_unit_ind`{Funext} (A:Unit->Type):IsEquiv(@Unit_indA) | 0:=isequiv_adjointify_(funf:forallu:Unit,Au=>ftt)(funf:forallu:Unit,Au=>path_forall(@Unit_indA(ftt))f(funx=>matchxwithtt=> 1end))(fun_=> 1).Global Instanceisequiv_unit_rec`{Funext} (A:Type):IsEquiv(@Unit_ind(fun_=>A)) | 0:=isequiv_unit_ind(fun_=>A).#[local]HintExtern4 =>progress(cbvbetaiota) :typeclass_instances.Definitionequiv_unit_rec`{Funext} (A:Type):A<~> (Unit->A):= (Build_Equiv__(@Unit_ind(fun_=>A))_).(* For various reasons, it is typically more convenient to define functions out of the unit as constant maps, rather thanUnit_ind. *)Notationunit_namex:= (fun(_:Unit) =>x).Global Instanceisequiv_unit_name@{ij} `{Funext} (A:Type@{i}): @IsEquiv@{ij}_(Unit->_) (fun(a:A) =>unit_namea).Proof.refine(isequiv_adjointify_(funf:Unit->_=>ftt)__).-introsf;applypath_forall@{iij};introsx.applyap@{ii},path_unit.-introsa;reflexivity.Defined.(* The negative universal property *)Definitionunit_coind{A:Type} :Unit-> (A->Unit):=fun__=>tt.Global Instanceisequiv_unit_coind`{Funext} (A:Type) :IsEquiv(@unit_coindA) | 0.Proof.refine(isequiv_adjointify_(funf=>tt)__).-introf.applypath_forall;introsx;applypath_unit.-introx;destructx;reflexivity.Defined.Definitionequiv_unit_coind`{Funext} (A:Type):Unit<~> (A->Unit):=Build_Equiv__(@unit_coindA)_.Truncation(* The Unit type is contractible *)Global Instancecontr_unit:ContrUnit| 0 :=Build_Contr_tt(funt:Unit=>matchtwithtt=> 1end).EquivalencesA contractible type is equivalent toUnit.Definitionequiv_contr_unit`{ContrA} :A<~>Unit:=equiv_contr_contr.(* Conversely, a type equivalent toUnitis contractible. We don't make this an instance because Coq would have to guess the equivalence.  And when it has a map in mind, it would try to useisequiv_contr_contr, which would cause a cycle. *)Definitioncontr_equiv_unit(A:Type) (f:A<~>Unit) :ContrA:=contr_equiv'Unitf^-1%equiv.The constant map toUnit.  We define this so we can get rid of an unneeded universe variable that Coq generates whenconstttis used in a context that doesn't haveUniverseMinimizationToSetas this file does. If we ever set that globally, then we could get rid of this and remove some imports of this file.Definitionconst_tt(A:Type) := @constAUnittt.

--- Miscellaneous\UnitCat.html ---
UnitCatLibrary UnitCatRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.Unit categoryGlobal Instanceisgraph_unit:IsGraphUnit.Proof.applyBuild_IsGraph.intros;exactUnit.Defined.Global Instanceis01cat_unit:Is01CatUnit.Proof.srapplyBuild_Is01Cat.all:intros;exacttt.Defined.Global Instanceis0gpd_unit:Is0GpdUnit.Proof.constructor;intros;exacttt.Defined.Global Instanceis2graph_unit:Is2GraphUnit:=funfg=>isgraph_unit.Global Instanceis1cat_unit:Is1CatUnit.Proof.econstructor.1,2:econstructor.all:intros;exacttt.Defined.

--- Miscellaneous\UnitCounit.html ---
UnitCounitLibrary UnitCounitAdjunctions by units and counitsRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportCategory.DualFunctor.DualNaturalTransformation.Dual.RequireImportFunctor.Composition.CoreFunctor.Identity.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopecategory_scope.Local OpenScopemorphism_scope.SectionAdjunction.Unit + UMP definition of adjunctionQuoting from Awodey's "Category Theory":An adjunction between categoriesCandDconsists of
      functorsF:C<->D:Gand a natural transformationT:1_C->G∘Fwith the property:(o) For anyc:C,d:D, andf:c->Gd, there exists a
          uniqueg:Fc->dsuch thatf=(Gg)∘(Tc)as
          indicated ing
     F c ..................> d

                 G g
     G (F c) --------------> G d
       ^                    _
       |                    /|
       |                  /
       |                /
       |              /
       | T c        /
       |          /  f
       |        /
       |      /
       |    /
       |  /
        cTerminology and notation:Fis called the left adjoint,Gis called the right
       adjoint, andTis called the unit of the adjunction.One sometimes writesF-|Gfor ``Fis left andGright
       adjoint.''The statement (o) is the UMP of the unitT.Note that the situationF⊣Gis a generalization of
     equivalence of categories, in that a pseudo-inverse is an
     adjoint. In that case, however, it is the relation between
     categories that one is interested in. Here, one is concerned with
     the relation between special functors. That is to say, it is not
     the relation on categories ``there exists an adjunction,'' but
     rather ``this functor has an adjoint'' that we are concerned
     with.Sectionunit.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.DefinitionAdjunctionUnit:={T:NaturalTransformation1 (GoF)|forall(c:C) (d:D) (f:morphismCc(Gd)),Contr{g:morphismD(Fc)d|G_1goTc=f}}.Endunit.Counit + UMP definition of adjunctionParaphrasing and quoting from Awody's "Category Theory":An adjunction between categoriesCandDconsists of functorsF:C<->D:Gand a natural transformationU:F∘G->1_Dwith the property:(o) For anyc:C,d:D, andg:Fc->d, there exists a
         uniquef:c->Gdsuch thatg=(Ud)∘(Ff)as
         indicated in the diagramf
     c ..................> G d

               F f
     F c --------------> F (G d)
      \                    |
        \                  |
          \                |
            \              |
              \            | U d
             g  \          |
                  \        |
                    \      |
                      \    |
                       _\| V
                          dTerminology and notation:The statement (o) is the UMP of the counitU.Sectioncounit.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.DefinitionAdjunctionCounit:={U:NaturalTransformation(FoG) 1|forall(c:C) (d:D) (g:morphismD(Fc)d),Contr{f:morphismCc(Gd) |UdoF_1f=g}}.Endcounit.The counit is just the dual of the unit.  We formalize this here
      so that we can use it to make coercions easier.Sectionunit_counit_op.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.Definitionadjunction_counit__op__adjunction_unit(A:AdjunctionUnitG^opF^op):AdjunctionCounitFG:=exist(funU:NaturalTransformation(FoG) 1 =>forall(c:C) (d:D) (g:morphismD(Fc)d),Contr{f:morphismCc(Gd)|UdoF_1f=g})(A.1^op)%natural_transformation(funcdg=>A.2dcg).Definitionadjunction_counit__op__adjunction_unit__inv(A:AdjunctionUnitGF):AdjunctionCounitF^opG^op:=exist(funU:NaturalTransformation(F^opoG^op) 1=>forall(c:C^op) (d:D^op) (g:morphismD^op((F^op)%functorc)d),Contr{f:morphismC^opc((G^op)%functord)|UdoF^op_1f=g})(A.1^op)%natural_transformation(funcdg=>A.2dcg).Definitionadjunction_unit__op__adjunction_counit(A:AdjunctionCounitG^opF^op):AdjunctionUnitFG:=exist(funT:NaturalTransformation1 (GoF) =>forall(c:C) (d:D) (f:morphismCc(Gd)),Contr{g:morphismD(Fc)d|G_1goTc=f})(A.1^op)%natural_transformation(funcdg=>A.2dcg).Definitionadjunction_unit__op__adjunction_counit__inv(A:AdjunctionCounitGF):AdjunctionUnitF^opG^op:=exist(funT:NaturalTransformation1 (G^opoF^op)=>forall(c:C^op) (d:D^op) (f:morphismC^opc((G^op)%functord)),Contr{g:morphismD^op((F^op)%functorc)d|G^op_1goTc=f})(A.1^op)%natural_transformation(funcdg=>A.2dcg).Endunit_counit_op.Unit + Counit + Zig + Zag definition of adjunctionQuoting Wikipedia on Adjoint Functors:A counit-unit adjunction between two categoriesCandDconsists of two functorsF:C←DandG:C→Dand two
      natural transformationsε : FG → 1_C
      η : 1_D → GFrespectively called the counit and the unit of the adjunction
      (terminology from universal algebra), such that the compositionsF η            ε F
      F -------> F G F -------> F

          η G            G ε
      G -------> G F G -------> Gare the identity transformations1_Fand1_GonFandGrespectively.In this situation we say that ``Fis left adjoint toG'' and
      ''Gis right adjoint toF'', and may indicate this
      relationship by writing(ε,η):F⊣G, or simplyF⊣G.In equation form, the above conditions on (ε, η) are the
      counit-unit equations1_F = ε F ∘ F η
      1_G = G ε ∘ η Gwhich mean that for eachXinCand eachYinD,1_{FY} = ε_{FY} ∘ F(η_Y)
      1_{GX} = G(ε_X) ∘ η_{GX}These equations are useful in reducing proofs about adjoint
      functors to algebraic manipulations.  They are sometimes called
      the ``zig-zag equations'' because of the appearance of the
      corresponding string diagrams.  A way to remember them is to
      first write down the nonsensical equation1=ε∘ηand then
      fill in eitherForGin one of the two simple ways which
      make the compositions defined.Note: The use of the prefix ``co'' in counit here is not
      consistent with the terminology of limits and colimits, because
      a colimit satisfies an initial property whereas the counit
      morphisms will satisfy terminal properties, and dually.  The
      term unit here is borrowed from the theory of monads where it
      looks like the insertion of the identity 1 into a monoid.Sectionunit_counit.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.(*Local Reserved Notation "'ε'".Local Reserved Notation "'η'".*)Use the per-object version of the equations, so that we don't
        need the associator in the middle.  Also, explicitly simplify
        some of the types so thatrewriteworks better.RecordAdjunctionUnitCounit:={unit:NaturalTransformation(identityC) (GoF)(*where "'η'" := unit*);counit:NaturalTransformation(FoG) (identityD)(*where "'ε'" := counit*);unit_counit_equation_1:forallY:C,(*ε (F Y) ∘ F ₁ (η Y) = identity (F Y);*)Category.Core.compose(C:=D) (s:=FY) (d:=F(G(FY))) (d':=FY)(counit(FY))(F_1(unitY:morphism_Y(G(FY))))= 1;unit_counit_equation_2:forallX:D,(* G ₁ (ε X) ∘ η (G X) = identity (G X) *)Category.Core.compose(C:=C) (s:=GX) (d:=G(F(GX))) (d':=GX)(G_1(counitX:morphism_(F(GX))X))(unit(GX))= 1}.Endunit_counit.EndAdjunction.Declare Scopeadjunction_scope.DelimitScopeadjunction_scopewithadjunction.Bind Scopeadjunction_scopewithAdjunctionUnit.Bind Scopeadjunction_scopewithAdjunctionCounit.Bind Scopeadjunction_scopewithAdjunctionUnitCounit.Argumentsunit[CD]%_category[FG]%_functor_%_adjunction/ .Argumentscounit[CD]%_category[FG]%_functor_%_adjunction/ .ArgumentsAdjunctionUnitCounit[CD]%_category(FG)%_functor.Argumentsunit_counit_equation_1[CD]%_category[FG]%_functor_%_adjunction_%_object.Argumentsunit_counit_equation_2[CD]%_category[FG]%_functor_%_adjunction_%_object.

--- Miscellaneous\UnitCounitCoercions.html ---
UnitCounitCoercionsLibrary UnitCounitCoercionsCoercions between the various (co)unit definitionsRequireImportCategory.CoreFunctor.CoreNaturalTransformation.Core.RequireImportAdjoint.UnitCounitAdjoint.Dual.RequireImportFunctor.Composition.CoreFunctor.Identity.RequireImportHoTT.TacticsBasics.TruncTypes.Sigma.RequireImportBasics.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopenatural_transformation_scope.Local OpenScopecategory_scope.Local OpenScopemorphism_scope.Sectionequivalences.Sectionfrom_unit_counit.Local Ltacunit_counit_of_t:=repeatmatchgoalwith|_=>split|_=>intro|_=>progressautowithmorphism|_=>progresssimpl|_=>rewrite!composition_of| [ |-context[components_of?T] ]=> (try_associativity_quicksimplrewrite<- (commutesT));try_associativity_quickprogressrewrite?unit_counit_equation_1, ?unit_counit_equation_2| [ |-context[components_of?T] ]=> (try_associativity_quicksimplrewrite(commutesT));try_associativity_quickprogressrewrite?unit_counit_equation_1, ?unit_counit_equation_2|_=>progresspath_inductionend.unit+counit+zig+zag → unit+UMPDefinitionadjunction_unit__of__adjunction_unit_counitCDFG(A: @AdjunctionUnitCounitCDFG):AdjunctionUnitFG.Proof.exists(unitA).introscdf.applycontr_inhabited_hprop;[applyhprop_allpath| (exists(counitAdoF_1f));abstractunit_counit_of_t].intros[? ?] [? ?].applypath_sigma_uncurried.letA:=matchgoalwith|- @sig?A?P=>constr:(A)endinletH:=freshinassert(H:A);[|existsH;exact(center_) ].simpl.letx:=matchgoalwith|- ?x= ?y=>constr:(x)endinlety:=matchgoalwith|- ?x= ?y=>constr:(y)endinrewrite<- (right_identity___x),<- (right_identity___y),<- !(unit_counit_equation_1A),<- ?associativity;repeatsimplrewrite<- (commutes(counitA));(try_associativity_quickrewrite<- !composition_of);repeatapplyap;etransitivity; [ |symmetry];eassumption.Defined.unit+counit+zig+zag → counit+UMPDefinitionadjunction_counit__of__adjunction_unit_counitCDFG(A: @AdjunctionUnitCounitCDFG):AdjunctionCounitFG:=adjunction_counit__op__adjunction_unit(adjunction_unit__of__adjunction_unit_counitA^op).Endfrom_unit_counit.Sectionto_unit_counit.Ltacto_unit_counit_nthelpercommutes_tac:=simpl;intros;applyhelper;repeatmatchgoalwith|_=>reflexivity|_=>rewrite!composition_of|_=>progressrewrite?identity_of, ?left_identity, ?right_identity| [ |-context[?x.1] ]=>try_associativity_quicksimplrewritex.2| [ |-context[components_of?T] ]=>simpl_do_clearcommutes_tac(commutesT)end.unit+UMP → unit+counit+zig+zagSectionfrom_unit.VariablesCD:PreCategory.VariableF:FunctorCD.VariableG:FunctorDC.Lemmacounit_natural_transformation__of__adjunction_unit_helper(A:AdjunctionUnitFG)sd(m:morphismDsd)(eta:=A.1)(eps:=funX=> (@center_(A.2 (GX)X1)).1):G_1(epsdoF_1(G_1m))oeta(Gs) =G_1m->G_1(moepss)oeta(Gs) =G_1m->epsdoF_1(G_1m) =moepss.Proof.intros.transitivity(@center_(A.2__(G_1m))).1; [symmetry| ];letx:=matchgoalwith|-_= ?x=>constr:(x)endinrefine((funH=>appr1(@contr_(A.2__(G_1m)) (x;H)))_);assumption.Qed.Definitioncounit_natural_transformation__of__adjunction_unit(A:AdjunctionUnitFG):NaturalTransformation(FoG) 1.Proof.refine(Build_NaturalTransformation(FoG) 1(fund=> (@center_(A.2 (Gd)d1)).1)_).abstract(to_unit_counit_ntcounit_natural_transformation__of__adjunction_unit_helperltac:(funH=>try_associativity_quickrewrite<-H)).Defined.Definitionzig__of__adjunction_unit(A:AdjunctionUnitFG)(Y:C)(eta:=A.1)(eps:=funX=> (@center_(A.2 (GX)X1)).1):G_1(eps(FY)oF_1(etaY))oetaY=etaY->eps(FY)oF_1(etaY) = 1.Proof.intros.etransitivity; [symmetry| ];simpl_do_clearltac:(funH=>applyH)(funyH=> (@contr_(A.2__(A.1Y)) (y;H))..1);tryassumption.simpl.rewrite?identity_of, ?left_identity, ?right_identity;reflexivity.Qed.Definitionadjunction_unit_counit__of__adjunction_unit(A:AdjunctionUnitFG):AdjunctionUnitCounitFG.Proof.existsA.1(counit_natural_transformation__of__adjunction_unitA);simpl;intros;trymatchgoalwith| [ |-context[?x.1] ] =>exactx.2end;[].abstract(to_unit_counit_ntzig__of__adjunction_unitltac:(funH=>try_associativity_quickrewrite<-H)).Defined.Endfrom_unit.counit+UMP → unit+counit+zig+zagDefinitionadjunction_unit_counit__of__adjunction_counitCDFG(A: @AdjunctionCounitCDFG):AdjunctionUnitCounitFG:= ((adjunction_unit_counit__of__adjunction_unit(adjunction_unit__op__adjunction_counit__invA))^op)%adjunction.Endto_unit_counit.Endequivalences.Coercionadjunction_unit__of__adjunction_unit_counit:AdjunctionUnitCounit>->AdjunctionUnit.Coercionadjunction_counit__of__adjunction_unit_counit:AdjunctionUnitCounit>->AdjunctionCounit.

--- Miscellaneous\Univalence.html ---
UnivalenceLibrary UnivalenceRequireImportTypes.Universe.To assume the Univalence axiom outright, import this file. (Doing this instead of simply positing Univalence directly avoids creating multiple witnesses for the axiom in different developments.)Axiomunivalence_axiom:Univalence.Global Existing Instanceunivalence_axiom.

--- Miscellaneous\UnivalenceImpliesFunext.html ---
UnivalenceImpliesFunextLibrary UnivalenceImpliesFunextRequireImportHoTT.Basics.RequireImportTypes.Universe.RequireImportMetatheory.CoreMetatheory.FunextVarieties.Generalizable All Variables.Univalence Implies Functional ExtensionalitySectionUnivalenceImpliesFunext.Context`{ua:Univalence_type}.Exponentiation preserves equivalences, i.e., ifeis an equivalence then so is post-composition bye.(* Should this go somewhere else? *)Theoremunivalence_isequiv_postcompose`{H0:IsEquivABw}C:IsEquiv(fun(g:C->A) =>wog).Proof.unfoldUnivalence_typein*.refine(isequiv_adjointify(fun(g:C->A) =>wog)(fun(g:C->B) =>w^-1og)__);intro;pose(Build_Equiv__w_)asw';changeH0with(@equiv_isequiv__w');changewwith(@equiv_fun__w');clearbodyw';clearH0w;rewrite<- (@eisretr__(@equiv_pathAB) (uaAB)w');generalize((@equiv_inv__(equiv_pathAB) (uaAB))w');introp;clearw';destructp;reflexivity.Defined.We are ready to prove functional extensionality, starting with the naive non-dependent version.Local Instanceisequiv_src_composeAB: @IsEquiv(A-> {xy:B*B&fstxy=sndxy})(A->B)(fung=> (fstopr1)og).Proof.rapply@univalence_isequiv_postcompose.refine(isequiv_adjointify(fstopr1) (funx=> ((x,x);idpath))(fun_=>idpath)_);letp:=freshinintros[[? ?]p];simplinp;destructp;reflexivity.Defined.Local Instanceisequiv_tgt_composeAB: @IsEquiv(A-> {xy:B*B&fstxy=sndxy})(A->B)(fung=> (sndopr1)og).Proof.rapply@univalence_isequiv_postcompose.refine(isequiv_adjointify(sndopr1) (funx=> ((x,x);idpath))(fun_=>idpath)_);letp:=freshinintros[[? ?]p];simplinp;destructp;reflexivity.Defined.TheoremUnivalence_implies_FunextNondep:NaiveNondepFunext.Proof.introsABfgp.Consider the following maps.pose(d:=funx:A=>exist(funxy=>fstxy=sndxy) (fx,fx) (idpath(fx))).pose(e:=funx:A=>exist(funxy=>fstxy=sndxy) (fx,gx) (px)).If we composedandewithfree_path_target, we getfandg, respectively. So, if we had a path fromdtoe, we would get one fromftog.changefwith((sndopr1)od).changegwith((sndopr1)oe).rapply(ap(fung=>sndopr1og)).Since composition withsrcis an equivalence, we can freely compose withsrc.pose(funABxy=> @equiv_inv___(@isequiv_ap___(@isequiv_src_composeAB)xy))asH'.applyH'.reflexivity.Defined.EndUnivalenceImpliesFunext.Now we use this to prove strong dependent funext.  Again only the codomain universe must be univalent, but the domain universe must be no larger than it is.  Thus practically speaking this means that a univalent universe satisfies funext only for functions between two types in that same universe.DefinitionUnivalence_implies_WeakFunext:Univalence_type->WeakFunext:=NaiveNondepFunext_implies_WeakFunexto@Univalence_implies_FunextNondep.DefinitionUnivalence_type_implies_Funext_type`{ua:Univalence_type@{jjplusone} }:Funext_type@{ijj}:=NaiveNondepFunext_implies_Funext(@Univalence_implies_FunextNondepua).The above proof justifies assumingUnivalence->Funext, which we did axiomatically inTypes/Universe.v.

--- Miscellaneous\UnivalenceVarieties.html ---
UnivalenceVarietiesLibrary UnivalenceVarietiesVarieties of univalenceRequireImportHoTT.BasicsHoTT.Types.RequireImportIdempotents.RequireImportMetatheory.Core.Local OpenScopepath_scope.A weaker form that only asserts that we can make equivalences into paths with a computation rule (no uniqueness rule).DefinitionWeakUnivalence:={etop:forallAB, (A<~>B) -> (A=B) &forallAB(f:A<~>B),equiv_pathAB(etopABf) =f}.The same thing, stated with an incoherent notion of equivalence but a pointwise equality for the computation rule.DefinitionIncoherentWeakUnivalence:={etop:forallAB(f:A->B) (g:B->A),(fog==idmap) -> (gof==idmap) -> (A=B) &forallABfgHK,equiv_pathAB(etopABfgHK) ==f}.Finally, it even suffices to consider only just a few special cases. This is due to Ian Orton and Andrew Pitts.RecordVeryWeakUnivalence:={unit:forallA,A= {a:A&Unit};flip:forallAB(C:A->B->Type),{a:A& {b:B&Cab}} = {b:B& {a:A&Cab}};contract:forallA,ContrA->A=Unit;unit_comp:forallAa,transportidmap(unitA)a= (a;tt);flip_comp:forallABC(a:A) (b:B) (c:Cab),transportidmap(flipABC) (a; (b;c)) = (b; (a;c))}.TheoremWeakUnivalence_implies_Univalence:WeakUnivalence->Univalence_type.Proof.intros[etopH]A.applyisequiv_from_functor_sigma.srapplyisequiv_contr_contr.srapply(contr_retracttype(Build_RetractOf__(funBe=> (Be.1 ;equiv_pathABe.1Be.2))(funBf=> (Bf.1 ;etopABf.1Bf.2))_)).intros[Bf].refine(path_sigma'(funB=>A<~>B) 1 (HABf)).Defined.For this one and the next one, we need to assume funext to start with (so that these forms of univalence, unlike the usual one, probably don't suffice to prove funext from).TheoremIncoherentWeakUnivalence_implies_Univalence`{Funext} :IncoherentWeakUnivalence->Univalence_type.Proof.intros[etopK].applyWeakUnivalence_implies_Univalence.transparentassert(etop': (forallAB, (A<~>B) -> (A=B))).{introsABf.refine(etopABff^-1__).-introsx;applyeisretr.-introsx;applyeissect. }existsetop'.introsABf.applypath_equiv,path_arrow,K.Defined.TheoremVeryWeakUnivalence_implies_Univalence`{Funext} :VeryWeakUnivalence->Univalence_type.Proof.introsvwu.applyWeakUnivalence_implies_Univalence.simplerefine(_;_).{introsABf.refine(unitvwuA@_@ (unitvwuB)^).refine(_@flipvwuAB(funab=>fa=b) @_).-applyap,path_arrow;introsa.symmetry;rapply(contractvwu).-applyap,path_arrow;introsb.apply(contractvwu);exact_. }{introsABf.applypath_equiv,path_arrow;introsa;cbn.rewrite!transport_pp.refine(moveR_transport_Vidmap(unitvwuB)_(fa)_).rewrite!(unit_compvwu).rewrite<- !(transport_composeidmapsig).rewrite(transport_sigma'(C:=funP(a0:A) =>Pa0));cbn.refine(ap__@_).1:{applyap,ap.exact(path_contr_(fa; 1)). }rewrite(flip_compvwu).rewritetransport_sigma';cbn.applyap,path_contr. }Defined.

--- Miscellaneous\Univalent.html ---
UnivalentLibrary UnivalentSaturation of the Grothendieck Construction of a functor to SetRequireImportCategory.CoreFunctor.Core.RequireImportCategory.Univalent.RequireImportCategory.Morphisms.RequireImportSetCategory.Core.RequireImportGrothendieck.ToSet.CoreGrothendieck.ToSet.Morphisms.RequireImportHoTT.Basics.EquivalencesHoTT.Basics.Trunc.RequireImportHoTT.Types.UniverseHoTT.Types.Sigma.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.SectionGrothendieck.Context`{Funext}.VariableC:PreCategory.Context`{IsCategoryC}.VariableF:FunctorCset_cat.Definitioncategory_isotoid_helper{sd} (a:cs=cd): (transport(func:C=>Fc)a(xs) =xd)<~> (F_1(idtoisoCa)) (xs) =xd.Proof.applyequiv_path.applyap10,ap.destructa;simpl.exact(ap10(identity_ofF_)^_).Defined.Argumentscategory_isotoid_helper:simplnever.Definitioncategory_isotoid{sd:categoryF}:s=d<~> (s<~=~>d)%category.Proof.refine(isequiv_sigma_category_isomorphism^-1oE_oE(equiv_ap'(issig_pairF)^-1sd)).refine(_oE(equiv_path_sigma___)^-1).simpl.simplerefine(equiv_functor_sigma'__).{exists(@idtoisoC__).exact_. }{exactcategory_isotoid_helper. }Defined.Global Instancepreservation:IsCategory(categoryF).Proof.introssd.refine(@isequiv_homotopic__category_isotoid(idtoiso(categoryF) (x:=s) (y:=d))__).introx.destructx;applypath_isomorphic,path_sigma_hprop.reflexivity.Defined.EndGrothendieck.

--- Miscellaneous\Universal.html ---
UniversalLibrary UniversalUniversal properties of product categoriesRequireImportCategory.CoreFunctor.CoreCategory.ProdFunctor.Composition.CoreFunctor.Prod.Core.RequireImportFunctor.Paths.RequireImportTypes.ProdHoTT.TacticsTypes.ForallTypes.Sigma.RequireImportBasics.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local Notationfst_type:=Basics.Overture.fst.Local Notationsnd_type:=Basics.Overture.snd.Local Notationpair_type:=Basics.Overture.pair.Local Notationprod_type:=Basics.Overture.prod.Local OpenScopemorphism_scope.Local OpenScopefunctor_scope.Sectionuniversal.Context`{Funext}.VariablesABC:PreCategory.Local OpenScopefunctor_scope.Sectionuniversal.Variablea:FunctorCA.Variableb:FunctorCB.fst∘(a*b)=aLemmacompose_fst_prod:fsto(a*b) =a.Proof.path_functor;trivial.Defined.snd∘(a*b)=bLemmacompose_snd_prod:sndo(a*b) =b.Proof.path_functor;trivial.Defined.Sectionunique.VariableF:FunctorC(A*B).HypothesisH1:fstoF=a.HypothesisH2:sndoF=b.Lemmaunique_helperc: (a*b)c=Fc.Proof.poseproof(ap(funF=>object_ofFc)H1).poseproof(ap(funF=>object_ofFc)H2).simplin*.path_induction.applyeta_prod.Defined.Lemmaunique_helper2:transport(funGO:C->prod_typeAB=>forallsd:C,morphismCsd->prod_type(morphismA(fst_type(GOs)) (fst_type(GOd)))(morphismB(snd_type(GOs)) (snd_type(GOd))))(path_forall(a*b)Funique_helper)(fun(sd:C) (m:morphismCsd) =>pair_type(a_1m) (b_1m)) =morphism_ofF.Proof.repeat(applypath_forall;intro).repeatmatchgoalwith|_=>reflexivity|_=>progresssimpl|_=>rewrite!transport_forall_constantend.transport_path_forall_hammer.unfoldunique_helper.repeatmatchgoalwith| [H:_=_|-_] =>caseH;simpl;clearHend.repeatmatchgoalwith| [ |-context[@morphism_of?C?D?F?s?d?m] ]=>destruct(@morphism_ofCDFsdm);clearm| [ |-context[@object_of?C?D?F?x] ]=>destruct(@object_ofCDFx);clearxend.reflexivity.Qed.Lemmaunique:a*b=F.Proof.path_functor.exists(path_forall__unique_helper).applyunique_helper2.Defined.Endunique.Local OpenScopecore_scope.Universal property characterizing unique product of functorsGlobal Instancecontr_prod_type`{IsHSet(FunctorCA),IsHSet(FunctorCB)}:Contr{F:FunctorC(A*B)|fstoF=a/\sndoF=b}.Proof.refine(Build_Contr_(a*b; (compose_fst_prod,compose_snd_prod))_).introy.applypath_sigma_uncurried.simpl.exists(unique(fst_typey.2) (snd_typey.2)).exact(center_).Qed.Enduniversal.Classification of path space of functors to a product precategoryDefinitionpath_prod(FG:FunctorC(A*B))(H1:fstoF=fstoG)(H2:sndoF=sndoG):F=G.Proof.etransitivity; [symmetry| ];applyunique;tryeassumption;reflexivity.Defined.Enduniversal.

--- Miscellaneous\UniversalMorphisms.html ---
UniversalMorphismsLibrary UniversalMorphismsAdjunctions as universal morphismsDefinitionsRequireAdjoint.UniversalMorphisms.Core.IncludeAdjoint.UniversalMorphisms.Core.

--- Miscellaneous\UniversalProperties.html ---
UniversalPropertiesLibrary UniversalPropertiesUniversal morphismsRequireImportCategory.CoreFunctor.Core.RequireImportCategory.DualFunctor.Dual.RequireImportCategory.Objects.RequireImportInitialTerminalCategory.CoreInitialTerminalCategory.Functors.RequireComma.Core.LocalSetWarningsAppend"-notation-overridden".(* work around bug 5567, https://coq.inria.fr/bugs/show_bug.cgi?id=5567, notation-overridden,parsing should not trigger for only printing notations *)ImportComma.Core.LocalSetWarningsAppend"notation-overridden".RequireImportTruncTypes.SigmaHoTT.Tactics.RequireImportBasics.Tactics.SetUniversePolymorphism.Set Implicit Arguments.Generalizable All Variables.SetAsymmetricPatterns.Local OpenScopemorphism_scope.SectionUniversalMorphism.Quoting Wikipedia:Suppose thatU:D→Cis a functor from a categoryDto a
      categoryC, and letXbe an object ofC.  Consider the
      following dual (opposite) notions:Local Ltacuniv_hprop_tUniversalProperty:=apply@istrunc_succinUniversalProperty;eapply@istrunc_sigma;first[intro;simpl;matchgoalwith| [ |-context[?mo1] ]=>simplrewrite(right_identity___m)| [ |-context[1o?m] ]=>simplrewrite(left_identity___m)end;assumption|bytypeclasseseauto].Initial morphismsSectionInitialMorphism.DefinitionVariablesCD:PreCategory.VariableX:C.VariableU:FunctorDC.An initial morphism fromXtoUis an initial object in
        the category(X↓U)of morphisms fromXtoU.  In other
        words, it consists of a pair(A,φ)whereAis an object
        ofDandφ:X→UAis a morphism inC, such that the
        following initial property is satisfied:WheneverYis an object ofDandf:X→UYis a
         morphism inC, then there exists a unique morphismg:A→Ysuch that the following diagram commutes:φ
         X -----> U A       A
          \        .        .
            \      . U g    . g
           f  \    .        .
               ↘   ↓        ↓
                 U Y        YDefinitionIsInitialMorphism(Ap:object(X/U)) :=IsInitialObject(X/U)Ap.Introduction ruleSectionIntroductionAbstractionBarrier.DefinitionBuild_IsInitialMorphism(*(Ap : Object (X ↓ U))*)(A:D)(* := CCO_b Ap*)(p:morphismCX(UA))(*:= CCO_f Ap*)(Ap:=CommaCategory.Build_object!XUttAp)(UniversalProperty:forall(A':D) (p':morphismCX(UA')),Contr{m:morphismDAA'|U_1mop=p'}):IsInitialMorphismAp.Proof.introx.specialize(UniversalProperty(CommaCategory.bx) (CommaCategory.fx)).We want to preserve the computation rules for the morphisms, even though they're unique up to unique isomorphism.eapplyistrunc_equiv_istrunc.-applyCommaCategory.issig_morphism.-applycontr_inhabited_hprop.+abstractuniv_hprop_tUniversalProperty.+ (existstt).(exists(@center_UniversalProperty).1).abstract(progressrewrite?right_identity, ?left_identity;exact(@center_UniversalProperty).2).Defined.DefinitionBuild_IsInitialMorphism_curried(A:D)(p:morphismCX(UA))(Ap:=CommaCategory.Build_object!XUttAp)(m:forall(A':D) (p':morphismCX(UA')),morphismDAA')(H:forall(A':D) (p':morphismCX(UA')),U_1(mA'p')op=p')(H':forall(A':D) (p':morphismCX(UA'))m',U_1m'op=p'->mA'p'=m'):IsInitialMorphismAp:=Build_IsInitialMorphismAp(funA'p'=>Build_Contr_(mA'p';HA'p')(funm'=>path_sigma_(mA'p';HA'p')m'(H'A'p'm'.1m'.2)(center_))).Projections from nested sigmas are currently rather slow.  We should just be able to doDefinition Build_IsInitialMorphism_uncurried
                 (univ
                  : { A : D
                    | { p : morphism C X (U A)
                       | let Ap := CommaCategory.Build_object !X U tt A p in
                         forall (A' : D) (p' : morphism C X (U A')),
                           { m : morphism D A A'
                           | { H : U _1 m o p = p'
                             | forall m',
                                 U _1 m' o p = p'
                                 -> m = m' }}}})
        := @Build_IsInitialMorphism_curried
             (univ.1)
             (univ.2.1)
             (fun A' p' => (univ.2.2 A' p').1)
             (fun A' p' => (univ.2.2 A' p').2.1)
             (fun A' p' => (univ.2.2 A' p').2.2).But that's currently too slow.  (About 6-8 seconds, on my machine.)  So instead we factor out all of the type parts by hand, and then apply them after.Letmake_uncurriedA'B'C'D'E'0(E'1:forallaa'bb'(c:C'aa'),D'aa'bb'c->E'0aa'->Type)(E':forallaa'bb'(c:C'aa'),D'aa'bb'c->E'0aa'->Type)F'(f:forall(a:A')(b:B'a)(c:forall(a':A') (b':B'a'),C'aa')(d:forall(a':A') (b':B'a'),D'aa'bb'(ca'b'))(e:forall(a':A') (b':B'a')(e0:E'0aa')(e1:E'1aa'bb'(ca'b') (da'b')e0),E'aa'bb'(ca'b') (da'b')e0),F'ab)(univ: {a:A'| {b:B'a|forall(a':A') (b':B'a'),{c:C'aa'| {d:D'aa'bb'c|forall(e0:E'0aa')(e1:E'1aa'bb'cde0),E'aa'bb'cde0}}}}):F'univ.1univ.2.1:=f(univ.1)(univ.2.1)(funA'p'=> (univ.2.2A'p').1)(funA'p'=> (univ.2.2A'p').2.1)(funA'p'=> (univ.2.2A'p').2.2).DefinitionBuild_IsInitialMorphism_uncurried:forall(univ: {A:D| {p:morphismCX(UA)|letAp:=CommaCategory.Build_object!XUttApinforall(A':D) (p':morphismCX(UA')),{m:morphismDAA'| {H:U_1mop=p'|forallm',U_1m'op=p'->m=m'}}}}),IsInitialMorphism(CommaCategory.Build_object!XUttuniv.1univ.2.1):= @make_uncurried________(@Build_IsInitialMorphism_curried).EndIntroductionAbstractionBarrier.Global ArgumentsBuild_IsInitialMorphism:simplnever.Global ArgumentsBuild_IsInitialMorphism_curried:simplnever.Global ArgumentsBuild_IsInitialMorphism_uncurried:simplnever.Elimination ruleSectionEliminationAbstractionBarrier.VariableAp:object(X/U).DefinitionIsInitialMorphism_object(M:IsInitialMorphismAp) :D:=CommaCategory.bAp.DefinitionIsInitialMorphism_morphism(M:IsInitialMorphismAp):morphismCX(U(IsInitialMorphism_objectM)):=CommaCategory.fAp.DefinitionIsInitialMorphism_property_morphism(M:IsInitialMorphismAp)(Y:D) (f:morphismCX(UY)):morphismD(IsInitialMorphism_objectM)Y:=CommaCategory.h(@center_(M(CommaCategory.Build_object!XUttYf))).DefinitionIsInitialMorphism_property_morphism_property(M:IsInitialMorphismAp)(Y:D) (f:morphismCX(UY)): (U_1(IsInitialMorphism_property_morphismMYf))oIsInitialMorphism_morphismM=f:=concat(CommaCategory.p(@center_(M(CommaCategory.Build_object!XUttYf))))(right_identity____).DefinitionIsInitialMorphism_property_morphism_unique(M:IsInitialMorphismAp)(Y:D) (f:morphismCX(UY))m'(H:U_1m'oIsInitialMorphism_morphismM=f):IsInitialMorphism_property_morphismMYf=m':=ap(@CommaCategory.h_______)(@contr_(M(CommaCategory.Build_object!XUttYf))(CommaCategory.Build_morphismAp(CommaCategory.Build_object!XUttYf)ttm'(H@ (right_identity____)^)%path)).DefinitionIsInitialMorphism_property(M:IsInitialMorphismAp)(Y:D) (f:morphismCX(UY)):Contr{m:morphismD(IsInitialMorphism_objectM)Y|U_1moIsInitialMorphism_morphismM=f}:=Build_Contr_(IsInitialMorphism_property_morphismMYf;IsInitialMorphism_property_morphism_propertyMYf)(funm'=>path_sigma_(IsInitialMorphism_property_morphismMYf;IsInitialMorphism_property_morphism_propertyMYf)m'(@IsInitialMorphism_property_morphism_uniqueMYfm'.1m'.2)(center_)).EndEliminationAbstractionBarrier.Global ArgumentsIsInitialMorphism_object:simplnever.Global ArgumentsIsInitialMorphism_morphism:simplnever.Global ArgumentsIsInitialMorphism_property:simplnever.Global ArgumentsIsInitialMorphism_property_morphism:simplnever.Global ArgumentsIsInitialMorphism_property_morphism_property:simplnever.Global ArgumentsIsInitialMorphism_property_morphism_unique:simplnever.EndInitialMorphism.Terminal morphismsSectionTerminalMorphism.DefinitionVariablesCD:PreCategory.VariableU:FunctorDC.VariableX:C.A terminal morphism fromUtoXis a terminal object in
       the comma category(U↓X)of morphisms fromUtoX.  In
       other words, it consists of a pair(A,φ)whereAis an
       object ofDandφ:UA->Xis a morphism inC, such
       that the following terminal property is satisfied:WheneverYis an object ofDandf:UY->Xis a
         morphism inC, then there exists a unique morphismg:Y->Asuch that the following diagram commutes:Y      U Y
         .       . \
       g .   U g .   \  f
         .       .     \
         ↓       ↓       ↘
         A      U A -----> X
                      φLocal Notationop_objectAp:= (CommaCategory.Build_object(Functors.from_terminalC^opX) (U^op)(CommaCategory.b(Ap:object(U/X)))(CommaCategory.a(Ap:object(U/X)))(CommaCategory.f(Ap:object(U/X))):object((X:objectC^op) /U^op)).DefinitionIsTerminalMorphism(Ap:object(U/X)) :Type:= @IsInitialMorphism(C^op)_X(U^op)(op_objectAp).Introduction ruleSectionIntroductionAbstractionBarrier.DefinitionBuild_IsTerminalMorphism:forall(*(Ap : Object (U ↓ X))*)(A:D)(* := CommaCategory.a Ap*)(p:morphismC(UA)X)(*:= CommaCategory.f Ap*)(Ap:=CommaCategory.Build_objectU!XAttp)(UniversalProperty:forall(A':D) (p':morphismC(UA')X),Contr{m:morphismDA'A|poU_1m=p'}),IsTerminalMorphismAp:= @Build_IsInitialMorphism(C^op)(D^op)X(U^op).DefinitionBuild_IsTerminalMorphism_curried:forall(A:D)(p:morphismC(UA)X)(Ap:=CommaCategory.Build_objectU!XAttp)(m:forall(A':D) (p':morphismC(UA')X),morphismDA'A)(H:forall(A':D) (p':morphismC(UA')X),poU_1(mA'p') =p')(H':forall(A':D) (p':morphismC(UA')X)m',poU_1m'=p'->mA'p'=m'),IsTerminalMorphismAp:= @Build_IsInitialMorphism_curried(C^op)(D^op)X(U^op).DefinitionBuild_IsTerminalMorphism_uncurried:forall(univ: {A:D| {p:morphismC(UA)X|letAp:=CommaCategory.Build_objectU!XAttpinforall(A':D) (p':morphismC(UA')X),{m:morphismDA'A| {H:poU_1m=p'|forallm',poU_1m'=p'->m=m'}}}}),IsTerminalMorphism(CommaCategory.Build_objectU!Xuniv.1ttuniv.2.1):= @Build_IsInitialMorphism_uncurried(C^op)(D^op)X(U^op).EndIntroductionAbstractionBarrier.Elimination ruleSectionEliminationAbstractionBarrier.VariableAp:object(U/X).VariableM:IsTerminalMorphismAp.DefinitionIsTerminalMorphism_object:D:=@IsInitialMorphism_objectC^opD^opXU^op(op_objectAp)M.DefinitionIsTerminalMorphism_morphism:morphismC(UIsTerminalMorphism_object)X:= @IsInitialMorphism_morphismC^opD^opXU^op(op_objectAp)M.DefinitionIsTerminalMorphism_property:forall(Y:D) (f:morphismC(UY)X),Contr{m:morphismDYIsTerminalMorphism_object|IsTerminalMorphism_morphismoU_1m=f}:= @IsInitialMorphism_propertyC^opD^opXU^op(op_objectAp)M.DefinitionIsTerminalMorphism_property_morphism:forall(Y:D) (f:morphismC(UY)X),morphismDYIsTerminalMorphism_object:= @IsInitialMorphism_property_morphismC^opD^opXU^op(op_objectAp)M.DefinitionIsTerminalMorphism_property_morphism_property:forall(Y:D) (f:morphismC(UY)X),IsTerminalMorphism_morphismo(U_1(IsTerminalMorphism_property_morphismYf))=f:= @IsInitialMorphism_property_morphism_propertyC^opD^opXU^op(op_objectAp)M.DefinitionIsTerminalMorphism_property_morphism_unique:forall(Y:D) (f:morphismC(UY)X)m'(H:IsTerminalMorphism_morphismoU_1m'=f),IsTerminalMorphism_property_morphismYf=m':= @IsInitialMorphism_property_morphism_uniqueC^opD^opXU^op(op_objectAp)M.EndEliminationAbstractionBarrier.EndTerminalMorphism.SectionUniversalMorphism.The term universal morphism refers either to an initial
        morphism or a terminal morphism, and the term universal
        property refers either to an initial property or a terminal
        property.  In each definition, the existence of the morphismgintuitively expresses the fact that(A,φ)is ``general
        enough'', while the uniqueness of the morphism ensures that(A,φ)is ``not too general''.EndUniversalMorphism.EndUniversalMorphism.ArgumentsBuild_IsInitialMorphism[CD]XUApUniversalProperty_.ArgumentsBuild_IsTerminalMorphism[CD]UXApUniversalProperty_.

--- Miscellaneous\Universe.html ---
UniverseLibrary UniverseRequireImportBasics.OvertureBasics.TacticsBasics.EquivalencesBasics.PathGroupoids.RequireImportTypes.Equiv.RequireImportWildCat.CoreWildCat.EquivWildCat.NatTransWildCat.TwoOneCat.The (1-)category of typesGlobal Instanceisgraph_type@{uv} :IsGraph@{vu}Type@{u}:=Build_IsGraphType@{u} (funab=>a->b).Global Instanceis01cat_type:Is01CatType.Proof.econstructor.+intro;exactidmap.+exact(funabcgf=>gof).Defined.Global Instanceis2graph_type:Is2GraphType:=funxy=>Build_IsGraph_(funfg=>f==g).Global Instanceis01cat_arrow{AB:Type} :Is01Cat(A$->B).Proof.econstructor.-exact(funfa=>idpath).-exact(funfghpqa=>qa@pa).Defined.Global Instanceis0gpd_arrow{AB:Type}:Is0Gpd(A$->B).Proof.applyBuild_Is0Gpd.introsfgpa;exact(pa)^.Defined.Global Instanceis0functor_type_postcomp{ABC:Type} (h:B$->C):Is0Functor(cat_postcompAh).Proof.applyBuild_Is0Functor.introsfgpa;exact(aph(pa)).Defined.Global Instanceis0functor_type_precomp{ABC:Type} (h:A$->B):Is0Functor(cat_precompCh).Proof.applyBuild_Is0Functor.introsfgpa;exact(p(ha)).Defined.Global Instanceis1cat_strong_type:Is1Cat_StrongType.Proof.srapplyBuild_Is1Cat_Strong;cbn;intros;reflexivity.Defined.Global Instancehasmorext_type`{Funext} :HasMorExtType.Proof.srapplyBuild_HasMorExt.introsABfg;cbnin*.refine(isequiv_homotopic(@apD10A(fun_=>B)fg)_).introsp.destructp;reflexivity.Defined.Global Instancehasequivs_type:HasEquivsType.Proof.srefine(Build_HasEquivsType____Equiv(@IsEquiv)________);introsAB.all:introsf.-exactf.-exact_.-applyBuild_Equiv.-intros;reflexivity.-intros;exact(f^-1).-cbn.intros?;applyeissect.-cbn.intros?;applyeisretr.-introsgrs;refine(isequiv_adjointifyfgrs).Defined.Global Instancehasmorext_core_type`{Funext} :HasMorExt(coreType) :=_.Definitioncatie_isequiv{AB:Type} {f:A$->B}`{IsEquivABf} :CatIsEquivf.Proof.assumption.Defined.#[export]HintImmediatecatie_isequiv:typeclass_instances.Global Instanceisinitial_zero:IsInitial(A:=Type)Empty.Proof.introA.exists(Empty_rec_).introsg.rapplyEmpty_ind.Defined.Global Instanceisterminal_unit:IsTerminal(A:=Type)Unit.Proof.introsA.exists(fun_=>tt).introsfx.bydestruct(fx).Defined.The 2-category of typesGlobal Instanceis3graph_type:Is3GraphType.Proof.introsABfg.applyBuild_IsGraph.introspq.exact(p==q).Defined.Global Instanceis1cat_type_homAB:Is1Cat(A$->B).Proof.repeatunshelveesplit.-introsfghpqx.exact(qx@px).-intros;bysymmetry.-introsfhpx.exact(px@@ 1).-introsghpx.exact(1 @@px).-intros? ? ? ? ? ? ? ?;applyconcat_p_pp.-intros? ? ? ? ? ? ? ?;applyconcat_pp_p.-intros? ? ? ?.applyconcat_p1.-intros? ? ? ?.applyconcat_1p.Defined.Global Instanceis1gpd_type_hom(AB:Type) :Is1Gpd(A$->B).Proof.repeatunshelveesplit.-intros? ? ? ?;applyconcat_pV.-intros? ? ? ?;applyconcat_Vp.Defined.Global Instanceis1functor_cat_postcomp{ABC:Type} (g:B$->C):Is1Functor(cat_postcompAg).Proof.repeatunshelveesplit.-intros? ? ? ?p?;exact(ap_(p_)).-intros? ? ? ? ? ?;cbn;applyap_pp.Defined.Global Instanceis1functor_cat_precomp{ABC:Type} (f:A$->B):Is1Functor(cat_precompCf).Proof.repeatunshelveesplit.intros? ? ? ?p?;exact(p_).Defined.Global Instanceis21cat_type:Is21CatType.Proof.snrapplyBuild_Is21Cat.1-4, 6-7:exact_.-introsabcfghkpqx;cbn.symmetry.applyconcat_Ap.-introsabcdfg.snrapplyBuild_Is1Natural.introshipx;cbn.exact(concat_p1_@ap_compose___@ (concat_1p_)^).-introsab.snrapplyBuild_Is1Natural.introsfgpx;cbn.exact(concat_p1_@ap_idmap_@ (concat_1p_)^).-introsab.snrapplyBuild_Is1Natural.introsfgpx;cbn.exact(concat_p1_@ (concat_1p_)^).-reflexivity.-reflexivity.Defined.

--- Miscellaneous\UniverseLevel.html ---
UniverseLevelLibrary UniverseLevelFromHoTTRequireImportBasics.OvertureBasics.PathGroupoids.Universe LevelsWe provide casting definitions for raising universe levels.Because we have cumulativity (thatT:U@{i}gives usT:U@{j}wheni<j), we may defineLift:U@{i}→U@{j}to be the identity function.DefinitionLift@{ij|i<j} (A:Type@{i}) :Type@{j}:=A.Definitionlift{A} :A->LiftA:=funx=>x.Definitionlower{A} :LiftA->A:=funx=>x.Definitionlift2{AB} (f:forallx:A,Bx) :forallx:LiftA,Lift(B(lowerx)):=f.Definitionlower2{AB} (f:forallx:LiftA,Lift(B(lowerx))) :forallx:A,Bx:=f.We makeliftandloweropaque so that typeclass resolution doesn't pick upisequiv_liftas an instance ofIsEquividmapand wreck havok.#[global]TypeclassesOpaqueliftlowerlift2lower2.Global Instanceisequiv_liftT:IsEquiv(@liftT):= @Build_IsEquiv__(@liftT)(@lowerT)(fun_=>idpath)(fun_=>idpath)(fun_=>idpath).Global Instanceisequiv_lift2AB:IsEquiv(@lift2AB):= @Build_IsEquiv__(@lift2AB)(@lower2AB)(fun_=>idpath)(fun_=>idpath)(fun_=>idpath).Global Instancelift_isequiv{AB} (f:A->B) {H:IsEquivf} : @IsEquiv(LiftA) (LiftB) (lift2f):= @Build_IsEquiv(LiftA) (LiftB)(lift2f)(lift2(f^-1))(funx=>aplift(eisretrf(lowerx)))(funx=>aplift(eissectf(lowerx)))(funx=> ((ap(aplift) (eisadjf(lowerx)))@ (ap_composeflift_)^)@ (@ap_composeA(LiftA) (LiftB)lift(lift2f)___)).Global Instancelower_isequiv{AB} (f:LiftA->LiftB) {H:IsEquivf} : @IsEquivAB(lower2f):= @Build_IsEquiv__(lower2f)(lower2(f^-1))(funx=>aplower(eisretrf(liftx)))(funx=>aplower(eissectf(liftx)))(funx=> ((ap(aplower) (eisadjf(liftx)))@ (ap_composeflower_)^)@ (@ap_compose(LiftA)ABlower(lower2f)___)).Definitionlower_equiv{AB} (e:Equiv(LiftA) (LiftB)) :EquivAB:= @Build_EquivAB(lower2e)_.This version doesn't force strict containment, i.e. it allows the two universes to possibly be the same.DefinitionLift'@{ij|i<=j} (A:Type@{i}) :Type@{j} :=A.However, if we don't give the universes as explicit arguments here, then Coq collapses them.Definitionlift'@{ij} {A:Type@{i}} :A->Lift'@{ij}A:=funx=>x.Definitionlower'@{ij} {A:Type@{i}} :Lift'@{ij}A->A:=funx=>x.Definitionlift'2@{ii'jj'} {A:Type@{i}} {B:A->Type@{i'}} (f:forallx:A,Bx):forallx:Lift'@{ij}A,Lift'@{i'j'} (B(lower'x)):=f.Definitionlower'2@{ii'jj'} {A:Type@{i}} {B:A->Type@{i'}}(f:forallx:Lift'@{ij}A,Lift'@{i'j'} (B(lower'x))):forallx:A,Bx:=f.We makeliftandloweropaque so that typeclass resolution doesn't pick upisequiv_liftas an instance ofIsEquividmapand wreck havok.#[global]TypeclassesOpaquelift'lower'lift'2lower'2.Global Instanceisequiv_lift'@{ij} (T:Type@{i}):IsEquiv(@lift'@{ij}T):= @Build_IsEquiv__(@lift'T)(@lower'T)(fun_=>idpath)(fun_=>idpath)(fun_=>idpath).Global Instanceisequiv_lift'2@{e0e1ii'jj'} (A:Type@{i}) (B:A->Type@{j}):IsEquiv@{e0e1} (@lift'2@{ii'jj'}AB):= @Build_IsEquiv__(@lift'2AB)(@lower'2AB)(fun_=>idpath)(fun_=>idpath)(fun_=>idpath).Global Instancelift'_isequiv@{abiji'j'}  {A:Type@{a}} {B:Type@{b}}(f:A->B) {H:IsEquivf}: @IsEquiv(Lift'@{ij}A) (Lift'@{i'j'}B) (lift'2f):= @Build_IsEquiv(Lift'A) (Lift'B)(lift'2f)(lift'2(f^-1))(funx=>aplift'(eisretrf(lower'x)))(funx=>aplift'(eissectf(lower'x)))(funx=> ((ap(aplift') (eisadjf(lower'x)))@ (ap_composeflift'_)^)@ (@ap_composeA(Lift'A) (Lift'B)lift'(lift'2f)___)).Global Instancelower'_isequiv@{iji'j'} {A:Type@{i}} {B:Type@{j}}(f:Lift'@{ij}A->Lift'@{i'j'}B) {H:IsEquivf}: @IsEquivAB(lower'2f):= @Build_IsEquiv__(lower'2f)(lower'2(f^-1))(funx=>aplower'(eisretrf(lift'x)))(funx=>aplower'(eissectf(lift'x)))(funx=> ((ap(aplower') (eisadjf(lift'x)))@ (ap_composeflower'_)^)@ (@ap_compose(Lift'A)ABlower'(lower'2f)___)).Definitionlower'_equiv@{iji'j'} {A:Type@{i}} {B:Type@{j}}(e:Equiv(Lift'@{ij}A) (Lift'@{i'j'}B)):EquivAB:= @Build_EquivAB(lower'2e)_.

--- Miscellaneous\Utf8Minimal.html ---
Utf8MinimalLibrary Utf8MinimalRequireExportBasics.Utf8Basics.OvertureBasics.Iff.Just enough Utf8/unicode for the Classes library to build, without depending on everything that HoTT.Utf8 depends on.(* Logic *)Notation"∀  x .. y , P" := (forallx, .. (forally,P) ..) :type_scope.Notation"∃  x .. y , P" := (existsx, .. (existsy,P) ..) :type_scope.Notation"x ∧ y" := (x/\y) :type_scope.Notation"x → y" := (x->y) :type_scope.Notation"x ↔ y" := (x<->y) :type_scope.(*Notation "¬ x" := (not x) : type_scope.*)(*Notation "x ≠ y" := (x <> y) : type_scope.*)(* Abstraction *)Notation"'λ'  x .. y , t" := (funx=> .. (funy=>t) ..).

--- Miscellaneous\V.html ---
VLibrary VThe cumulative hierarchyV.RequireImportHoTT.BasicsHoTT.Types.RequireImportHSetTruncType.RequireImportColimits.SpanPushout.RequireImportHoTT.Truncations.CoreColimits.Quotient.Local OpenScopenat_scope.Local OpenScopepath_scope.Bitotal relationDefinitionbitotal{AB:Type} (R:A->B->HProp) :=(foralla:A,hexists(fun(b:B) =>Rab))* (forallb:B,hexists(fun(a:A) =>Rab)).The cumulative hierarchy VModuleExportCumulativeHierarchy.Private InductiveV@{U'U|U<U'} :Type@{U'} :=|set{A:Type@{U}} (f:A->V) :V.Axiomsetext:forall{AB:Type} (R:A->B->HProp)(bitot_R:bitotalR) (h:SPushoutR->V),set(ho(spushlR)) =set(ho(spushrR)).Axiomishset_V:IsHSetV.Global Existing Instanceishset_V.The induction principle.  Annotating the universes here greatly reduces the number of universe variables later in the file.  For example,functionbelow went from 279 to 3.  IfV_indneeds to be generalized in the future, checkfunctionto make sure things haven't exploded again.FixpointV_ind@{U'Uu|U<U'} (P:V@{U'U} ->Type@{u})(H_0trunc:forallv:V@{U'U},IsTrunc0 (Pv))(H_set:forall(A:Type@{U}) (f:A->V) (H_f:foralla:A,P(fa)),P(setf))(H_setext:forall(AB:Type@{U}) (R:A->B->HProp@{U}) (bitot_R:bitotalR)(h:SPushoutR->V) (H_h:forallx:SPushoutR,P(hx)),transport@{U'u}_(setextRbitot_Rh) (H_setA(hospushlR) (H_hoDspushlR))=H_setB(hospushrR) (H_hoDspushrR) )(v:V):Pv:= (matchvwith|setAf=>fun__=>H_setAf(funa=>V_indPH_0truncH_setH_setext(fa))end)H_setextH_0trunc.We don't need to axiomatize the computation rule because we get it for free thanks to 0-truncationEndCumulativeHierarchy.DefinitionV_comp_setext(P:V->Type)(H_0trunc:forallv:V,IsTrunc0 (Pv))(H_set:forall(A:Type) (f:A->V) (H_f:foralla:A,P(fa)),P(setf))(H_setext:forall(AB:Type) (R:A->B->HProp) (bitot_R:bitotalR)(h:SPushoutR->V) (H_h:forallx:SPushoutR,P(hx)),(setextRbitot_Rh) # (H_setA(hospushlR) (H_hoDspushlR))=H_setB(hospushrR) (H_hoDspushrR) )(AB:Type) (R:A->B->HProp) (bitot_R:bitotalR) (h:SPushoutR->V):apD(V_indPH_0truncH_setH_setext) (setextRbitot_Rh)=H_setextABRbitot_Rh((V_indPH_0truncH_setH_setext)oDh).Proof.applypath_ishprop.Defined.The non-dependent eliminatorDefinitionV_rec(P:Type)(H_0trunc:IsTrunc0P)(H_set:forall(A:Type), (A->V) -> (A->P) ->P)(H_setext:forall(AB:Type) (R:A->B->HProp) (bitot_R:bitotalR)(h:SPushoutR->V) (H_h:SPushoutR->P),H_setA(hospushlR) (H_hospushlR) =H_setB(hospushrR) (H_hospushrR) ):V->P.Proof.refine(V_ind__H_set_).intros.exact(transport_const__@H_setextABRbitot_RhH_h).Defined.DefinitionV_comp_nd_setext(P:Type)(H_0trunc:IsTrunc0P)(H_set:forall(A:Type), (A->V) -> (A->P) ->P)(H_setext:forall(AB:Type) (R:A->B->HProp) (bitot_R:bitotalR)(h:SPushoutR->V) (H_h:SPushoutR->P),H_setA(hospushlR) (H_hospushlR) =H_setB(hospushrR) (H_hospushrR) )(AB:Type) (R:A->B->HProp) (bitot_R:bitotalR) (h:SPushoutR->V):ap(V_recPH_0truncH_setH_setext) (setextRbitot_Rh)=H_setextABRbitot_Rh((V_recPH_0truncH_setH_setext)oh).Proof.applypath_ishprop.Defined.Alternative induction principle (This is close to the one from the book)Definitionequal_img{ABC:Type} (f:A->C) (g:B->C) :=(foralla:A,hexists(fun(b:B) =>fa=gb))* (forallb:B,hexists(fun(a:A) =>fa=gb)).Definitionsetext'{AB:Type} (f:A->V) (g:B->V) (eq_img:equal_imgfg):setf=setg.Proof.pose(R:=funab=>Build_HProp(fa=gb)).pose(h:=SPushout_recRVfg(fun__r=>r)).exact(setextReq_imgh).Defined.DefinitionV_rec'(P:Type)(H_0trunc:IsTrunc0P)(H_set:forall(A:Type), (A->V) -> (A->P) ->P)(H_setext':forall(AB:Type) (f:A->V) (g:B->V), (equal_imgfg) ->forall(H_f:A->P) (H_g:B->P), (equal_imgH_fH_g) ->(H_setAfH_f) = (H_setBgH_g) ):V->P.Proof.refine(V_rec__H_set_).introsABRbitot_RhH_h.applyH_setext'.-split.+introa.generalize(fstbitot_Ra).apply(Trunc_functor(-1)).intros[br].existsb.exact(aph(spglueRr)).+introb.generalize(sndbitot_Rb).apply(Trunc_functor(-1)).intros[ar].existsa.exact(aph(spglueRr)).-split.+introa.generalize(fstbitot_Ra).apply(Trunc_functor(-1)).intros[br].existsb.exact(apH_h(spglueRr)).+introb.generalize(sndbitot_Rb).apply(Trunc_functor(-1)).intros[ar].existsa.exact(apH_h(spglueRr)).Defined.Note that the hypothesis H_setext' differs from the one given in section 10.5 of the HoTT book.DefinitionV_ind'(P:V->Type)(H_0trunc:forallv:V,IsTrunc0 (Pv))(H_set:forall(A:Type) (f:A->V) (H_f:foralla:A,P(fa)),P(setf))(H_setext':forall(AB:Type) (f:A->V) (g:B->V)(eq_img:equal_imgfg)(H_f:foralla:A,P(fa)) (H_g:forallb:B,P(gb))(H_eqimg: (foralla:A,hexists(fun(b:B) =>hexists(fun(p:fa=gb) =>p# (H_fa) =H_gb)))* (forallb:B,hexists(fun(a:A) =>hexists(fun(p:fa=gb) =>p# (H_fa) =H_gb))) ),(setext'fgeq_img) # (H_setAfH_f) = (H_setBgH_g)):forallv:V,Pv.Proof.applyV_indwithH_set;tryassumption.introsABRbitot_RhH_h.pose(f:=hospushlR:A->V).pose(g:=hospushrR:B->V).pose(H_f:=H_hoDspushlR:foralla:A,P(fa)).pose(H_g:=H_hoDspushrR:forallb:B,P(gb)).assert(eq_img:equal_imgfg).{split.-introa.generalize(fstbitot_Ra).apply(Trunc_functor(-1)).intros[br].existsb.exact(aph(spglueRr)).-introb.generalize(sndbitot_Rb).apply(Trunc_functor(-1)).intros[ar].existsa.exact(aph(spglueRr)). }transitivity(transportP(setext'(hospushlR) (hospushrR)eq_img)(H_setA(hospushlR) (H_hoDspushlR))).{apply(ap(funp=>transportPp(H_setA(hospushlR) (H_hoDspushlR)))).applypath_ishprop. }apply(H_setext'ABfgeq_imgH_fH_g).split.-introa.set(truncb:=fstbitot_Ra).generalizetruncb.apply(Trunc_functor(-1)).intros[bRab].existsb.applytr.exists(aph(spglueRRab)).apply(concatR(apDH_h(spglueRRab))).applyinverse.unfoldf,g.applytransport_compose.-introsb.set(trunca:=sndbitot_Rb).generalizetrunca.apply(Trunc_functor(-1)).intros[aRab].existsa.applytr.exists(aph(spglueRRab)).apply(concatR(apDH_h(spglueRRab))).applyinverse.unfoldf,g.applytransport_compose.Defined.Simpler induction principle when the goal is an hpropDefinitionV_ind_hprop(P:V->Type)(H_set:forall(A:Type) (f:A->V) (H_f:foralla:A,P(fa)),P(setf))(isHProp_P:forallv:V,IsHProp(Pv)):forallv:V,Pv.Proof.refine(V_ind__H_set_).intros.applypath_ishprop.Defined.SectionAssumingUA.Context`{ua:Univalence}.Membership relationDefinitionmem(x:V) :V->HProp.Proof.simplerefine(V_rec'____).-introsAf_.exact(hexists(funa:A=>fa=x)).-simpl.introsABfgeqimg___.applypath_iff_hprop;simpl.+introH.refine(Trunc_rec_H).intros[ap].generalize(fsteqimga).apply(Trunc_functor(-1)).intros[bp'].existsb.transitivity(fa);autowithpath_hints.+introH.refine(Trunc_rec_H).intros[bp].generalize(sndeqimgb).apply(Trunc_functor(-1)).intros[ap'].existsa.transitivity(gb);autowithpath_hints.Defined.Declare Scopeset_scope.Notation"x ∈ v" := (memxv) :set_scope.OpenScopeset_scope.Subset relationDefinitionsubset(x:V) (y:V) :HProp:=Build_HProp(forallz:V,z∈x->z∈y).Notation"x ⊆ y" := (subsetxy) :set_scope.Bisimulation relationThe equality in V lives in Type@{U'}. We define the bisimulation relation which is a U-small resizing of the equality in V: it must live in HProp_U : Type{U'}, hence the codomain is HProp@{U}. We then prove that bisimulation is equality (bisim_equals_id), then use it to prove the key lemma monic_set_present.(* We define bisimulation by double induction on V. We first fix the first argument as set(A,f) and define bisim_aux : V -> HProp, by induction. This is the inner of the two inductions. *)Local Definitionbisim_aux(A:Type) (f:A->V) (H_f:A->V->HProp) :V->HProp.Proof.applyV_rec'with(funBg_=>Build_HProp( (foralla,hexists(funb=>H_fa(gb)))*forallb,hexists(funa=>H_fa(gb)) )).-exact_.-introsBB'gg'eq_imgH_gH_g'H_img;simpl.applypath_iff_hprop;simpl.+intros[H1H2];split.*introa.refine(Trunc_rec_(H1a)).intros[bH3].generalize(fsteq_imgb).unfoldhexists.refine(@Trunc_functor(-1) {b0:B'&gb=g'b0} {b0:B'&H_fa(g'b0)}_).intros[b'p].existsb'.exact(transport(funx=>H_fax)pH3).*introb'.refine(Trunc_rec_(sndeq_imgb')).intros[bp].generalize(H2b).apply(Trunc_functor(-1)).intros[aH3].existsa.exact(transport(funx=>H_fax)pH3).+intros[H1H2];split.*introa.refine(Trunc_rec_(H1a)).intros[b'H3].generalize(sndeq_imgb').apply(Trunc_functor(-1)).intros[bp].existsb.exact(transport(funx=>H_fax)p^H3).*introb.refine(Trunc_rec_(fsteq_imgb)).intros[b'p].generalize(H2b').apply(Trunc_functor(-1)).intros[aH3].existsa.exact(transport(funx=>H_fax)p^H3).Defined.(* Then we define bisim : V -> (V -> HProp) by induction again *)Definitionbisimulation:V@{U'U} ->V@{U'U} ->HProp@{U}.Proof.refine(V_rec'(V->HProp)_bisim_aux_).introsABfgeq_imgH_fH_gH_img.applypath_forall.refine(V_ind_hprop___).introsCh_;simpl.applypath_iff_hprop;simpl.-intros[H1H2];split.+introb.refine(Trunc_rec_(sndH_imgb)).intros[ap].generalize(H1a).apply(Trunc_functor(-1)).intros[cH3].existsc.exact((ap10p(hc)) #H3).+introc.refine(Trunc_rec_(H2c)).intros[aH3].generalize(fstH_imga).apply(Trunc_functor(-1)).intros[bp].existsb.exact((ap10p(hc)) #H3).-intros[H1H2];split.+introa.refine(Trunc_rec_(fstH_imga)).intros[bp].generalize(H1b).apply(Trunc_functor(-1)).intros[cH3].existsc.exact((ap10p^ (hc)) #H3).+introc.refine(Trunc_rec_(H2c)).intros[bH3].generalize(sndH_imgb).apply(Trunc_functor(-1)).intros[ap].existsa.exact((ap10p^ (hc)) #H3).Defined.Notation"u ~~ v" := (bisimulationuv) :set_scope.Global Instancereflexive_bisimulation:Reflexivebisimulation.Proof.refine(V_ind_hprop___).introsAfH_f;simpl.split.-introa;applytr;existsa;auto.-introa;applytr;existsa;auto.Defined.Lemmabisimulation_equiv_id:foralluv:V, (u=v) <~> (u~~v).Proof.introsuv.applyequiv_iff_hprop.-introp;exact(transport(funx=>u~~x)p(reflexive_bisimulationu)).-generalizeuv.refine(V_ind_hprop___);introsAfH_f.refine(V_ind_hprop___);introsBg_.simpl;intros[H1H2].applysetext'.split.+introa.generalize(H1a).apply(Trunc_functor(-1)).intros[bh].existsb;exact(H_fa(gb)h).+introb.generalize(H2b).apply(Trunc_functor(-1)).intros[ah].existsa;exact(H_fa(gb)h).Defined.Canonical presentation of V-sets (Lemma 10.5.6)Using the regular kernel would lead to a universe inconsistency in the monic_set_present lemma later.Definitionker_bisim{A} (f:A->V) (xy:A) := (fx~~fy).Definitionker_bisim_is_ker{A} (f:A->V):forall(xy:A),fx=fy<~>ker_bisimfxy.Proof.intros;applybisimulation_equiv_id.Defined.SectionMonicSetPresent_Uniqueness.Given u : V, we want to show that the representation u = @set Au mu, where Au is an hSet and mu is monic, is unique.Context{u:V} {AuAu':Type} {h:IsHSetAu} {h':IsHSetAu'} {mu:Au->V} {mono:IsEmbeddingmu}{mu':Au'->V} {mono':IsEmbeddingmu'} {p:u=setmu} {p':u=setmu'}.Lemmaeq_img_untrunc: (foralla:Au, {a':Au'&mu'a'=mua})* (foralla':Au', {a:Au&mua=mu'a'}).Proof.split.-introa.exact(@untrunc_istrunc(-1)_(mono'(mua)) (transport(funx=>mua∈x) (p^ @p') (tr(a; 1)))).-introa'.exact(@untrunc_istrunc(-1)_(mono(mu'a')) (transport(funx=>mu'a'∈x) (p'^ @p) (tr(a'; 1)))).Defined.Lete:Au->Au':=funa=>pr1(fsteq_img_untrunca).Letinv_e:Au'->Au:=funa'=>pr1(sndeq_img_untrunca').Lethom1:eoinv_e==idmap.Proof.introa'.apply(isinj_embeddingmu'mono').transitivity(mu(inv_ea')).-exact(pr2(fsteq_img_untrunc(inv_ea'))).-exact(pr2(sndeq_img_untrunca')).Defined.Lethom2:inv_eoe==idmap.Proof.introa.apply(isinj_embeddingmumono).transitivity(mu'(ea)).-exact(pr2(sndeq_img_untrunc(ea))).-exact(pr2(fsteq_img_untrunca)).Defined.Letpath:Au'=Au.Proof.applypath_universe_uncurried.apply(equiv_adjointifyinv_eehom2hom1).Defined.Lemmamu_eq_mu':transport(funA:Type=>A->V)path^mu=mu'.Proof.applypath_forall.introa'.transitivity(transport(funX=>V)path^ (mu(transport(funX:Type=>X)path^^a'))).-apply(@transport_arrowType(funX:Type=>X) (funX=>V)AuAu'path^mua').-transitivity(mu(transportidmappath^^a')).+applytransport_const.+transitivity(mu(inv_ea')).2:apply(pr2(sndeq_img_untrunca')).refine(apmu_).transitivity(transportidmappatha').*exact(ap(funx=>transportidmapxa') (inv_Vpath)).*applytransport_path_universe.Defined.Lemmamonic_set_present_uniqueness: (Au; (mu; (h,mono,p))) = (Au'; (mu'; (h',mono',p'))) :> {A:Type& {m:A->V&IsHSetA*IsEmbeddingm* (u=setm)}}.Proof.applypath_sigma_uncurried;simpl.existspath^.transitivity(path^ #mu;transportD(funA=>A->V) (funAm=>IsHSetA*IsEmbeddingm* (u=setm))path^mu(h,mono,p)).-apply(@transport_sigmaType(funA=>A->V) (funAm=>IsHSetA*IsEmbeddingm* (u=setm))AuAu'path^ (mu; (h,mono,p))).-applypath_sigma_hprop;simpl.exactmu_eq_mu'.Defined.EndMonicSetPresent_Uniqueness.This lemma actually says a little more than 10.5.6, i.e., that Au is a hSetLemmamonic_set_present:forallu:V,exists(Au:Type) (m:Au->V),(IsHSetAu) * (IsEmbeddingm) * (u=setm).Proof.applyV_ind_hprop.-introsAf_.destruct(quotient_kernel_factor_generalf(ker_bisimf) (ker_bisim_is_kerf))as[Au[eu[mu(((hset_Au,epi_eu),mono_mu),factor)]]].existsAu,mu.split;[exact(hset_Au,mono_mu)|].applysetext';split.+introa.applytr;exists(eua).exact(ap10factora).+introa'.generalize(epi_eua').introIC;refine(Trunc_functor(-1)_(@center_IC)).intros[ap].existsa.transitivity(mu(eua)).*exact(ap10factora).*exact(apmup).-introv.applyhprop_allpath.intros[Au[mu((hset,mono),p)]].intros[Au'[mu'((hset',mono'),p')]].applymonic_set_present_uniqueness.Defined.Definitiontype_of_members(u:V) :Type:=pr1(monic_set_presentu).Notation"[ u ]" := (type_of_membersu) :set_scope.Definitionfunc_of_members{u:V} : [u] ->V:=pr1(pr2(monic_set_presentu)) : [u] ->V.Definitionis_hset_typeofmembers{u:V} :IsHSet([u]) :=fst(fst(pr2(pr2(monic_set_presentu)))).DefinitionIsEmbedding_funcofmembers{u:V} :IsEmbeddingfunc_of_members:=snd(fst(pr2(pr2(monic_set_presentu)))).Definitionis_valid_presentation(u:V) :u=setfunc_of_members:=snd(pr2(pr2(monic_set_presentu))).Lemmas 10.5.8 (i) & (vii), we put them here because they are useful laterLemmaextensionality:forall{xy:V}, (x⊆y*y⊆x) <->x=y.Proof.refine(V_ind_hprop___).introsAf_.refine(V_ind_hprop___).introsBg_.split.-intros[H1H2].applysetext'.split.+intro.refine(Trunc_rec_(H1(fa) (tr(a;1)))).intros[bp].applytr.existsb.exactp^.+intro.apply(H2(gb)).applytr;existsb;reflexivity.-introp;split.+introszHz.apply(transport(funx=>z∈x)pHz).+introszHz.apply(transport(funx=>z∈x)p^Hz).Qed.Lemmamem_induction(C:V->HProp): (forallv, (forallx,x∈v->Cx) ->Cv) ->forallv,Cv.Proof.introH.refine(V_ind_hprop___).introsAfH_f.applyH.introsxHx.generalizeHx;applyTrunc_rec.intros[ap].exact(transportCp(H_fa)).Defined.Two useful lemmasGlobal Instanceirreflexive_mem:Irreflexivemem.Proof.assert(forallv,IsHProp(complement(funxx0:V=>x∈x0)vv)).(* https://coq.inria.fr/bugs/show_bug.cgi?id=3854 *){intro.unfoldcomplement.exact_. }refine(mem_induction(funx=>Build_HProp(~x∈x))_);simplin*.introsvH.introHv.exact(HvHvHv).Defined.Lemmapath_V_eqimg{AB} {f:A->V} {g:B->V} :setf=setg->equal_imgfg.Proof.introp.split.-introa.assert(H:fa∈setg).{apply(sndextensionalityp).applytr;existsa;reflexivity. }generalizeH;apply(Trunc_functor(-1)).intros[bp'].existsb;exactp'^.-introb.assert(H:gb∈setf).{apply(sndextensionalityp^).applytr;existsb;reflexivity. }generalizeH;apply(Trunc_functor(-1)).intros[ap'].existsa;exactp'.Defined.Definitions of particular sets in VThe empty setDefinitionV_empty:V:=set(Empty_ind(fun_=>V)).The singleton {u}DefinitionV_singleton(u:V) :V@{U'U} :=set(Unit_indu).Global Instanceisequiv_ap_V_singleton{uv:V}:IsEquiv(@ap__V_singletonuv).Proof.simplerefine(Build_IsEquiv_______);trysolve[intro;applypath_ishprop].{introH.specialize(path_V_eqimgH).intros(H1,H2).refine(Trunc_rec_(H1tt)).intros[tp].destructt;exactp. }Defined.The pair {u,v}DefinitionV_pair(u:V) (v:V) :V@{U'U} :=set(funb:Bool=>ifbthenuelsev).Lemmapath_pair{uvu'v':V@{U'U}} : (u=u') * (v=v') ->V_pairuv=V_pairu'v'.Proof.intros(H1,H2).applysetext'.split.+applyBool_ind.*applytr;existstrue.assumption.*applytr;existsfalse;assumption.+applyBool_ind.*applytr;existstrue;assumption.*applytr;existsfalse;assumption.Defined.Lemmapair_eq_singleton{uvw:V} :V_pairuv=V_singletonw<-> (u=w) * (v=w).Proof.split.+introH.destruct(path_V_eqimgH)as(H1,H2).refine(Trunc_rec_(H1true)).intros[tp];destructt.refine(Trunc_rec_(H1false)).intros[tp'];destructt.split; [exactp|exactp'].+intros(p1,p2).applysetext';split.*introa;applytr;existstt.destructa; [exactp1|exactp2].*introt;applytr;existstrue.destructt;exactp1.Defined.The ordered pair (u,v)DefinitionV_pair_ord(u:V) (v:V) :V:=V_pair(V_singletonu) (V_pairuv).Notation" [ u , v ] " := (V_pair_orduv) :set_scope.Lemmapath_pair_ord{abcd:V} : [a,b] = [c,d] <-> (a=c) * (b=d).Proof.split.-introp.assert(p1:a=c).+assert(H:V_singletona∈ [c,d]).{apply(sndextensionalityp).simpl.applytr;existstrue;reflexivity. }refine(Trunc_rec_H).intros[tp'];destructt.*apply((apV_singleton)^-1p'^).*symmetry;apply(fstpair_eq_singletonp').+split.*exactp1.*assert(H:hor(b=c) (b=d)).{assert(H':V_pairab∈ [c,d]).{apply(sndextensionalityp).applytr;existsfalse;reflexivity. }refine(Trunc_rec_H').intros[tp'];destructt.-applytr;left.apply(fstpair_eq_singletonp'^).-destruct(path_V_eqimgp')as(H1,H2).generalize(H2false);apply(Trunc_functor(-1)).intros[tp''];destructt.+left;exactp''^.+right;exactp''^. }refine(Trunc_rec_H).introcase;destructcaseas[p'|p'].2:assumption.assert(H': [a,b] =V_singleton(V_singletonb)).{apply(sndpair_eq_singleton).split.-applyap;exact(p1@p'^).-apply(sndpair_eq_singleton).split; [exact(p1@p'^) |reflexivity]. }assert(H'':V_paircd=V_singletonb)byapply(fstpair_eq_singleton(p^ @H')).symmetry;apply(fstpair_eq_singletonH'').-intros(p,p').applypath_pair.split.+applyap;exactp.+applypath_pair.split;assumption;assumption.Defined.The cartesian product a × bDefinitionV_cart_prod(a:V) (b:V) :V:=set(funx: [a] * [b] => [func_of_members(fstx),func_of_members(sndx)]).Notation" a × b " := (V_cart_prodab) :set_scope.f is a function with domain a and codomain bDefinitionV_is_func(a:V) (b:V) (f:V) :=f⊆ (a×b)* (forallx,x∈a->hexists(funy=>y∈b* [x,y] ∈f))* (forallxyy', [x,y] ∈f* [x,y'] ∈f->y=y').The set of functions from a to bDefinitionV_func(a:V) (b:V) :V:= @set([a] -> [b]) (funf=>set(funx=> [func_of_membersx,func_of_members(fx)] )).The union of a set UvDefinitionV_union(v:V) :=@set({x: [v] & [func_of_membersx]}) (funz=>func_of_members(pr2z)).The ordinal successor x ∪ {x}DefinitionV_succ:V->V.Proof.simplerefine(V_rec'____).-introsAf_.exact(set(fun(x:A+Unit) =>matchxwithinla=>fa|inrtt=>setfend)).-simpl;introsABfgeq_img___.applysetext'.split.+intro.destructa.*generalize(fsteq_imga).apply(Trunc_functor(-1)).intros[bp].exists(inlb);exactp.*applytr;exists(inrtt).destructu.applysetext';auto.+intro.destructb.*generalize(sndeq_imgb).apply(Trunc_functor(-1)).intros[ap].exists(inla);exactp.*applytr;exists(inrtt).destructu.applysetext';auto.Defined.The set of finite ordinalsDefinitionV_omega:V:=set(fixIn:=matchnwith0   =>V_empty|Sn=>V_succ(In)end).Axioms of set theory (theorem 10.5.8)Lemmanot_mem_Vempty:forallx, ~ (x∈V_empty).Proof.introsxHx.generalizeHx;applyTrunc_rec.intros[ff_].exactff.Qed.Lemmapairing:foralluv,hexists(funw=>forallx,x∈w<->hor(x=u) (x=v)).Proof.introsuv.applytr.exists(V_pairuv).intro;split;apply(Trunc_functor(-1)).-intros[[|]p]; [left|right];exactp^.-intros[p|p]; [existstrue|existsfalse];exactp^.Qed.Lemmainfinity: (V_empty∈V_omega) * (forallx,x∈V_omega->V_succx∈V_omega).Proof.split.-applytr;exists0;auto.-intro.apply(Trunc_functor(-1)).intros[np].exists(Sn).rewritep;auto.Qed.Lemmaunion:forallv,hexists(funw=>forallx,x∈w<->hexists(funu=>x∈u*u∈v)).Proof.introv.applytr;exists(V_unionv).introx;split.-introH.simplinH.generalizeH;apply(Trunc_functor(-1)).intros[[u'x']p];simplinp.exists(func_of_membersu');split.+refine(transport(funz=>x∈z) (is_valid_presentation(func_of_membersu'))^_).simpl.applytr;existsx'.exactp.+refine(transport(funz=>func_of_membersu'∈z) (is_valid_presentationv)^_).simpl.applytr;existsu';reflexivity.-applyTrunc_rec.intros[u(Hx,Hu)].generalize(transport(funz=>u∈z) (is_valid_presentationv)Hu).applyTrunc_rec.intros[u'pu].generalize(transport(funz=>x∈z) (is_valid_presentation(func_of_membersu')) (transport(funz=>x∈z)pu^Hx)).applyTrunc_rec.intros[x'px].applytr.exists(u';x').exactpx.Qed.Lemmafunction:foralluv,hexists(funw=>forallx,x∈w<->V_is_funcuvx).Proof.introsuv.applytr;exists(V_funcuv).assert(memb_u:u=set(@func_of_membersu))byexact(is_valid_presentationu).assert(memb_v:v=set(@func_of_membersv))byexact(is_valid_presentationv).introphi;split.-introH.split;[split|].+introszHz.simplin*.generalizeH.applyTrunc_rec.intros[hp_phi].generalize(transport(funx=>z∈x)p_phi^Hz).apply(Trunc_functor(-1)).intros[ap].exists(a,ha).assumption.+introsxHx.generalize(transport(funy=>x∈y)memb_uHx).applyTrunc_rec.intros[ap].generalizeH;apply(Trunc_functor(-1)).intros[hp_phi].exists(func_of_members(ha)).split.*exact(transport(funz=>func_of_members(ha) ∈z)memb_v^ (tr(ha; 1))).*apply(transport(funy=> [x,func_of_members(ha)] ∈y)p_phi).applytr;existsa.rewritep;reflexivity.+introsxyy'(Hy,Hy').generalizeH;applyTrunc_rec.intros[hp_phi].generalize(transport(funz=> [x,y] ∈z)p_phi^Hy).applyTrunc_rec.intros[ap].generalize(transport(funz=> [x,y'] ∈z)p_phi^Hy').applyTrunc_rec.intros[a'p'].destruct(fstpath_pair_ordp)as(px,py).destruct(fstpath_pair_ordp')as(px',py').transitivity(func_of_members(ha));autowithpath_hints.transitivity(func_of_members(ha'));autowithpath_hints.refine(apfunc_of_members_).refine(aph_).apply(isinj_embeddingfunc_of_membersIsEmbedding_funcofmembersaa'(px@px'^)).-intros((H1,H2),H3).simpl.assert(h:foralla: [u], {b: [v] & [func_of_membersa,func_of_membersb] ∈phi}).{introa.pose(x:=func_of_membersa).transparentassert(H: {y:V&y∈v* [x,y] ∈phi}).-refine(@untrunc_istrunc(-1) {y:V&y∈v* [x,y] ∈phi}_(H2x(transport(funz=>x∈z)memb_u^ (tr(a; 1))))).applyhprop_allpath.intros[y(H1_y,H2_y)] [y'(H1_y',H2_y')].applypath_sigma_uncurried;simpl.exists(H3xyy'(H2_y,H2_y')).applypath_ishprop.-destructHas[y(H1_y,H2_y)].destruct(@untrunc_istrunc(-1)_(IsEmbedding_funcofmembersy) (transport(funz=>y∈z)memb_vH1_y))as[bHb].existsb.exact(transport(funz=> [x,z] ∈phi)Hb^H2_y). }applytr;exists(funa=>pr1(ha)).applyextensionality.split.+introszHz.generalizeHz;applyTrunc_rec.intros[aHa].exact(transport(funw=>w∈phi)Ha(pr2(ha))).+introszHz.simpl.generalize(H1zHz).apply(Trunc_functor(-1)).intros[(a,b)p].simplinp.existsa.transitivity([func_of_membersa,func_of_membersb]);autowithpath_hints.applyap.applyH3with(func_of_membersa).split.*exact(pr2(ha)).*exact(transport(funw=>w∈phi)p^Hz).Qed.Lemmareplacement:forall(r:V->V) (x:V),hexists(funw=>forally,y∈w<->hexists(funz=>z∈x* (rz=y))).Proof.intror.refine(V_ind_hprop___).introsAf_.applytr.exists(set(rof)).split.-apply(Trunc_functor(-1)).intros[ap].exists(fa).split.+applytr;existsa;auto.+assumption.-applyTrunc_rec.intros[z[hp]].generalizeh.apply(Trunc_functor(-1)).intros[ap'].existsa.transitivity(rz);autowithpath_hints.exact(aprp').Qed.Lemmaseparation(C:V->HProp) :foralla:V,hexists(funw=>forallx,x∈w<->x∈a* (Cx)).Proof.refine(V_ind_hprop___).introsAf_.applytr.exists(set(funz: {a:A&C(fa)} =>f(pr1z))).split.-applyTrunc_rec.intros[[ah]p].split. +applytr;existsa;assumption. +exact(transportCph).-intros[H1H2].generalizeH1.apply(Trunc_functor(-1)).intros[ap].exists(a;transportCp^H2).exactp.Qed.EndAssumingUA.

--- Miscellaneous\Vector.html ---
VectorLibrary VectorRequireImportBasics.OvertureBasics.TruncBasics.TacticsBasics.PathGroupoids.RequireImportTypes.Sigma.RequireImportAlgebra.AbGroups.AbelianGroupAlgebra.Rings.RingAlgebra.Rings.Module.RequireImportSpaces.Nat.Core.RequireImportSpaces.List.CoreSpaces.List.TheorySpaces.List.Paths.RequireImportabstract_algebra.Local OpenScopemc_scope.LocalSetUniverseMinimizationToSet.LocalSetPolymorphicInductiveCumulativity.VectorsA vector is simply a list with a specified length. This data structure has many uses, but here we will focus on lists of left module elements.DefinitionDefinitionVector@{i|} (A:Type@{i}) (n:nat) :Type@{i}:= {l:listA&lengthl=n}.ConstructorsDefinitionBuild_Vector(A:Type) (n:nat)(f:forall(i:nat), (i<n)%nat->A):VectorAn.Proof.exists(list_map(fun'(i;Hi) =>fiHi) (seq'n)).lhsnrapplylength_list_map.applylength_seq'.Defined.ProjectionsDefinitionentry{A:Type} {n:nat} (v:VectorAn)i{Hi: (i<n)%nat} :A:=nth'(pr1v)i((pr2v)^ #Hi).Basic propertiesDefinitionentry_Build_Vector{A:Type} {n}(f:forall(i:nat), (i<n)%nat->A)i{Hi: (i<n)%nat}:entry(Build_VectorAnf)i=fiHi.Proof.snrefine(nth'_list_map___(_^ #Hi)_@_).1:nrapplylength_seq'.snrapplyap011D.1:nrapplynth'_seq'.rapplypath_ishprop.Defined.Global Instanceistrunc_vector@{i} (A:Type@{i}) (n:nat)k`{IsTrunck.+2A}:IsTrunck.+2 (VectorAn).Proof.rapplyistrunc_sigma@{iii}.Defined.Definitionpath_vector@{i} (A:Type@{i}) {n:nat} (v1v2:Vector@{i}An)(H:foralli(H: (i<n)%nat),entryv1i=entryv2i):v1=v2.Proof.rapplypath_sigma_hprop@{iii}.snrapplypath_list_nth'.1:exact(pr2v1@ (pr2v2)^).introsiHi.snrefine(_@Hi(pr2v1#Hi) @_).1, 2:applynth'_nth'.Defined.Definitionpath_entry_vector{A:Type} {n:nat} (v:VectorAn)(ij:nat) (Hi: (i<n)%nat) (Hj: (j<n)%nat) (p:i=j):entryvi=entryvj.Proof.destructp.applynth'_nth'.Defined.OperationsDefinitionvector_map{AB:Type} {n} (f:A->B):VectorAn->VectorBn:=funv=>Build_VectorBn(funi_=>f(entryvi)).Definitionvector_map2{ABC:Type} {n} (f:A->B->C):VectorAn->VectorBn->VectorCn:=funv1v2=>Build_VectorCn(funi_=>f(entryv1i) (entryv2i)).Abelian group structureSectionVectorAddition.Context(A:AbGroup) (n:nat).Definitionvector_plus:Plus(VectorAn) :=vector_map2(+).Definitionvector_zero:Zero(VectorAn):=Build_VectorAn(fun__=> 0).Definitionvector_neg:Negate(VectorAn) :=vector_map(-).Definitionassociative_vector_plus:Associativevector_plus.Proof.introsv1v2v3;applypath_vector;introsiHi.rewrite4entry_Build_Vector.applyassociativity.Defined.Definitioncommutative_vector_plus:Commutativevector_plus.Proof.introsv1v2;applypath_vector;introsiHi.rewrite2entry_Build_Vector.applycommutativity.Defined.Definitionleft_identity_vector_plus:LeftIdentityvector_plusvector_zero.Proof.introsv;applypath_vector;introsiHi.rewrite2entry_Build_Vector.applyleft_identity.Defined.Definitionright_identity_vector_plus:RightIdentityvector_plusvector_zero.Proof.introsv;applypath_vector;introsiHi.rewrite2entry_Build_Vector.applyright_identity.Defined.Definitionleft_inverse_vector_plus:LeftInversevector_plusvector_negvector_zero.Proof.introsv;applypath_vector;introsiHi.rewrite3entry_Build_Vector.applyleft_inverse.Defined.Definitionright_inverse_vector_plus:RightInversevector_plusvector_negvector_zero.Proof.introsv;applypath_vector;introsiHi.rewrite3entry_Build_Vector.applyright_inverse.Defined.Definitionabgroup_vector:AbGroup.Proof.snrapplyBuild_AbGroup.1:snrapplyBuild_Group.5:repeatsplit.-exact(VectorAn).-exactvector_plus.-exactvector_zero.-exactvector_neg.-exact_.-exactassociative_vector_plus.-exactleft_identity_vector_plus.-exactright_identity_vector_plus.-exactleft_inverse_vector_plus.-exactright_inverse_vector_plus.-exactcommutative_vector_plus.Defined.EndVectorAddition.Argumentsvector_plus{An}v1v2.Module structureSectionVectorScale.A vector of elements of an R-module is itself an R-module. A special case is when the R-module is the ring R itself.Context(M:AbGroup) (n:nat) {R:Ring} `{IsLeftModuleRM}.Definitionvector_lact(r:R) :VectorMn->VectorMn:=vector_map(lactr).Definitionleft_heterodistribute_vector_lact_plus:LeftHeteroDistributevector_lactvector_plusvector_plus.Proof.introsrv1v2;applypath_vector;introsiHi.rewrite5entry_Build_Vector.applydistribute_l.Defined.Definitionright_heterodistribute_vector_lact_plus:RightHeteroDistributevector_lact(+)vector_plus.Proof.introsr1r2v;applypath_vector;introsiHi.rewrite4entry_Build_Vector.applydistribute_r.Defined.Definitionheteroassociative_vector_lact_plus:HeteroAssociativevector_lactvector_lactvector_lact(.*.).Proof.introsrsv;applypath_vector;introsiHi.rewrite3entry_Build_Vector.applyassociativity.Defined.Definitionleft_identity_vector_lact:LeftIdentityvector_lact1.Proof.introsv;applypath_vector;introsiHi.rewriteentry_Build_Vector.applyleft_identity.Defined.Definitionisleftmodule_isleftmodule_vector:IsLeftModuleR(abgroup_vectorMn).Proof.snrapplyBuild_IsLeftModule.-exactvector_lact.-exactleft_heterodistribute_vector_lact_plus.-exactright_heterodistribute_vector_lact_plus.-exactheteroassociative_vector_lact_plus.-exactleft_identity_vector_lact.Defined.EndVectorScale.Argumentsvector_lact{MnR_}rv.

--- Miscellaneous\Wedge.html ---
WedgeLibrary WedgeRequireImportBasicsTypes.RequireImportPointed.CorePointed.pSusp.RequireImportColimits.Pushout.RequireImportWildCat.RequireImportHomotopy.Suspension.LocalSetUniverseMinimizationToSet.Wedge sumsLocal OpenScopepointed_scope.DefinitionWedge(XY:pType) :pType:= [Pushout(fun_:Unit=>pointX) (fun_=>pointY),pushl(pointX)].Notation"X \/ Y" := (WedgeXY) :pointed_scope.Definitionwedge_inl{XY} :X$->X\/Y.Proof.snrapplyBuild_pMap.-exact(funx=>pushlx).-reflexivity.Defined.Definitionwedge_inr{XY} :Y$->X\/Y.Proof.snrapplyBuild_pMap.-exact(funx=>pushrx).-symmetry.byrapplypglue.Defined.Definitionwglue{XY:pType}:pushl(pointX) = (pushr(pointY)) :> (X\/Y) :=pgluett.Wedge recursion into an unpointed type.Definitionwedge_rec'{XY:pType} {Z:Type}(f:X->Z) (g:Y->Z) (w:fpt=gpt):WedgeXY->Z.Proof.snrapplyPushout_rec.-exactf.-exactg.-intro.exactw.Defined.Definitionwedge_rec{XY:pType} {Z:pType} (f:X$->Z) (g:Y$->Z):X\/Y$->Z.Proof.snrapplyBuild_pMap.-snrapply(wedge_rec'fg).exact(point_eqf@ (point_eqg)^).-exact(point_eqf).Defined.Definitionwedge_rec_beta_wglue{XYZ:pType} (f:X$->Z) (g:Y$->Z):ap(wedge_recfg)wglue=point_eqf@ (point_eqg)^:=Pushout_rec_beta_pglue_fg_tt.Definitionwedge_pr1{XY:pType} :X\/Y$->X:=wedge_recpmap_idmappconst.Definitionwedge_pr2{XY:pType} :X\/Y$->Y:=wedge_recpconstpmap_idmap.Definitionwedge_incl(XY:pType) :X\/Y$->X*Y:=pprod_corec_wedge_pr1wedge_pr2.Definitionwedge_incl_beta_wglue{XY:pType}:ap(@wedge_inclXY)wglue= 1.Proof.lhs_Vnrapplyeta_path_prod.lhsnrapplyap011.-lhs_Vnrapplyap_compose.nrapplywedge_rec_beta_wglue.-lhs_Vnrapplyap_compose.nrapplywedge_rec_beta_wglue.-reflexivity.Defined.1-universal property of wedge.Lemmawedge_upXYZ(fg:X\/Y$->Z):f$owedge_inl$==g$owedge_inl->f$owedge_inr$==g$owedge_inr->f$==g.Proof.introspq.snrapplyBuild_pHomotopy.-snrapply(Pushout_ind_pq).intros[].nrapplytransport_paths_FlFr'.lhsnrapply(whiskerL_(dpoint_eqq)).rhsnrapply(whiskerR(dpoint_eqp)).clearpq.lhsnrapplyconcat_p_pp.simpl.applymoveR_pV.lhsnrapplywhiskerL.{nrapplywhiskerR.applyap_V. }lhsnrapplyconcat_p_pp.lhsnrapplywhiskerR.1:applyconcat_pV.rhsnrapplyconcat_p_pp.applymoveL_pM.lhs_Vnrapplyconcat_p1.lhsnrapplyconcat_pp_p.lhs_VnrapplywhiskerL.1:apply(inv_pp1).rhsnrapplywhiskerL.2:applyap_V.applymoveL_pV.reflexivity.-simpl;pelimpq.f_ap.1:applyconcat_1p.lhsnrapplyinv_pp.applyconcat_p1.Defined.Global Instancehasbinarycoproducts:HasBinaryCoproductspType.Proof.introsXY.snrapplyBuild_BinaryCoproduct.-exact(X\/Y).-exactwedge_inl.-exactwedge_inr.-introsZfg.byapplywedge_rec.-introsZfg.snrapplyBuild_pHomotopy.1:reflexivity.bysimpl;pelimf.-introsZfg.snrapplyBuild_pHomotopy.1:reflexivity.simpl.applymoveL_pV.applymoveL_pM.refine(_@ (ap_V_(pgluett))^).applymoveR_Mp.applymoveL_pV.applymoveR_Vp.refine(Pushout_rec_beta_pglue_fg__@_).simpl.bypelimfg.-introsZfgpq.byapplywedge_up.Defined.Lemmas about wedge functionsLemmawedge_pr1_inl{XY} :wedge_pr1$o(@wedge_inlXY) $==pmap_idmap.Proof.reflexivity.Defined.Lemmawedge_pr1_inr{XY} :wedge_pr1$o(@wedge_inrXY) $==pconst.Proof.snrapplyBuild_pHomotopy.1:reflexivity.rhsnrapplyconcat_p1.rhsnrapplyconcat_p1.rhsnrapply(ap_V_wglue).exact(inverse2(wedge_rec_beta_wgluepmap_idmappconst)^).Defined.Lemmawedge_pr2_inl{XY} :wedge_pr2$o(@wedge_inlXY) $==pconst.Proof.reflexivity.Defined.Lemmawedge_pr2_inr{XY} :wedge_pr2$o(@wedge_inrXY) $==pmap_idmap.Proof.snrapplyBuild_pHomotopy.1:reflexivity.rhsnrapplyconcat_p1.rhsnrapplyconcat_p1.rhsnrapply(ap_V_wglue).exact(inverse2(wedge_rec_beta_wgluepconstpmap_idmap)^).Defined.Wedge of an indexed family of pointed typesNote that the index type is not necessarily pointed. An empty wedge is the unit type which is the zero object in the category of pointed types.DefinitionFamilyWedge(I:Type) (X:I->pType) :pType.Proof.snrapplyBuild_pType.-srefine(Pushout(A:=I) (B:=sigX) (C:=pUnit)__).+exact(funi=> (i;pt)).+exact(fun_=>pt).-applypushr.exactpt.Defined.Definitionfwedge_in'(I:Type) (X:I->pType):foralli,Xi$->FamilyWedgeIX:=funi=>Build_pMap__(funx=>pushl(i;x)) (pgluei).We have an inclusion mappushl:sigX->FamilyWedgeX.  WhenIis pointed, so issigX, and then this inclusion map is pointed.Definitionfwedge_in(I:pType) (X:I->pType):psigma(pointed_famX) $->FamilyWedgeIX:=Build_pMap__pushl(pgluept).Recursion principle for the wedge of an indexed family of pointed types.Definitionfwedge_rec(I:Type) (X:I->pType) (Z:pType)(f:foralli,Xi$->Z):FamilyWedgeIX$->Z.Proof.snrapplyBuild_pMap.-snrapplyPushout_rec.+apply(sig_recf).+exactpconst.+introsi.exact(point_eq(fi)).-exactidpath.Defined.We specify a universe variable here to prevent minimization toSet.Global Instancehasallcoproducts_ptype:HasAllCoproductspType@{u}.Proof.introsIX.snrapplyBuild_Coproduct.-exact(FamilyWedgeIX).-exact(fwedge_in'IX).-exact(fwedge_recIX).-introsZfi.snrapplyBuild_pHomotopy.1:reflexivity.simpl.applymoveL_pV.applyequiv_1p_q1.symmetry.exact(Pushout_rec_beta_pglueZ_(unit_namept) (funi=>point_eq(fi))_).-introsZfgh.snrapplyBuild_pHomotopy.+snrapplyPushout_ind.*intros[ix].nrapplyh.*intros[].exact(point_eq_@ (point_eq_)^).*introsi;cbn.nrapplytransport_paths_FlFr'.lhsnrapplyconcat_p_pp.applymoveR_pV.rhsnrapplyconcat_pp_p.applymoveL_pM.symmetry.exact(dpoint_eq(hi)).+reflexivity.Defined.Wedge inclusions into the product can be defined if the indexing type has decidable paths. This is because we need to choose which factor a given wedge summand should land in.Definitionfwedge_incl`{Funext} (I:Type) `(DecidablePathsI) (X:I->pType):FamilyWedgeIX$->pproductX:=cat_coprod_prodX.The pinch map on the suspensionGiven a suspension, there is a natural map from the suspension to the wedge of the suspension with itself. This is known as the pinch map.This is the image to keep in mind:*
                                   /|\
                                  / | \
    Susp X                       /  |  \
                                /   |   \
       *                       * merid(x)*
      /|\                       \   |   /
     / | \                       \  |  /
    /  |  \                       \ | /
   /   |   \      Pinch            \|/
  * merid(x)*   ---------->         *
   \   |   /                       /|\
    \  |  /                       / | \
     \ | /                       /  |  \
      \|/                       /   |   \
       *                       * merid(x)*
                                \   |   /
                                 \  |  /
                                  \ | /
                                   \|/
                                    *Note that this is only a conceptual picture as we aren't working with "reduced suspensions". This means we have to track back alongmeridptmaking this map a little trickier to imagine.The pinch map for a suspension.Definitionpsusp_pinch(X:pType) :psuspX$->psuspX\/psuspX.Proof.refine(Build_pMap__(Susp_recptpt_)idpath).introsx.refine(apwedge_inl_@wglue@apwedge_inr_@wglue^).1,2:exact(loop_susp_unitXx).Defined.It should compute whenaped on a merid.Definitionpsusp_pinch_beta_merid{X:pType} (x:X):ap(psusp_pinchX) (meridx)=apwedge_inl(loop_susp_unitXx) @wglue@apwedge_inr(loop_susp_unitXx) @wglue^.Proof.rapplySusp_rec_beta_merid.Defined.Doing wedge projections on the pinch map gives the identity.Definitionwedge_pr1_psusp_pinch{X}:wedge_pr1$opsusp_pinchX$==Id(psuspX).Proof.snrapplyBuild_pHomotopy.-snrapplySusp_ind_FlFr.+reflexivity.+exact(meridpt).+introsx.rhsnrapplyconcat_1p.rhsnrapplyap_idmap.applymoveR_pM.change(?t=_)with(t=loop_susp_unitXx).lhsnrapply(ap_compose(psusp_pinchX)).lhsnrapply(ap_(psusp_pinch_beta_meridx)).lhsnrapplyap_pp.lhsnrapply(ap(funx=>_@x) (ap_V__)).applymoveR_pV.rhsnrapply(whiskerL_(wedge_rec_beta_wglue__)).lhsnrapplyap_pp.lhsnrapply(ap(funx=>_@x)).{lhs_Vnrapplyap_compose.applyap_const. }lhsnrapplyconcat_p1.lhsnrapplyap_pp.lhsnrapply(ap(funx=>_@x) (wedge_rec_beta_wglue__)).f_ap.lhs_Vnrapply(ap_composewedge_inl).applyap_idmap.-reflexivity.Defined.Definitionwedge_pr2_psusp_pinch{X}:wedge_pr2$opsusp_pinchX$==Id(psuspX).Proof.snrapplyBuild_pHomotopy.-snrapplySusp_ind_FlFr.+reflexivity.+exact(meridpt).+introsx.rhsnrapplyconcat_1p.rhsnrapplyap_idmap.applymoveR_pM.change(?t=_)with(t=loop_susp_unitXx).lhsnrapply(ap_compose(psusp_pinchX)).lhsnrapply(ap_(psusp_pinch_beta_meridx)).lhsnrapplyap_pp.lhsnrapply(ap(funx=>_@x) (ap_V__)).applymoveR_pV.rhsnrapply(whiskerL_(wedge_rec_beta_wglue__)).lhsnrapplyap_pp.lhsnrapply(ap(funx=>_@x)_).{lhs_Vnrapplyap_compose.applyap_idmap. }rhsnrapplyconcat_p1.applymoveR_pM.lhsnrapplyap_pp.rhsnrapplyconcat_pV.lhsnrapply(ap_(wedge_rec_beta_wglue__)).applymoveR_pM.lhs_Vnrapply(ap_composewedge_inl).rapplyap_const.-reflexivity.Defined.

--- Miscellaneous\Wide.html ---
WideLibrary WideWide subcategoriesWe reuse ∑-precategories; a wide subcategory has the same objects, and a ∑ type as its morphisms.  We make use of the fact that the extra component should be an hProp to not require as many proofs.RequireImportCategory.Sigma.OnMorphisms.Notationwide:=sig_mor.

--- Miscellaneous\WildCat.html ---
WildCatLibrary WildCat(* Theory *)RequireExportWildCat.Adjoint.RequireExportWildCat.Core.RequireExportWildCat.Equiv.RequireExportWildCat.Opposite.RequireExportWildCat.Induced.RequireExportWildCat.EquivGpd.RequireExportWildCat.FunctorCat.RequireExportWildCat.NatTrans.RequireExportWildCat.Yoneda.RequireExportWildCat.Square.RequireExportWildCat.PointedCat.RequireExportWildCat.Bifunctor.RequireExportWildCat.Monoidal.RequireExportWildCat.MonoidalTwistConstruction.RequireExportWildCat.Products.RequireExportWildCat.Coproducts.RequireExportWildCat.Displayed.RequireExportWildCat.DisplayedEquiv.(* See also contrib/SetoidRewrite.v for tools that can be used for rewriting in wild categories. *)(* Examples *)RequireExportWildCat.Universe.RequireExportWildCat.Paths.RequireExportWildCat.UnitCat.RequireExportWildCat.EmptyCat.RequireExportWildCat.Prod.RequireExportWildCat.Sum.RequireExportWildCat.Forall.RequireExportWildCat.Sigma.RequireExportWildCat.ZeroGroupoid.(* Higher categories *)RequireExportWildCat.TwoOneCat.

--- Miscellaneous\WType.html ---
WTypeLibrary WTypeRequireImportHoTT.Basics.RequireImportTypes.ForallTypes.Sigma.Theorems about W-types (well-founded trees)InductiveW(A:Type) (B:A->Type) :Type:=w_sup(x:A) : (Bx->WAB) ->WAB.Definitionw_label{AB} (w:WAB) :A:=matchwwith|w_supxy=>xend.Definitionw_arg{AB} (w:WAB) :B(w_labelw) ->WAB:=matchwwith|w_supxy=>yend.Definitionissig_W(A:Type) (B:A->Type):_<~>WAB:=ltac:(issig).PathsDefinitionequiv_path_wtype{AB} (zz':WAB): (w_labelz;w_argz) = (w_labelz';w_argz') :> {a:_&Ba->WAB} <~>z=z':= (equiv_ap'(issig_WAB)^-1%equivzz')^-1%equiv.Definitionequiv_path_wtype'{AB} (zz':WAB): {p:w_labelz=w_labelz'&w_argz=w_argz'otransportBp}<~>z=z'.Proof.refine(equiv_path_wtype__oEequiv_path_sigma___oE_).applyequiv_functor_sigma_id.destructzas[z1z2],z'as[z1'z2'].cbn;introsp.destructp.reflexivity.Defined.W-types preserve truncationGlobal Instanceistrunc_wtype`{Funext}{AB} {n:trunc_index} `{IsTruncn.+1A}:IsTruncn.+1 (WAB) | 100.Proof.applyistrunc_S.introsz;inductionzas[aw].introy;destructyas[a0w0].nrefine(istrunc_equiv_istrunc_(equiv_path_wtype'__)).rapplyistrunc_sigma.cbn;introp.destructp.apply(istrunc_equiv_istrunc_(equiv_path_forall__)).Defined.

--- Miscellaneous\Yoneda.html ---
YonedaLibrary YonedaRequireImportBasics.OvertureBasics.Tactics.RequireImportWildCat.Core.RequireImportWildCat.Equiv.RequireImportWildCat.Universe.RequireImportWildCat.Opposite.RequireImportWildCat.FunctorCat.RequireImportWildCat.NatTrans.RequireImportWildCat.Prod.RequireImportWildCat.Bifunctor.RequireImportWildCat.ZeroGroupoid.Two-variable hom-functorsGlobal Instanceis0functor_hom{A} `{Is01CatA}: @Is0Functor(A^op*A)Type__(uncurry(@HomA_)).Proof.applyBuild_Is0Functor.intros[a1a2] [b1b2] [f1f2]g;cbnin*.exact(f2$og$of1).Defined.This requires morphism extensionality!Global Instanceis1functor_hom{A} `{HasMorExtA}: @Is1Functor(A^op*A)Type________(uncurry(@HomA_))_.Proof.applyBuild_Is1Functor.-intros[a1a2] [b1b2] [f1f2] [g1g2] [p1p2]q;unfoldfst,sndin*.applypath_hom.refine(((p2$@Rq) $@R_) $@ ((g2$oq) $@Lp1)).-intros[a1a2]f;cbnin*.applypath_hom.exact(cat_idr_$@cat_idlf).-intros[a1a2] [b1b2] [c1c2] [f1f2] [g1g2]h;cbnin*.applypath_hom.refine(cat_assoc___$@_).refine(cat_assoc___$@_).refine(_$@cat_assoc_opp___).refine(g2$@L_).refine(_$@cat_assoc_opp___).refine(cat_assoc_opp___).Defined.Global Instanceis0bifunctor_hom{A} `{Is01CatA}:Is0Bifunctor(A:=A^op) (B:=A) (C:=Type) (@HomA_).Proof.nrapplyBuild_Is0Bifunctor'.1-2:exact_.exactis0functor_hom.Defined.While it is possible to prove the bifunctor coherence condition fromIs1Cat_Strong, 1-functoriality requires morphism extensionality.Global Instanceis1bifunctor_hom{A} `{Is1CatA} `{HasMorExtA}:Is1Bifunctor(A:=A^op) (B:=A) (C:=Type) (@HomA_).Proof.nrapplyBuild_Is1Bifunctor'.exactis1functor_hom.Defined.Definitionfun01_hom{A} `{Is01CatA}:Fun01(A^op*A)Type:= @Build_Fun01_____is0functor_hom.The covariant Yoneda lemmaThis is easier than the contravariant version because it doesn't involve any "op"s.Definitionopyon{A:Type} `{IsGraphA} (a:A) :A->Type:=funb=> (a$->b).We prove this explicitly instead of using the bifunctor instance above so that we can applyfmapin each argument independently without mapping an identity in the other.Global Instanceis0functor_opyon{A:Type} `{Is01CatA} (a:A):Is0Functor(opyona).Proof.applyBuild_Is0Functor.unfoldopyon;introsbcfg;cbnin*.exact(f$og).Defined.Global Instanceis1functor_opyon{A:Type} `{Is1CatA} `{!HasMorExtA} (a:A):Is1Functor(opyona).Proof.rapplyBuild_Is1Functor.+introsxyfgph.applypath_hom.apply(cat_prewhiskerp).+introsxh.applypath_hom.applycat_idl.+introsxyzfgh.applypath_hom.applycat_assoc.Defined.We record these corollaries here, since we use some of them below.Definitionequiv_postcompose_cat_equiv{A:Type} `{HasEquivsA} `{!HasMorExtA}{xyz:A} (f:y$<~>z): (x$->y) <~> (x$->z):=emap(opyonx)f.Definitionequiv_precompose_cat_equiv{A:Type} `{HasEquivsA} `{!HasMorExtA}{xyz:A} (f:x$<~>y): (y$->z) <~> (x$->z):= @equiv_postcompose_cat_equivA^op______zyxf.(* The following implicitly usehasequivs_core.  Note that whenAhas morphism extensionality, it doesn't follow thatcoreAdoes.  We'd need to know that being an equivalence is a proposition, and we don't assume that (since even forTypeit requiresFunext, seehasmorext_core_type). So we need to assume this in the following results. *)Postcomposition with a cat_equiv is an equivalence between the types of equivalences.Definitionequiv_postcompose_core_cat_equiv{A:Type} `{HasEquivsA} `{!HasMorExt(coreA)}{xyz:A} (f:y$<~>z): (x$<~>y) <~> (x$<~>z).Proof.change((Build_corex$->Build_corey) <~> (Build_corex$->Build_corez)).refine(equiv_postcompose_cat_equiv(A:=coreA)_).exactf.(* It doesn't work to insertfon the previous line. *)Defined.Definitionequiv_precompose_core_cat_equiv{A:Type} `{HasEquivsA} `{!HasMorExt(coreA)}{xyz:A} (f:x$<~>y): (y$<~>z) <~> (x$<~>z).Proof.change((Build_corey$->Build_corez) <~> (Build_corex$->Build_corez)).refine(equiv_precompose_cat_equiv(A:=coreA)_).exactf.(* It doesn't work to insertfon the previous line. *)Defined.Definitionopyoneda{A:Type} `{Is01CatA} (a:A)(F:A->Type) {ff:Is0FunctorF}:Fa-> (opyona$=>F).Proof.introsxbf.exact(fmapFfx).Defined.Definitionun_opyoneda{A:Type} `{Is01CatA}(a:A) (F:A->Type) {ff:Is0FunctorF}: (opyona$=>F) ->Fa:=funalpha=>alphaa(Ida).Global Instanceis1natural_opyoneda{A:Type} `{Is1CatA}(a:A) (F:A->Type) `{!Is0FunctorF, !Is1FunctorF} (x:Fa):Is1Natural(opyona)F(opyonedaaFx).Proof.snrapplyBuild_Is1Natural.unfoldopyon,opyoneda;introsbcfg;cbnin*.exact(fmap_compFgfx).Defined.This is form of injectivity ofopyoneda.Definitionopyoneda_isinj{A:Type} `{Is1CatA} (a:A)(F:A->Type) `{!Is0FunctorF, !Is1FunctorF}(xx':Fa) (p:forallb,opyonedaaFxb==opyonedaaFx'b):x=x'.Proof.refine((fmap_idFax)^ @_@fmap_idFax').cbninp.exact(pa(Ida)).Defined.This says thatopyonis faithful, although we haven't yet defined a graph structure on natural transformations to express this in that way.  This follows from the previous result, but then would needHasMorExtA, since the previous result assumes thatFis a 1-functor, which is stronger than what is needed.  The direct proof below only needs the weaker assumptionIs1Cat_StrongA.Definitionopyon_faithful{A:Type} `{Is1Cat_StrongA}(ab:A) (fg:b$->a)(p:forall(c:A) (h:a$->c),h$of=h$og):f=g:= (cat_idl_strongf)^ @pa(Ida) @cat_idl_strongg.The composite in one direction is the identity map.Definitionopyoneda_issect{A:Type} `{Is1CatA} (a:A)(F:A->Type) `{!Is0FunctorF, !Is1FunctorF}(x:Fa):un_opyonedaaF(opyonedaaFx) =x:=fmap_idFax.We assume for the converse that the coherences inAare equalities (this is a weak funext-type assumption).  Note that we do not in general recover the witness of 1-naturality.  Indeed, ifAis fully coherent, then a transformation of the formopyonedaaFxis always also fully coherently natural, so an incoherent witness of 1-naturality could not be recovered in this way.Definitionopyoneda_isretr{A:Type} `{Is1Cat_StrongA} (a:A)(F:A->Type) `{!Is0FunctorF, !Is1FunctorF}(alpha:opyona$=>F) {alnat:Is1Natural(opyona)Falpha}(b:A):opyonedaaF(un_opyonedaaFalpha)b$==alphab.Proof.unfoldopyoneda,un_opyoneda,opyon;introsf.refine((isnatalphaf(Ida))^ @_).cbn.applyap.exact(cat_idr_strongf).Defined.A natural transformation between representable functors induces a map between the representing objects.Definitionopyon_cancel{A:Type} `{Is01CatA} (ab:A): (opyona$=>opyonb) -> (b$->a):=un_opyonedaa(opyonb).Definitionopyon1{A:Type} `{Is01CatA} (a:A) :Fun01AType.Proof.rapply(Build_Fun01__(opyona)).Defined.Definitionopyon11{A:Type} `{Is1CatA} `{!HasMorExtA} (a:A) :Fun11AType.Proof.rapply(Build_Fun11__(opyona)).Defined.An equivalence between representable functors induces an equivalence between the representing objects.Definitionopyon_equiv{A:Type} `{HasEquivsA} `{!Is1Cat_StrongA}{ab:A}: (opyon1a$<~>opyon1b) -> (b$<~>a).Proof.introsf.refine(cate_adjointify(fa(Ida)) (f^-1$b(Idb))__);applyGpdHom_path;cbnin*.-refine((isnat_natequiv(natequiv_inversef) (fa(Ida)) (Idb))^ @_);cbn.refine(_@cate_issect(fa) (Ida));cbn.applyap.srapplycat_idr_strong.-refine((isnat_natequivf(f^-1$b(Idb)) (Ida))^ @_);cbn.refine(_@cate_isretr(fb) (Idb));cbn.applyap.srapplycat_idr_strong.Defined.Definitionnatequiv_opyon_equiv{A:Type} `{HasEquivsA}`{!HasMorExtA} {ab:A}: (b$<~>a) -> (opyon1a$<~>opyon1b).Proof.introe.snrapplyBuild_NatEquiv.-introsc.exact(equiv_precompose_cat_equive).-rapplyis1natural_opyoneda.Defined.The covariant Yoneda lemma using 0-groupoidsWe repeat the above, regardingopyonas landing in 0-groupoids, using the 1-category structure onZeroGpdinZeroGroupoid.v.  This has many advantages.  It avoidsHasMorExt, which means that we don't needFunextin many examples.  It also avoidsIs1Cat_Strong, which means the results all have the same hypotheses, namely thatAis a 1-category.  This allows us to simplify the proof ofopyon_equiv_0gpd, making use ofopyoneda_isretr_0gpd.Definitionopyon_0gpd{A:Type} `{Is1CatA} (a:A) :A->ZeroGpd:=funb=>Build_ZeroGpd(a$->b)___.Global Instanceis0functor_hom_0gpd{A:Type} `{Is1CatA}:Is0Functor(A:=A^op*A) (B:=ZeroGpd) (uncurry(opyon_0gpd(A:=A))).Proof.nrapplyBuild_Is0Functor.intros[a1a2] [b1b2] [f1f2];unfoldopin*;cbnin*.rapply(Build_Morphism_0Gpd(opyon_0gpda1a2) (opyon_0gpdb1b2)(cat_postcompb1f2ocat_precompa2f1)).Defined.Global Instanceis1functor_hom_0gpd{A:Type} `{Is1CatA}:Is1Functor(A:=A^op*A) (B:=ZeroGpd) (uncurry(opyon_0gpd(A:=A))).Proof.nrapplyBuild_Is1Functor.-intros[a1a2] [b1b2] [f1f2] [g1g2] [pq]h.exact(h$@Lp$@@q).-intros[a1a2]h.exact(cat_idl_$@cat_idr_).-intros[a1a2] [b1b2] [c1c2] [f1f2] [g1g2]h.refine(cat_assoc___$@_).refine(g2$@L_).refine(_$@L(cat_assoc_opp___) $@_).exact(cat_assoc_opp___).Defined.Global Instanceis0bifunctor_hom_0gpd{A:Type} `{Is1CatA}:Is0Bifunctor(A:=A^op) (B:=A) (C:=ZeroGpd) (opyon_0gpd(A:=A)).Proof.snrapplyBuild_Is0Bifunctor'.1,2:exact_.exactis0functor_hom_0gpd.Defined.Global Instanceis1bifunctor_hom_0gpd{A:Type} `{Is1CatA}:Is1Bifunctor(A:=A^op) (B:=A) (C:=ZeroGpd) (opyon_0gpd(A:=A)).Proof.snrapplyBuild_Is1Bifunctor'.exactis1functor_hom_0gpd.Defined.Global Instanceis0functor_opyon_0gpd{A:Type} `{Is1CatA} (a:A):Is0Functor(opyon_0gpda).Proof.applyBuild_Is0Functor.introsbcf.exact(Build_Morphism_0Gpd(opyon_0gpdab) (opyon_0gpdac) (cat_postcompaf)_).Defined.Global Instanceis1functor_opyon_0gpd{A:Type} `{Is1CatA} (a:A):Is1Functor(opyon_0gpda).Proof.rapplyBuild_Is1Functor.+introsxyfgph.apply(cat_prewhiskerp).+introsxh.applycat_idl.+introsxyzfgh.applycat_assoc.Defined.Definitionopyoneda_0gpd{A:Type} `{Is1CatA} (a:A)(F:A->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}:Fa-> (opyon_0gpda$=>F).Proof.introsxb.refine(Build_Morphism_0Gpd(opyon_0gpdab) (Fb) (funf=>fmapFfx)_).rapplyBuild_Is0Functor.introsf1f2h.exact(fmap2Fhx).Defined.Definitionun_opyoneda_0gpd{A:Type} `{Is1CatA}(a:A) (F:A->ZeroGpd) {ff:Is0FunctorF}: (opyon_0gpda$=>F) ->Fa:=funalpha=>alphaa(Ida).Global Instanceis1natural_opyoneda_0gpd{A:Type} `{Is1CatA}(a:A) (F:A->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF} (x:Fa):Is1Natural(opyon_0gpda)F(opyoneda_0gpdaFx).Proof.snrapplyBuild_Is1Natural.unfoldopyon_0gpd,opyoneda_0gpd;introsbcfg;cbnin*.exact(fmap_compFgfx).Defined.This is form of injectivity ofopyoneda_0gpd.Definitionopyoneda_isinj_0gpd{A:Type} `{Is1CatA} (a:A)(F:A->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}(xx':Fa) (p:forallb:A,opyoneda_0gpdaFxb$==opyoneda_0gpdaFx'b):x$==x'.Proof.refine((fmap_idFax)^$ $@_$@fmap_idFax').cbninp.exact(pa(Ida)).Defined.This says thatopyon_0gpdis faithful, although we haven't yet defined a graph structure on natural transformations to express this in that way.Definitionopyon_faithful_0gpd{A:Type} `{Is1CatA} (ab:A)(fg:b$->a) (p:forall(c:A) (h:a$->c),h$of$==h$og):f$==g:=opyoneda_isinj_0gpda_fgp.The composite in one direction is the identity map.Definitionopyoneda_issect_0gpd{A:Type} `{Is1CatA} (a:A)(F:A->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}(x:Fa):un_opyoneda_0gpdaF(opyoneda_0gpdaFx) $==x:=fmap_idFax.For the other composite, note that we do not in general recover the witness of 1-naturality.  Indeed, ifAis fully coherent, then a transformation of the formopyonedaaFxis always also fully coherently natural, so an incoherent witness of 1-naturality could not be recovered in this way.Definitionopyoneda_isretr_0gpd{A:Type} `{Is1CatA} (a:A)(F:A->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}(alpha:opyon_0gpda$=>F) {alnat:Is1Natural(opyon_0gpda)Falpha}(b:A):opyoneda_0gpdaF(un_opyoneda_0gpdaFalpha)b$==alphab.Proof.unfoldopyoneda,un_opyoneda,opyon;introsf.refine((isnatalphaf(Ida))^$ $@_).cbn.apply(fmap(alphab)).exact(cat_idrf).Defined.A natural transformation between representable functors induces a map between the representing objects.Definitionopyon_cancel_0gpd{A:Type} `{Is1CatA} (ab:A): (opyon_0gpda$=>opyon_0gpdb) -> (b$->a):=un_opyoneda_0gpda(opyon_0gpdb).Since no extra hypotheses are needed, we use the name with "1" for theFun11version.Definitionopyon1_0gpd{A:Type} `{Is1CatA} (a:A) :Fun11AZeroGpd:=Build_Fun11__(opyon_0gpda).An equivalence between representable functors induces an equivalence between the representing objects.  We explain how this compares toopyon_equivabove.  Instead of assuming that eachfc:(a$->c)->(b$->c)is an equivalence of types, it only needs to be an equivalence of 0-groupoids.  For example, this means that we have a mapgc:(b$->c)->(a$->c)such that for eachk:a$->c,gc(fck)$==k, rather thangc(fck)=kas the version with types requires.  Similarly, the naturality is up to 2-cells, instead of up to paths.  This allows us to avoidFunextandHasMorExtwhen using this result.  As a side benefit, we also don't require thatAis strong. The proof is also simpler, since we can re-use the work done inopyoneda_isretr_0gpd.Definitionopyon_equiv_0gpd{A:Type} `{HasEquivsA}{ab:A} (f:opyon1_0gpda$<~>opyon1_0gpdb):b$<~>a.Proof.(* These are the maps that will define the desired equivalence: *)set(fa:= (cate_funfa) (Ida)).(* Equivalently,un_opyoneda_0gpda_f. *)set(gb:= (cate_funf^-1$b) (Idb)).(* Equivalently,un_opyoneda_0gpdb_f^-1$. *)srapply(cate_adjointifyfagb).(*opyoneda_0gpdis defined by postcomposition, soopyoneda_isretr_0gpdsimplifies both LHSs.*)-exact(opyoneda_isretr_0gpd__f^-1$afa$@cat_eissect(fa) (Ida)).-exact(opyoneda_isretr_0gpd__fbgb$@cat_eisretr(fb) (Idb)).Defined.Sinceopyon_0gpdis a 1-functor, postcomposition with acat_equivis an equivalence between the hom 0-groupoids. Note that we do not requireHasMorExt, asequiv_postcompose_cat_equivdoes.Definitionequiv_postcompose_cat_equiv_0gpd{A:Type} `{HasEquivsA}{xyz:A} (f:y$<~>z):opyon_0gpdxy$<~>opyon_0gpdxz:=emap(opyon_0gpdx)f.The dual result, which is used in the next result.Definitionequiv_precompose_cat_equiv_0gpd{A:Type} `{HasEquivsA}{xyz:A} (f:x$<~>y):opyon_0gpdyz$<~>opyon_0gpdxz:= @equiv_postcompose_cat_equiv_0gpdA^op_____zyxf.A converse toopyon_equiv_0gpd.  Together, we get a logical equivalence betweenb$<~>aandopyon_0gpda$<~>opyon_0gpdb, withoutHasMorExt.Definitionnatequiv_opyon_equiv_0gpd{A:Type} `{HasEquivsA}{ab:A} (e:b$<~>a):opyon1_0gpda$<~>opyon1_0gpdb.Proof.snrapplyBuild_NatEquiv.-introc;exact(equiv_precompose_cat_equiv_0gpde).-rapplyis1natural_opyoneda_0gpd.Defined.The contravariant Yoneda lemmaWe can deduce this from the covariant version with some boilerplate.Definitionyon{A:Type} `{IsGraphA} (a:A) :A^op->Type:=opyon(A:=A^op)a.Global Instanceis0functor_yon{A:Type} `{H:Is01CatA} (a:A):Is0Functor(yona):=is0functor_opyon(A:=A^op)a.Global Instanceis1functor_yon{A:Type} `{H:Is1CatA} `{!HasMorExtA} (a:A):Is1Functor(yona):=is1functor_opyon(A:=A^op)a.Definitionyoneda{A:Type} `{Is01CatA} (a:A)(F:A^op->Type) `{!Is0FunctorF}:Fa-> (yona$=>F):= @opyoneda(A^op)__aF_.Definitionun_yoneda{A:Type} `{Is01CatA} (a:A)(F:A^op->Type) `{!Is0FunctorF}: (yona$=>F) ->Fa:=un_opyoneda(A:=A^op)aF.Global Instanceis1natural_yoneda{A:Type} `{Is1CatA} (a:A)(F:A^op->Type) `{!Is0FunctorF, !Is1FunctorF} (x:Fa):Is1Natural(yona)F(yonedaaFx):=is1natural_opyoneda(A:=A^op)aFx.Definitionyoneda_isinj{A:Type} `{Is1CatA} (a:A)(F:A^op->Type) `{!Is0FunctorF, !Is1FunctorF}(xx':Fa) (p:forallb,yonedaaFxb==yonedaaFx'b):x=x':=opyoneda_isinj(A:=A^op)aFxx'p.Definitionyon_faithful{A:Type} `{Is1Cat_StrongA}(ab:A) (fg:b$->a)(p:forall(c:A) (h:c$->b),f$oh=g$oh):f=g:=opyon_faithful(A:=A^op)bafgp.Definitionyoneda_issect{A:Type} `{Is1CatA} (a:A)(F:A^op->Type) `{!Is0FunctorF, !Is1FunctorF} (x:Fa):un_yonedaaF(yonedaaFx) =x:=opyoneda_issect(A:=A^op)aFx.Definitionyoneda_isretr{A:Type} `{Is1Cat_StrongA} (a:A)(F:A^op->Type) `{!Is0FunctorF}(* Without the hint here, Coq guesses to first project fromIs1Cat_StrongAand then pass to opposites, whereas what we need is to first pass to opposites and then project. *)`{@Is1Functor_____(is1cat_is1cat_strongA^op)____F_}(alpha:yona$=>F) {alnat:Is1Natural(yona)Falpha}(b:A):yonedaaF(un_yonedaaFalpha)b$==alphab:=opyoneda_isretr(A:=A^op)aFalphab.Definitionyon_cancel{A:Type} `{Is01CatA} (ab:A): (yona$=>yonb) -> (a$->b):=un_yonedaa(yonb).Definitionyon1{A:Type} `{Is01CatA} (a:A) :Fun01A^opType:=opyon1(A:=A^op)a.Definitionyon11{A:Type} `{Is1CatA} `{!HasMorExtA} (a:A) :Fun11A^opType:=opyon11(A:=A^op)a.Definitionyon_equiv{A:Type} `{HasEquivsA} `{!Is1Cat_StrongA}(ab:A): (yon1a$<~>yon1b) -> (a$<~>b):=opyon_equiv(A:=A^op).Definitionnatequiv_yon_equiv{A:Type} `{HasEquivsA}`{!HasMorExtA} (ab:A): (a$<~>b) -> (yon1a$<~>yon1b):=natequiv_opyon_equiv(A:=A^op).The contravariant Yoneda lemma using 0-groupoidsDefinitionyon_0gpd{A:Type} `{Is1CatA} (a:A) :A^op->ZeroGpd:=opyon_0gpd(A:=A^op)a.Global Instanceis0functor_yon_0gpd{A:Type} `{Is1CatA} (a:A):Is0Functor(yon_0gpda):=is0functor_opyon_0gpd(A:=A^op)a.Global Instanceis1functor_yon_0gpd{A:Type} `{Is1CatA} (a:A):Is1Functor(yon_0gpda):=is1functor_opyon_0gpd(A:=A^op)a.Definitionyoneda_0gpd{A:Type} `{Is1CatA} (a:A)(F:A^op->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}:Fa-> (yon_0gpda$=>F):=opyoneda_0gpd(A:=A^op)aF.Definitionun_yoneda_0gpd{A:Type} `{Is1CatA}(a:A) (F:A^op->ZeroGpd) {ff:Is0FunctorF}: (yon_0gpda$=>F) ->Fa:=un_opyoneda_0gpd(A:=A^op)aF.Global Instanceis1natural_yoneda_0gpd{A:Type} `{Is1CatA}(a:A) (F:A^op->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF} (x:Fa):Is1Natural(yon_0gpda)F(yoneda_0gpdaFx):=is1natural_opyoneda_0gpd(A:=A^op)aFx.Definitionyoneda_isinj_0gpd{A:Type} `{Is1CatA} (a:A)(F:A^op->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}(xx':Fa) (p:forallb:A,yoneda_0gpdaFxb$==yoneda_0gpdaFx'b):x$==x':=opyoneda_isinj_0gpd(A:=A^op)aFxx'p.Definitionyon_faithful_0gpd{A:Type} `{Is1CatA} (ab:A)(fg:b$->a) (p:forall(c:A) (h:c$->b),f$oh$==g$oh):f$==g:=opyon_faithful_0gpd(A:=A^op)bafgp.Definitionyoneda_issect_0gpd{A:Type} `{Is1CatA} (a:A)(F:A^op->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}(x:Fa):un_yoneda_0gpdaF(yoneda_0gpdaFx) $==x:=opyoneda_issect_0gpd(A:=A^op)aFx.Definitionyoneda_isretr_0gpd{A:Type} `{Is1CatA} (a:A)(F:A^op->ZeroGpd) `{!Is0FunctorF, !Is1FunctorF}(alpha:yon_0gpda$=>F) {alnat:Is1Natural(yon_0gpda)Falpha}(b:A):yoneda_0gpdaF(un_yoneda_0gpdaFalpha)b$==alphab:=opyoneda_isretr_0gpd(A:=A^op)aFalphab.Definitionyon_cancel_0gpd{A:Type} `{Is1CatA} (ab:A): (yon_0gpda$=>yon_0gpdb) -> (a$->b):=opyon_cancel_0gpd(A:=A^op)ab.Definitionyon1_0gpd{A:Type} `{Is1CatA} (a:A) :Fun11A^opZeroGpd:=opyon1_0gpd(A:=A^op)a.Definitionyon_equiv_0gpd{A:Type} `{HasEquivsA}{ab:A} (f:yon1_0gpda$<~>yon1_0gpdb):a$<~>b:=opyon_equiv_0gpd(A:=A^op)f.Definitionnatequiv_yon_equiv_0gpd{A:Type} `{HasEquivsA}{ab:A} (e:a$<~>b):yon1_0gpd(A:=A)a$<~>yon1_0gpdb:=natequiv_opyon_equiv_0gpd(A:=A^op) (e:CatEquiv(A:=A^op)ba).

--- Miscellaneous\Z.html ---
ZLibrary ZRequireImportClasses.interfaces.canonical_names.RequireImportAlgebra.AbGroups.RequireImportAlgebra.Rings.CRing.RequireImportSpaces.IntSpaces.Pos.RequireImportWildCat.Core.In this file we define the ringcring_Zof integers with underlying abelian groupabgroup_Zdefined in Algebra.AbGroups.Z. We also define multiplication by an integer in a general ring, and show thatcring_Zis initial.The ring of integersDefinitioncring_Z:CRing.Proof.snrapplyBuild_CRing'.-exactabgroup_Z.-exact1%int.-exactint_mul.-exactint_mul_comm.-exactint_mul_assoc.-exactint_dist_l.-exactint_mul_1_l.Defined.Local OpenScopemc_scope.Given a ring elementr, we get a mapInt->Rsending an integer to that multiple ofr.Definitionrng_int_mult(R:Ring) :=grp_pow_homo:R->Int->R.Multiplying a ring elementrby an integernis equivalent to first multiplying the unit1of the ring byn, and then multiplying the result byr.  This is distributivity of right multiplication byrover the sum.Definitionrng_int_mult_dist_r{R:Ring} (r:R) (n:cring_Z):rng_int_multRrn= (rng_int_multR1n) *r.Proof.cbn.rhsnrapply(grp_pow_natural(grp_homo_rng_right_multr));cbn.byrewriterng_mult_one_l.Defined.Similarly, there is a left-distributive law.Definitionrng_int_mult_dist_l{R:Ring} (r:R) (n:cring_Z):rng_int_multRrn=r* (rng_int_multR1n).Proof.cbn.rhsnrapply(grp_pow_natural(grp_homo_rng_left_multr));cbn.byrewriterng_mult_one_r.Defined.rng_int_multR1preserves multiplication.  This requires that the specified ring element is the unit.Global Instanceissemigrouppreserving_mult_rng_int_mult(R:Ring):IsSemiGroupPreserving(A:=cring_Z) (Aop:=(.*.)) (Bop:=(.*.)) (rng_int_multR1).Proof.introsxy.cbn;unfoldsg_op.lhsnrapplygrp_pow_int_mul.nrapplyrng_int_mult_dist_l.Defined.rng_int_multR1is a ring homomorphismDefinitionrng_homo_int(R:Ring) : (cring_Z:Ring) $->R.Proof.snrapplyBuild_RingHomomorphism.1:exact(rng_int_multR1).repeatsplit.1,2:exact_.applyrng_plus_zero_r.Defined.The integers are the initial commutative ringGlobal Instanceisinitial_cring_Z:IsInitialcring_Z.Proof.unfoldIsInitial.introR.exists(rng_homo_intR).introsgx.unfoldrng_homo_int,rng_int_mult;cbn.inductionxas[|x|x].-byrhsnrapply(grp_homo_unitg).-rewritegrp_pow_succ.change(x.+1%int)with(1 +x)%int.rewrite(rng_homo_plusg1x).rewriterng_homo_one.f_ap.-rewritegrp_pow_pred.rewriteIHx.clearIHx.rewrite<- (rng_homo_oneg).rewrite<- (rng_homo_negateg).lhs_Vnrapply(rng_homo_plusg).f_ap.Defined.

--- Miscellaneous\ZeroGroupoid.html ---
ZeroGroupoidLibrary ZeroGroupoidRequireImportBasics.OvertureBasics.TacticsBasics.PathGroupoids.RequireImportWildCat.CoreWildCat.EquivWildCat.EquivGpdWildCat.Forall.The wild 1-category of 0-groupoids.Here we define a wild 1-category structure on the type of 0-groupoids.  We think of the 1-cellsg$==hin a 0-groupoidGas a substitute for the pathsg=h, and so we closely follow the definitions used for the 1-category of types with=replaced by$==.  In fact, the 1-category structure on types should be the pullback of the 1-category structure on 0-groupoids along a natural mapType->ZeroGpdwhich sendsAtoAequipped with its path types.  A second motivating example is the 0-groupoid with underlying typeA->Band homotopies as the 1-cells.  The definitions chosen here exactly make the Yoneda lemmaopyon_equiv_0gpdgo through.RecordZeroGpd:= {carrier:>Type;isgraph_carrier:IsGraphcarrier;is01cat_carrier:Is01Catcarrier;is0gpd_carrier:Is0Gpdcarrier;}.Global Existing Instanceisgraph_carrier.Global Existing Instanceis01cat_carrier.Global Existing Instanceis0gpd_carrier.(* The morphisms of 0-groupoids are the 0-functors.  This is the same asFun01, but we put a different graph and 01-category structure on it, so we give this a custom name. *)RecordMorphism_0Gpd(GH:ZeroGpd) := {fun_0gpd:>carrierG->carrierH;is0functor_fun_0gpd:Is0Functorfun_0gpd;}.Global Existing Instanceis0functor_fun_0gpd.Now we show that the typeZeroGpdof 0-groupoids is itself a 1-category, with morphisms the 0-functors.Global Instanceisgraph_0gpd:IsGraphZeroGpd.Proof.applyBuild_IsGraph.exactMorphism_0Gpd.Defined.Global Instanceis01cat_0gpd:Is01CatZeroGpd.Proof.srapplyBuild_Is01Cat.-introG.exact(Build_Morphism_0GpdGGidmap_).-introsGHKfg.exact(Build_Morphism_0Gpd__(fog)_).Defined.(* The 2-cells are unnatural transformations, and are analogous to homotopies. *)Global Instanceis2graph_0gpd:Is2GraphZeroGpd.Proof.introsGH.snrapplyBuild_IsGraph.introsfg.exact(forallx:G,fx$==gx).Defined.Global Instanceis1cat_0gpd:Is1CatZeroGpd.Proof.snrapplyBuild_Is1Cat.-introsGH.srapplyBuild_Is01Cat.+introf.exact(funx=>Id(fx)).+introsfghpq.exact(funx=>qx$@px).-introsGH.srapplyBuild_Is0Gpd.introsfgp.exact(funx=> (px)^$).-introsGHKf.srapplyBuild_Is0Functor.introsghpx.cbn.exact(fmapf(px)).-introsGHKf.srapplyBuild_Is0Functor.introsghpx.cbn.exact(p(fx)).-reflexivity.(* Associativity. *)-reflexivity.(* Associativity in opposite direction. *)-reflexivity.(* Left identity. *)-reflexivity.(* Right identity. *)Defined.We define equivalences of 0-groupoids as the bi-invertible maps, usingCat_BiInvandCat_IsBiInv.  This definition is chosen to provide what is needed for the Yoneda lemma, and because it specializes to one of the correct definitions for types.Global Instancehasequivs_0gpd:HasEquivsZeroGpd:=cat_hasequivsZeroGpd.Coq can't find the composite of the coercionscate_fun:G$<~>H>->G$->Handfun_0gpd:Morphism_0GpdGH>->G->H, probably because it passes through the definitional equality ofG$->HandMorphism_0GpdGH.  I couldn't find a solution, so instead here is a helper function to manually do the coercion when needed.Definitionequiv_fun_0gpd{GH:ZeroGpd} (f:G$<~>H) :G->H:=fun_0gpd__(cat_equiv_fun___f).Tools for manipulating equivalences of 0-groupoidsEven though the proofs are easy, in certain contexts Coq gets confused about$==vs$->, which makes it hard to prove this inline.  So we record them here.Every equivalence is injective.Definitionisinj_equiv_0gpd{GH:ZeroGpd} (f:G$<~>H){xy:G} (h:equiv_fun_0gpdfx$==equiv_fun_0gpdfy):x$==y.Proof.exact((cat_eissectfx)^$ $@fmap(equiv_fun_0gpdf^-1$)h$@cat_eissectfy).Defined.This is one example of many things that could be ported from Basics/Equivalences.v.DefinitionmoveR_equiv_V_0gpd{GH:ZeroGpd} (f:G$<~>H) (x:H) (y:G) (p:x$==equiv_fun_0gpdfy):equiv_fun_0gpdf^-1$x$==y:=fmap(equiv_fun_0gpdf^-1$)p$@cat_eissectfy.DefinitionmoveL_equiv_V_0gpd{GH:ZeroGpd} (f:G$<~>H) (x:H) (y:G) (p:equiv_fun_0gpdfy$==x):y$==equiv_fun_0gpdf^-1$x:= (cat_eissectfy)^$ $@fmap(equiv_fun_0gpdf^-1$)p.fis an equivalence of 0-groupoids iffIsSurjInjfWe now give a different characterization of the equivalences of 0-groupoids, as the injective split essentially surjective 0-functors, which are defined in EquivGpd.  Advantages of this logically equivalent formulation are that it tends to be easier to prove in examples and that in some cases it is definitionally equal toExtensionAlong, which is convenient.  See Homotopy/Suspension.v and Algebra/AbGroups/Abelianization for examples. Advantages of the bi-invertible definition are that it reproduces a definition that is equivalent toIsEquivwhen applied to types, assumingFunext.  It also works in any 1-category.Every equivalence is injective and split essentially surjective.Global Instanceissurjinj_equiv_0gpd{GH:ZeroGpd} (f:G$<~>H):IsSurjInj(equiv_fun_0gpdf).Proof.econstructor.-introy.exists(equiv_fun_0gpdf^-1$y).rapplycat_eisretr.-applyisinj_equiv_0gpd.Defined.Conversely, every injective split essentially surjective 0-functor is an equivalence.  In practice, this is often the easiest way to prove that a functor is an equivalence.Definitionisequiv_0gpd_issurjinj{GH:ZeroGpd} (F:G$->H){e:IsSurjInjF}:Cat_IsBiInvF.Proof.destructeas[e0e1];unfoldSplEssSurjine0.srapplycatie_adjointify.-snrapplyBuild_Morphism_0Gpd.1:exact(funy=> (e0y).1).snrapplyBuild_Is0Functor;cbnbeta.introsy1y2m.applye1.exact((e0y1).2 $@m$@ ((e0y2).2)^$).-cbn.applye0.-cbn.introx.applye1.applye0.Defined.I-indexed products for anI-indexed family of 0-groupoids.Definitionprod_0gpd(I:Type) (G:I->ZeroGpd) :ZeroGpd.Proof.rapply(Build_ZeroGpd(foralli,Gi)).Defined.Thei-th projection from theI-indexed product of 0-groupoids.Definitionprod_0gpd_pr{I:Type} {G:I->ZeroGpd}:foralli,prod_0gpdIG$->Gi.Proof.introsi.snrapplyBuild_Morphism_0Gpd.1:exact(funf=>fi).snrapplyBuild_Is0Functor;cbnbeta.introsfgp.exact(pi).Defined.The universal property of the product of 0-groupoids holds almost definitionally.Definitionequiv_prod_0gpd_corec{I:Type} {G:ZeroGpd} {H:I->ZeroGpd}: (foralli,G$->Hi) <~> (G$->prod_0gpdIH).Proof.snrapplyBuild_Equiv.{introf.snrapplyBuild_Morphism_0Gpd.1:exact(funxi=>fix).snrapplyBuild_Is0Functor;cbnbeta.introsxypi;simpl.exact(fmap(fi)p). }snrapplyBuild_IsEquiv.-introf.introsi.exact(prod_0gpd_pri$of).-introf.reflexivity.-introf.reflexivity.-reflexivity.Defined.Indexed products of groupoids with equivalent indices and fiberwise equivalent factors are equivalent.Definitioncate_prod_0gpd{IJ:Type} (ie:I<~>J)(G:I->ZeroGpd) (H:J->ZeroGpd)(f:forall(i:I),Gi$<~>H(iei)):prod_0gpdIG$<~>prod_0gpdJH.Proof.snrapplycate_adjointify.-snrapplyBuild_Morphism_0Gpd.+introshj.exact(transportH(eisretriej) (cate_fun(f(ie^-1j)) (h_))).+nrapplyBuild_Is0Functor.introsghpj.destruct(eisretriej).refine(_$oHom_path(transport_1__)).applyBuild_Morphism_0Gpd.exact(p_).-exact(equiv_prod_0gpd_corec(funi=> (fi)^-1$ $oprod_0gpd_pr(iei))).-introshj.cbn.destruct(eisretriej).exact(cate_isretr(f_)_).-introsgi.cbn.refine(_$oHom_path(ap(cate_fun(fi)^-1$) (transport2_(eisadjiei)_))).destruct(eissectiei).exact(cate_issect(f_)_).Defined.

--- Truncations\Trunc.html ---
TruncLibrary TruncTruncatednessRequireImportBasics.OvertureBasics.ContractibleBasics.EquivalencesBasics.TacticsBasics.NatBasics.Iff.LocalSetUniverseMinimizationToSet.Local OpenScopetrunc_scope.Local OpenScopepath_scope.Generalizable VariablesABmnf.Notation for truncation-levelsOpenScopetrunc_scope.Increase a truncation index by a natural number.Fixpointtrunc_index_inc@{} (k:trunc_index) (n:nat):trunc_index:=matchnwith|O=>k|Sm=> (trunc_index_inckm).+1end.This is a variation that inserts the successor operations in the other order.  This is sometimes convenient.Fixpointtrunc_index_inc'@{} (k:trunc_index) (n:nat):trunc_index:=matchnwith|O=>k|Sm=> (trunc_index_inc'k.+1m)end.Definitiontrunc_index_inc'_succ@{} (n:nat) (k:trunc_index):trunc_index_inc'k.+1n= (trunc_index_inc'kn).+1.Proof.revertk;simple_inductionnnIHn;introk.-reflexivity.-apply(IHnk.+1).Defined.Definitiontrunc_index_inc_agree@{} (k:trunc_index) (n:nat):trunc_index_inckn=trunc_index_inc'kn.Proof.simple_inductionnnIHn.-reflexivity.-simpl.refine(ap_IHn@_).symmetry;applytrunc_index_inc'_succ.Defined.Definitionnat_to_trunc_index@{} (n:nat) :trunc_index:= (trunc_index_incminus_twon).+2.Coercionnat_to_trunc_index:nat>->trunc_index.Definitiontrunc_index_inc'_0n(n:nat):trunc_index_inc'0%natn=n.Proof.inductionnas[|np].1:reflexivity.refine(trunc_index_inc'_succ__@_).exact(ap_p).Defined.Definitionint_to_trunc_index@{} (v:Decimal.int) :optiontrunc_index:=matchvwith|Decimal.Posd=>Some(nat_to_trunc_index(Nat.of_uintd))|Decimal.Negd=>matchNat.of_uintdwith| 2%nat=>Someminus_two| 1%nat=>Some(minus_two.+1)| 0%nat=>Some(minus_two.+2)|_=>Noneendend.Definitionnum_int_to_trunc_index@{} (v:Numeral.int) :optiontrunc_index:=matchvwith|Numeral.IntDecv=>int_to_trunc_indexv|Numeral.IntHex_=>Noneend.Fixpointtrunc_index_to_little_uint@{}nacc:=matchnwith|minus_two=>acc|minus_two.+1 =>acc|minus_two.+2 =>acc|trunc_Sn=>trunc_index_to_little_uintn(Decimal.Little.succacc)end.Definitiontrunc_index_to_int@{}n:=matchnwith|minus_two=>Decimal.Neg(Nat.to_uint2)|minus_two.+1 =>Decimal.Neg(Nat.to_uint1)|n=>Decimal.Pos(Decimal.rev(trunc_index_to_little_uintnDecimal.zero))end.Definitiontrunc_index_to_num_int@{}n:=Numeral.IntDec(trunc_index_to_intn).This allows us to use notation like (-2) and 42 for atrunc_index.Number Notationtrunc_indexnum_int_to_trunc_indextrunc_index_to_num_int:trunc_scope.Sends a trunc_indexnto the natural numbern+2.Fixpointtrunc_index_to_nat(n:trunc_index) :nat:=matchnwith|minus_two=> 0%nat|n'.+1 => (trunc_index_to_natn').+1end.Arithmetic on truncation-levels.Fixpointtrunc_index_add@{} (mn:trunc_index) :trunc_index:=matchmwith| -2 =>n|m'.+1 => (trunc_index_addm'n).+1end.Notation"m +2+ n" := (trunc_index_addmn) :trunc_scope.Definitiontrunc_index_add_minus_two@{}m:m+2+ -2 =m.Proof.simple_inductionmmIHm.1:reflexivity.cbn;applyap.assumption.Defined.Definitiontrunc_index_add_succ@{}mn:m+2+n.+1 = (m+2+n).+1.Proof.revertm;simple_inductionnnIHn;introm;simple_inductionmmIHm.1,3:reflexivity.all:cbn;applyap.all:assumption.Defined.Definitiontrunc_index_add_comm@{}mn:m+2+n=n+2+m.Proof.simple_inductionnnIHn.-applytrunc_index_add_minus_two.-exact(trunc_index_add_succ__@aptrunc_SIHn).Defined.Fixpointtrunc_index_leq@{} (mn:trunc_index) :Type0:=matchm,nwith| -2,_=>Unit|m'.+1, -2 =>Empty|m'.+1,n'.+1 =>trunc_index_leqm'n'end.Existing Classtrunc_index_leq.Notation"m <= n" := (trunc_index_leqmn) :trunc_scope.Global Instancetrunc_index_leq_minus_two_n@{}n: -2 <=n:=tt.Global Instancetrunc_index_leq_succ@{}n:n<=n.+1.Proof.byinductionnas[|nIHn]usingtrunc_index_ind.Defined.Definitiontrunc_index_pred@{} :trunc_index->trunc_index.Proof.intros[|m].1:exact(-2).exactm.Defined.Notation"n '.-1'" := (trunc_index_predn) :trunc_scope.Notation"n '.-2'" := (n.-1.-1) :trunc_scope.Definitiontrunc_index_succ_pred@{} (n:nat): (n.-1).+1 =n.Proof.simple_inductionnnIHn.1:reflexivity.unfoldnat_to_trunc_indexin*;cbnin*.refine(aptrunc_SIHn).Defined.Definitiontrunc_index_leq_minus_two@{} {n}:n<= -2 ->n= -2.Proof.destructn.1:reflexivity.contradiction.Defined.Definitiontrunc_index_leq_succ'@{}nm:n<=m->n<=m.+1.Proof.revertm.inductionnas[|nIHn]usingtrunc_index_ind.1:exact_.introsmp;cbn.inductionmas[|mIHm]usingtrunc_index_ind.1:destructp.applyIHn,p.Defined.Global Instancetrunc_index_leq_refl@{}:Reflexivetrunc_index_leq.Proof.intron.byinductionnas[|nIHn]usingtrunc_index_ind.Defined.Global Instancetrunc_index_leq_transitive@{}:Transitivetrunc_index_leq.Proof.introsabcpq.revertbacpq.inductionbas[|bIHb]usingtrunc_index_ind.{introsacp.bydestruct(trunc_index_leq_minus_twop). }inductionaas[|aIHa]usingtrunc_index_ind;inductioncas[|cIHc]usingtrunc_index_ind.all:intros.1,2:exacttt.1:contradiction.cbninp,q;cbn.byapplyIHb.Defined.Definitiontrunc_index_leq_add@{}nm:n<=m+2+n.Proof.simple_inductionmmIHm.-reflexivity.-rapplytrunc_index_leq_transitive.Defined.Definitiontrunc_index_leq_add'@{}nm:n<=n+2+m.Proof.rewritetrunc_index_add_comm.applytrunc_index_leq_add.Defined.Fixpointtrunc_index_min@{} (nm:trunc_index):trunc_index.Proof.destructn.1:exact(-2).destructm.1:exact(-2).exact(trunc_index_minnm).+1.Defined.Definitiontrunc_index_min_minus_two@{}n:trunc_index_minn(-2) = -2.Proof.bydestructn.Defined.Definitiontrunc_index_min_swap@{}nm:trunc_index_minnm=trunc_index_minmn.Proof.revertm.simple_inductionnnIHn;introm.{symmetry.applytrunc_index_min_minus_two. }simple_inductionmmIHm.1:reflexivity.cbn;applyap,IHn.Defined.Definitiontrunc_index_min_path@{}nm: (trunc_index_minnm=n) + (trunc_index_minnm=m).Proof.revertm;simple_inductionnnIHn;introm.1:byapplyinl.simple_inductionmmIHm.1:byapplyinr.destruct(IHnm).1:applyinl.2:applyinr.1,2:cbn;byapplyap.Defined.Definitiontrunc_index_min_leq_left@{} (nm:trunc_index):trunc_index_minnm<=n.Proof.revertnm.refine(trunc_index_ind___); [ |introsnIHn].all:refine(trunc_index_ind___); [ |introsmIHm].all:tryexacttt.exact(IHnm).Defined.Definitiontrunc_index_min_leq_right@{} (nm:trunc_index):trunc_index_minnm<=m.Proof.revertnm.refine(trunc_index_ind___); [ |introsnIHn].all:refine(trunc_index_ind___); [ |introsmIHm].all:tryexacttt.exact(IHnm).Defined.Truncatedness proper.A contractible space is (-2)-truncated, by definition. This function is the identity, so there is never any need to actually use it, but it exists to be found in searches.Definitioncontr_istrunc_minus_two`{H:IsTrunc(-2)A} :ContrA:=H.Truncation levels are cumulative.Global Instanceistrunc_paths'{n:trunc_index} {A:Type} `{IsTruncnA}:forallxy:A,IsTruncn(x=y) | 1000.Proof.generalizedependentA.simple_inductionnnIH;simpl;introsAHxy.-applycontr_paths_contr.-applyistrunc_S.rapplyIH.Defined.Global Instanceistrunc_succ{n:trunc_index} {A:Type} `{IsTruncnA}:IsTruncn.+1A| 1000.Proof.applyistrunc_S.applyistrunc_paths'.Defined.This could be anInstance(with very high priority, so it doesn't get applied trivially).  However, we haven't given typeclass search any hints allowing it to solve goals likem<=n, so it would only ever be used trivially.Definitionistrunc_leq{mn} (Hmn:m<=n) `{IsTruncmA}:IsTruncnA.Proof.generalizedependentA;generalizedependentm.simple_inductionnn'IH;intros[ |m']HmnA? .-(* -2, -2 *)assumption.-(* S m', -2 *)destructHmn.-(* -2, S n' *)apply@istrunc_succ, (IH(-2));auto.-(* S m', S n' *)applyistrunc_S.introsxy;apply(IHm');autowithtypeclass_instances.Defined.In particular, a contractible type, hprop, or hset is truncated at all higher levels.  We don't allow these to be used as idmaps, since there would be no point to it.Definitionistrunc_contr{n} {A} `{ContrA} :IsTruncn.+1A:= (@istrunc_leq(-2)n.+1tt__).Definitionistrunc_hprop{n} {A} `{IsHPropA} :IsTruncn.+2A:= (@istrunc_leq(-1)n.+2tt__).Definitionistrunc_hset{n} {A} `{IsHSetA}:IsTruncn.+3A:= (@istrunc_leq0n.+3tt__).Consider the preceding definitions as instances for typeclass search, but only if the requisite hypothesis is already a known assumption; otherwise they result in long or interminable searches.#[export]HintImmediateistrunc_contr:typeclass_instances.#[export]HintImmediateistrunc_hprop:typeclass_instances.#[export]HintImmediateistrunc_hset:typeclass_instances.Equivalence preserves truncation (this is, of course, trivial with univalence).  This is not anInstancebecause it causes infinite loops.Definitionistrunc_isequiv_istruncA{B} (f:A->B)`{IsTruncnA} `{IsEquivABf}:IsTruncnB.Proof.generalizedependentB;generalizedependentA.simple_inductionnnIH;simpl;introsA?Bf?.-exact(contr_equiv_f).-applyistrunc_S.introsxy.refine(IH___(ap(f^-1))^-1_).Defined.Definitionistrunc_equiv_istruncA{B} (f:A<~>B) `{IsTruncnA}:IsTruncnB:=istrunc_isequiv_istruncAf.Truncated morphismsClassIsTruncMap(n:trunc_index) {XY:Type} (f:X->Y):=istruncmap_fiber:forally:Y,IsTruncn(hfiberfy).Global Existing Instanceistruncmap_fiber.NotationIsEmbedding:= (IsTruncMap(-1)).Universes of truncated typesIt is convenient for some purposes to consider the universe of all n-truncated types (within a given universe of types).  In particular, this allows us to state the important fact that each such universe is itself (n+1)-truncated.RecordTruncType(n:trunc_index) := {trunctype_type:Type;trunctype_istrunc:IsTruncntrunctype_type}.ArgumentsBuild_TruncType__{_}.Argumentstrunctype_type{_}_.Argumentstrunctype_istrunc[_]_.Coerciontrunctype_type:TruncType>->Sortclass.Global Existing Instancetrunctype_istrunc.Notation"n -Type" := (TruncTypen) :type_scope.NotationHProp:= (-1)-Type.NotationHSet:= 0-Type.NotationBuild_HProp:= (Build_TruncType(-1)).NotationBuild_HSet:= (Build_TruncType0).This is (as of October 2014) the onlyCanonicalStructurein the library.  It would be nice to do without it, in the interests of minimizing the number of fancy Coq features that the reader needs to know about.CanonicalStructuredefault_TruncType:=funnTP=> (@Build_TruncTypenTP).Facts about hpropsAn inhabited proposition is contractible.  This is not anInstancebecause it causes infinite loops.Lemmacontr_inhabited_hprop(A:Type) `{H:IsHPropA} (x:A):ContrA.Proof.apply(Build_Contr_x).introy.rapplycenter.Defined.If inhabitation implies contractibility, then we have an h-proposition.  We probably won't often have a hypothesis of the formA->ContrA, so we make sure we give priority to other instances.Global Instancehprop_inhabited_contr(A:Type): (A->ContrA) ->IsHPropA| 10000.Proof.introsH;applyistrunc_S;introsxy.pose(C:=Hx).applycontr_paths_contr.Defined.Any two points in an hprop are connected by a path.Theorempath_ishprop`{H:IsHPropA}:forallxy:A,x=y.Proof.introsxy.rapplycenter.Defined.Conversely, this property characterizes hprops.Theoremhprop_allpath(A:Type): (forall(xy:A),x=y) ->IsHPropA.Proof.introsH;applyistrunc_S;introsxy.nrapplycontr_paths_contr.exact(Build_Contr_x(Hx)).Defined.Two propositions are equivalent as soon as there are maps in both directions.Definitionisequiv_iff_hprop`{IsHPropA} `{IsHPropB}(f:A->B) (g:B->A):IsEquivf.Proof.apply(isequiv_adjointifyfg);intros?;applypath_ishprop.Defined.Definitionequiv_iff_hprop_uncurried`{IsHPropA} `{IsHPropB}: (A<->B) -> (A<~>B).Proof.introfg.apply(equiv_adjointify(fstfg) (sndfg));intros?;applypath_ishprop.Defined.Definitionequiv_iff_hprop`{IsHPropA} `{IsHPropB}: (A->B) -> (B->A) -> (A<~>B):=funfg=>equiv_iff_hprop_uncurried(f,g).Corollaryiff_contr_hprop(A:Type) `{IsHPropA}:ContrA<->A.Proof.split.-applycenter.-rapplycontr_inhabited_hprop.Defined.Truncatedness: any dependent product of n-types is an n-typeDefinitioncontr_forall`{Funext} `{P:A->Type} `{foralla,Contr(Pa)}:Contr(foralla,Pa).Proof.apply(Build_Contr_(funa=>center(Pa))).introf.applypath_forall.introa.applycontr.Defined.Global Instanceistrunc_forall`{Funext} `{P:A->Type} `{foralla,IsTruncn(Pa)}:IsTruncn(foralla,Pa) | 100.Proof.generalizedependentP.simple_inductionnnIH;simpl;introsP?.(* casen=-2, i.e. contractibility *)-applycontr_forall.(* case n = n'.+1 *)-applyistrunc_S.introsfg;apply(istrunc_isequiv_istrunc@{u1u1}_(apD10@{__u1} ^-1)).Defined.Truncatedness is an hprop.Global Instanceishprop_istrunc`{Funext} (n:trunc_index) (A:Type):IsHProp(IsTruncnA) | 0.Proof.revertA;simple_inductionnnIH;cbn;introA.-nrapply(istrunc_equiv_istrunc_(equiv_istrunc_unfold(-2)A)^-1%equiv).applyhprop_allpath.intros[a1c1] [a2c2].destruct(c1a2).apply(ap(exist_a1)).funextx.pose(Build_Contr_a1c1);applypath2_contr.-rapply(istrunc_equiv_istrunc_(equiv_istrunc_unfoldn.+1A)^-1%equiv).(* This case follows fromistrunc_forall. *)Defined.Bytrunc_hprop, it follows thatIsTruncnAis alsom-truncated for anym>=-1.Similarly, a map being truncated is also a proposition.Global Instanceishprop_istruncmap`{Funext} (n:trunc_index) {XY:Type} (f:X->Y):IsHProp(IsTruncMapnf).Proof.applyhprop_allpath;introsst.applypath_forall;introsx.applypath_ishprop.Defined.If a typeAisn-truncated, thenIsTruncnAis contractible.Global Instancecontr_istrunc`{Funext} (n:trunc_index) (A:Type) `{istruncA:IsTruncnA}:Contr(IsTruncnA) | 100:=contr_inhabited_hprop__.Corollaryequiv_contr_hprop(A:Type) `{Funext} `{IsHPropA}:ContrA<~>A.Proof.exact(equiv_iff_hprop_uncurried(iff_contr_hpropA)).Defined.If a typeAimplies that it isn.+1-truncated, then it isn.+1-truncated.Definitionistrunc_inhabited_istrunc{n:trunc_index}{A:Type} (H:A->IsTruncn.+1A):IsTruncn.+1A:=istrunc_S_(funab=>Haab).If you are looking for a theorem about truncation, you may want to read the note "Finding Theorems" in "STYLE.md".

--- Truncations\Truncations.html ---
TruncationsLibrary TruncationsRequireExportHoTT.Truncations.Core.RequireExportHoTT.Truncations.SeparatedTrunc.RequireExportHoTT.Truncations.Connectedness.

--- Truncations\TruncType.html ---
TruncTypeLibrary TruncTypeRequireImportHoTT.BasicsHoTT.Types.RequireImportHProp.Generalizable VariablesABnf.Universes of truncated typesNow that we have the univalence axiom (fromTypes/Universe), we study further the universesTruncTypeof truncated types (includinghPropandhSet) that were defined inBasics/Trunc.Paths inTruncTypeSectionTruncType.Context`{Univalence}.Definitionissig_trunctype{n:trunc_index}: {X:Type&IsTruncnX} <~>TruncTypen.Proof.issig.Defined.Definitionequiv_path_trunctype'{n:trunc_index} (AB:TruncTypen): (A=B:>Type) <~> (A=B:>TruncTypen).Proof.refine((equiv_ap'issig_trunctype^-1__)^-1oE_).exact(equiv_path_sigma_hprop(_;_) (_;_)).Defined.Global Instanceisequiv_ap_trunctype{n:trunc_index} (AB:n-Type):IsEquiv(@ap__(@trunctype_typen)AB).Proof.srefine(isequiv_homotopic_^-1%equiv_).1:applyequiv_path_trunctype'.intros[];reflexivity.Defined.Definitionequiv_path_trunctype{n:trunc_index} (AB:TruncTypen): (A<~>B) <~> (A=B:>TruncTypen):=equiv_path_trunctype'__oEequiv_path_universe__.Definitionpath_trunctype@{ab} {n:trunc_index} {AB:TruncTypen}:A<~>B-> (A=B:>TruncTypen):=equiv_path_trunctype@{ab}AB.Global Instanceisequiv_path_trunctype{n:trunc_index} {AB:TruncTypen}:IsEquiv(@path_trunctypenAB) :=_.path_trunctypeis functorialDefinitionpath_trunctype_1{n:trunc_index} {A:TruncTypen}:path_trunctype(equiv_idmapA) =idpath.Proof.unfoldpath_trunctype;simpl.rewrite(eta_path_universe_uncurried1).rewritepath_sigma_hprop_1.reflexivity.Qed.Definitionpath_trunctype_V{n:trunc_index} {AB:TruncTypen}(f:A<~>B):path_trunctypef^-1 = (path_trunctypef)^.Proof.unfoldpath_trunctype;simpl.rewritepath_universe_V_uncurried.rewrite(path_sigma_hprop_V(path_universe_uncurriedf)).refine(concat_p1_@concat_1p_@_).refine(_@ (apinverse(concat_1p_))^ @ (apinverse(concat_p1_))^).refine(ap_V__).Qed.Definitionpath_trunctype_pp{n:trunc_index} {ABC:TruncTypen}(f:A<~>B) (g:B<~>C):path_trunctype(goEf) =path_trunctypef@path_trunctypeg.Proof.unfoldpath_trunctype;simpl.rewritepath_universe_compose_uncurried.rewrite(path_sigma_hprop_pp(path_universe_uncurriedf)__(trunctype_istruncB)).refine(concat_p1_@concat_1p_@_).refine(_@ (ap_(concat_1p_))^ @ (ap_(concat_p1_))^).refine(_@ (ap(funz=>z@_) (concat_1p_))^ @ (ap(funz=>z@_) (concat_p1_))^).refine(ap_pp___).Qed.Definitionap_trunctype{n:trunc_index} {AB:TruncTypen} {f:A<~>B}:aptrunctype_type(path_trunctypef) =path_universe_uncurriedf.Proof.destructA,B.cbnin*.cbn;destruct(path_universe_uncurriedf).rewriteconcat_1p,concat_p1.rewrite<- 2ap_compose.applyap_const.Qed.Definitionpath_hset{AB} := @path_trunctype0AB.Definitionpath_hprop{AB} := @path_trunctype(-1)AB.Global Instanceistrunc_trunctype{n:trunc_index}:IsTruncn.+1 (TruncTypen) | 0.Proof.applyistrunc_S.introsAB.refine(istrunc_equiv_istrunc_(equiv_path_trunctype@{ij}AB)).casenas[ |n'].-applycontr_equiv_contr_contr.(* The reason is different in this case. *)-applyistrunc_equiv.Defined.Global Instanceisset_HProp:IsHSetHProp:=_.Global Instanceistrunc_sig_istrunc:foralln,IsTruncn.+1 {A:Type&IsTruncnA} | 0.Proof.intron.apply(istrunc_equiv_istrunc_issig_trunctype^-1).Defined.Some standard inhabitantsDefinitionUnit_hp:HProp:= (Build_HPropUnit).DefinitionFalse_hp:HProp:= (Build_HPropEmpty).DefinitionNegation_hp`{Funext} (hprop:HProp) :HProp:=Build_HProp(~hprop).We could continue with products etcThe canonical map from Bool to hPropDefinitionis_true(b:Bool) :HProp:=ifbthenUnit_hpelseFalse_hp.Facts about HProps using univalenceGlobal Instancetrunc_path_IsHPropXY`{IsHPropY}:IsHProp(X=Y).Proof.applyhprop_allpath.introspf1pf2.apply(equiv_inj(equiv_pathXY)).applypath_equiv,path_arrow.introsx;byapplypath_ishprop.Qed.Definitionpath_iff_ishprop_uncurried`{IsHPropA,IsHPropB}: (A<->B) ->A=B:>Type:= @path_universe_uncurried_ABoequiv_iff_hprop_uncurried.Definitionpath_iff_hprop_uncurried{AB:HProp}: (A<->B) ->A=B:>HProp:= (@path_hpropAB)o(@equiv_iff_hprop_uncurriedA_B_).Global Instanceisequiv_path_iff_ishprop_uncurried`{IsHPropA,IsHPropB}:IsEquiv(@path_iff_ishprop_uncurriedA_B_) :=_.Global Instanceisequiv_path_iff_hprop_uncurried{AB:HProp}:IsEquiv(@path_iff_hprop_uncurriedAB) :=_.Definitionpath_iff_ishprop`{IsHPropA,IsHPropB}: (A->B) -> (B->A) ->A=B:>Type:=funfg=>path_iff_ishprop_uncurried(f,g).Definitionpath_iff_hprop{AB:HProp}: (A->B) -> (B->A) ->A=B:>HProp:=funfg=>path_iff_hprop_uncurried(f,g).Lemmaequiv_path_iff_ishprop{AB:Type} `{IsHPropA,IsHPropB}: (A<->B) <~> (A=B).Proof.exact(Build_Equiv__path_iff_ishprop_uncurried_).Defined.Lemmaequiv_path_iff_hprop{AB:HProp}: (A<->B) <~> (A=B).Proof.refine(equiv_path_trunctype'__oEequiv_path_iff_ishprop).Defined.EndTruncType.

